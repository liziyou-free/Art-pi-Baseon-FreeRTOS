
ART-PI.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .onchip_flash 00000000  08000000  08000000  0003015c  2**0
                  CONTENTS
  1 .isr_vector   00000298  90000000  90000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000127f0  900002a0  900002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00003208  90012a90  90012a90  00022a90  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  90015c98  90015c98  00025c98  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  90015c9c  90015c9c  00025c9c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000009c  24000000  90015ca0  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .RxDecripSection 00000060  2400009c  90015d3c  0003009c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .TxDecripSection 00000060  240000fc  90015d9c  000300fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000d2d8  2400015c  90015dfc  0003015c  2**2
                  ALLOC
 10 ._user_heap_stack 00001004  2400d434  90015dfc  0003d434  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  0003015c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00053f91  00000000  00000000  0003018a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000c6de  00000000  00000000  0008411b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    00029157  00000000  00000000  000907f9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00002610  00000000  00000000  000b9950  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00004120  00000000  00000000  000bbf60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0004e39a  00000000  00000000  000c0080  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00055cf6  00000000  00000000  0010e41a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00189982  00000000  00000000  00164110  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  002eda92  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00007bd4  00000000  00000000  002edae4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

900002a0 <__do_global_dtors_aux>:
900002a0:	b510      	push	{r4, lr}
900002a2:	4c05      	ldr	r4, [pc, #20]	; (900002b8 <__do_global_dtors_aux+0x18>)
900002a4:	7823      	ldrb	r3, [r4, #0]
900002a6:	b933      	cbnz	r3, 900002b6 <__do_global_dtors_aux+0x16>
900002a8:	4b04      	ldr	r3, [pc, #16]	; (900002bc <__do_global_dtors_aux+0x1c>)
900002aa:	b113      	cbz	r3, 900002b2 <__do_global_dtors_aux+0x12>
900002ac:	4804      	ldr	r0, [pc, #16]	; (900002c0 <__do_global_dtors_aux+0x20>)
900002ae:	f3af 8000 	nop.w
900002b2:	2301      	movs	r3, #1
900002b4:	7023      	strb	r3, [r4, #0]
900002b6:	bd10      	pop	{r4, pc}
900002b8:	2400015c 	.word	0x2400015c
900002bc:	00000000 	.word	0x00000000
900002c0:	90012a78 	.word	0x90012a78

900002c4 <frame_dummy>:
900002c4:	b508      	push	{r3, lr}
900002c6:	4b03      	ldr	r3, [pc, #12]	; (900002d4 <frame_dummy+0x10>)
900002c8:	b11b      	cbz	r3, 900002d2 <frame_dummy+0xe>
900002ca:	4903      	ldr	r1, [pc, #12]	; (900002d8 <frame_dummy+0x14>)
900002cc:	4803      	ldr	r0, [pc, #12]	; (900002dc <frame_dummy+0x18>)
900002ce:	f3af 8000 	nop.w
900002d2:	bd08      	pop	{r3, pc}
900002d4:	00000000 	.word	0x00000000
900002d8:	24000160 	.word	0x24000160
900002dc:	90012a78 	.word	0x90012a78

900002e0 <strlen>:
900002e0:	4603      	mov	r3, r0
900002e2:	f813 2b01 	ldrb.w	r2, [r3], #1
900002e6:	2a00      	cmp	r2, #0
900002e8:	d1fb      	bne.n	900002e2 <strlen+0x2>
900002ea:	1a18      	subs	r0, r3, r0
900002ec:	3801      	subs	r0, #1
900002ee:	4770      	bx	lr

900002f0 <memchr>:
900002f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
900002f4:	2a10      	cmp	r2, #16
900002f6:	db2b      	blt.n	90000350 <memchr+0x60>
900002f8:	f010 0f07 	tst.w	r0, #7
900002fc:	d008      	beq.n	90000310 <memchr+0x20>
900002fe:	f810 3b01 	ldrb.w	r3, [r0], #1
90000302:	3a01      	subs	r2, #1
90000304:	428b      	cmp	r3, r1
90000306:	d02d      	beq.n	90000364 <memchr+0x74>
90000308:	f010 0f07 	tst.w	r0, #7
9000030c:	b342      	cbz	r2, 90000360 <memchr+0x70>
9000030e:	d1f6      	bne.n	900002fe <memchr+0xe>
90000310:	b4f0      	push	{r4, r5, r6, r7}
90000312:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
90000316:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
9000031a:	f022 0407 	bic.w	r4, r2, #7
9000031e:	f07f 0700 	mvns.w	r7, #0
90000322:	2300      	movs	r3, #0
90000324:	e8f0 5602 	ldrd	r5, r6, [r0], #8
90000328:	3c08      	subs	r4, #8
9000032a:	ea85 0501 	eor.w	r5, r5, r1
9000032e:	ea86 0601 	eor.w	r6, r6, r1
90000332:	fa85 f547 	uadd8	r5, r5, r7
90000336:	faa3 f587 	sel	r5, r3, r7
9000033a:	fa86 f647 	uadd8	r6, r6, r7
9000033e:	faa5 f687 	sel	r6, r5, r7
90000342:	b98e      	cbnz	r6, 90000368 <memchr+0x78>
90000344:	d1ee      	bne.n	90000324 <memchr+0x34>
90000346:	bcf0      	pop	{r4, r5, r6, r7}
90000348:	f001 01ff 	and.w	r1, r1, #255	; 0xff
9000034c:	f002 0207 	and.w	r2, r2, #7
90000350:	b132      	cbz	r2, 90000360 <memchr+0x70>
90000352:	f810 3b01 	ldrb.w	r3, [r0], #1
90000356:	3a01      	subs	r2, #1
90000358:	ea83 0301 	eor.w	r3, r3, r1
9000035c:	b113      	cbz	r3, 90000364 <memchr+0x74>
9000035e:	d1f8      	bne.n	90000352 <memchr+0x62>
90000360:	2000      	movs	r0, #0
90000362:	4770      	bx	lr
90000364:	3801      	subs	r0, #1
90000366:	4770      	bx	lr
90000368:	2d00      	cmp	r5, #0
9000036a:	bf06      	itte	eq
9000036c:	4635      	moveq	r5, r6
9000036e:	3803      	subeq	r0, #3
90000370:	3807      	subne	r0, #7
90000372:	f015 0f01 	tst.w	r5, #1
90000376:	d107      	bne.n	90000388 <memchr+0x98>
90000378:	3001      	adds	r0, #1
9000037a:	f415 7f80 	tst.w	r5, #256	; 0x100
9000037e:	bf02      	ittt	eq
90000380:	3001      	addeq	r0, #1
90000382:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
90000386:	3001      	addeq	r0, #1
90000388:	bcf0      	pop	{r4, r5, r6, r7}
9000038a:	3801      	subs	r0, #1
9000038c:	4770      	bx	lr
9000038e:	bf00      	nop

90000390 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
90000390:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
90000392:	4829      	ldr	r0, [pc, #164]	; (90000438 <MX_FMC_Init+0xa8>)
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
90000394:	2500      	movs	r5, #0
90000396:	4b29      	ldr	r3, [pc, #164]	; (9000043c <MX_FMC_Init+0xac>)
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
90000398:	2110      	movs	r1, #16
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
9000039a:	f44f 6600 	mov.w	r6, #2048	; 0x800
{
9000039e:	b08c      	sub	sp, #48	; 0x30
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
900003a0:	2208      	movs	r2, #8
900003a2:	2401      	movs	r4, #1
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
900003a4:	6285      	str	r5, [r0, #40]	; 0x28
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
900003a6:	e9c0 3500 	strd	r3, r5, [r0]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
900003aa:	2340      	movs	r3, #64	; 0x40
900003ac:	e9c0 1304 	strd	r1, r3, [r0, #16]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
900003b0:	f44f 7380 	mov.w	r3, #256	; 0x100
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 6;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
900003b4:	a905      	add	r1, sp, #20
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
900003b6:	e9c0 3506 	strd	r3, r5, [r0, #24]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
900003ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900003be:	e9c0 6308 	strd	r6, r3, [r0, #32]
  SdramTiming.LoadToActiveDelay = 2;
900003c2:	2302      	movs	r3, #2
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
900003c4:	e9c0 4202 	strd	r4, r2, [r0, #8]
  SdramTiming.ExitSelfRefreshDelay = 8;
900003c8:	e9cd 3205 	strd	r3, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 6;
900003cc:	2206      	movs	r2, #6
  SdramTiming.RCDDelay = 2;
900003ce:	930b      	str	r3, [sp, #44]	; 0x2c
  SdramTiming.RowCycleDelay = 6;
900003d0:	e9cd 2207 	strd	r2, r2, [sp, #28]
  SdramTiming.RPDelay = 2;
900003d4:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
900003d8:	f005 fc5a 	bl	90005c90 <HAL_SDRAM_Init>
900003dc:	b108      	cbz	r0, 900003e2 <MX_FMC_Init+0x52>
  {
    Error_Handler( );
900003de:	f000 fa3d 	bl	9000085c <Error_Handler>
  SdramTypdef.CommandTarget= FMC_SDRAM_CMD_TARGET_BANK1;
900003e2:	2610      	movs	r6, #16
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
900003e4:	a901      	add	r1, sp, #4
900003e6:	2232      	movs	r2, #50	; 0x32
900003e8:	4813      	ldr	r0, [pc, #76]	; (90000438 <MX_FMC_Init+0xa8>)
  FMC_SDRAM_CommandTypeDef  SdramTypdef={0};
900003ea:	9504      	str	r5, [sp, #16]
  SdramTypdef.CommandMode= FMC_SDRAM_CMD_CLK_ENABLE;
900003ec:	9401      	str	r4, [sp, #4]
  SdramTypdef.AutoRefreshNumber= 1;
900003ee:	9403      	str	r4, [sp, #12]
  SdramTypdef.CommandTarget= FMC_SDRAM_CMD_TARGET_BANK1;
900003f0:	9602      	str	r6, [sp, #8]
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
900003f2:	f005 fc75 	bl	90005ce0 <HAL_SDRAM_SendCommand>
  SdramTypdef.CommandMode= FMC_SDRAM_CMD_PALL;
900003f6:	2302      	movs	r3, #2
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
900003f8:	2232      	movs	r2, #50	; 0x32
900003fa:	a901      	add	r1, sp, #4
900003fc:	480e      	ldr	r0, [pc, #56]	; (90000438 <MX_FMC_Init+0xa8>)
  SdramTypdef.CommandMode= FMC_SDRAM_CMD_PALL;
900003fe:	9301      	str	r3, [sp, #4]
  SdramTypdef.ModeRegisterDefinition= 0;
90000400:	9504      	str	r5, [sp, #16]
  SdramTypdef.CommandTarget= FMC_SDRAM_CMD_TARGET_BANK1;
90000402:	e9cd 6402 	strd	r6, r4, [sp, #8]
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
90000406:	f005 fc6b 	bl	90005ce0 <HAL_SDRAM_SendCommand>
  HAL_SDRAM_SetAutoRefreshNumber(SdramHandle,8);
9000040a:	2108      	movs	r1, #8
9000040c:	480a      	ldr	r0, [pc, #40]	; (90000438 <MX_FMC_Init+0xa8>)
9000040e:	f005 fc9e 	bl	90005d4e <HAL_SDRAM_SetAutoRefreshNumber>
  SdramTypdef.CommandMode= FMC_SDRAM_CMD_LOAD_MODE;
90000412:	2304      	movs	r3, #4
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
90000414:	2232      	movs	r2, #50	; 0x32
90000416:	a901      	add	r1, sp, #4
  SdramTypdef.CommandMode= FMC_SDRAM_CMD_LOAD_MODE;
90000418:	9301      	str	r3, [sp, #4]
  SdramTypdef.ModeRegisterDefinition= 0x01|0x02<<4|1<<9;
9000041a:	f240 2321 	movw	r3, #545	; 0x221
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
9000041e:	4806      	ldr	r0, [pc, #24]	; (90000438 <MX_FMC_Init+0xa8>)
  SdramTypdef.ModeRegisterDefinition= 0x01|0x02<<4|1<<9;
90000420:	9304      	str	r3, [sp, #16]
  SdramTypdef.CommandTarget= FMC_SDRAM_CMD_TARGET_BANK1;
90000422:	e9cd 6402 	strd	r6, r4, [sp, #8]
  HAL_SDRAM_SendCommand(SdramHandle,&SdramTypdef,50);
90000426:	f005 fc5b 	bl	90005ce0 <HAL_SDRAM_SendCommand>
  HAL_SDRAM_ProgramRefreshRate(SdramHandle,677);
9000042a:	f240 21a5 	movw	r1, #677	; 0x2a5
9000042e:	4802      	ldr	r0, [pc, #8]	; (90000438 <MX_FMC_Init+0xa8>)
90000430:	f005 fc75 	bl	90005d1e <HAL_SDRAM_ProgramRefreshRate>
  }

  /* USER CODE BEGIN FMC_Init 2 */
  sdram_config(&hsdram1);
  /* USER CODE END FMC_Init 2 */
}
90000434:	b00c      	add	sp, #48	; 0x30
90000436:	bd70      	pop	{r4, r5, r6, pc}
90000438:	2400017c 	.word	0x2400017c
9000043c:	52004140 	.word	0x52004140

90000440 <HAL_SDRAM_MspInit>:
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
90000440:	b5f0      	push	{r4, r5, r6, r7, lr}
90000442:	b0b7      	sub	sp, #220	; 0xdc
  GPIO_InitTypeDef GPIO_InitStruct = {0};
90000444:	2100      	movs	r1, #0
90000446:	2214      	movs	r2, #20
90000448:	a802      	add	r0, sp, #8
9000044a:	f011 fac7 	bl	900119dc <memset>
  if (FMC_Initialized) {
9000044e:	4b37      	ldr	r3, [pc, #220]	; (9000052c <HAL_SDRAM_MspInit+0xec>)
90000450:	6819      	ldr	r1, [r3, #0]
90000452:	2900      	cmp	r1, #0
90000454:	d167      	bne.n	90000526 <HAL_SDRAM_MspInit+0xe6>
  FMC_Initialized = 1;
90000456:	2401      	movs	r4, #1
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
90000458:	22a4      	movs	r2, #164	; 0xa4
9000045a:	a80d      	add	r0, sp, #52	; 0x34
  FMC_Initialized = 1;
9000045c:	601c      	str	r4, [r3, #0]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
9000045e:	f011 fabd 	bl	900119dc <memset>
    PeriphClkInitStruct.PLL2.PLL2M = 25;
90000462:	2319      	movs	r3, #25
90000464:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    PeriphClkInitStruct.PLL2.PLL2P = 2;
90000468:	21f0      	movs	r1, #240	; 0xf0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
9000046a:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PLL2.PLL2M = 25;
9000046c:	e9cd 2307 	strd	r2, r3, [sp, #28]
    PeriphClkInitStruct.PLL2.PLL2P = 2;
90000470:	2302      	movs	r3, #2
90000472:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
    PeriphClkInitStruct.PLL2.PLL2R = 1;
90000476:	e9cd 340b 	strd	r3, r4, [sp, #44]	; 0x2c
    PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_PLL2;
9000047a:	9318      	str	r3, [sp, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
9000047c:	f003 fdcc 	bl	90004018 <HAL_RCCEx_PeriphCLKConfig>
90000480:	b108      	cbz	r0, 90000486 <HAL_SDRAM_MspInit+0x46>
      Error_Handler();
90000482:	f000 f9eb 	bl	9000085c <Error_Handler>
  __HAL_RCC_FMC_CLK_ENABLE();
90000486:	4b2a      	ldr	r3, [pc, #168]	; (90000530 <HAL_SDRAM_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000488:	240c      	movs	r4, #12
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000048a:	2702      	movs	r7, #2
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000048c:	2600      	movs	r6, #0
  __HAL_RCC_FMC_CLK_ENABLE();
9000048e:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000492:	2503      	movs	r5, #3
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
90000494:	a902      	add	r1, sp, #8
90000496:	4827      	ldr	r0, [pc, #156]	; (90000534 <HAL_SDRAM_MspInit+0xf4>)
  __HAL_RCC_FMC_CLK_ENABLE();
90000498:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
9000049c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
900004a0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
900004a4:	9406      	str	r4, [sp, #24]
  __HAL_RCC_FMC_CLK_ENABLE();
900004a6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
900004aa:	9301      	str	r3, [sp, #4]
900004ac:	9b01      	ldr	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900004ae:	f64f 7383 	movw	r3, #65411	; 0xff83
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900004b2:	e9cd 6504 	strd	r6, r5, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900004b6:	e9cd 3702 	strd	r3, r7, [sp, #8]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
900004ba:	f002 fccb 	bl	90002e54 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_5|GPIO_PIN_4
900004be:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
900004c2:	a902      	add	r1, sp, #8
900004c4:	481c      	ldr	r0, [pc, #112]	; (90000538 <HAL_SDRAM_MspInit+0xf8>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
900004c6:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900004c8:	e9cd 3702 	strd	r3, r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900004cc:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
900004d0:	f002 fcc0 	bl	90002e54 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_14
900004d4:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
900004d8:	a902      	add	r1, sp, #8
900004da:	4818      	ldr	r0, [pc, #96]	; (9000053c <HAL_SDRAM_MspInit+0xfc>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
900004dc:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900004de:	e9cd 3702 	strd	r3, r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900004e2:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
900004e6:	f002 fcb5 	bl	90002e54 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_1|GPIO_PIN_0|GPIO_PIN_3
900004ea:	f64f 033f 	movw	r3, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
900004ee:	a902      	add	r1, sp, #8
900004f0:	4813      	ldr	r0, [pc, #76]	; (90000540 <HAL_SDRAM_MspInit+0x100>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
900004f2:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900004f4:	e9cd 3702 	strd	r3, r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900004f8:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
900004fc:	f002 fcaa 	bl	90002e54 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000500:	a902      	add	r1, sp, #8
90000502:	4810      	ldr	r0, [pc, #64]	; (90000544 <HAL_SDRAM_MspInit+0x104>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000504:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000506:	e9cd 4702 	strd	r4, r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000050a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
9000050e:	f002 fca1 	bl	90002e54 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_5;
90000512:	2320      	movs	r3, #32
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000514:	a902      	add	r1, sp, #8
90000516:	480c      	ldr	r0, [pc, #48]	; (90000548 <HAL_SDRAM_MspInit+0x108>)
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000518:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000051a:	e9cd 3702 	strd	r3, r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000051e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000522:	f002 fc97 	bl	90002e54 <HAL_GPIO_Init>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
90000526:	b037      	add	sp, #220	; 0xdc
90000528:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000052a:	bf00      	nop
9000052c:	24000178 	.word	0x24000178
90000530:	58024400 	.word	0x58024400
90000534:	58021000 	.word	0x58021000
90000538:	58021800 	.word	0x58021800
9000053c:	58020c00 	.word	0x58020c00
90000540:	58021400 	.word	0x58021400
90000544:	58020800 	.word	0x58020800
90000548:	58021c00 	.word	0x58021c00

9000054c <StartDefaultTask>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
9000054c:	b508      	push	{r3, lr}
  /* init code for LWIP */
  MX_LWIP_Init();
9000054e:	f000 fc87 	bl	90000e60 <MX_LWIP_Init>
  /* USER CODE BEGIN StartDefaultTask */
  defualt_thread_entry();
90000552:	f001 f87f 	bl	90001654 <defualt_thread_entry>
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
90000556:	2001      	movs	r0, #1
90000558:	f006 fca6 	bl	90006ea8 <osDelay>
  for(;;)
9000055c:	e7fb      	b.n	90000556 <StartDefaultTask+0xa>

9000055e <vApplicationIdleHook>:
}
9000055e:	4770      	bx	lr

90000560 <vApplicationTickHook>:
90000560:	4770      	bx	lr

90000562 <vApplicationStackOverflowHook>:
}
90000562:	4770      	bx	lr

90000564 <vApplicationMallocFailedHook>:
90000564:	4770      	bx	lr

90000566 <vApplicationDaemonTaskStartupHook>:
90000566:	4770      	bx	lr

90000568 <MX_FREERTOS_Init>:
void MX_FREERTOS_Init(void) {
90000568:	b508      	push	{r3, lr}
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
9000056a:	4a04      	ldr	r2, [pc, #16]	; (9000057c <MX_FREERTOS_Init+0x14>)
9000056c:	2100      	movs	r1, #0
9000056e:	4804      	ldr	r0, [pc, #16]	; (90000580 <MX_FREERTOS_Init+0x18>)
90000570:	f006 fc51 	bl	90006e16 <osThreadNew>
90000574:	4b03      	ldr	r3, [pc, #12]	; (90000584 <MX_FREERTOS_Init+0x1c>)
90000576:	6018      	str	r0, [r3, #0]
}
90000578:	bd08      	pop	{r3, pc}
9000057a:	bf00      	nop
9000057c:	90012a9c 	.word	0x90012a9c
90000580:	9000054d 	.word	0x9000054d
90000584:	240001b0 	.word	0x240001b0

90000588 <MX_GPIO_Init>:
*/
void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
90000588:	4b2b      	ldr	r3, [pc, #172]	; (90000638 <MX_GPIO_Init+0xb0>)
{
9000058a:	b088      	sub	sp, #32
  __HAL_RCC_GPIOC_CLK_ENABLE();
9000058c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000590:	f042 0204 	orr.w	r2, r2, #4
90000594:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000598:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
9000059c:	f002 0204 	and.w	r2, r2, #4
900005a0:	9201      	str	r2, [sp, #4]
900005a2:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOE_CLK_ENABLE();
900005a4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005a8:	f042 0210 	orr.w	r2, r2, #16
900005ac:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
900005b0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005b4:	f002 0210 	and.w	r2, r2, #16
900005b8:	9202      	str	r2, [sp, #8]
900005ba:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
900005bc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005c0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
900005c4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
900005c8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005cc:	f002 0240 	and.w	r2, r2, #64	; 0x40
900005d0:	9203      	str	r2, [sp, #12]
900005d2:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
900005d4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005d8:	f042 0208 	orr.w	r2, r2, #8
900005dc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
900005e0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005e4:	f002 0208 	and.w	r2, r2, #8
900005e8:	9204      	str	r2, [sp, #16]
900005ea:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
900005ec:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005f0:	f042 0220 	orr.w	r2, r2, #32
900005f4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
900005f8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900005fc:	f002 0220 	and.w	r2, r2, #32
90000600:	9205      	str	r2, [sp, #20]
90000602:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOH_CLK_ENABLE();
90000604:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000608:	f042 0280 	orr.w	r2, r2, #128	; 0x80
9000060c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000610:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000614:	f002 0280 	and.w	r2, r2, #128	; 0x80
90000618:	9206      	str	r2, [sp, #24]
9000061a:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOA_CLK_ENABLE();
9000061c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000620:	f042 0201 	orr.w	r2, r2, #1
90000624:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000628:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000062c:	f003 0301 	and.w	r3, r3, #1
90000630:	9307      	str	r3, [sp, #28]
90000632:	9b07      	ldr	r3, [sp, #28]

}
90000634:	b008      	add	sp, #32
90000636:	4770      	bx	lr
90000638:	58024400 	.word	0x58024400

9000063c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
9000063c:	b530      	push	{r4, r5, lr}
9000063e:	b09f      	sub	sp, #124	; 0x7c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
90000640:	224c      	movs	r2, #76	; 0x4c
90000642:	2100      	movs	r1, #0
90000644:	a80b      	add	r0, sp, #44	; 0x2c
90000646:	f011 f9c9 	bl	900119dc <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
9000064a:	2220      	movs	r2, #32
9000064c:	2100      	movs	r1, #0
9000064e:	a803      	add	r0, sp, #12
90000650:	f011 f9c4 	bl	900119dc <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
90000654:	2002      	movs	r0, #2
90000656:	f002 fcef 	bl	90003038 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
9000065a:	2300      	movs	r3, #0
9000065c:	9300      	str	r3, [sp, #0]
9000065e:	4b39      	ldr	r3, [pc, #228]	; (90000744 <SystemClock_Config+0x108>)
90000660:	6ada      	ldr	r2, [r3, #44]	; 0x2c
90000662:	f022 0201 	bic.w	r2, r2, #1
90000666:	62da      	str	r2, [r3, #44]	; 0x2c
90000668:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000066a:	f003 0301 	and.w	r3, r3, #1
9000066e:	9300      	str	r3, [sp, #0]
90000670:	4b35      	ldr	r3, [pc, #212]	; (90000748 <SystemClock_Config+0x10c>)
90000672:	699a      	ldr	r2, [r3, #24]
90000674:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
90000678:	619a      	str	r2, [r3, #24]
9000067a:	699a      	ldr	r2, [r3, #24]
9000067c:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
90000680:	9200      	str	r2, [sp, #0]
90000682:	9a00      	ldr	r2, [sp, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
90000684:	699a      	ldr	r2, [r3, #24]
90000686:	0495      	lsls	r5, r2, #18
90000688:	d5fc      	bpl.n	90000684 <SystemClock_Config+0x48>

  __HAL_RCC_SYSCFG_CLK_ENABLE();
9000068a:	4a30      	ldr	r2, [pc, #192]	; (9000074c <SystemClock_Config+0x110>)
9000068c:	f8d2 10f4 	ldr.w	r1, [r2, #244]	; 0xf4
90000690:	f041 0102 	orr.w	r1, r1, #2
90000694:	f8c2 10f4 	str.w	r1, [r2, #244]	; 0xf4
90000698:	f8d2 10f4 	ldr.w	r1, [r2, #244]	; 0xf4
9000069c:	f001 0102 	and.w	r1, r1, #2
900006a0:	9101      	str	r1, [sp, #4]
900006a2:	9901      	ldr	r1, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
900006a4:	2100      	movs	r1, #0
900006a6:	9102      	str	r1, [sp, #8]
900006a8:	6999      	ldr	r1, [r3, #24]
900006aa:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
900006ae:	6199      	str	r1, [r3, #24]
900006b0:	699b      	ldr	r3, [r3, #24]
900006b2:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
900006b6:	9302      	str	r3, [sp, #8]
900006b8:	4b22      	ldr	r3, [pc, #136]	; (90000744 <SystemClock_Config+0x108>)
900006ba:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
900006bc:	f041 0101 	orr.w	r1, r1, #1
900006c0:	62d9      	str	r1, [r3, #44]	; 0x2c
900006c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
900006c4:	4920      	ldr	r1, [pc, #128]	; (90000748 <SystemClock_Config+0x10c>)
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
900006c6:	f003 0301 	and.w	r3, r3, #1
900006ca:	9302      	str	r3, [sp, #8]
900006cc:	9b02      	ldr	r3, [sp, #8]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
900006ce:	698b      	ldr	r3, [r1, #24]
900006d0:	049c      	lsls	r4, r3, #18
900006d2:	d5fc      	bpl.n	900006ce <SystemClock_Config+0x92>

  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
900006d4:	6a93      	ldr	r3, [r2, #40]	; 0x28

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900006d6:	2101      	movs	r1, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 5;
  RCC_OscInitStruct.PLL.PLLN = 192;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
900006d8:	2404      	movs	r4, #4
  RCC_OscInitStruct.PLL.PLLN = 192;
900006da:	2005      	movs	r0, #5
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
900006dc:	f023 0303 	bic.w	r3, r3, #3
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
900006e0:	2508      	movs	r5, #8
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
900006e2:	f043 0302 	orr.w	r3, r3, #2
900006e6:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900006e8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLN = 192;
900006ec:	22c0      	movs	r2, #192	; 0xc0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900006ee:	e9cd 130b 	strd	r1, r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
900006f2:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
900006f4:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLP = 2;
900006f8:	9318      	str	r3, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLR = 2;
900006fa:	e9cd 4319 	strd	r4, r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
900006fe:	2300      	movs	r3, #0
  RCC_OscInitStruct.PLL.PLLN = 192;
90000700:	e9cd 0216 	strd	r0, r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
90000704:	a80b      	add	r0, sp, #44	; 0x2c
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
90000706:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
90000708:	e9cd 531b 	strd	r5, r3, [sp, #108]	; 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
9000070c:	f002 ff1a 	bl	90003544 <HAL_RCC_OscConfig>
90000710:	b108      	cbz	r0, 90000716 <SystemClock_Config+0xda>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
90000712:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
90000714:	e7fe      	b.n	90000714 <SystemClock_Config+0xd8>
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
90000716:	223f      	movs	r2, #63	; 0x3f
90000718:	2303      	movs	r3, #3
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
9000071a:	4621      	mov	r1, r4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
9000071c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
90000720:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
90000722:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
90000726:	e9cd 0505 	strd	r0, r5, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
9000072a:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
9000072c:	e9cd 3307 	strd	r3, r3, [sp, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
90000730:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
90000734:	f003 fa38 	bl	90003ba8 <HAL_RCC_ClockConfig>
90000738:	b108      	cbz	r0, 9000073e <SystemClock_Config+0x102>
9000073a:	b672      	cpsid	i
  while (1)
9000073c:	e7fe      	b.n	9000073c <SystemClock_Config+0x100>
}
9000073e:	b01f      	add	sp, #124	; 0x7c
90000740:	bd30      	pop	{r4, r5, pc}
90000742:	bf00      	nop
90000744:	58000400 	.word	0x58000400
90000748:	58024800 	.word	0x58024800
9000074c:	58024400 	.word	0x58024400

90000750 <main>:
{
90000750:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  MPU_Config();
90000752:	f000 ff87 	bl	90001664 <MPU_Config>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
90000756:	4b3f      	ldr	r3, [pc, #252]	; (90000854 <main+0x104>)
90000758:	695a      	ldr	r2, [r3, #20]
9000075a:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
9000075e:	d111      	bne.n	90000784 <main+0x34>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
90000760:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90000764:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
90000768:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
9000076c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90000770:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
90000774:	695a      	ldr	r2, [r3, #20]
90000776:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
9000077a:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
9000077c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90000780:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
90000784:	4a33      	ldr	r2, [pc, #204]	; (90000854 <main+0x104>)
90000786:	6953      	ldr	r3, [r2, #20]
90000788:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
9000078c:	d123      	bne.n	900007d6 <main+0x86>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
9000078e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
90000792:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
90000796:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
9000079a:	f643 74e0 	movw	r4, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
9000079e:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
900007a2:	f3c3 334e 	ubfx	r3, r3, #13, #15
900007a6:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900007a8:	ea03 0604 	and.w	r6, r3, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
900007ac:	4601      	mov	r1, r0
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900007ae:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
900007b2:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900007b4:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
      } while (ways-- != 0U);
900007b8:	d2f9      	bcs.n	900007ae <main+0x5e>
    } while(sets-- != 0U);
900007ba:	3b20      	subs	r3, #32
900007bc:	f113 0f20 	cmn.w	r3, #32
900007c0:	d1f2      	bne.n	900007a8 <main+0x58>
900007c2:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
900007c6:	6953      	ldr	r3, [r2, #20]
900007c8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900007cc:	6153      	str	r3, [r2, #20]
900007ce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
900007d2:	f3bf 8f6f 	isb	sy
  HAL_Init();
900007d6:	f001 fa5f 	bl	90001c98 <HAL_Init>
  SystemClock_Config();
900007da:	f7ff ff2f 	bl	9000063c <SystemClock_Config>
  __HAL_RCC_D2SRAM1_CLK_ENABLE();
900007de:	4b1e      	ldr	r3, [pc, #120]	; (90000858 <main+0x108>)
900007e0:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
900007e4:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
900007e8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
900007ec:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
900007f0:	f002 5200 	and.w	r2, r2, #536870912	; 0x20000000
900007f4:	9201      	str	r2, [sp, #4]
900007f6:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_D2SRAM2_CLK_ENABLE();
900007f8:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
900007fc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
90000800:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
90000804:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
90000808:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
9000080c:	9202      	str	r2, [sp, #8]
9000080e:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_D2SRAM3_CLK_ENABLE();
90000810:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
90000814:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
90000818:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
9000081c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
90000820:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
90000824:	9303      	str	r3, [sp, #12]
90000826:	9b03      	ldr	r3, [sp, #12]
  MX_GPIO_Init();
90000828:	f7ff feae 	bl	90000588 <MX_GPIO_Init>
  MX_SDMMC1_SD_Init();
9000082c:	f000 f8a6 	bl	9000097c <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
90000830:	f000 f9ae 	bl	90000b90 <MX_FATFS_Init>
  MX_QUADSPI_Init();
90000834:	f000 f814 	bl	90000860 <MX_QUADSPI_Init>
  MX_FMC_Init();
90000838:	f7ff fdaa 	bl	90000390 <MX_FMC_Init>
  W25QXX_Init();
9000083c:	f001 f8b2 	bl	900019a4 <W25QXX_Init>
  W25Q_Memory_Mapped_Enable();
90000840:	f001 f8c0 	bl	900019c4 <W25Q_Memory_Mapped_Enable>
  osKernelInitialize();  /* Call init function for freertos objects (in freertos.c) */
90000844:	f006 faa4 	bl	90006d90 <osKernelInitialize>
  MX_FREERTOS_Init();
90000848:	f7ff fe8e 	bl	90000568 <MX_FREERTOS_Init>
  osKernelStart();
9000084c:	f006 fac2 	bl	90006dd4 <osKernelStart>
  while (1)
90000850:	e7fe      	b.n	90000850 <main+0x100>
90000852:	bf00      	nop
90000854:	e000ed00 	.word	0xe000ed00
90000858:	58024400 	.word	0x58024400

9000085c <Error_Handler>:
  __ASM volatile ("cpsid i" : : : "memory");
9000085c:	b672      	cpsid	i
  while (1)
9000085e:	e7fe      	b.n	9000085e <Error_Handler+0x2>

90000860 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
90000860:	b508      	push	{r3, lr}
  /* USER CODE END QUADSPI_Init 0 */

  /* USER CODE BEGIN QUADSPI_Init 1 */

  /* USER CODE END QUADSPI_Init 1 */
  hqspi.Instance = QUADSPI;
90000862:	480d      	ldr	r0, [pc, #52]	; (90000898 <MX_QUADSPI_Init+0x38>)
  hqspi.Init.ClockPrescaler = 2;
90000864:	2302      	movs	r3, #2
90000866:	4a0d      	ldr	r2, [pc, #52]	; (9000089c <MX_QUADSPI_Init+0x3c>)
  hqspi.Init.FifoThreshold = 32;
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
90000868:	2120      	movs	r1, #32
  hqspi.Init.FlashSize = 8;
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_2_CYCLE;
9000086a:	f04f 0c08 	mov.w	ip, #8
  hqspi.Init.ClockPrescaler = 2;
9000086e:	e9c0 2300 	strd	r2, r3, [r0]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
90000872:	2310      	movs	r3, #16
90000874:	e9c0 1302 	strd	r1, r3, [r0, #8]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_2_CYCLE;
90000878:	f44f 7380 	mov.w	r3, #256	; 0x100
9000087c:	e9c0 c304 	strd	ip, r3, [r0, #16]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
90000880:	2300      	movs	r3, #0
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
90000882:	e9c0 3306 	strd	r3, r3, [r0, #24]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
90000886:	6203      	str	r3, [r0, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
90000888:	f002 fcd2 	bl	90003230 <HAL_QSPI_Init>
9000088c:	b118      	cbz	r0, 90000896 <MX_QUADSPI_Init+0x36>
  }
  /* USER CODE BEGIN QUADSPI_Init 2 */

  /* USER CODE END QUADSPI_Init 2 */

}
9000088e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
90000892:	f7ff bfe3 	b.w	9000085c <Error_Handler>
}
90000896:	bd08      	pop	{r3, pc}
90000898:	240001b4 	.word	0x240001b4
9000089c:	52005000 	.word	0x52005000

900008a0 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
900008a0:	b5f0      	push	{r4, r5, r6, r7, lr}
900008a2:	b0b9      	sub	sp, #228	; 0xe4
900008a4:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
900008a6:	2214      	movs	r2, #20
900008a8:	2100      	movs	r1, #0
900008aa:	a804      	add	r0, sp, #16
900008ac:	f011 f896 	bl	900119dc <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
900008b0:	22bc      	movs	r2, #188	; 0xbc
900008b2:	2100      	movs	r1, #0
900008b4:	a809      	add	r0, sp, #36	; 0x24
900008b6:	f011 f891 	bl	900119dc <memset>
  if(qspiHandle->Instance==QUADSPI)
900008ba:	6822      	ldr	r2, [r4, #0]
900008bc:	4b2b      	ldr	r3, [pc, #172]	; (9000096c <HAL_QSPI_MspInit+0xcc>)
900008be:	429a      	cmp	r2, r3
900008c0:	d152      	bne.n	90000968 <HAL_QSPI_MspInit+0xc8>

  /* USER CODE END QUADSPI_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
900008c2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
900008c6:	a809      	add	r0, sp, #36	; 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
900008c8:	9309      	str	r3, [sp, #36]	; 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
900008ca:	f003 fba5 	bl	90004018 <HAL_RCCEx_PeriphCLKConfig>
900008ce:	b108      	cbz	r0, 900008d4 <HAL_QSPI_MspInit+0x34>
    {
      Error_Handler();
900008d0:	f7ff ffc4 	bl	9000085c <Error_Handler>
    }

    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
900008d4:	4b26      	ldr	r3, [pc, #152]	; (90000970 <HAL_QSPI_MspInit+0xd0>)
    PF8     ------> QUADSPI_BK1_IO0
    PF10     ------> QUADSPI_CLK
    PF9     ------> QUADSPI_BK1_IO1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900008d6:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900008d8:	2500      	movs	r5, #0
900008da:	2403      	movs	r4, #3
    __HAL_RCC_QSPI_CLK_ENABLE();
900008dc:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
900008e0:	270a      	movs	r7, #10
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
900008e2:	a904      	add	r1, sp, #16
900008e4:	4823      	ldr	r0, [pc, #140]	; (90000974 <HAL_QSPI_MspInit+0xd4>)
    __HAL_RCC_QSPI_CLK_ENABLE();
900008e6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
900008ea:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
900008ee:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
900008f2:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
900008f6:	9201      	str	r2, [sp, #4]
900008f8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOG_CLK_ENABLE();
900008fa:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900008fe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
90000902:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000906:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
9000090a:	f002 0240 	and.w	r2, r2, #64	; 0x40
9000090e:	9202      	str	r2, [sp, #8]
90000910:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOF_CLK_ENABLE();
90000912:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000916:	f042 0220 	orr.w	r2, r2, #32
9000091a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
9000091e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
90000922:	9708      	str	r7, [sp, #32]
    __HAL_RCC_GPIOF_CLK_ENABLE();
90000924:	f003 0320 	and.w	r3, r3, #32
90000928:	9303      	str	r3, [sp, #12]
9000092a:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000092c:	2340      	movs	r3, #64	; 0x40
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000092e:	e9cd 5406 	strd	r5, r4, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000932:	e9cd 3604 	strd	r3, r6, [sp, #16]
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
90000936:	f002 fa8d 	bl	90002e54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
9000093a:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
9000093e:	a904      	add	r1, sp, #16
90000940:	480d      	ldr	r0, [pc, #52]	; (90000978 <HAL_QSPI_MspInit+0xd8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000942:	e9cd 3604 	strd	r3, r6, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
90000946:	2309      	movs	r3, #9
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000948:	e9cd 5406 	strd	r5, r4, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
9000094c:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
9000094e:	f002 fa81 	bl	90002e54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
90000952:	f44f 7340 	mov.w	r3, #768	; 0x300
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
90000956:	a904      	add	r1, sp, #16
90000958:	4807      	ldr	r0, [pc, #28]	; (90000978 <HAL_QSPI_MspInit+0xd8>)
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
9000095a:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000095c:	e9cd 3604 	strd	r3, r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000960:	e9cd 5406 	strd	r5, r4, [sp, #24]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
90000964:	f002 fa76 	bl	90002e54 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
90000968:	b039      	add	sp, #228	; 0xe4
9000096a:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000096c:	52005000 	.word	0x52005000
90000970:	58024400 	.word	0x58024400
90000974:	58021800 	.word	0x58021800
90000978:	58021400 	.word	0x58021400

9000097c <MX_SDMMC1_SD_Init>:
  /* USER CODE END SDMMC1_Init 0 */

  /* USER CODE BEGIN SDMMC1_Init 1 */

  /* USER CODE END SDMMC1_Init 1 */
  hsd1.Instance = SDMMC1;
9000097c:	4b06      	ldr	r3, [pc, #24]	; (90000998 <MX_SDMMC1_SD_Init+0x1c>)
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
9000097e:	2200      	movs	r2, #0
90000980:	4906      	ldr	r1, [pc, #24]	; (9000099c <MX_SDMMC1_SD_Init+0x20>)
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
90000982:	609a      	str	r2, [r3, #8]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
90000984:	e9c3 1200 	strd	r1, r2, [r3]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
90000988:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
9000098c:	e9c3 1203 	strd	r1, r2, [r3, #12]
  hsd1.Init.ClockDiv = 3;
90000990:	2203      	movs	r2, #3
90000992:	615a      	str	r2, [r3, #20]
  /* USER CODE BEGIN SDMMC1_Init 2 */

  /* USER CODE END SDMMC1_Init 2 */

}
90000994:	4770      	bx	lr
90000996:	bf00      	nop
90000998:	24000200 	.word	0x24000200
9000099c:	52007000 	.word	0x52007000

900009a0 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
900009a0:	b5f0      	push	{r4, r5, r6, r7, lr}
900009a2:	b0b9      	sub	sp, #228	; 0xe4
900009a4:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
900009a6:	2214      	movs	r2, #20
900009a8:	2100      	movs	r1, #0
900009aa:	a804      	add	r0, sp, #16
900009ac:	f011 f816 	bl	900119dc <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
900009b0:	22bc      	movs	r2, #188	; 0xbc
900009b2:	2100      	movs	r1, #0
900009b4:	a809      	add	r0, sp, #36	; 0x24
900009b6:	f011 f811 	bl	900119dc <memset>
  if(sdHandle->Instance==SDMMC1)
900009ba:	6822      	ldr	r2, [r4, #0]
900009bc:	4b29      	ldr	r3, [pc, #164]	; (90000a64 <HAL_SD_MspInit+0xc4>)
900009be:	429a      	cmp	r2, r3
900009c0:	d14e      	bne.n	90000a60 <HAL_SD_MspInit+0xc0>

  /* USER CODE END SDMMC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;
900009c2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
900009c6:	a809      	add	r0, sp, #36	; 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;
900009c8:	9309      	str	r3, [sp, #36]	; 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
900009ca:	f003 fb25 	bl	90004018 <HAL_RCCEx_PeriphCLKConfig>
900009ce:	b108      	cbz	r0, 900009d4 <HAL_SD_MspInit+0x34>
    {
      Error_Handler();
900009d0:	f7ff ff44 	bl	9000085c <Error_Handler>
    }

    /* SDMMC1 clock enable */
    __HAL_RCC_SDMMC1_CLK_ENABLE();
900009d4:	4b24      	ldr	r3, [pc, #144]	; (90000a68 <HAL_SD_MspInit+0xc8>)
    PC8     ------> SDMMC1_D0
    PC9     ------> SDMMC1_D1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_8
                          |GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900009d6:	2702      	movs	r7, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900009d8:	2601      	movs	r6, #1
900009da:	2503      	movs	r5, #3
    __HAL_RCC_SDMMC1_CLK_ENABLE();
900009dc:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
900009e0:	240c      	movs	r4, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
900009e2:	a904      	add	r1, sp, #16
900009e4:	4821      	ldr	r0, [pc, #132]	; (90000a6c <HAL_SD_MspInit+0xcc>)
    __HAL_RCC_SDMMC1_CLK_ENABLE();
900009e6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900009ea:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
900009ee:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
900009f2:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
900009f6:	9201      	str	r2, [sp, #4]
900009f8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
900009fa:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900009fe:	f042 0204 	orr.w	r2, r2, #4
90000a02:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000a06:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000a0a:	f002 0204 	and.w	r2, r2, #4
90000a0e:	9202      	str	r2, [sp, #8]
90000a10:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
90000a12:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90000a16:	f042 0208 	orr.w	r2, r2, #8
90000a1a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90000a1e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
90000a22:	9408      	str	r4, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
90000a24:	f003 0308 	and.w	r3, r3, #8
90000a28:	9303      	str	r3, [sp, #12]
90000a2a:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a2c:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000a30:	e9cd 6506 	strd	r6, r5, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a34:	e9cd 3704 	strd	r3, r7, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000a38:	f002 fa0c 	bl	90002e54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
90000a3c:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
90000a3e:	a904      	add	r1, sp, #16
90000a40:	480b      	ldr	r0, [pc, #44]	; (90000a70 <HAL_SD_MspInit+0xd0>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
90000a42:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a44:	e9cd 3704 	strd	r3, r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000a48:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
90000a4c:	f002 fa02 	bl	90002e54 <HAL_GPIO_Init>

    /* SDMMC1 interrupt Init */
    HAL_NVIC_SetPriority(SDMMC1_IRQn, 5, 0);
90000a50:	2031      	movs	r0, #49	; 0x31
90000a52:	2200      	movs	r2, #0
90000a54:	2105      	movs	r1, #5
90000a56:	f001 f993 	bl	90001d80 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
90000a5a:	2031      	movs	r0, #49	; 0x31
90000a5c:	f001 f9c2 	bl	90001de4 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
90000a60:	b039      	add	sp, #228	; 0xe4
90000a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
90000a64:	52007000 	.word	0x52007000
90000a68:	58024400 	.word	0x58024400
90000a6c:	58020800 	.word	0x58020800
90000a70:	58020c00 	.word	0x58020c00

90000a74 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
90000a74:	4b0a      	ldr	r3, [pc, #40]	; (90000aa0 <HAL_MspInit+0x2c>)
{
90000a76:	b082      	sub	sp, #8

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
90000a78:	210f      	movs	r1, #15
90000a7a:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_SYSCFG_CLK_ENABLE();
90000a7e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
90000a82:	f042 0202 	orr.w	r2, r2, #2
90000a86:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
90000a8a:	2200      	movs	r2, #0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
90000a8c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
90000a90:	f003 0302 	and.w	r3, r3, #2
90000a94:	9301      	str	r3, [sp, #4]
90000a96:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
90000a98:	b002      	add	sp, #8
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
90000a9a:	f001 b971 	b.w	90001d80 <HAL_NVIC_SetPriority>
90000a9e:	bf00      	nop
90000aa0:	58024400 	.word	0x58024400

90000aa4 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
90000aa4:	e7fe      	b.n	90000aa4 <NMI_Handler>

90000aa6 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
90000aa6:	e7fe      	b.n	90000aa6 <HardFault_Handler>

90000aa8 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
90000aa8:	e7fe      	b.n	90000aa8 <MemManage_Handler>

90000aaa <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
90000aaa:	e7fe      	b.n	90000aaa <BusFault_Handler>

90000aac <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
90000aac:	e7fe      	b.n	90000aac <UsageFault_Handler>

90000aae <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
90000aae:	4770      	bx	lr

90000ab0 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
90000ab0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
90000ab2:	f001 f91f 	bl	90001cf4 <HAL_IncTick>
#if (INCLUDE_xTaskGetSchedulerState == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
90000ab6:	f008 f885 	bl	90008bc4 <xTaskGetSchedulerState>
90000aba:	2801      	cmp	r0, #1
90000abc:	d003      	beq.n	90000ac6 <SysTick_Handler+0x16>
  }
#endif /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
90000abe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  xPortSysTickHandler();
90000ac2:	f006 bdc7 	b.w	90007654 <xPortSysTickHandler>
}
90000ac6:	bd08      	pop	{r3, pc}

90000ac8 <SDMMC1_IRQHandler>:
void SDMMC1_IRQHandler(void)
{
  /* USER CODE BEGIN SDMMC1_IRQn 0 */

  /* USER CODE END SDMMC1_IRQn 0 */
  HAL_SD_IRQHandler(&hsd1);
90000ac8:	4801      	ldr	r0, [pc, #4]	; (90000ad0 <SDMMC1_IRQHandler+0x8>)
90000aca:	f004 bfbf 	b.w	90005a4c <HAL_SD_IRQHandler>
90000ace:	bf00      	nop
90000ad0:	24000200 	.word	0x24000200

90000ad4 <ETH_IRQHandler>:
void ETH_IRQHandler(void)
{
  /* USER CODE BEGIN ETH_IRQn 0 */

  /* USER CODE END ETH_IRQn 0 */
  HAL_ETH_IRQHandler(&heth);
90000ad4:	4801      	ldr	r0, [pc, #4]	; (90000adc <ETH_IRQHandler+0x8>)
90000ad6:	f001 be97 	b.w	90002808 <HAL_ETH_IRQHandler>
90000ada:	bf00      	nop
90000adc:	24000364 	.word	0x24000364

90000ae0 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
90000ae0:	2001      	movs	r0, #1
90000ae2:	4770      	bx	lr

90000ae4 <_kill>:

int _kill(int pid, int sig)
{
	errno = EINVAL;
90000ae4:	4b02      	ldr	r3, [pc, #8]	; (90000af0 <_kill+0xc>)
90000ae6:	2216      	movs	r2, #22
	return -1;
}
90000ae8:	f04f 30ff 	mov.w	r0, #4294967295
	errno = EINVAL;
90000aec:	601a      	str	r2, [r3, #0]
}
90000aee:	4770      	bx	lr
90000af0:	2400d3a8 	.word	0x2400d3a8

90000af4 <_exit>:
	errno = EINVAL;
90000af4:	4b01      	ldr	r3, [pc, #4]	; (90000afc <_exit+0x8>)
90000af6:	2216      	movs	r2, #22
90000af8:	601a      	str	r2, [r3, #0]

void _exit (int status)
{
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
90000afa:	e7fe      	b.n	90000afa <_exit+0x6>
90000afc:	2400d3a8 	.word	0x2400d3a8

90000b00 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
90000b00:	b570      	push	{r4, r5, r6, lr}
90000b02:	460d      	mov	r5, r1
90000b04:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
90000b06:	460e      	mov	r6, r1
90000b08:	1b73      	subs	r3, r6, r5
90000b0a:	429c      	cmp	r4, r3
90000b0c:	dc01      	bgt.n	90000b12 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
90000b0e:	4620      	mov	r0, r4
90000b10:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
90000b12:	f3af 8000 	nop.w
90000b16:	f806 0b01 	strb.w	r0, [r6], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
90000b1a:	e7f5      	b.n	90000b08 <_read+0x8>

90000b1c <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
90000b1c:	b570      	push	{r4, r5, r6, lr}
90000b1e:	460d      	mov	r5, r1
90000b20:	4614      	mov	r4, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
90000b22:	460e      	mov	r6, r1
90000b24:	1b73      	subs	r3, r6, r5
90000b26:	429c      	cmp	r4, r3
90000b28:	dc01      	bgt.n	90000b2e <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
90000b2a:	4620      	mov	r0, r4
90000b2c:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
90000b2e:	f816 0b01 	ldrb.w	r0, [r6], #1
90000b32:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
90000b36:	e7f5      	b.n	90000b24 <_write+0x8>

90000b38 <_close>:

int _close(int file)
{
	return -1;
}
90000b38:	f04f 30ff 	mov.w	r0, #4294967295
90000b3c:	4770      	bx	lr

90000b3e <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
90000b3e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
90000b42:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
90000b44:	604b      	str	r3, [r1, #4]
}
90000b46:	4770      	bx	lr

90000b48 <_isatty>:

int _isatty(int file)
{
	return 1;
}
90000b48:	2001      	movs	r0, #1
90000b4a:	4770      	bx	lr

90000b4c <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
90000b4c:	2000      	movs	r0, #0
90000b4e:	4770      	bx	lr

90000b50 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
90000b50:	4a0a      	ldr	r2, [pc, #40]	; (90000b7c <_sbrk+0x2c>)
{
90000b52:	4603      	mov	r3, r0
  if (NULL == __sbrk_heap_end)
90000b54:	6811      	ldr	r1, [r2, #0]
{
90000b56:	b510      	push	{r4, lr}
  if (NULL == __sbrk_heap_end)
90000b58:	b909      	cbnz	r1, 90000b5e <_sbrk+0xe>
  {
    __sbrk_heap_end = &_end;
90000b5a:	4909      	ldr	r1, [pc, #36]	; (90000b80 <_sbrk+0x30>)
90000b5c:	6011      	str	r1, [r2, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
90000b5e:	6810      	ldr	r0, [r2, #0]
90000b60:	4c08      	ldr	r4, [pc, #32]	; (90000b84 <_sbrk+0x34>)
90000b62:	4909      	ldr	r1, [pc, #36]	; (90000b88 <_sbrk+0x38>)
90000b64:	4403      	add	r3, r0
90000b66:	1b09      	subs	r1, r1, r4
90000b68:	428b      	cmp	r3, r1
  {
    errno = ENOMEM;
90000b6a:	bf83      	ittte	hi
90000b6c:	4b07      	ldrhi	r3, [pc, #28]	; (90000b8c <_sbrk+0x3c>)
90000b6e:	220c      	movhi	r2, #12
    return (void *)-1;
90000b70:	f04f 30ff 	movhi.w	r0, #4294967295
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
90000b74:	6013      	strls	r3, [r2, #0]
    errno = ENOMEM;
90000b76:	bf88      	it	hi
90000b78:	601a      	strhi	r2, [r3, #0]

  return (void *)prev_heap_end;
}
90000b7a:	bd10      	pop	{r4, pc}
90000b7c:	2400027c 	.word	0x2400027c
90000b80:	2400d438 	.word	0x2400d438
90000b84:	00000800 	.word	0x00000800
90000b88:	24080000 	.word	0x24080000
90000b8c:	2400d3a8 	.word	0x2400d3a8

90000b90 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
90000b90:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
90000b92:	4903      	ldr	r1, [pc, #12]	; (90000ba0 <MX_FATFS_Init+0x10>)
90000b94:	4803      	ldr	r0, [pc, #12]	; (90000ba4 <MX_FATFS_Init+0x14>)
90000b96:	f006 f8f7 	bl	90006d88 <FATFS_LinkDriver>
90000b9a:	4b03      	ldr	r3, [pc, #12]	; (90000ba8 <MX_FATFS_Init+0x18>)
90000b9c:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
90000b9e:	bd08      	pop	{r3, pc}
90000ba0:	24000280 	.word	0x24000280
90000ba4:	90012ac0 	.word	0x90012ac0
90000ba8:	24000284 	.word	0x24000284

90000bac <BSP_SD_ReadBlocks_DMA>:
  * @param  ReadAddr: Address from where data is to be read
  * @param  NumOfBlocks: Number of SD blocks to read
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)
{
90000bac:	b508      	push	{r3, lr}
90000bae:	4613      	mov	r3, r2
  uint8_t sd_state = MSD_OK;

  /* Read block(s) in DMA transfer mode */
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
90000bb0:	460a      	mov	r2, r1
90000bb2:	4601      	mov	r1, r0
90000bb4:	4803      	ldr	r0, [pc, #12]	; (90000bc4 <BSP_SD_ReadBlocks_DMA+0x18>)
90000bb6:	f004 faa7 	bl	90005108 <HAL_SD_ReadBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;
}
90000bba:	3800      	subs	r0, #0
90000bbc:	bf18      	it	ne
90000bbe:	2001      	movne	r0, #1
90000bc0:	bd08      	pop	{r3, pc}
90000bc2:	bf00      	nop
90000bc4:	24000200 	.word	0x24000200

90000bc8 <BSP_SD_WriteBlocks_DMA>:
  * @param  WriteAddr: Address from where data is to be written
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)
{
90000bc8:	b508      	push	{r3, lr}
90000bca:	4613      	mov	r3, r2
  uint8_t sd_state = MSD_OK;

  /* Write block(s) in DMA transfer mode */
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
90000bcc:	460a      	mov	r2, r1
90000bce:	4601      	mov	r1, r0
90000bd0:	4803      	ldr	r0, [pc, #12]	; (90000be0 <BSP_SD_WriteBlocks_DMA+0x18>)
90000bd2:	f004 fb03 	bl	900051dc <HAL_SD_WriteBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;
}
90000bd6:	3800      	subs	r0, #0
90000bd8:	bf18      	it	ne
90000bda:	2001      	movne	r0, #1
90000bdc:	bd08      	pop	{r3, pc}
90000bde:	bf00      	nop
90000be0:	24000200 	.word	0x24000200

90000be4 <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
90000be4:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
90000be6:	4803      	ldr	r0, [pc, #12]	; (90000bf4 <BSP_SD_GetCardState+0x10>)
90000be8:	f004 fec4 	bl	90005974 <HAL_SD_GetCardState>
}
90000bec:	3804      	subs	r0, #4
90000bee:	bf18      	it	ne
90000bf0:	2001      	movne	r0, #1
90000bf2:	bd08      	pop	{r3, pc}
90000bf4:	24000200 	.word	0x24000200

90000bf8 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
90000bf8:	4601      	mov	r1, r0
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
90000bfa:	4801      	ldr	r0, [pc, #4]	; (90000c00 <BSP_SD_GetCardInfo+0x8>)
90000bfc:	f004 bde8 	b.w	900057d0 <HAL_SD_GetCardInfo>
90000c00:	24000200 	.word	0x24000200

90000c04 <HAL_SD_TxCpltCallback>:
  * @brief Tx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
90000c04:	b508      	push	{r3, lr}
  BSP_SD_WriteCpltCallback();
90000c06:	f000 f905 	bl	90000e14 <BSP_SD_WriteCpltCallback>
}
90000c0a:	bd08      	pop	{r3, pc}

90000c0c <HAL_SD_RxCpltCallback>:
  * @brief Rx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
90000c0c:	b508      	push	{r3, lr}
  BSP_SD_ReadCpltCallback();
90000c0e:	f000 f913 	bl	90000e38 <BSP_SD_ReadCpltCallback>
}
90000c12:	bd08      	pop	{r3, pc}

90000c14 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
90000c14:	b082      	sub	sp, #8
  __IO uint8_t status = SD_PRESENT;
90000c16:	2301      	movs	r3, #1
90000c18:	f88d 3007 	strb.w	r3, [sp, #7]

  /* USER CODE BEGIN IsDetectedSection */
  /* user code can be inserted here */
  /* USER CODE END IsDetectedSection */

  return status;
90000c1c:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
90000c20:	b002      	add	sp, #8
90000c22:	4770      	bx	lr

90000c24 <BSP_SD_Init>:
{
90000c24:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
90000c26:	f7ff fff5 	bl	90000c14 <BSP_SD_IsDetected>
90000c2a:	2801      	cmp	r0, #1
90000c2c:	d10c      	bne.n	90000c48 <BSP_SD_Init+0x24>
  sd_state = HAL_SD_Init(&hsd1);
90000c2e:	4807      	ldr	r0, [pc, #28]	; (90000c4c <BSP_SD_Init+0x28>)
90000c30:	f004 feb4 	bl	9000599c <HAL_SD_Init>
  if (sd_state == MSD_OK)
90000c34:	b938      	cbnz	r0, 90000c46 <BSP_SD_Init+0x22>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
90000c36:	f44f 4180 	mov.w	r1, #16384	; 0x4000
90000c3a:	4804      	ldr	r0, [pc, #16]	; (90000c4c <BSP_SD_Init+0x28>)
90000c3c:	f004 fdda 	bl	900057f4 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
90000c40:	3800      	subs	r0, #0
90000c42:	bf18      	it	ne
90000c44:	2001      	movne	r0, #1
}
90000c46:	bd08      	pop	{r3, pc}
    return MSD_ERROR_SD_NOT_PRESENT;
90000c48:	2002      	movs	r0, #2
90000c4a:	e7fc      	b.n	90000c46 <BSP_SD_Init+0x22>
90000c4c:	24000200 	.word	0x24000200

90000c50 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
90000c50:	4b13      	ldr	r3, [pc, #76]	; (90000ca0 <SD_ioctl+0x50>)
{
90000c52:	b530      	push	{r4, r5, lr}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
90000c54:	781c      	ldrb	r4, [r3, #0]
{
90000c56:	b08b      	sub	sp, #44	; 0x2c
90000c58:	4615      	mov	r5, r2
  if (Stat & STA_NOINIT) return RES_NOTRDY;
90000c5a:	f014 0401 	ands.w	r4, r4, #1
90000c5e:	d11b      	bne.n	90000c98 <SD_ioctl+0x48>

  switch (cmd)
90000c60:	2903      	cmp	r1, #3
90000c62:	d803      	bhi.n	90000c6c <SD_ioctl+0x1c>
90000c64:	e8df f001 	tbb	[pc, r1]
90000c68:	120c061a 	.word	0x120c061a
90000c6c:	2404      	movs	r4, #4
  default:
    res = RES_PARERR;
  }

  return res;
}
90000c6e:	4620      	mov	r0, r4
90000c70:	b00b      	add	sp, #44	; 0x2c
90000c72:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
90000c74:	a801      	add	r0, sp, #4
90000c76:	f7ff ffbf 	bl	90000bf8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
90000c7a:	9b07      	ldr	r3, [sp, #28]
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
90000c7c:	602b      	str	r3, [r5, #0]
    break;
90000c7e:	e7f6      	b.n	90000c6e <SD_ioctl+0x1e>
    BSP_SD_GetCardInfo(&CardInfo);
90000c80:	a801      	add	r0, sp, #4
90000c82:	f7ff ffb9 	bl	90000bf8 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
90000c86:	9b08      	ldr	r3, [sp, #32]
90000c88:	802b      	strh	r3, [r5, #0]
    break;
90000c8a:	e7f0      	b.n	90000c6e <SD_ioctl+0x1e>
    BSP_SD_GetCardInfo(&CardInfo);
90000c8c:	a801      	add	r0, sp, #4
90000c8e:	f7ff ffb3 	bl	90000bf8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
90000c92:	9b08      	ldr	r3, [sp, #32]
90000c94:	0a5b      	lsrs	r3, r3, #9
90000c96:	e7f1      	b.n	90000c7c <SD_ioctl+0x2c>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
90000c98:	2403      	movs	r4, #3
90000c9a:	e7e8      	b.n	90000c6e <SD_ioctl+0x1e>
    res = RES_OK;
90000c9c:	460c      	mov	r4, r1
90000c9e:	e7e6      	b.n	90000c6e <SD_ioctl+0x1e>
90000ca0:	24000000 	.word	0x24000000

90000ca4 <SD_status>:
{
90000ca4:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
90000ca6:	2301      	movs	r3, #1
90000ca8:	4c05      	ldr	r4, [pc, #20]	; (90000cc0 <SD_status+0x1c>)
90000caa:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
90000cac:	f7ff ff9a 	bl	90000be4 <BSP_SD_GetCardState>
90000cb0:	b918      	cbnz	r0, 90000cba <SD_status+0x16>
    Stat &= ~STA_NOINIT;
90000cb2:	7823      	ldrb	r3, [r4, #0]
90000cb4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
90000cb8:	7023      	strb	r3, [r4, #0]
  return Stat;
90000cba:	7820      	ldrb	r0, [r4, #0]
}
90000cbc:	bd10      	pop	{r4, pc}
90000cbe:	bf00      	nop
90000cc0:	24000000 	.word	0x24000000

90000cc4 <SD_CheckStatusWithTimeout.constprop.0>:
static int SD_CheckStatusWithTimeout(uint32_t timeout)
90000cc4:	b538      	push	{r3, r4, r5, lr}
  timer = osKernelGetTickCount();
90000cc6:	f006 f89f 	bl	90006e08 <osKernelGetTickCount>
  while( osKernelGetTickCount() - timer < timeout)
90000cca:	f247 552f 	movw	r5, #29999	; 0x752f
  timer = osKernelGetTickCount();
90000cce:	4604      	mov	r4, r0
  while( osKernelGetTickCount() - timer < timeout)
90000cd0:	f006 f89a 	bl	90006e08 <osKernelGetTickCount>
90000cd4:	1b03      	subs	r3, r0, r4
90000cd6:	42ab      	cmp	r3, r5
90000cd8:	d902      	bls.n	90000ce0 <SD_CheckStatusWithTimeout.constprop.0+0x1c>
  return -1;
90000cda:	f04f 30ff 	mov.w	r0, #4294967295
90000cde:	e003      	b.n	90000ce8 <SD_CheckStatusWithTimeout.constprop.0+0x24>
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
90000ce0:	f7ff ff80 	bl	90000be4 <BSP_SD_GetCardState>
90000ce4:	2800      	cmp	r0, #0
90000ce6:	d1f3      	bne.n	90000cd0 <SD_CheckStatusWithTimeout.constprop.0+0xc>
}
90000ce8:	bd38      	pop	{r3, r4, r5, pc}
	...

90000cec <SD_write>:
{
90000cec:	b530      	push	{r4, r5, lr}
90000cee:	b085      	sub	sp, #20
90000cf0:	460c      	mov	r4, r1
90000cf2:	9201      	str	r2, [sp, #4]
90000cf4:	9300      	str	r3, [sp, #0]
  if (SD_CheckStatusWithTimeout(SD_TIMEOUT) < 0)
90000cf6:	f7ff ffe5 	bl	90000cc4 <SD_CheckStatusWithTimeout.constprop.0>
90000cfa:	2800      	cmp	r0, #0
90000cfc:	e9dd 2100 	ldrd	r2, r1, [sp]
90000d00:	da02      	bge.n	90000d08 <SD_write+0x1c>
  DRESULT res = RES_ERROR;
90000d02:	2001      	movs	r0, #1
}
90000d04:	b005      	add	sp, #20
90000d06:	bd30      	pop	{r4, r5, pc}
  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
90000d08:	4620      	mov	r0, r4
90000d0a:	f7ff ff5d 	bl	90000bc8 <BSP_SD_WriteBlocks_DMA>
90000d0e:	4602      	mov	r2, r0
90000d10:	2800      	cmp	r0, #0
90000d12:	d1f6      	bne.n	90000d02 <SD_write+0x16>
    status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
90000d14:	480e      	ldr	r0, [pc, #56]	; (90000d50 <SD_write+0x64>)
90000d16:	f247 5330 	movw	r3, #30000	; 0x7530
90000d1a:	f10d 010e 	add.w	r1, sp, #14
90000d1e:	6800      	ldr	r0, [r0, #0]
90000d20:	f006 fa4b 	bl	900071ba <osMessageQueueGet>
    if ((status == osOK) && (event == WRITE_CPLT_MSG))
90000d24:	2800      	cmp	r0, #0
90000d26:	d1ec      	bne.n	90000d02 <SD_write+0x16>
90000d28:	f8bd 300e 	ldrh.w	r3, [sp, #14]
90000d2c:	2b02      	cmp	r3, #2
90000d2e:	d1e8      	bne.n	90000d02 <SD_write+0x16>
        timer = osKernelGetTickCount();
90000d30:	f006 f86a 	bl	90006e08 <osKernelGetTickCount>
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
90000d34:	f247 552f 	movw	r5, #29999	; 0x752f
        timer = osKernelGetTickCount();
90000d38:	4604      	mov	r4, r0
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
90000d3a:	f006 f865 	bl	90006e08 <osKernelGetTickCount>
90000d3e:	1b03      	subs	r3, r0, r4
90000d40:	42ab      	cmp	r3, r5
90000d42:	d8de      	bhi.n	90000d02 <SD_write+0x16>
          if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
90000d44:	f7ff ff4e 	bl	90000be4 <BSP_SD_GetCardState>
90000d48:	2800      	cmp	r0, #0
90000d4a:	d1f6      	bne.n	90000d3a <SD_write+0x4e>
90000d4c:	e7da      	b.n	90000d04 <SD_write+0x18>
90000d4e:	bf00      	nop
90000d50:	24000288 	.word	0x24000288

90000d54 <SD_read>:
{
90000d54:	b530      	push	{r4, r5, lr}
90000d56:	b085      	sub	sp, #20
90000d58:	460c      	mov	r4, r1
90000d5a:	9201      	str	r2, [sp, #4]
90000d5c:	9300      	str	r3, [sp, #0]
  if (SD_CheckStatusWithTimeout(SD_TIMEOUT) < 0)
90000d5e:	f7ff ffb1 	bl	90000cc4 <SD_CheckStatusWithTimeout.constprop.0>
90000d62:	2800      	cmp	r0, #0
90000d64:	e9dd 2100 	ldrd	r2, r1, [sp]
90000d68:	da02      	bge.n	90000d70 <SD_read+0x1c>
  DRESULT res = RES_ERROR;
90000d6a:	2001      	movs	r0, #1
}
90000d6c:	b005      	add	sp, #20
90000d6e:	bd30      	pop	{r4, r5, pc}
    ret = BSP_SD_ReadBlocks_DMA((uint32_t*)buff, (uint32_t)(sector), count);
90000d70:	4620      	mov	r0, r4
90000d72:	f7ff ff1b 	bl	90000bac <BSP_SD_ReadBlocks_DMA>
    if (ret == MSD_OK) {
90000d76:	4602      	mov	r2, r0
90000d78:	2800      	cmp	r0, #0
90000d7a:	d1f6      	bne.n	90000d6a <SD_read+0x16>
          status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
90000d7c:	480e      	ldr	r0, [pc, #56]	; (90000db8 <SD_read+0x64>)
90000d7e:	f247 5330 	movw	r3, #30000	; 0x7530
90000d82:	f10d 010e 	add.w	r1, sp, #14
90000d86:	6800      	ldr	r0, [r0, #0]
90000d88:	f006 fa17 	bl	900071ba <osMessageQueueGet>
          if ((status == osOK) && (event == READ_CPLT_MSG))
90000d8c:	2800      	cmp	r0, #0
90000d8e:	d1ec      	bne.n	90000d6a <SD_read+0x16>
90000d90:	f8bd 300e 	ldrh.w	r3, [sp, #14]
90000d94:	2b01      	cmp	r3, #1
90000d96:	d1e8      	bne.n	90000d6a <SD_read+0x16>
            timer = osKernelGetTickCount();
90000d98:	f006 f836 	bl	90006e08 <osKernelGetTickCount>
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
90000d9c:	f247 552f 	movw	r5, #29999	; 0x752f
            timer = osKernelGetTickCount();
90000da0:	4604      	mov	r4, r0
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
90000da2:	f006 f831 	bl	90006e08 <osKernelGetTickCount>
90000da6:	1b03      	subs	r3, r0, r4
90000da8:	42ab      	cmp	r3, r5
90000daa:	d8de      	bhi.n	90000d6a <SD_read+0x16>
              if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
90000dac:	f7ff ff1a 	bl	90000be4 <BSP_SD_GetCardState>
90000db0:	2800      	cmp	r0, #0
90000db2:	d1f6      	bne.n	90000da2 <SD_read+0x4e>
90000db4:	e7da      	b.n	90000d6c <SD_read+0x18>
90000db6:	bf00      	nop
90000db8:	24000288 	.word	0x24000288

90000dbc <SD_initialize>:
{
90000dbc:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;
90000dbe:	4c13      	ldr	r4, [pc, #76]	; (90000e0c <SD_initialize+0x50>)
90000dc0:	2501      	movs	r5, #1
90000dc2:	7025      	strb	r5, [r4, #0]
  if(osKernelGetState() == osKernelRunning)
90000dc4:	f005 fff6 	bl	90006db4 <osKernelGetState>
90000dc8:	2802      	cmp	r0, #2
90000dca:	d11d      	bne.n	90000e08 <SD_initialize+0x4c>
    if(BSP_SD_Init() == MSD_OK)
90000dcc:	f7ff ff2a 	bl	90000c24 <BSP_SD_Init>
90000dd0:	b950      	cbnz	r0, 90000de8 <SD_initialize+0x2c>
  Stat = STA_NOINIT;
90000dd2:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
90000dd4:	f7ff ff06 	bl	90000be4 <BSP_SD_GetCardState>
90000dd8:	b918      	cbnz	r0, 90000de2 <SD_initialize+0x26>
    Stat &= ~STA_NOINIT;
90000dda:	7823      	ldrb	r3, [r4, #0]
90000ddc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
90000de0:	7023      	strb	r3, [r4, #0]
  return Stat;
90000de2:	7823      	ldrb	r3, [r4, #0]
90000de4:	b2db      	uxtb	r3, r3
      Stat = SD_CheckStatus(lun);
90000de6:	7023      	strb	r3, [r4, #0]
    if (Stat != STA_NOINIT)
90000de8:	7823      	ldrb	r3, [r4, #0]
90000dea:	2b01      	cmp	r3, #1
90000dec:	d00c      	beq.n	90000e08 <SD_initialize+0x4c>
      if (SDQueueID == NULL)
90000dee:	4d08      	ldr	r5, [pc, #32]	; (90000e10 <SD_initialize+0x54>)
90000df0:	682a      	ldr	r2, [r5, #0]
90000df2:	b94a      	cbnz	r2, 90000e08 <SD_initialize+0x4c>
      SDQueueID = osMessageQueueNew(QUEUE_SIZE, 2, NULL);
90000df4:	2102      	movs	r1, #2
90000df6:	200a      	movs	r0, #10
90000df8:	f006 f974 	bl	900070e4 <osMessageQueueNew>
90000dfc:	6028      	str	r0, [r5, #0]
      if (SDQueueID == NULL)
90000dfe:	b918      	cbnz	r0, 90000e08 <SD_initialize+0x4c>
        Stat |= STA_NOINIT;
90000e00:	7823      	ldrb	r3, [r4, #0]
90000e02:	f043 0301 	orr.w	r3, r3, #1
90000e06:	7023      	strb	r3, [r4, #0]
  return Stat;
90000e08:	7820      	ldrb	r0, [r4, #0]
}
90000e0a:	bd38      	pop	{r3, r4, r5, pc}
90000e0c:	24000000 	.word	0x24000000
90000e10:	24000288 	.word	0x24000288

90000e14 <BSP_SD_WriteCpltCallback>:
   * is always called before any SD_Read()/SD_Write() call
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, WRITE_CPLT_MSG, 0);
#else
   const uint16_t msg = WRITE_CPLT_MSG;
90000e14:	2302      	movs	r3, #2
{
90000e16:	b507      	push	{r0, r1, r2, lr}
   const uint16_t msg = WRITE_CPLT_MSG;
90000e18:	f8ad 3006 	strh.w	r3, [sp, #6]
   osMessageQueuePut(SDQueueID, (const void *)&msg, NULL, 0);
90000e1c:	2300      	movs	r3, #0
90000e1e:	4805      	ldr	r0, [pc, #20]	; (90000e34 <BSP_SD_WriteCpltCallback+0x20>)
90000e20:	f10d 0106 	add.w	r1, sp, #6
90000e24:	461a      	mov	r2, r3
90000e26:	6800      	ldr	r0, [r0, #0]
90000e28:	f006 f997 	bl	9000715a <osMessageQueuePut>
#endif
}
90000e2c:	b003      	add	sp, #12
90000e2e:	f85d fb04 	ldr.w	pc, [sp], #4
90000e32:	bf00      	nop
90000e34:	24000288 	.word	0x24000288

90000e38 <BSP_SD_ReadCpltCallback>:
   * is always called before any SD_Read()/SD_Write() call
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, READ_CPLT_MSG, 0);
#else
   const uint16_t msg = READ_CPLT_MSG;
90000e38:	2301      	movs	r3, #1
{
90000e3a:	b507      	push	{r0, r1, r2, lr}
   const uint16_t msg = READ_CPLT_MSG;
90000e3c:	f8ad 3006 	strh.w	r3, [sp, #6]
   osMessageQueuePut(SDQueueID, (const void *)&msg, NULL, 0);
90000e40:	2300      	movs	r3, #0
90000e42:	4805      	ldr	r0, [pc, #20]	; (90000e58 <BSP_SD_ReadCpltCallback+0x20>)
90000e44:	f10d 0106 	add.w	r1, sp, #6
90000e48:	461a      	mov	r2, r3
90000e4a:	6800      	ldr	r0, [r0, #0]
90000e4c:	f006 f985 	bl	9000715a <osMessageQueuePut>
#endif
}
90000e50:	b003      	add	sp, #12
90000e52:	f85d fb04 	ldr.w	pc, [sp], #4
90000e56:	bf00      	nop
90000e58:	24000288 	.word	0x24000288

90000e5c <ethernet_link_status_updated>:
  else /* netif is down */
  {
/* USER CODE BEGIN 6 */
/* USER CODE END 6 */
  }
}
90000e5c:	4770      	bx	lr
	...

90000e60 <MX_LWIP_Init>:
  tcpip_init( NULL, NULL );
90000e60:	2100      	movs	r1, #0
{
90000e62:	b530      	push	{r4, r5, lr}
  tcpip_init( NULL, NULL );
90000e64:	4608      	mov	r0, r1
{
90000e66:	b085      	sub	sp, #20
  tcpip_init( NULL, NULL );
90000e68:	f010 f952 	bl	90011110 <tcpip_init>
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
90000e6c:	4d1c      	ldr	r5, [pc, #112]	; (90000ee0 <MX_LWIP_Init+0x80>)
  ipaddr.addr = 0;
90000e6e:	2000      	movs	r0, #0
90000e70:	491c      	ldr	r1, [pc, #112]	; (90000ee4 <MX_LWIP_Init+0x84>)
  gw.addr = 0;
90000e72:	4b1d      	ldr	r3, [pc, #116]	; (90000ee8 <MX_LWIP_Init+0x88>)
  netmask.addr = 0;
90000e74:	4a1d      	ldr	r2, [pc, #116]	; (90000eec <MX_LWIP_Init+0x8c>)
  ipaddr.addr = 0;
90000e76:	6008      	str	r0, [r1, #0]
  gw.addr = 0;
90000e78:	6018      	str	r0, [r3, #0]
  netmask.addr = 0;
90000e7a:	6010      	str	r0, [r2, #0]
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
90000e7c:	4c1c      	ldr	r4, [pc, #112]	; (90000ef0 <MX_LWIP_Init+0x90>)
90000e7e:	9502      	str	r5, [sp, #8]
90000e80:	4d1c      	ldr	r5, [pc, #112]	; (90000ef4 <MX_LWIP_Init+0x94>)
90000e82:	e9cd 0500 	strd	r0, r5, [sp]
90000e86:	4620      	mov	r0, r4
90000e88:	f00b fcc2 	bl	9000c810 <netif_add>
  netif_set_default(&gnetif);
90000e8c:	4620      	mov	r0, r4
90000e8e:	f00b fbcf 	bl	9000c630 <netif_set_default>
  if (netif_is_link_up(&gnetif))
90000e92:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    netif_set_up(&gnetif);
90000e96:	4620      	mov	r0, r4
  if (netif_is_link_up(&gnetif))
90000e98:	0759      	lsls	r1, r3, #29
90000e9a:	d51d      	bpl.n	90000ed8 <MX_LWIP_Init+0x78>
    netif_set_up(&gnetif);
90000e9c:	f00b fd56 	bl	9000c94c <netif_set_up>
  memset(&attributes, 0x0, sizeof(osThreadAttr_t));
90000ea0:	4c15      	ldr	r4, [pc, #84]	; (90000ef8 <MX_LWIP_Init+0x98>)
  netif_set_link_callback(&gnetif, ethernet_link_status_updated);
90000ea2:	4916      	ldr	r1, [pc, #88]	; (90000efc <MX_LWIP_Init+0x9c>)
90000ea4:	4812      	ldr	r0, [pc, #72]	; (90000ef0 <MX_LWIP_Init+0x90>)
90000ea6:	f00b fbc9 	bl	9000c63c <netif_set_link_callback>
  memset(&attributes, 0x0, sizeof(osThreadAttr_t));
90000eaa:	2220      	movs	r2, #32
90000eac:	2100      	movs	r1, #0
90000eae:	1d20      	adds	r0, r4, #4
90000eb0:	f010 fd94 	bl	900119dc <memset>
  attributes.name = "EthLink";
90000eb4:	4b12      	ldr	r3, [pc, #72]	; (90000f00 <MX_LWIP_Init+0xa0>)
  attributes.priority = 5;
90000eb6:	f44f 7200 	mov.w	r2, #512	; 0x200
  osThreadNew(ethernet_link_thread, &gnetif, &attributes);
90000eba:	490d      	ldr	r1, [pc, #52]	; (90000ef0 <MX_LWIP_Init+0x90>)
  attributes.name = "EthLink";
90000ebc:	6023      	str	r3, [r4, #0]
  attributes.priority = 5;
90000ebe:	2305      	movs	r3, #5
  osThreadNew(ethernet_link_thread, &gnetif, &attributes);
90000ec0:	4810      	ldr	r0, [pc, #64]	; (90000f04 <MX_LWIP_Init+0xa4>)
  attributes.priority = 5;
90000ec2:	e9c4 2305 	strd	r2, r3, [r4, #20]
  osThreadNew(ethernet_link_thread, &gnetif, &attributes);
90000ec6:	4622      	mov	r2, r4
90000ec8:	f005 ffa5 	bl	90006e16 <osThreadNew>
  dhcp_start(&gnetif);
90000ecc:	4808      	ldr	r0, [pc, #32]	; (90000ef0 <MX_LWIP_Init+0x90>)
}
90000ece:	b005      	add	sp, #20
90000ed0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  dhcp_start(&gnetif);
90000ed4:	f009 b950 	b.w	9000a178 <dhcp_start>
    netif_set_down(&gnetif);
90000ed8:	f00b fd68 	bl	9000c9ac <netif_set_down>
90000edc:	e7e0      	b.n	90000ea0 <MX_LWIP_Init+0x40>
90000ede:	bf00      	nop
90000ee0:	9001109d 	.word	0x9001109d
90000ee4:	240002f8 	.word	0x240002f8
90000ee8:	240002f4 	.word	0x240002f4
90000eec:	240002fc 	.word	0x240002fc
90000ef0:	240002b0 	.word	0x240002b0
90000ef4:	90001095 	.word	0x90001095
90000ef8:	2400028c 	.word	0x2400028c
90000efc:	90000e5d 	.word	0x90000e5d
90000f00:	90012ad4 	.word	0x90012ad4
90000f04:	900013bd 	.word	0x900013bd

90000f08 <ETH_PHY_IO_DeInit>:
  * @retval 0 if OK, -1 if ERROR
  */
int32_t ETH_PHY_IO_DeInit (void)
{
  return 0;
}
90000f08:	2000      	movs	r0, #0
90000f0a:	4770      	bx	lr

90000f0c <low_level_output>:
{
90000f0c:	b530      	push	{r4, r5, lr}
90000f0e:	b08d      	sub	sp, #52	; 0x34
90000f10:	460c      	mov	r4, r1
  memset(Txbuffer, 0 , ETH_TX_DESC_CNT*sizeof(ETH_BufferTypeDef));
90000f12:	2230      	movs	r2, #48	; 0x30
90000f14:	2100      	movs	r1, #0
90000f16:	4668      	mov	r0, sp
90000f18:	f010 fd60 	bl	900119dc <memset>
  for(q = p; q != NULL; q = q->next)
90000f1c:	466a      	mov	r2, sp
90000f1e:	4623      	mov	r3, r4
  uint32_t i = 0U;
90000f20:	2100      	movs	r1, #0
  for(q = p; q != NULL; q = q->next)
90000f22:	b9db      	cbnz	r3, 90000f5c <low_level_output+0x50>
  TxConfig.Length = p->tot_len;
90000f24:	4d16      	ldr	r5, [pc, #88]	; (90000f80 <low_level_output+0x74>)
  pbuf_ref(p);
90000f26:	4620      	mov	r0, r4
  TxConfig.Length = p->tot_len;
90000f28:	8923      	ldrh	r3, [r4, #8]
  TxConfig.TxBuffer = Txbuffer;
90000f2a:	f8c5 d008 	str.w	sp, [r5, #8]
  TxConfig.Length = p->tot_len;
90000f2e:	606b      	str	r3, [r5, #4]
  TxConfig.pData = p;
90000f30:	636c      	str	r4, [r5, #52]	; 0x34
  pbuf_ref(p);
90000f32:	f00c f80f 	bl	9000cf54 <pbuf_ref>
  HAL_ETH_Transmit_IT(&heth, &TxConfig);
90000f36:	4629      	mov	r1, r5
  while(osSemaphoreAcquire(TxPktSemaphore, TIME_WAITING_FOR_INPUT)!=osOK)
90000f38:	4d12      	ldr	r5, [pc, #72]	; (90000f84 <low_level_output+0x78>)
  HAL_ETH_Transmit_IT(&heth, &TxConfig);
90000f3a:	4813      	ldr	r0, [pc, #76]	; (90000f88 <low_level_output+0x7c>)
90000f3c:	f001 fb8b 	bl	90002656 <HAL_ETH_Transmit_IT>
  while(osSemaphoreAcquire(TxPktSemaphore, TIME_WAITING_FOR_INPUT)!=osOK)
90000f40:	f04f 31ff 	mov.w	r1, #4294967295
90000f44:	6828      	ldr	r0, [r5, #0]
90000f46:	f006 f87a 	bl	9000703e <osSemaphoreAcquire>
90000f4a:	4604      	mov	r4, r0
90000f4c:	2800      	cmp	r0, #0
90000f4e:	d1f7      	bne.n	90000f40 <low_level_output+0x34>
  HAL_ETH_ReleaseTxPacket(&heth);
90000f50:	480d      	ldr	r0, [pc, #52]	; (90000f88 <low_level_output+0x7c>)
90000f52:	f001 fc2b 	bl	900027ac <HAL_ETH_ReleaseTxPacket>
  return errval;
90000f56:	4620      	mov	r0, r4
}
90000f58:	b00d      	add	sp, #52	; 0x34
90000f5a:	bd30      	pop	{r4, r5, pc}
    if(i >= ETH_TX_DESC_CNT)
90000f5c:	2904      	cmp	r1, #4
90000f5e:	d00c      	beq.n	90000f7a <low_level_output+0x6e>
    Txbuffer[i].buffer = q->payload;
90000f60:	6858      	ldr	r0, [r3, #4]
90000f62:	6010      	str	r0, [r2, #0]
    Txbuffer[i].len = q->len;
90000f64:	8958      	ldrh	r0, [r3, #10]
90000f66:	6050      	str	r0, [r2, #4]
    if(i>0)
90000f68:	b109      	cbz	r1, 90000f6e <low_level_output+0x62>
      Txbuffer[i-1].next = &Txbuffer[i];
90000f6a:	f842 2c04 	str.w	r2, [r2, #-4]
    if(q->next == NULL)
90000f6e:	681b      	ldr	r3, [r3, #0]
90000f70:	b903      	cbnz	r3, 90000f74 <low_level_output+0x68>
      Txbuffer[i].next = NULL;
90000f72:	6093      	str	r3, [r2, #8]
    i++;
90000f74:	3101      	adds	r1, #1
  for(q = p; q != NULL; q = q->next)
90000f76:	320c      	adds	r2, #12
90000f78:	e7d3      	b.n	90000f22 <low_level_output+0x16>
      return ERR_IF;
90000f7a:	f06f 000b 	mvn.w	r0, #11
90000f7e:	e7eb      	b.n	90000f58 <low_level_output+0x4c>
90000f80:	24000328 	.word	0x24000328
90000f84:	24000360 	.word	0x24000360
90000f88:	24000364 	.word	0x24000364

90000f8c <ETH_PHY_IO_GetTick>:
  * @brief  Get the time in millisecons used for internal PHY driver process.
  * @retval Time value
  */
int32_t ETH_PHY_IO_GetTick(void)
{
  return HAL_GetTick();
90000f8c:	f000 bebe 	b.w	90001d0c <HAL_GetTick>

90000f90 <ETH_PHY_IO_Init>:
  HAL_ETH_SetMDIOClockRange(&heth);
90000f90:	4802      	ldr	r0, [pc, #8]	; (90000f9c <ETH_PHY_IO_Init+0xc>)
{
90000f92:	b508      	push	{r3, lr}
  HAL_ETH_SetMDIOClockRange(&heth);
90000f94:	f001 fe0e 	bl	90002bb4 <HAL_ETH_SetMDIOClockRange>
}
90000f98:	2000      	movs	r0, #0
90000f9a:	bd08      	pop	{r3, pc}
90000f9c:	24000364 	.word	0x24000364

90000fa0 <ETH_PHY_IO_ReadReg>:
{
90000fa0:	b508      	push	{r3, lr}
90000fa2:	4613      	mov	r3, r2
  if(HAL_ETH_ReadPHYRegister(&heth, DevAddr, RegAddr, pRegVal) != HAL_OK)
90000fa4:	460a      	mov	r2, r1
90000fa6:	4601      	mov	r1, r0
90000fa8:	4803      	ldr	r0, [pc, #12]	; (90000fb8 <ETH_PHY_IO_ReadReg+0x18>)
90000faa:	f001 fcd0 	bl	9000294e <HAL_ETH_ReadPHYRegister>
90000fae:	3800      	subs	r0, #0
90000fb0:	bf18      	it	ne
90000fb2:	2001      	movne	r0, #1
}
90000fb4:	4240      	negs	r0, r0
90000fb6:	bd08      	pop	{r3, pc}
90000fb8:	24000364 	.word	0x24000364

90000fbc <ETH_PHY_IO_WriteReg>:
{
90000fbc:	b508      	push	{r3, lr}
90000fbe:	4613      	mov	r3, r2
  if(HAL_ETH_WritePHYRegister(&heth, DevAddr, RegAddr, RegVal) != HAL_OK)
90000fc0:	460a      	mov	r2, r1
90000fc2:	4601      	mov	r1, r0
90000fc4:	4803      	ldr	r0, [pc, #12]	; (90000fd4 <ETH_PHY_IO_WriteReg+0x18>)
90000fc6:	f001 fcf1 	bl	900029ac <HAL_ETH_WritePHYRegister>
90000fca:	3800      	subs	r0, #0
90000fcc:	bf18      	it	ne
90000fce:	2001      	movne	r0, #1
}
90000fd0:	4240      	negs	r0, r0
90000fd2:	bd08      	pop	{r3, pc}
90000fd4:	24000364 	.word	0x24000364

90000fd8 <pbuf_free_custom>:
{
90000fd8:	4601      	mov	r1, r0
  LWIP_MEMPOOL_FREE(RX_POOL, custom_pbuf);
90000fda:	4808      	ldr	r0, [pc, #32]	; (90000ffc <pbuf_free_custom+0x24>)
{
90000fdc:	b508      	push	{r3, lr}
  LWIP_MEMPOOL_FREE(RX_POOL, custom_pbuf);
90000fde:	f00b fa31 	bl	9000c444 <memp_free_pool>
  if (RxAllocStatus == RX_ALLOC_ERROR)
90000fe2:	4b07      	ldr	r3, [pc, #28]	; (90001000 <pbuf_free_custom+0x28>)
90000fe4:	781a      	ldrb	r2, [r3, #0]
90000fe6:	2a01      	cmp	r2, #1
90000fe8:	d107      	bne.n	90000ffa <pbuf_free_custom+0x22>
    RxAllocStatus = RX_ALLOC_OK;
90000fea:	2200      	movs	r2, #0
90000fec:	701a      	strb	r2, [r3, #0]
    osSemaphoreRelease(RxPktSemaphore);
90000fee:	4b05      	ldr	r3, [pc, #20]	; (90001004 <pbuf_free_custom+0x2c>)
90000ff0:	6818      	ldr	r0, [r3, #0]
}
90000ff2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    osSemaphoreRelease(RxPktSemaphore);
90000ff6:	f006 b84d 	b.w	90007094 <osSemaphoreRelease>
}
90000ffa:	bd08      	pop	{r3, pc}
90000ffc:	90012b4c 	.word	0x90012b4c
90001000:	24000320 	.word	0x24000320
90001004:	24000324 	.word	0x24000324

90001008 <ethernetif_input>:
{
90001008:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
9000100c:	4605      	mov	r5, r0
    if (osSemaphoreAcquire(RxPktSemaphore, TIME_WAITING_FOR_INPUT) == osOK)
9000100e:	4f11      	ldr	r7, [pc, #68]	; (90001054 <ethernetif_input+0x4c>)
  if(RxAllocStatus == RX_ALLOC_OK)
90001010:	f8df 8044 	ldr.w	r8, [pc, #68]	; 90001058 <ethernetif_input+0x50>
    HAL_ETH_ReadData(&heth, (void **)&p);
90001014:	f8df 9044 	ldr.w	r9, [pc, #68]	; 9000105c <ethernetif_input+0x54>
    if (osSemaphoreAcquire(RxPktSemaphore, TIME_WAITING_FOR_INPUT) == osOK)
90001018:	f04f 31ff 	mov.w	r1, #4294967295
9000101c:	6838      	ldr	r0, [r7, #0]
9000101e:	f006 f80e 	bl	9000703e <osSemaphoreAcquire>
90001022:	4604      	mov	r4, r0
90001024:	2800      	cmp	r0, #0
90001026:	d1f7      	bne.n	90001018 <ethernetif_input+0x10>
  if(RxAllocStatus == RX_ALLOC_OK)
90001028:	f898 3000 	ldrb.w	r3, [r8]
  struct pbuf *p = NULL;
9000102c:	9401      	str	r4, [sp, #4]
  if(RxAllocStatus == RX_ALLOC_OK)
9000102e:	b91b      	cbnz	r3, 90001038 <ethernetif_input+0x30>
    HAL_ETH_ReadData(&heth, (void **)&p);
90001030:	a901      	add	r1, sp, #4
90001032:	4648      	mov	r0, r9
90001034:	f001 fb3d 	bl	900026b2 <HAL_ETH_ReadData>
  return p;
90001038:	9e01      	ldr	r6, [sp, #4]
        if (p != NULL)
9000103a:	2e00      	cmp	r6, #0
9000103c:	d0ec      	beq.n	90001018 <ethernetif_input+0x10>
          if (netif->input( p, netif) != ERR_OK )
9000103e:	692b      	ldr	r3, [r5, #16]
90001040:	4629      	mov	r1, r5
90001042:	4630      	mov	r0, r6
90001044:	4798      	blx	r3
90001046:	2800      	cmp	r0, #0
90001048:	d0ee      	beq.n	90001028 <ethernetif_input+0x20>
            pbuf_free(p);
9000104a:	4630      	mov	r0, r6
9000104c:	f00b fe28 	bl	9000cca0 <pbuf_free>
90001050:	e7ea      	b.n	90001028 <ethernetif_input+0x20>
90001052:	bf00      	nop
90001054:	24000324 	.word	0x24000324
90001058:	24000320 	.word	0x24000320
9000105c:	24000364 	.word	0x24000364

90001060 <HAL_ETH_RxCpltCallback>:
  osSemaphoreRelease(RxPktSemaphore);
90001060:	4b01      	ldr	r3, [pc, #4]	; (90001068 <HAL_ETH_RxCpltCallback+0x8>)
90001062:	6818      	ldr	r0, [r3, #0]
90001064:	f006 b816 	b.w	90007094 <osSemaphoreRelease>
90001068:	24000324 	.word	0x24000324

9000106c <HAL_ETH_TxCpltCallback>:
  osSemaphoreRelease(TxPktSemaphore);
9000106c:	4b01      	ldr	r3, [pc, #4]	; (90001074 <HAL_ETH_TxCpltCallback+0x8>)
9000106e:	6818      	ldr	r0, [r3, #0]
90001070:	f006 b810 	b.w	90007094 <osSemaphoreRelease>
90001074:	24000360 	.word	0x24000360

90001078 <HAL_ETH_ErrorCallback>:
{
90001078:	b508      	push	{r3, lr}
  if((HAL_ETH_GetDMAError(handlerEth) & ETH_DMACSR_RBU) == ETH_DMACSR_RBU)
9000107a:	f001 fee7 	bl	90002e4c <HAL_ETH_GetDMAError>
9000107e:	0603      	lsls	r3, r0, #24
90001080:	d505      	bpl.n	9000108e <HAL_ETH_ErrorCallback+0x16>
     osSemaphoreRelease(RxPktSemaphore);
90001082:	4b03      	ldr	r3, [pc, #12]	; (90001090 <HAL_ETH_ErrorCallback+0x18>)
90001084:	6818      	ldr	r0, [r3, #0]
}
90001086:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     osSemaphoreRelease(RxPktSemaphore);
9000108a:	f006 b803 	b.w	90007094 <osSemaphoreRelease>
}
9000108e:	bd08      	pop	{r3, pc}
90001090:	24000324 	.word	0x24000324

90001094 <ethernetif_init>:
{
90001094:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
90001098:	4604      	mov	r4, r0
{
9000109a:	b0a5      	sub	sp, #148	; 0x94
  LWIP_ASSERT("netif != NULL", (netif != NULL));
9000109c:	b930      	cbnz	r0, 900010ac <ethernetif_init+0x18>
9000109e:	4b61      	ldr	r3, [pc, #388]	; (90001224 <ethernetif_init+0x190>)
900010a0:	f240 12f5 	movw	r2, #501	; 0x1f5
900010a4:	4960      	ldr	r1, [pc, #384]	; (90001228 <ethernetif_init+0x194>)
900010a6:	4861      	ldr	r0, [pc, #388]	; (9000122c <ethernetif_init+0x198>)
900010a8:	f010 fd80 	bl	90011bac <iprintf>
  netif->name[0] = IFNAME0;
900010ac:	f247 4373 	movw	r3, #29811	; 0x7473
  ETH_MACConfigTypeDef MACConf = {0};
900010b0:	2264      	movs	r2, #100	; 0x64
900010b2:	2100      	movs	r1, #0
900010b4:	a80b      	add	r0, sp, #44	; 0x2c
  netif->name[0] = IFNAME0;
900010b6:	86e3      	strh	r3, [r4, #54]	; 0x36
  MACAddr[0] = 0x00;
900010b8:	2500      	movs	r5, #0
  netif->output = etharp_output;
900010ba:	4b5d      	ldr	r3, [pc, #372]	; (90001230 <ethernetif_init+0x19c>)
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
900010bc:	2701      	movs	r7, #1
  heth.Instance = ETH;
900010be:	4e5d      	ldr	r6, [pc, #372]	; (90001234 <ethernetif_init+0x1a0>)
  netif->output = etharp_output;
900010c0:	6163      	str	r3, [r4, #20]
  netif->linkoutput = low_level_output;
900010c2:	4b5d      	ldr	r3, [pc, #372]	; (90001238 <ethernetif_init+0x1a4>)
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
900010c4:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 9000126c <ethernetif_init+0x1d8>
  netif->linkoutput = low_level_output;
900010c8:	61a3      	str	r3, [r4, #24]
  ETH_MACConfigTypeDef MACConf = {0};
900010ca:	f010 fc87 	bl	900119dc <memset>
  heth.Instance = ETH;
900010ce:	4b5b      	ldr	r3, [pc, #364]	; (9000123c <ethernetif_init+0x1a8>)
  hal_eth_init_status = HAL_ETH_Init(&heth);
900010d0:	4630      	mov	r0, r6
  MACAddr[0] = 0x00;
900010d2:	f88d 5000 	strb.w	r5, [sp]
  heth.Instance = ETH;
900010d6:	6033      	str	r3, [r6, #0]
  MACAddr[1] = 0x80;
900010d8:	2380      	movs	r3, #128	; 0x80
  MACAddr[3] = 0x00;
900010da:	f88d 5003 	strb.w	r5, [sp, #3]
  MACAddr[1] = 0x80;
900010de:	f88d 3001 	strb.w	r3, [sp, #1]
  MACAddr[2] = 0xE1;
900010e2:	23e1      	movs	r3, #225	; 0xe1
  MACAddr[4] = 0x00;
900010e4:	f88d 5004 	strb.w	r5, [sp, #4]
  MACAddr[2] = 0xE1;
900010e8:	f88d 3002 	strb.w	r3, [sp, #2]
  heth.Init.TxDesc = DMATxDscrTab;
900010ec:	4b54      	ldr	r3, [pc, #336]	; (90001240 <ethernetif_init+0x1ac>)
  MACAddr[5] = 0x00;
900010ee:	f88d 5005 	strb.w	r5, [sp, #5]
  heth.Init.TxDesc = DMATxDscrTab;
900010f2:	60f3      	str	r3, [r6, #12]
  heth.Init.RxDesc = DMARxDscrTab;
900010f4:	4b53      	ldr	r3, [pc, #332]	; (90001244 <ethernetif_init+0x1b0>)
  heth.Init.MACAddr = &MACAddr[0];
900010f6:	f8c6 d004 	str.w	sp, [r6, #4]
  heth.Init.RxDesc = DMARxDscrTab;
900010fa:	6133      	str	r3, [r6, #16]
  heth.Init.RxBuffLen = 1536;
900010fc:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
90001100:	7237      	strb	r7, [r6, #8]
  heth.Init.RxBuffLen = 1536;
90001102:	6173      	str	r3, [r6, #20]
  hal_eth_init_status = HAL_ETH_Init(&heth);
90001104:	f001 fd92 	bl	90002c2c <HAL_ETH_Init>
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
90001108:	2234      	movs	r2, #52	; 0x34
9000110a:	4629      	mov	r1, r5
  hal_eth_init_status = HAL_ETH_Init(&heth);
9000110c:	4680      	mov	r8, r0
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
9000110e:	f109 0004 	add.w	r0, r9, #4
90001112:	f010 fc63 	bl	900119dc <memset>
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
90001116:	2321      	movs	r3, #33	; 0x21
  LWIP_MEMPOOL_INIT(RX_POOL);
90001118:	484b      	ldr	r0, [pc, #300]	; (90001248 <ethernetif_init+0x1b4>)
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
9000111a:	f8c9 3000 	str.w	r3, [r9]
  TxConfig.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
9000111e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
90001122:	f8c9 3014 	str.w	r3, [r9, #20]
  LWIP_MEMPOOL_INIT(RX_POOL);
90001126:	f00b f939 	bl	9000c39c <memp_init_pool>
  netif->hwaddr_len = ETH_HWADDR_LEN;
9000112a:	2306      	movs	r3, #6
  RxPktSemaphore = osSemaphoreNew(1, 1, NULL);
9000112c:	4639      	mov	r1, r7
9000112e:	4638      	mov	r0, r7
  netif->hwaddr_len = ETH_HWADDR_LEN;
90001130:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
90001134:	6873      	ldr	r3, [r6, #4]
90001136:	781a      	ldrb	r2, [r3, #0]
90001138:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
9000113c:	785a      	ldrb	r2, [r3, #1]
9000113e:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
90001142:	789a      	ldrb	r2, [r3, #2]
90001144:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
90001148:	78da      	ldrb	r2, [r3, #3]
9000114a:	f884 2031 	strb.w	r2, [r4, #49]	; 0x31
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
9000114e:	791a      	ldrb	r2, [r3, #4]
90001150:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
  RxPktSemaphore = osSemaphoreNew(1, 1, NULL);
90001154:	462a      	mov	r2, r5
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
90001156:	795b      	ldrb	r3, [r3, #5]
90001158:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
  netif->mtu = ETH_MAX_PAYLOAD;
9000115c:	f240 53dc 	movw	r3, #1500	; 0x5dc
90001160:	85a3      	strh	r3, [r4, #44]	; 0x2c
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
90001162:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
90001166:	f043 030a 	orr.w	r3, r3, #10
9000116a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  RxPktSemaphore = osSemaphoreNew(1, 1, NULL);
9000116e:	f005 ff1c 	bl	90006faa <osSemaphoreNew>
90001172:	4b36      	ldr	r3, [pc, #216]	; (9000124c <ethernetif_init+0x1b8>)
  TxPktSemaphore = osSemaphoreNew(1, 1, NULL);
90001174:	462a      	mov	r2, r5
90001176:	4639      	mov	r1, r7
  RxPktSemaphore = osSemaphoreNew(1, 1, NULL);
90001178:	6018      	str	r0, [r3, #0]
  TxPktSemaphore = osSemaphoreNew(1, 1, NULL);
9000117a:	4638      	mov	r0, r7
9000117c:	f005 ff15 	bl	90006faa <osSemaphoreNew>
90001180:	4b33      	ldr	r3, [pc, #204]	; (90001250 <ethernetif_init+0x1bc>)
  memset(&attributes, 0x0, sizeof(osThreadAttr_t));
90001182:	2220      	movs	r2, #32
90001184:	4629      	mov	r1, r5
  TxPktSemaphore = osSemaphoreNew(1, 1, NULL);
90001186:	6018      	str	r0, [r3, #0]
  memset(&attributes, 0x0, sizeof(osThreadAttr_t));
90001188:	a803      	add	r0, sp, #12
9000118a:	f010 fc27 	bl	900119dc <memset>
  attributes.name = "EthIf";
9000118e:	4b31      	ldr	r3, [pc, #196]	; (90001254 <ethernetif_init+0x1c0>)
  attributes.priority = osPriorityRealtime;
90001190:	f44f 6180 	mov.w	r1, #1024	; 0x400
  osThreadNew(ethernetif_input, netif, &attributes);
90001194:	aa02      	add	r2, sp, #8
  attributes.name = "EthIf";
90001196:	9302      	str	r3, [sp, #8]
  attributes.priority = osPriorityRealtime;
90001198:	2330      	movs	r3, #48	; 0x30
  osThreadNew(ethernetif_input, netif, &attributes);
9000119a:	482f      	ldr	r0, [pc, #188]	; (90001258 <ethernetif_init+0x1c4>)
  attributes.priority = osPriorityRealtime;
9000119c:	e9cd 1307 	strd	r1, r3, [sp, #28]
  osThreadNew(ethernetif_input, netif, &attributes);
900011a0:	4621      	mov	r1, r4
900011a2:	f005 fe38 	bl	90006e16 <osThreadNew>
  LAN8742_RegisterBusIO(&LAN8742, &LAN8742_IOCtx);
900011a6:	492d      	ldr	r1, [pc, #180]	; (9000125c <ethernetif_init+0x1c8>)
900011a8:	482d      	ldr	r0, [pc, #180]	; (90001260 <ethernetif_init+0x1cc>)
900011aa:	f000 fc2f 	bl	90001a0c <LAN8742_RegisterBusIO>
  LAN8742_Init(&LAN8742);
900011ae:	482c      	ldr	r0, [pc, #176]	; (90001260 <ethernetif_init+0x1cc>)
900011b0:	f000 fc40 	bl	90001a34 <LAN8742_Init>
  if (hal_eth_init_status == HAL_OK)
900011b4:	f1b8 0f00 	cmp.w	r8, #0
900011b8:	d130      	bne.n	9000121c <ethernetif_init+0x188>
    PHYLinkState = LAN8742_GetLinkState(&LAN8742);
900011ba:	4829      	ldr	r0, [pc, #164]	; (90001260 <ethernetif_init+0x1cc>)
900011bc:	f000 fc9b 	bl	90001af6 <LAN8742_GetLinkState>
    if(PHYLinkState <= LAN8742_STATUS_LINK_DOWN)
900011c0:	42b8      	cmp	r0, r7
900011c2:	dc09      	bgt.n	900011d8 <ethernetif_init+0x144>
      netif_set_link_down(netif);
900011c4:	4620      	mov	r0, r4
900011c6:	f00b fc77 	bl	9000cab8 <netif_set_link_down>
      netif_set_down(netif);
900011ca:	4620      	mov	r0, r4
900011cc:	f00b fbee 	bl	9000c9ac <netif_set_down>
}
900011d0:	2000      	movs	r0, #0
900011d2:	b025      	add	sp, #148	; 0x94
900011d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      switch (PHYLinkState)
900011d8:	3803      	subs	r0, #3
    HAL_ETH_GetMACConfig(&heth, &MACConf);
900011da:	a90b      	add	r1, sp, #44	; 0x2c
900011dc:	2802      	cmp	r0, #2
900011de:	bf93      	iteet	ls
900011e0:	4b20      	ldrls	r3, [pc, #128]	; (90001264 <ethernetif_init+0x1d0>)
      switch (PHYLinkState)
900011e2:	f44f 4580 	movhi.w	r5, #16384	; 0x4000
900011e6:	f44f 5600 	movhi.w	r6, #8192	; 0x2000
900011ea:	f833 6010 	ldrhls.w	r6, [r3, r0, lsl #1]
900011ee:	bf9c      	itt	ls
900011f0:	4b1d      	ldrls	r3, [pc, #116]	; (90001268 <ethernetif_init+0x1d4>)
900011f2:	f833 5010 	ldrhls.w	r5, [r3, r0, lsl #1]
    HAL_ETH_GetMACConfig(&heth, &MACConf);
900011f6:	480f      	ldr	r0, [pc, #60]	; (90001234 <ethernetif_init+0x1a0>)
900011f8:	f001 fc0a 	bl	90002a10 <HAL_ETH_GetMACConfig>
    HAL_ETH_SetMACConfig(&heth, &MACConf);
900011fc:	a90b      	add	r1, sp, #44	; 0x2c
900011fe:	480d      	ldr	r0, [pc, #52]	; (90001234 <ethernetif_init+0x1a0>)
    MACConf.Speed = speed;
90001200:	e9cd 5610 	strd	r5, r6, [sp, #64]	; 0x40
    HAL_ETH_SetMACConfig(&heth, &MACConf);
90001204:	f001 fcca 	bl	90002b9c <HAL_ETH_SetMACConfig>
    HAL_ETH_Start_IT(&heth);
90001208:	480a      	ldr	r0, [pc, #40]	; (90001234 <ethernetif_init+0x1a0>)
9000120a:	f001 f991 	bl	90002530 <HAL_ETH_Start_IT>
    netif_set_up(netif);
9000120e:	4620      	mov	r0, r4
90001210:	f00b fb9c 	bl	9000c94c <netif_set_up>
    netif_set_link_up(netif);
90001214:	4620      	mov	r0, r4
90001216:	f00b fbfb 	bl	9000ca10 <netif_set_link_up>
9000121a:	e7d9      	b.n	900011d0 <ethernetif_init+0x13c>
    Error_Handler();
9000121c:	f7ff fb1e 	bl	9000085c <Error_Handler>
90001220:	e7d6      	b.n	900011d0 <ethernetif_init+0x13c>
90001222:	bf00      	nop
90001224:	90012adc 	.word	0x90012adc
90001228:	90013511 	.word	0x90013511
9000122c:	90012aff 	.word	0x90012aff
90001230:	9000ad39 	.word	0x9000ad39
90001234:	24000364 	.word	0x24000364
90001238:	90000f0d 	.word	0x90000f0d
9000123c:	40028000 	.word	0x40028000
90001240:	240000fc 	.word	0x240000fc
90001244:	2400009c 	.word	0x2400009c
90001248:	90012b4c 	.word	0x90012b4c
9000124c:	24000324 	.word	0x24000324
90001250:	24000360 	.word	0x24000360
90001254:	90012b27 	.word	0x90012b27
90001258:	90001009 	.word	0x90001009
9000125c:	24000004 	.word	0x24000004
90001260:	24000300 	.word	0x24000300
90001264:	90012b2e 	.word	0x90012b2e
90001268:	90012b34 	.word	0x90012b34
9000126c:	24000328 	.word	0x24000328

90001270 <sys_now>:
  return HAL_GetTick();
90001270:	f000 bd4c 	b.w	90001d0c <HAL_GetTick>

90001274 <HAL_ETH_MspInit>:
{
90001274:	b5f0      	push	{r4, r5, r6, r7, lr}
90001276:	b08d      	sub	sp, #52	; 0x34
90001278:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
9000127a:	2214      	movs	r2, #20
9000127c:	2100      	movs	r1, #0
9000127e:	a807      	add	r0, sp, #28
90001280:	f010 fbac 	bl	900119dc <memset>
  if(ethHandle->Instance==ETH)
90001284:	6822      	ldr	r2, [r4, #0]
90001286:	4b48      	ldr	r3, [pc, #288]	; (900013a8 <HAL_ETH_MspInit+0x134>)
90001288:	429a      	cmp	r2, r3
9000128a:	f040 808b 	bne.w	900013a4 <HAL_ETH_MspInit+0x130>
    __HAL_RCC_ETH1MAC_CLK_ENABLE();
9000128e:	4b47      	ldr	r3, [pc, #284]	; (900013ac <HAL_ETH_MspInit+0x138>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90001290:	2401      	movs	r4, #1
90001292:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90001294:	250b      	movs	r5, #11
    __HAL_RCC_ETH1MAC_CLK_ENABLE();
90001296:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000129a:	2702      	movs	r7, #2
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
9000129c:	a907      	add	r1, sp, #28
9000129e:	4844      	ldr	r0, [pc, #272]	; (900013b0 <HAL_ETH_MspInit+0x13c>)
    __HAL_RCC_ETH1MAC_CLK_ENABLE();
900012a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
900012a4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
900012a8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
900012ac:	f402 4200 	and.w	r2, r2, #32768	; 0x8000
900012b0:	9201      	str	r2, [sp, #4]
900012b2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_ETH1TX_CLK_ENABLE();
900012b4:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
900012b8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900012bc:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
900012c0:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
900012c4:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
900012c8:	9202      	str	r2, [sp, #8]
900012ca:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_ETH1RX_CLK_ENABLE();
900012cc:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
900012d0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
900012d4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
900012d8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
900012dc:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
900012e0:	9203      	str	r2, [sp, #12]
900012e2:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOG_CLK_ENABLE();
900012e4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900012e8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
900012ec:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
900012f0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
900012f4:	f002 0240 	and.w	r2, r2, #64	; 0x40
900012f8:	9204      	str	r2, [sp, #16]
900012fa:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
900012fc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90001300:	f042 0204 	orr.w	r2, r2, #4
90001304:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90001308:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
9000130c:	f002 0204 	and.w	r2, r2, #4
90001310:	9205      	str	r2, [sp, #20]
90001312:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOA_CLK_ENABLE();
90001314:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
90001318:	f042 0201 	orr.w	r2, r2, #1
9000131c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
90001320:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90001324:	f003 0301 	and.w	r3, r3, #1
90001328:	9306      	str	r3, [sp, #24]
9000132a:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000132c:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
90001330:	e9cd 3707 	strd	r3, r7, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90001334:	e9cd 4609 	strd	r4, r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90001338:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
9000133a:	f001 fd8b 	bl	90002e54 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
9000133e:	2332      	movs	r3, #50	; 0x32
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90001340:	a907      	add	r1, sp, #28
90001342:	481c      	ldr	r0, [pc, #112]	; (900013b4 <HAL_ETH_MspInit+0x140>)
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90001344:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90001346:	e9cd 3707 	strd	r3, r7, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000134a:	e9cd 4609 	strd	r4, r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
9000134e:	f001 fd81 	bl	90002e54 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_1|GPIO_PIN_7;
90001352:	2386      	movs	r3, #134	; 0x86
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90001354:	a907      	add	r1, sp, #28
90001356:	4818      	ldr	r0, [pc, #96]	; (900013b8 <HAL_ETH_MspInit+0x144>)
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90001358:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Pin = GPIO_PIN_3;
9000135a:	2508      	movs	r5, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000135c:	e9cd 3707 	strd	r3, r7, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90001360:	e9cd 4609 	strd	r4, r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90001364:	f001 fd76 	bl	90002e54 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ETH_IRQn, 5, 0);
90001368:	2200      	movs	r2, #0
9000136a:	2105      	movs	r1, #5
9000136c:	203d      	movs	r0, #61	; 0x3d
9000136e:	f000 fd07 	bl	90001d80 <HAL_NVIC_SetPriority>
    GPIO_InitStruct.Pull = GPIO_NOPULL;
90001372:	2600      	movs	r6, #0
    HAL_NVIC_EnableIRQ(ETH_IRQn);
90001374:	203d      	movs	r0, #61	; 0x3d
90001376:	f000 fd35 	bl	90001de4 <HAL_NVIC_EnableIRQ>
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
9000137a:	a907      	add	r1, sp, #28
9000137c:	480e      	ldr	r0, [pc, #56]	; (900013b8 <HAL_ETH_MspInit+0x144>)
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
9000137e:	e9cd 5407 	strd	r5, r4, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90001382:	e9cd 6609 	strd	r6, r6, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90001386:	f001 fd65 	bl	90002e54 <HAL_GPIO_Init>
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
9000138a:	4632      	mov	r2, r6
9000138c:	4629      	mov	r1, r5
9000138e:	480a      	ldr	r0, [pc, #40]	; (900013b8 <HAL_ETH_MspInit+0x144>)
90001390:	f001 fe4c 	bl	9000302c <HAL_GPIO_WritePin>
    HAL_Delay(200);
90001394:	20c8      	movs	r0, #200	; 0xc8
90001396:	f000 fcbf 	bl	90001d18 <HAL_Delay>
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
9000139a:	4622      	mov	r2, r4
9000139c:	4629      	mov	r1, r5
9000139e:	4806      	ldr	r0, [pc, #24]	; (900013b8 <HAL_ETH_MspInit+0x144>)
900013a0:	f001 fe44 	bl	9000302c <HAL_GPIO_WritePin>
}
900013a4:	b00d      	add	sp, #52	; 0x34
900013a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
900013a8:	40028000 	.word	0x40028000
900013ac:	58024400 	.word	0x58024400
900013b0:	58021800 	.word	0x58021800
900013b4:	58020800 	.word	0x58020800
900013b8:	58020000 	.word	0x58020000

900013bc <ethernet_link_thread>:
/**
  * @brief  Check the ETH link state then update ETH driver and netif link accordingly.
  * @retval None
  */
void ethernet_link_thread(void* argument)
{
900013bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ETH_MACConfigTypeDef MACConf = {0};
  int32_t PHYLinkState = 0;
  uint32_t linkchanged = 0U, speed = 0U, duplex = 0U;
900013c0:	2500      	movs	r5, #0
{
900013c2:	b09a      	sub	sp, #104	; 0x68

/* USER CODE END ETH link init */

  for(;;)
  {
  PHYLinkState = LAN8742_GetLinkState(&LAN8742);
900013c4:	f8df 9094 	ldr.w	r9, [pc, #148]	; 9000145c <ethernet_link_thread+0xa0>
{
900013c8:	4604      	mov	r4, r0
  uint32_t linkchanged = 0U, speed = 0U, duplex = 0U;
900013ca:	46a8      	mov	r8, r5
900013cc:	462f      	mov	r7, r5
    }

    if(linkchanged)
    {
      /* Get MAC Config MAC */
      HAL_ETH_GetMACConfig(&heth, &MACConf);
900013ce:	4e21      	ldr	r6, [pc, #132]	; (90001454 <ethernet_link_thread+0x98>)
  ETH_MACConfigTypeDef MACConf = {0};
900013d0:	2264      	movs	r2, #100	; 0x64
900013d2:	f8df a08c 	ldr.w	sl, [pc, #140]	; 90001460 <ethernet_link_thread+0xa4>
900013d6:	2100      	movs	r1, #0
900013d8:	a801      	add	r0, sp, #4
900013da:	f010 faff 	bl	900119dc <memset>
  PHYLinkState = LAN8742_GetLinkState(&LAN8742);
900013de:	4648      	mov	r0, r9
900013e0:	f000 fb89 	bl	90001af6 <LAN8742_GetLinkState>
  if(netif_is_link_up(netif) && (PHYLinkState <= LAN8742_STATUS_LINK_DOWN))
900013e4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
900013e8:	075a      	lsls	r2, r3, #29
900013ea:	d510      	bpl.n	9000140e <ethernet_link_thread+0x52>
900013ec:	2801      	cmp	r0, #1
900013ee:	dc0c      	bgt.n	9000140a <ethernet_link_thread+0x4e>
    HAL_ETH_Stop_IT(&heth);
900013f0:	4630      	mov	r0, r6
900013f2:	f001 f8ef 	bl	900025d4 <HAL_ETH_Stop_IT>
    netif_set_down(netif);
900013f6:	4620      	mov	r0, r4
900013f8:	f00b fad8 	bl	9000c9ac <netif_set_down>
    netif_set_link_down(netif);
900013fc:	4620      	mov	r0, r4
900013fe:	f00b fb5b 	bl	9000cab8 <netif_set_link_down>

/* USER CODE BEGIN ETH link Thread core code for User BSP */

/* USER CODE END ETH link Thread core code for User BSP */

    osDelay(100);
90001402:	2064      	movs	r0, #100	; 0x64
90001404:	f005 fd50 	bl	90006ea8 <osDelay>
  PHYLinkState = LAN8742_GetLinkState(&LAN8742);
90001408:	e7e9      	b.n	900013de <ethernet_link_thread+0x22>
  else if(!netif_is_link_up(netif) && (PHYLinkState > LAN8742_STATUS_LINK_DOWN))
9000140a:	075b      	lsls	r3, r3, #29
9000140c:	d4f9      	bmi.n	90001402 <ethernet_link_thread+0x46>
9000140e:	2801      	cmp	r0, #1
90001410:	ddf7      	ble.n	90001402 <ethernet_link_thread+0x46>
    switch (PHYLinkState)
90001412:	1e83      	subs	r3, r0, #2
90001414:	2b03      	cmp	r3, #3
90001416:	d819      	bhi.n	9000144c <ethernet_link_thread+0x90>
90001418:	4a0f      	ldr	r2, [pc, #60]	; (90001458 <ethernet_link_thread+0x9c>)
9000141a:	f83a 8013 	ldrh.w	r8, [sl, r3, lsl #1]
9000141e:	f832 5013 	ldrh.w	r5, [r2, r3, lsl #1]
      HAL_ETH_GetMACConfig(&heth, &MACConf);
90001422:	a901      	add	r1, sp, #4
90001424:	4630      	mov	r0, r6
90001426:	f001 faf3 	bl	90002a10 <HAL_ETH_GetMACConfig>
      HAL_ETH_SetMACConfig(&heth, &MACConf);
9000142a:	a901      	add	r1, sp, #4
9000142c:	4630      	mov	r0, r6
      netif_set_link_up(netif);
9000142e:	2701      	movs	r7, #1
      MACConf.Speed = speed;
90001430:	e9cd 8506 	strd	r8, r5, [sp, #24]
      HAL_ETH_SetMACConfig(&heth, &MACConf);
90001434:	f001 fbb2 	bl	90002b9c <HAL_ETH_SetMACConfig>
      HAL_ETH_Start(&heth);
90001438:	4630      	mov	r0, r6
9000143a:	f001 f843 	bl	900024c4 <HAL_ETH_Start>
      netif_set_up(netif);
9000143e:	4620      	mov	r0, r4
90001440:	f00b fa84 	bl	9000c94c <netif_set_up>
      netif_set_link_up(netif);
90001444:	4620      	mov	r0, r4
90001446:	f00b fae3 	bl	9000ca10 <netif_set_link_up>
9000144a:	e7da      	b.n	90001402 <ethernet_link_thread+0x46>
    if(linkchanged)
9000144c:	2f00      	cmp	r7, #0
9000144e:	d0d8      	beq.n	90001402 <ethernet_link_thread+0x46>
90001450:	e7e7      	b.n	90001422 <ethernet_link_thread+0x66>
90001452:	bf00      	nop
90001454:	24000364 	.word	0x24000364
90001458:	90012b42 	.word	0x90012b42
9000145c:	24000300 	.word	0x24000300
90001460:	90012b3a 	.word	0x90012b3a

90001464 <HAL_ETH_RxAllocateCallback>:
  }
}

void HAL_ETH_RxAllocateCallback(uint8_t **buff)
{
90001464:	b513      	push	{r0, r1, r4, lr}
90001466:	4604      	mov	r4, r0
/* USER CODE BEGIN HAL ETH RxAllocateCallback */
  struct pbuf_custom *p = LWIP_MEMPOOL_ALLOC(RX_POOL);
90001468:	480c      	ldr	r0, [pc, #48]	; (9000149c <HAL_ETH_RxAllocateCallback+0x38>)
9000146a:	f00a ffb9 	bl	9000c3e0 <memp_malloc_pool>
  if (p)
9000146e:	4603      	mov	r3, r0
90001470:	b178      	cbz	r0, 90001492 <HAL_ETH_RxAllocateCallback+0x2e>
  {
    /* Get the buff from the struct pbuf address. */
    *buff = (uint8_t *)p + offsetof(RxBuff_t, buff);
90001472:	f100 0220 	add.w	r2, r0, #32
    p->custom_free_function = pbuf_free_custom;
90001476:	490a      	ldr	r1, [pc, #40]	; (900014a0 <HAL_ETH_RxAllocateCallback+0x3c>)
    *buff = (uint8_t *)p + offsetof(RxBuff_t, buff);
90001478:	6022      	str	r2, [r4, #0]
    p->custom_free_function = pbuf_free_custom;
9000147a:	6101      	str	r1, [r0, #16]
    /* Initialize the struct pbuf.
    * This must be performed whenever a buffer's allocated because it may be
    * changed by lwIP or the app, e.g., pbuf_free decrements ref. */
    pbuf_alloced_custom(PBUF_RAW, 0, PBUF_REF, p, *buff, ETH_RX_BUFFER_SIZE);
9000147c:	f44f 61c0 	mov.w	r1, #1536	; 0x600
90001480:	e9cd 2100 	strd	r2, r1, [sp]
90001484:	2100      	movs	r1, #0
90001486:	2241      	movs	r2, #65	; 0x41
90001488:	4608      	mov	r0, r1
9000148a:	f00b fbb7 	bl	9000cbfc <pbuf_alloced_custom>
  {
    RxAllocStatus = RX_ALLOC_ERROR;
    *buff = NULL;
  }
/* USER CODE END HAL ETH RxAllocateCallback */
}
9000148e:	b002      	add	sp, #8
90001490:	bd10      	pop	{r4, pc}
    RxAllocStatus = RX_ALLOC_ERROR;
90001492:	4a04      	ldr	r2, [pc, #16]	; (900014a4 <HAL_ETH_RxAllocateCallback+0x40>)
90001494:	2101      	movs	r1, #1
    *buff = NULL;
90001496:	6020      	str	r0, [r4, #0]
    RxAllocStatus = RX_ALLOC_ERROR;
90001498:	7011      	strb	r1, [r2, #0]
}
9000149a:	e7f8      	b.n	9000148e <HAL_ETH_RxAllocateCallback+0x2a>
9000149c:	90012b4c 	.word	0x90012b4c
900014a0:	90000fd9 	.word	0x90000fd9
900014a4:	24000320 	.word	0x24000320

900014a8 <HAL_ETH_RxLinkCallback>:

void HAL_ETH_RxLinkCallback(void **pStart, void **pEnd, uint8_t *buff, uint16_t Length)
{
900014a8:	b530      	push	{r4, r5, lr}
  struct pbuf **ppEnd = (struct pbuf **)pEnd;
  struct pbuf *p = NULL;

  /* Get the struct pbuf from the buff address. */
  p = (struct pbuf *)(buff - offsetof(RxBuff_t, buff));
  p->next = NULL;
900014aa:	2500      	movs	r5, #0
  p = (struct pbuf *)(buff - offsetof(RxBuff_t, buff));
900014ac:	f1a2 0420 	sub.w	r4, r2, #32
  p->tot_len = 0;
  p->len = Length;
900014b0:	f822 3c16 	strh.w	r3, [r2, #-22]
  p->next = NULL;
900014b4:	f842 5c20 	str.w	r5, [r2, #-32]
  p->tot_len = 0;
900014b8:	f822 5c18 	strh.w	r5, [r2, #-24]

  /* Chain the buffer. */
  if (!*ppStart)
900014bc:	6805      	ldr	r5, [r0, #0]
900014be:	b9b5      	cbnz	r5, 900014ee <HAL_ETH_RxLinkCallback+0x46>
  {
    /* The first buffer of the packet. */
    *ppStart = p;
900014c0:	6004      	str	r4, [r0, #0]
  else
  {
    /* Chain the buffer to the end of the packet. */
    (*ppEnd)->next = p;
  }
  *ppEnd  = p;
900014c2:	600c      	str	r4, [r1, #0]

  /* Update the total length of all the buffers of the chain. Each pbuf in the chain should have its tot_len
   * set to its own length, plus the length of all the following pbufs in the chain. */
  for (p = *ppStart; p != NULL; p = p->next)
900014c4:	6801      	ldr	r1, [r0, #0]
900014c6:	b9a9      	cbnz	r1, 900014f4 <HAL_ETH_RxLinkCallback+0x4c>
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) { 
900014c8:	b183      	cbz	r3, 900014ec <HAL_ETH_RxLinkCallback+0x44>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
900014ca:	f002 011f 	and.w	r1, r2, #31
900014ce:	440b      	add	r3, r1
  __ASM volatile ("dsb 0xF":::"memory");
900014d0:	f3bf 8f4f 	dsb	sy
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
    
      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900014d4:	480a      	ldr	r0, [pc, #40]	; (90001500 <HAL_ETH_RxLinkCallback+0x58>)
        op_addr += __SCB_DCACHE_LINE_SIZE;
        op_size -= __SCB_DCACHE_LINE_SIZE;
      } while ( op_size > 0 );
900014d6:	4413      	add	r3, r2
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900014d8:	f8c0 225c 	str.w	r2, [r0, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
900014dc:	3220      	adds	r2, #32
      } while ( op_size > 0 );
900014de:	1a99      	subs	r1, r3, r2
900014e0:	2900      	cmp	r1, #0
900014e2:	dcf9      	bgt.n	900014d8 <HAL_ETH_RxLinkCallback+0x30>
900014e4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
900014e8:	f3bf 8f6f 	isb	sy

  /* Invalidate data cache because Rx DMA's writing to physical memory makes it stale. */
  SCB_InvalidateDCache_by_Addr((uint32_t *)buff, Length);

/* USER CODE END HAL ETH RxLinkCallback */
}
900014ec:	bd30      	pop	{r4, r5, pc}
    (*ppEnd)->next = p;
900014ee:	680d      	ldr	r5, [r1, #0]
900014f0:	602c      	str	r4, [r5, #0]
900014f2:	e7e6      	b.n	900014c2 <HAL_ETH_RxLinkCallback+0x1a>
    p->tot_len += Length;
900014f4:	8908      	ldrh	r0, [r1, #8]
900014f6:	4418      	add	r0, r3
900014f8:	8108      	strh	r0, [r1, #8]
  for (p = *ppStart; p != NULL; p = p->next)
900014fa:	6809      	ldr	r1, [r1, #0]
900014fc:	e7e3      	b.n	900014c6 <HAL_ETH_RxLinkCallback+0x1e>
900014fe:	bf00      	nop
90001500:	e000ed00 	.word	0xe000ed00

90001504 <HAL_ETH_TxFreeCallback>:

void HAL_ETH_TxFreeCallback(uint32_t * buff)
{
/* USER CODE BEGIN HAL ETH TxFreeCallback */

  pbuf_free((struct pbuf *)buff);
90001504:	f00b bbcc 	b.w	9000cca0 <pbuf_free>

90001508 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
90001508:	f8df d034 	ldr.w	sp, [pc, #52]	; 90001540 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
9000150c:	f000 fb3e 	bl	90001b8c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
90001510:	480c      	ldr	r0, [pc, #48]	; (90001544 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
90001512:	490d      	ldr	r1, [pc, #52]	; (90001548 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
90001514:	4a0d      	ldr	r2, [pc, #52]	; (9000154c <LoopFillZerobss+0x1a>)
  movs r3, #0
90001516:	2300      	movs	r3, #0
  b LoopCopyDataInit
90001518:	e002      	b.n	90001520 <LoopCopyDataInit>

9000151a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
9000151a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
9000151c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
9000151e:	3304      	adds	r3, #4

90001520 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
90001520:	18c4      	adds	r4, r0, r3
  cmp r4, r1
90001522:	428c      	cmp	r4, r1
  bcc CopyDataInit
90001524:	d3f9      	bcc.n	9000151a <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
90001526:	4a0a      	ldr	r2, [pc, #40]	; (90001550 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
90001528:	4c0a      	ldr	r4, [pc, #40]	; (90001554 <LoopFillZerobss+0x22>)
  movs r3, #0
9000152a:	2300      	movs	r3, #0
  b LoopFillZerobss
9000152c:	e001      	b.n	90001532 <LoopFillZerobss>

9000152e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
9000152e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
90001530:	3204      	adds	r2, #4

90001532 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
90001532:	42a2      	cmp	r2, r4
  bcc FillZerobss
90001534:	d3fb      	bcc.n	9000152e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
90001536:	f010 fa07 	bl	90011948 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
9000153a:	f7ff f909 	bl	90000750 <main>
  bx  lr
9000153e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
90001540:	24080000 	.word	0x24080000
  ldr r0, =_sdata
90001544:	24000000 	.word	0x24000000
  ldr r1, =_edata
90001548:	2400009c 	.word	0x2400009c
  ldr r2, =_sidata
9000154c:	90015ca0 	.word	0x90015ca0
  ldr r2, =_sbss
90001550:	2400015c 	.word	0x2400015c
  ldr r4, =_ebss
90001554:	2400d434 	.word	0x2400d434

90001558 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
90001558:	e7fe      	b.n	90001558 <ADC3_IRQHandler>

9000155a <stm32_lock_acquire>:
/**
  * @brief Acquire STM32 lock
  * @param lock The lock to acquire
  */
static inline void stm32_lock_acquire(LockingData_t *lock)
{
9000155a:	b508      	push	{r3, lr}
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
  STM32_LOCK_ASSERT_VALID_NESTING_LEVEL(lock);
9000155c:	7a03      	ldrb	r3, [r0, #8]
9000155e:	2b01      	cmp	r3, #1
90001560:	d903      	bls.n	9000156a <stm32_lock_acquire+0x10>
  __ASM volatile ("cpsid i" : : : "memory");
90001562:	b672      	cpsid	i
90001564:	f7ff f97a 	bl	9000085c <Error_Handler>
90001568:	e7fe      	b.n	90001568 <stm32_lock_acquire+0xe>
  lock->basepri[lock->nesting_level++] = taskENTER_CRITICAL_FROM_ISR();
9000156a:	1c5a      	adds	r2, r3, #1
9000156c:	7202      	strb	r2, [r0, #8]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
9000156e:	f3ef 8211 	mrs	r2, BASEPRI
90001572:	f04f 0150 	mov.w	r1, #80	; 0x50
90001576:	f381 8811 	msr	BASEPRI, r1
9000157a:	f3bf 8f6f 	isb	sy
9000157e:	f3bf 8f4f 	dsb	sy
90001582:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
90001586:	bd08      	pop	{r3, pc}

90001588 <stm32_lock_release>:
/**
  * @brief Release STM32 lock
  * @param lock The lock to release
  */
static inline void stm32_lock_release(LockingData_t *lock)
{
90001588:	b508      	push	{r3, lr}
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
  lock->nesting_level--;
9000158a:	7a03      	ldrb	r3, [r0, #8]
9000158c:	3b01      	subs	r3, #1
9000158e:	b2db      	uxtb	r3, r3
  STM32_LOCK_ASSERT_VALID_NESTING_LEVEL(lock);
90001590:	2b01      	cmp	r3, #1
  lock->nesting_level--;
90001592:	7203      	strb	r3, [r0, #8]
  STM32_LOCK_ASSERT_VALID_NESTING_LEVEL(lock);
90001594:	d903      	bls.n	9000159e <stm32_lock_release+0x16>
90001596:	b672      	cpsid	i
90001598:	f7ff f960 	bl	9000085c <Error_Handler>
9000159c:	e7fe      	b.n	9000159c <stm32_lock_release+0x14>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
9000159e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
900015a2:	f383 8811 	msr	BASEPRI, r3
  taskEXIT_CRITICAL_FROM_ISR(lock->basepri[lock->nesting_level]);
}
900015a6:	bd08      	pop	{r3, pc}

900015a8 <__retarget_lock_init_recursive>:
/**
  * @brief Initialize recursive lock
  * @param lock The lock
  */
void __retarget_lock_init_recursive(_LOCK_T *lock)
{
900015a8:	b510      	push	{r4, lr}
  if (lock == NULL)
900015aa:	4604      	mov	r4, r0
900015ac:	b918      	cbnz	r0, 900015b6 <__retarget_lock_init_recursive+0xe>
  {
    errno = EINVAL;
900015ae:	4b09      	ldr	r3, [pc, #36]	; (900015d4 <__retarget_lock_init_recursive+0x2c>)
900015b0:	2216      	movs	r2, #22
900015b2:	601a      	str	r2, [r3, #0]
    return;
  }

  /* Unable to allocate memory */
  STM32_LOCK_BLOCK();
}
900015b4:	bd10      	pop	{r4, pc}
  *lock = (_LOCK_T)malloc(sizeof(struct __lock));
900015b6:	200c      	movs	r0, #12
900015b8:	f010 f9ea 	bl	90011990 <malloc>
900015bc:	6020      	str	r0, [r4, #0]
  if (*lock != NULL)
900015be:	b120      	cbz	r0, 900015ca <__retarget_lock_init_recursive+0x22>
    lock->basepri[i] = 0;
900015c0:	2300      	movs	r3, #0
900015c2:	e9c0 3300 	strd	r3, r3, [r0]
  lock->nesting_level = 0;
900015c6:	7203      	strb	r3, [r0, #8]
    return;
900015c8:	e7f4      	b.n	900015b4 <__retarget_lock_init_recursive+0xc>
900015ca:	b672      	cpsid	i
  STM32_LOCK_BLOCK();
900015cc:	f7ff f946 	bl	9000085c <Error_Handler>
900015d0:	e7fe      	b.n	900015d0 <__retarget_lock_init_recursive+0x28>
900015d2:	bf00      	nop
900015d4:	2400d3a8 	.word	0x2400d3a8

900015d8 <__retarget_lock_acquire>:
/**
  * @brief Acquire lock
  * @param lock The lock
  */
void __retarget_lock_acquire(_LOCK_T lock)
{
900015d8:	b508      	push	{r3, lr}
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
900015da:	b918      	cbnz	r0, 900015e4 <__retarget_lock_acquire+0xc>
900015dc:	b672      	cpsid	i
900015de:	f7ff f93d 	bl	9000085c <Error_Handler>
900015e2:	e7fe      	b.n	900015e2 <__retarget_lock_acquire+0xa>
  stm32_lock_acquire(STM32_LOCK_PARAMETER(lock));
}
900015e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stm32_lock_acquire(STM32_LOCK_PARAMETER(lock));
900015e8:	f7ff bfb7 	b.w	9000155a <stm32_lock_acquire>

900015ec <__retarget_lock_acquire_recursive>:
900015ec:	f7ff bff4 	b.w	900015d8 <__retarget_lock_acquire>

900015f0 <__retarget_lock_release>:
/**
  * @brief Release lock
  * @param lock The lock
  */
void __retarget_lock_release(_LOCK_T lock)
{
900015f0:	b508      	push	{r3, lr}
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
900015f2:	b918      	cbnz	r0, 900015fc <__retarget_lock_release+0xc>
900015f4:	b672      	cpsid	i
900015f6:	f7ff f931 	bl	9000085c <Error_Handler>
900015fa:	e7fe      	b.n	900015fa <__retarget_lock_release+0xa>
  stm32_lock_release(STM32_LOCK_PARAMETER(lock));
}
900015fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stm32_lock_release(STM32_LOCK_PARAMETER(lock));
90001600:	f7ff bfc2 	b.w	90001588 <stm32_lock_release>

90001604 <__retarget_lock_release_recursive>:
90001604:	f7ff bff4 	b.w	900015f0 <__retarget_lock_release>

90001608 <sdram_speed_test>:

uint32_t *test_buffer = (uint32_t *)0xC0000000;   //[(1024*1024*16)/4] __attribute__((section("sdram0")));

static volatile int start_time = 0, end_time = 0, final_value = 0;

void sdram_speed_test() {
90001608:	b510      	push	{r4, lr}
    
    start_time = HAL_GetTick();
9000160a:	f000 fb7f 	bl	90001d0c <HAL_GetTick>
9000160e:	4c0c      	ldr	r4, [pc, #48]	; (90001640 <sdram_speed_test+0x38>)
    memset(test_buffer, 0xA5A5, 1024*1024*32);
90001610:	4b0c      	ldr	r3, [pc, #48]	; (90001644 <sdram_speed_test+0x3c>)
90001612:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
90001616:	f24a 51a5 	movw	r1, #42405	; 0xa5a5
    start_time = HAL_GetTick();
9000161a:	6020      	str	r0, [r4, #0]
    memset(test_buffer, 0xA5A5, 1024*1024*32);
9000161c:	6818      	ldr	r0, [r3, #0]
9000161e:	f010 f9dd 	bl	900119dc <memset>
    end_time = HAL_GetTick();
90001622:	f000 fb73 	bl	90001d0c <HAL_GetTick>
90001626:	4b08      	ldr	r3, [pc, #32]	; (90001648 <sdram_speed_test+0x40>)
90001628:	6018      	str	r0, [r3, #0]
    final_value = end_time - start_time;
9000162a:	681b      	ldr	r3, [r3, #0]
9000162c:	6822      	ldr	r2, [r4, #0]
    printf("time :%d", final_value);
9000162e:	4807      	ldr	r0, [pc, #28]	; (9000164c <sdram_speed_test+0x44>)
    final_value = end_time - start_time;
90001630:	1a9b      	subs	r3, r3, r2
90001632:	4a07      	ldr	r2, [pc, #28]	; (90001650 <sdram_speed_test+0x48>)
}
90001634:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    final_value = end_time - start_time;
90001638:	6013      	str	r3, [r2, #0]
    printf("time :%d", final_value);
9000163a:	6811      	ldr	r1, [r2, #0]
9000163c:	f010 bab6 	b.w	90011bac <iprintf>
90001640:	24004dc8 	.word	0x24004dc8
90001644:	24000018 	.word	0x24000018
90001648:	24004dc0 	.word	0x24004dc0
9000164c:	90012b58 	.word	0x90012b58
90001650:	24004dc4 	.word	0x24004dc4

90001654 <defualt_thread_entry>:
void defualt_thread_entry(void){
90001654:	b508      	push	{r3, lr}
    sdram_speed_test();
90001656:	f7ff ffd7 	bl	90001608 <sdram_speed_test>
}
9000165a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    lwiperf_example_init();
9000165e:	f005 bb6d 	b.w	90006d3c <lwiperf_example_init>
	...

90001664 <MPU_Config>:
    }
}


void MPU_Config( void )
{
90001664:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  MPU_Region_InitTypeDef MPU_InitStruct;
  
  /* Disable the MPU */
  HAL_MPU_Disable();
90001666:	f000 fbdf 	bl	90001e28 <HAL_MPU_Disable>
  
  MPU_InitStruct.Enable           = MPU_REGION_ENABLE;
9000166a:	2301      	movs	r3, #1
  MPU_InitStruct.BaseAddress      = 0x24000000;
  MPU_InitStruct.Size             = MPU_REGION_SIZE_512KB;
9000166c:	f04f 5210 	mov.w	r2, #603979776	; 0x24000000
  MPU_InitStruct.IsCacheable      = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable      = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.Number           = MPU_REGION_NUMBER0;
  MPU_InitStruct.TypeExtField     = MPU_TEX_LEVEL1;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
90001670:	f44f 7480 	mov.w	r4, #256	; 0x100
  MPU_InitStruct.Enable           = MPU_REGION_ENABLE;
90001674:	f8ad 3000 	strh.w	r3, [sp]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
90001678:	4668      	mov	r0, sp
  MPU_InitStruct.Size             = MPU_REGION_SIZE_512KB;
9000167a:	4b1a      	ldr	r3, [pc, #104]	; (900016e4 <MPU_Config+0x80>)
  MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
9000167c:	9403      	str	r4, [sp, #12]
  MPU_InitStruct.Size             = MPU_REGION_SIZE_512KB;
9000167e:	e9cd 2301 	strd	r2, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
90001682:	f000 fbef 	bl	90001e64 <HAL_MPU_ConfigRegion>

  MPU_InitStruct.Enable           = MPU_REGION_ENABLE;
90001686:	f240 1301 	movw	r3, #257	; 0x101
  MPU_InitStruct.BaseAddress      = 0x20000000;
  MPU_InitStruct.Size             = MPU_REGION_SIZE_128KB;
9000168a:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  MPU_InitStruct.IsShareable      = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.Number           = MPU_REGION_NUMBER1;
  MPU_InitStruct.TypeExtField     = MPU_TEX_LEVEL1;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
9000168e:	4668      	mov	r0, sp
  MPU_InitStruct.Enable           = MPU_REGION_ENABLE;
90001690:	f8ad 3000 	strh.w	r3, [sp]
  MPU_InitStruct.Size             = MPU_REGION_SIZE_128KB;
90001694:	4b14      	ldr	r3, [pc, #80]	; (900016e8 <MPU_Config+0x84>)
  MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
90001696:	9403      	str	r4, [sp, #12]
  MPU_InitStruct.Size             = MPU_REGION_SIZE_128KB;
90001698:	e9cd 1301 	strd	r1, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
9000169c:	f000 fbe2 	bl	90001e64 <HAL_MPU_ConfigRegion>
  
  /* Configure the MPU attributes as Device not cacheable 
     for ETH DMA descriptors */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
900016a0:	f240 2301 	movw	r3, #513	; 0x201
  MPU_InitStruct.BaseAddress = 0x30000000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_128KB;
900016a4:	f04f 5040 	mov.w	r0, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
900016a8:	f8ad 3000 	strh.w	r3, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_128KB;
900016ac:	4b0f      	ldr	r3, [pc, #60]	; (900016ec <MPU_Config+0x88>)
900016ae:	e9cd 0301 	strd	r0, r3, [sp, #4]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
900016b2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
900016b6:	4668      	mov	r0, sp
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
900016b8:	9303      	str	r3, [sp, #12]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
900016ba:	f000 fbd3 	bl	90001e64 <HAL_MPU_ConfigRegion>
  
  /* Configure the MPU attributes as Normal Non Cacheable
     for LwIP RAM heap which contains the Tx buffers */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
900016be:	f240 3301 	movw	r3, #769	; 0x301
  MPU_InitStruct.BaseAddress = 0x30044000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_32KB;
900016c2:	f8df c030 	ldr.w	ip, [pc, #48]	; 900016f4 <MPU_Config+0x90>
  MPU_InitStruct.Number = MPU_REGION_NUMBER3;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
900016c6:	4668      	mov	r0, sp
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
900016c8:	9403      	str	r4, [sp, #12]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
900016ca:	f8ad 3000 	strh.w	r3, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_32KB;
900016ce:	4b08      	ldr	r3, [pc, #32]	; (900016f0 <MPU_Config+0x8c>)
900016d0:	e9cd c301 	strd	ip, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
900016d4:	f000 fbc6 	bl	90001e64 <HAL_MPU_ConfigRegion>

  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
900016d8:	2004      	movs	r0, #4
900016da:	f000 fbb3 	bl	90001e44 <HAL_MPU_Enable>
}
900016de:	b004      	add	sp, #16
900016e0:	bd10      	pop	{r4, pc}
900016e2:	bf00      	nop
900016e4:	03010012 	.word	0x03010012
900016e8:	03010010 	.word	0x03010010
900016ec:	03000010 	.word	0x03000010
900016f0:	0301000e 	.word	0x0301000e
900016f4:	30044000 	.word	0x30044000

900016f8 <W25QXX_ExitQPIMode>:
    W25QXX_Reset();
    W25QXX_EnterQPIMode();
}

void W25QXX_ExitQPIMode(void)
{
900016f8:	b510      	push	{r4, lr}
    QSPI_CommandTypeDef cmd;

    cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
900016fa:	f44f 7340 	mov.w	r3, #768	; 0x300
{
900016fe:	b08e      	sub	sp, #56	; 0x38
    cmd.Instruction = W25X_ExitQPIMode;

    cmd.AddressMode = QSPI_ADDRESS_NONE;
90001700:	2400      	movs	r4, #0

    cmd.DdrMode = QSPI_DDR_MODE_DISABLE;
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;

    HAL_QSPI_Command(&hqspi, &cmd, 100);
90001702:	2264      	movs	r2, #100	; 0x64
    cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
90001704:	9306      	str	r3, [sp, #24]
    cmd.Instruction = W25X_ExitQPIMode;
90001706:	23ff      	movs	r3, #255	; 0xff
    HAL_QSPI_Command(&hqspi, &cmd, 100);
90001708:	4669      	mov	r1, sp
9000170a:	480b      	ldr	r0, [pc, #44]	; (90001738 <W25QXX_ExitQPIMode+0x40>)
    cmd.Instruction = W25X_ExitQPIMode;
9000170c:	9300      	str	r3, [sp, #0]
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
9000170e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    cmd.AddressMode = QSPI_ADDRESS_NONE;
90001712:	9407      	str	r4, [sp, #28]
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
90001714:	9303      	str	r3, [sp, #12]
    cmd.Address = 0x00;
90001716:	9401      	str	r4, [sp, #4]
    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
90001718:	9408      	str	r4, [sp, #32]
    cmd.AlternateBytesSize = 0;
9000171a:	9404      	str	r4, [sp, #16]
    cmd.AlternateBytes = 0x00;
9000171c:	9402      	str	r4, [sp, #8]
    cmd.DummyCycles = 0;
9000171e:	9405      	str	r4, [sp, #20]
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
90001720:	940d      	str	r4, [sp, #52]	; 0x34
    cmd.NbData = 0;
90001722:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
90001726:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
    HAL_QSPI_Command(&hqspi, &cmd, 100);
9000172a:	f001 fdcf 	bl	900032cc <HAL_QSPI_Command>

    w25qxx_mode = W25QXX_MODE_SPI;
9000172e:	4b03      	ldr	r3, [pc, #12]	; (9000173c <W25QXX_ExitQPIMode+0x44>)
90001730:	701c      	strb	r4, [r3, #0]
}
90001732:	b00e      	add	sp, #56	; 0x38
90001734:	bd10      	pop	{r4, pc}
90001736:	bf00      	nop
90001738:	240001b4 	.word	0x240001b4
9000173c:	24004dcc 	.word	0x24004dcc

90001740 <W25QXX_ReadSR>:
        HAL_QSPI_Transmit(&hqspi, &dat, 100);
    }
}

uint8_t W25QXX_ReadSR(uint8_t srx)
{
90001740:	b500      	push	{lr}
    uint8_t dat = 0;
90001742:	2300      	movs	r3, #0
{
90001744:	b091      	sub	sp, #68	; 0x44
    uint8_t dat = 0;
90001746:	f88d 3007 	strb.w	r3, [sp, #7]

    QSPI_CommandTypeDef cmd;

    if (w25qxx_mode)
9000174a:	4b1d      	ldr	r3, [pc, #116]	; (900017c0 <W25QXX_ReadSR+0x80>)
9000174c:	781b      	ldrb	r3, [r3, #0]
9000174e:	b36b      	cbz	r3, 900017ac <W25QXX_ReadSR+0x6c>
    {
        cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
90001750:	f44f 7340 	mov.w	r3, #768	; 0x300
90001754:	9308      	str	r3, [sp, #32]
        cmd.DataMode = QSPI_DATA_4_LINES;
90001756:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
        cmd.DataMode = QSPI_DATA_1_LINE;
    }

    cmd.AddressMode = QSPI_ADDRESS_NONE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
9000175a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
        cmd.DataMode = QSPI_DATA_1_LINE;
9000175e:	930b      	str	r3, [sp, #44]	; 0x2c

    cmd.DdrMode = QSPI_DDR_MODE_DISABLE;
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;

    switch (srx)
90001760:	2802      	cmp	r0, #2
    cmd.AddressMode = QSPI_ADDRESS_NONE;
90001762:	f04f 0300 	mov.w	r3, #0
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
90001766:	9205      	str	r2, [sp, #20]
    cmd.NbData = 1;
90001768:	f04f 0201 	mov.w	r2, #1
    cmd.AddressMode = QSPI_ADDRESS_NONE;
9000176c:	9309      	str	r3, [sp, #36]	; 0x24
    cmd.Address = 0x00;
9000176e:	9303      	str	r3, [sp, #12]
    cmd.NbData = 1;
90001770:	920c      	str	r2, [sp, #48]	; 0x30
    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
90001772:	930a      	str	r3, [sp, #40]	; 0x28
    cmd.AlternateBytesSize = 0;
90001774:	9306      	str	r3, [sp, #24]
    cmd.AlternateBytes = 0x00;
90001776:	9304      	str	r3, [sp, #16]
    cmd.DummyCycles = 0;
90001778:	9307      	str	r3, [sp, #28]
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
9000177a:	930f      	str	r3, [sp, #60]	; 0x3c
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
9000177c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
    switch (srx)
90001780:	d01a      	beq.n	900017b8 <W25QXX_ReadSR+0x78>
90001782:	2803      	cmp	r0, #3
90001784:	d01a      	beq.n	900017bc <W25QXX_ReadSR+0x7c>
    {
    case 1:
        cmd.Instruction = W25X_ReadStatusReg1;
90001786:	2305      	movs	r3, #5
        break;
    default:
        cmd.Instruction = W25X_ReadStatusReg1;
        break;
    }
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
90001788:	2264      	movs	r2, #100	; 0x64
9000178a:	a902      	add	r1, sp, #8
9000178c:	480d      	ldr	r0, [pc, #52]	; (900017c4 <W25QXX_ReadSR+0x84>)
        cmd.Instruction = W25X_ReadStatusReg3;
9000178e:	9302      	str	r3, [sp, #8]
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
90001790:	f001 fd9c 	bl	900032cc <HAL_QSPI_Command>
90001794:	b928      	cbnz	r0, 900017a2 <W25QXX_ReadSR+0x62>
    {
        HAL_QSPI_Receive(&hqspi, &dat, 100);
90001796:	2264      	movs	r2, #100	; 0x64
90001798:	f10d 0107 	add.w	r1, sp, #7
9000179c:	4809      	ldr	r0, [pc, #36]	; (900017c4 <W25QXX_ReadSR+0x84>)
9000179e:	f001 fe31 	bl	90003404 <HAL_QSPI_Receive>
    }

    return dat;
}
900017a2:	f89d 0007 	ldrb.w	r0, [sp, #7]
900017a6:	b011      	add	sp, #68	; 0x44
900017a8:	f85d fb04 	ldr.w	pc, [sp], #4
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
900017ac:	f44f 7380 	mov.w	r3, #256	; 0x100
900017b0:	9308      	str	r3, [sp, #32]
        cmd.DataMode = QSPI_DATA_1_LINE;
900017b2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
900017b6:	e7d0      	b.n	9000175a <W25QXX_ReadSR+0x1a>
        cmd.Instruction = W25X_ReadStatusReg2;
900017b8:	2335      	movs	r3, #53	; 0x35
900017ba:	e7e5      	b.n	90001788 <W25QXX_ReadSR+0x48>
        cmd.Instruction = W25X_ReadStatusReg3;
900017bc:	2315      	movs	r3, #21
900017be:	e7e3      	b.n	90001788 <W25QXX_ReadSR+0x48>
900017c0:	24004dcc 	.word	0x24004dcc
900017c4:	240001b4 	.word	0x240001b4

900017c8 <W25QXX_WriteSR>:

void W25QXX_WriteSR(uint8_t srx, uint8_t dat)
{
    QSPI_CommandTypeDef cmd;

    if (w25qxx_mode)
900017c8:	4b18      	ldr	r3, [pc, #96]	; (9000182c <W25QXX_WriteSR+0x64>)
{
900017ca:	b500      	push	{lr}
900017cc:	b091      	sub	sp, #68	; 0x44
    if (w25qxx_mode)
900017ce:	781b      	ldrb	r3, [r3, #0]
{
900017d0:	f88d 1007 	strb.w	r1, [sp, #7]
    if (w25qxx_mode)
900017d4:	b323      	cbz	r3, 90001820 <W25QXX_WriteSR+0x58>
    {
        cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
900017d6:	f44f 7340 	mov.w	r3, #768	; 0x300
900017da:	9308      	str	r3, [sp, #32]
        cmd.DataMode = QSPI_DATA_4_LINES;
900017dc:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
        cmd.DataMode = QSPI_DATA_1_LINE;
    }

    cmd.AddressMode = QSPI_ADDRESS_NONE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
900017e0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
        cmd.DataMode = QSPI_DATA_1_LINE;
900017e4:	930b      	str	r3, [sp, #44]	; 0x2c
    cmd.AddressMode = QSPI_ADDRESS_NONE;
900017e6:	2300      	movs	r3, #0
        break;
    default:
        cmd.Instruction = W25X_WriteStatusReg1;
        break;
    }
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
900017e8:	a902      	add	r1, sp, #8
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
900017ea:	9205      	str	r2, [sp, #20]
    cmd.NbData = 1;
900017ec:	2201      	movs	r2, #1
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
900017ee:	4810      	ldr	r0, [pc, #64]	; (90001830 <W25QXX_WriteSR+0x68>)
    cmd.NbData = 1;
900017f0:	920c      	str	r2, [sp, #48]	; 0x30
        cmd.Instruction = W25X_WriteStatusReg1;
900017f2:	9202      	str	r2, [sp, #8]
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
900017f4:	2264      	movs	r2, #100	; 0x64
    cmd.AddressMode = QSPI_ADDRESS_NONE;
900017f6:	9309      	str	r3, [sp, #36]	; 0x24
    cmd.Address = 0x00;
900017f8:	9303      	str	r3, [sp, #12]
    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
900017fa:	930a      	str	r3, [sp, #40]	; 0x28
    cmd.AlternateBytesSize = 0;
900017fc:	9306      	str	r3, [sp, #24]
    cmd.AlternateBytes = 0x00;
900017fe:	9304      	str	r3, [sp, #16]
    cmd.DummyCycles = 0;
90001800:	9307      	str	r3, [sp, #28]
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
90001802:	930f      	str	r3, [sp, #60]	; 0x3c
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
90001804:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
90001808:	f001 fd60 	bl	900032cc <HAL_QSPI_Command>
9000180c:	b928      	cbnz	r0, 9000181a <W25QXX_WriteSR+0x52>
    {
        HAL_QSPI_Transmit(&hqspi, &dat, 100);
9000180e:	2264      	movs	r2, #100	; 0x64
90001810:	f10d 0107 	add.w	r1, sp, #7
90001814:	4806      	ldr	r0, [pc, #24]	; (90001830 <W25QXX_WriteSR+0x68>)
90001816:	f001 fd9c 	bl	90003352 <HAL_QSPI_Transmit>
    }
}
9000181a:	b011      	add	sp, #68	; 0x44
9000181c:	f85d fb04 	ldr.w	pc, [sp], #4
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
90001820:	f44f 7380 	mov.w	r3, #256	; 0x100
90001824:	9308      	str	r3, [sp, #32]
        cmd.DataMode = QSPI_DATA_1_LINE;
90001826:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000182a:	e7d9      	b.n	900017e0 <W25QXX_WriteSR+0x18>
9000182c:	24004dcc 	.word	0x24004dcc
90001830:	240001b4 	.word	0x240001b4

90001834 <W25QXX_WriteEnable>:

void W25QXX_WriteEnable(uint8_t en)
{
    QSPI_CommandTypeDef cmd;

    if (w25qxx_mode)
90001834:	4b13      	ldr	r3, [pc, #76]	; (90001884 <W25QXX_WriteEnable+0x50>)
    {
        cmd.Instruction = W25X_WriteDisable;
    }

    cmd.AddressMode = QSPI_ADDRESS_NONE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
90001836:	f44f 5200 	mov.w	r2, #8192	; 0x2000
{
9000183a:	b500      	push	{lr}
    if (w25qxx_mode)
9000183c:	781b      	ldrb	r3, [r3, #0]
{
9000183e:	b08f      	sub	sp, #60	; 0x3c
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
90001840:	2b00      	cmp	r3, #0
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
90001842:	9203      	str	r2, [sp, #12]

    cmd.DdrMode = QSPI_DDR_MODE_DISABLE;
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;

    HAL_QSPI_Command(&hqspi, &cmd, 100);
90001844:	4669      	mov	r1, sp
90001846:	f04f 0264 	mov.w	r2, #100	; 0x64
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
9000184a:	bf14      	ite	ne
9000184c:	f44f 7340 	movne.w	r3, #768	; 0x300
90001850:	f44f 7380 	moveq.w	r3, #256	; 0x100
        cmd.Instruction = W25X_WriteDisable;
90001854:	2800      	cmp	r0, #0
    HAL_QSPI_Command(&hqspi, &cmd, 100);
90001856:	480c      	ldr	r0, [pc, #48]	; (90001888 <W25QXX_WriteEnable+0x54>)
90001858:	9306      	str	r3, [sp, #24]
        cmd.Instruction = W25X_WriteDisable;
9000185a:	bf14      	ite	ne
9000185c:	2306      	movne	r3, #6
9000185e:	2304      	moveq	r3, #4
90001860:	9300      	str	r3, [sp, #0]
    cmd.AddressMode = QSPI_ADDRESS_NONE;
90001862:	2300      	movs	r3, #0
90001864:	9307      	str	r3, [sp, #28]
    cmd.Address = 0x00;
90001866:	9301      	str	r3, [sp, #4]
    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
90001868:	9308      	str	r3, [sp, #32]
    cmd.AlternateBytesSize = 0;
9000186a:	9304      	str	r3, [sp, #16]
    cmd.AlternateBytes = 0x00;
9000186c:	9302      	str	r3, [sp, #8]
    cmd.DummyCycles = 0;
9000186e:	9305      	str	r3, [sp, #20]
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
90001870:	930d      	str	r3, [sp, #52]	; 0x34
    cmd.NbData = 0;
90001872:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
90001876:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
    HAL_QSPI_Command(&hqspi, &cmd, 100);
9000187a:	f001 fd27 	bl	900032cc <HAL_QSPI_Command>
}
9000187e:	b00f      	add	sp, #60	; 0x3c
90001880:	f85d fb04 	ldr.w	pc, [sp], #4
90001884:	24004dcc 	.word	0x24004dcc
90001888:	240001b4 	.word	0x240001b4

9000188c <W25QXX_EnterQPIMode>:
{
9000188c:	b500      	push	{lr}
    dat = W25QXX_ReadSR(2);
9000188e:	2002      	movs	r0, #2
{
90001890:	b091      	sub	sp, #68	; 0x44
    dat = W25QXX_ReadSR(2);
90001892:	f7ff ff55 	bl	90001740 <W25QXX_ReadSR>
    if ((dat & QE_MASK) == 0x00)
90001896:	0783      	lsls	r3, r0, #30
    dat = W25QXX_ReadSR(2);
90001898:	f88d 0007 	strb.w	r0, [sp, #7]
    if ((dat & QE_MASK) == 0x00)
9000189c:	d40b      	bmi.n	900018b6 <W25QXX_EnterQPIMode+0x2a>
        W25QXX_WriteEnable(1);
9000189e:	2001      	movs	r0, #1
900018a0:	f7ff ffc8 	bl	90001834 <W25QXX_WriteEnable>
        dat |= QE_MASK;
900018a4:	f89d 1007 	ldrb.w	r1, [sp, #7]
        W25QXX_WriteSR(2, dat);
900018a8:	2002      	movs	r0, #2
        dat |= QE_MASK;
900018aa:	f041 0102 	orr.w	r1, r1, #2
900018ae:	f88d 1007 	strb.w	r1, [sp, #7]
        W25QXX_WriteSR(2, dat);
900018b2:	f7ff ff89 	bl	900017c8 <W25QXX_WriteSR>
    cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
900018b6:	f44f 7380 	mov.w	r3, #256	; 0x100
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
900018ba:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    HAL_QSPI_Command(&hqspi, &cmd, 100);
900018be:	a902      	add	r1, sp, #8
900018c0:	4819      	ldr	r0, [pc, #100]	; (90001928 <W25QXX_EnterQPIMode+0x9c>)
    cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
900018c2:	9308      	str	r3, [sp, #32]
    cmd.Instruction = W25X_EnterQPIMode;
900018c4:	2338      	movs	r3, #56	; 0x38
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
900018c6:	9205      	str	r2, [sp, #20]
    HAL_QSPI_Command(&hqspi, &cmd, 100);
900018c8:	2264      	movs	r2, #100	; 0x64
    cmd.Instruction = W25X_EnterQPIMode;
900018ca:	9302      	str	r3, [sp, #8]
    cmd.AddressMode = QSPI_ADDRESS_NONE;
900018cc:	2300      	movs	r3, #0
900018ce:	9309      	str	r3, [sp, #36]	; 0x24
    cmd.Address = 0x00;
900018d0:	9303      	str	r3, [sp, #12]
    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
900018d2:	930a      	str	r3, [sp, #40]	; 0x28
    cmd.AlternateBytesSize = 0;
900018d4:	9306      	str	r3, [sp, #24]
    cmd.AlternateBytes = 0x00;
900018d6:	9304      	str	r3, [sp, #16]
    cmd.DummyCycles = 0;
900018d8:	9307      	str	r3, [sp, #28]
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
900018da:	930f      	str	r3, [sp, #60]	; 0x3c
    cmd.NbData = 0;
900018dc:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
900018e0:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
    HAL_QSPI_Command(&hqspi, &cmd, 100);
900018e4:	f001 fcf2 	bl	900032cc <HAL_QSPI_Command>
    w25qxx_mode = W25QXX_MODE_QPI;
900018e8:	2001      	movs	r0, #1
900018ea:	4b10      	ldr	r3, [pc, #64]	; (9000192c <W25QXX_EnterQPIMode+0xa0>)
900018ec:	7018      	strb	r0, [r3, #0]
    cmd.InstructionMode = QSPI_INSTRUCTION_4_LINES;
900018ee:	f44f 7340 	mov.w	r3, #768	; 0x300
900018f2:	9308      	str	r3, [sp, #32]
    cmd.Instruction = W25X_SetReadParameters;
900018f4:	23c0      	movs	r3, #192	; 0xc0
900018f6:	9302      	str	r3, [sp, #8]
    cmd.DataMode = QSPI_DATA_4_LINES;
900018f8:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
    cmd.NbData = 1;
900018fc:	e9cd 300b 	strd	r3, r0, [sp, #44]	; 0x2c
    dat = 0x03 << 4;
90001900:	2330      	movs	r3, #48	; 0x30
90001902:	f88d 3007 	strb.w	r3, [sp, #7]
    W25QXX_WriteEnable(1);
90001906:	f7ff ff95 	bl	90001834 <W25QXX_WriteEnable>
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
9000190a:	2264      	movs	r2, #100	; 0x64
9000190c:	a902      	add	r1, sp, #8
9000190e:	4806      	ldr	r0, [pc, #24]	; (90001928 <W25QXX_EnterQPIMode+0x9c>)
90001910:	f001 fcdc 	bl	900032cc <HAL_QSPI_Command>
90001914:	b928      	cbnz	r0, 90001922 <W25QXX_EnterQPIMode+0x96>
        HAL_QSPI_Transmit(&hqspi, &dat, 100);
90001916:	2264      	movs	r2, #100	; 0x64
90001918:	f10d 0107 	add.w	r1, sp, #7
9000191c:	4802      	ldr	r0, [pc, #8]	; (90001928 <W25QXX_EnterQPIMode+0x9c>)
9000191e:	f001 fd18 	bl	90003352 <HAL_QSPI_Transmit>
}
90001922:	b011      	add	sp, #68	; 0x44
90001924:	f85d fb04 	ldr.w	pc, [sp], #4
90001928:	240001b4 	.word	0x240001b4
9000192c:	24004dcc 	.word	0x24004dcc

90001930 <W25QXX_WaitBusy>:
    HAL_QSPI_Command(&hqspi, &cmd, 100);
    W25QXX_WaitBusy();
}

void W25QXX_WaitBusy(void)
{
90001930:	b508      	push	{r3, lr}
    while ((W25QXX_ReadSR(1) & BUSY_MASK) == BUSY_MASK)
90001932:	2001      	movs	r0, #1
90001934:	f7ff ff04 	bl	90001740 <W25QXX_ReadSR>
90001938:	07c3      	lsls	r3, r0, #31
9000193a:	d4fa      	bmi.n	90001932 <W25QXX_WaitBusy+0x2>
        ;
}
9000193c:	bd08      	pop	{r3, pc}
	...

90001940 <W25QXX_Reset>:

void W25QXX_Reset(void)
{
    QSPI_CommandTypeDef cmd;

    if (w25qxx_mode)
90001940:	4b16      	ldr	r3, [pc, #88]	; (9000199c <W25QXX_Reset+0x5c>)
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
    }
    cmd.Instruction = W25X_EnableReset;

    cmd.AddressMode = QSPI_ADDRESS_NONE;
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
90001942:	f44f 5200 	mov.w	r2, #8192	; 0x2000
{
90001946:	b500      	push	{lr}
    if (w25qxx_mode)
90001948:	781b      	ldrb	r3, [r3, #0]
{
9000194a:	b08f      	sub	sp, #60	; 0x3c
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
9000194c:	2b00      	cmp	r3, #0
    cmd.AddressSize = QSPI_ADDRESS_24_BITS;
9000194e:	9203      	str	r2, [sp, #12]
        cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
90001950:	bf14      	ite	ne
90001952:	f44f 7340 	movne.w	r3, #768	; 0x300
90001956:	f44f 7380 	moveq.w	r3, #256	; 0x100
9000195a:	9306      	str	r3, [sp, #24]
    cmd.Instruction = W25X_EnableReset;
9000195c:	2366      	movs	r3, #102	; 0x66
9000195e:	9300      	str	r3, [sp, #0]
    cmd.AddressMode = QSPI_ADDRESS_NONE;
90001960:	2300      	movs	r3, #0
90001962:	9307      	str	r3, [sp, #28]
    cmd.Address = 0;
90001964:	9301      	str	r3, [sp, #4]

    cmd.DataMode = QSPI_DATA_NONE;
    cmd.NbData = 0;

    cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
90001966:	9308      	str	r3, [sp, #32]
    cmd.AlternateBytesSize = 0;
90001968:	9304      	str	r3, [sp, #16]
    cmd.AlternateBytes = 0x00;
9000196a:	9302      	str	r3, [sp, #8]

    cmd.DummyCycles = 0;
9000196c:	9305      	str	r3, [sp, #20]

    cmd.DdrMode = QSPI_DDR_MODE_DISABLE;
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
    cmd.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
9000196e:	930d      	str	r3, [sp, #52]	; 0x34
    cmd.NbData = 0;
90001970:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
    cmd.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
90001974:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c

    W25QXX_WaitBusy();
90001978:	f7ff ffda 	bl	90001930 <W25QXX_WaitBusy>
    if (HAL_QSPI_Command(&hqspi, &cmd, 100) == HAL_OK)
9000197c:	2264      	movs	r2, #100	; 0x64
9000197e:	4669      	mov	r1, sp
90001980:	4807      	ldr	r0, [pc, #28]	; (900019a0 <W25QXX_Reset+0x60>)
90001982:	f001 fca3 	bl	900032cc <HAL_QSPI_Command>
90001986:	b930      	cbnz	r0, 90001996 <W25QXX_Reset+0x56>
    {
        cmd.Instruction = W25X_ResetDevice;
90001988:	2399      	movs	r3, #153	; 0x99
        HAL_QSPI_Command(&hqspi, &cmd, 100);
9000198a:	2264      	movs	r2, #100	; 0x64
9000198c:	4669      	mov	r1, sp
9000198e:	4804      	ldr	r0, [pc, #16]	; (900019a0 <W25QXX_Reset+0x60>)
        cmd.Instruction = W25X_ResetDevice;
90001990:	9300      	str	r3, [sp, #0]
        HAL_QSPI_Command(&hqspi, &cmd, 100);
90001992:	f001 fc9b 	bl	900032cc <HAL_QSPI_Command>
    }
}
90001996:	b00f      	add	sp, #60	; 0x3c
90001998:	f85d fb04 	ldr.w	pc, [sp], #4
9000199c:	24004dcc 	.word	0x24004dcc
900019a0:	240001b4 	.word	0x240001b4

900019a4 <W25QXX_Init>:
{
900019a4:	b508      	push	{r3, lr}
	HAL_QSPI_MspInit(&hqspi);
900019a6:	4806      	ldr	r0, [pc, #24]	; (900019c0 <W25QXX_Init+0x1c>)
900019a8:	f7fe ff7a 	bl	900008a0 <HAL_QSPI_MspInit>
    MX_QUADSPI_Init();
900019ac:	f7fe ff58 	bl	90000860 <MX_QUADSPI_Init>
    W25QXX_ExitQPIMode();
900019b0:	f7ff fea2 	bl	900016f8 <W25QXX_ExitQPIMode>
    W25QXX_Reset();
900019b4:	f7ff ffc4 	bl	90001940 <W25QXX_Reset>
}
900019b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    W25QXX_EnterQPIMode();
900019bc:	f7ff bf66 	b.w	9000188c <W25QXX_EnterQPIMode>
900019c0:	240001b4 	.word	0x240001b4

900019c4 <W25Q_Memory_Mapped_Enable>:

void W25Q_Memory_Mapped_Enable(void)
{
900019c4:	b500      	push	{lr}
  QSPI_CommandTypeDef s_command;
  QSPI_MemoryMappedTypeDef s_mem_mapped_cfg;
 
  /* Configure the command for the read instruction */
  s_command.InstructionMode = QSPI_INSTRUCTION_4_LINES;
900019c6:	f44f 7340 	mov.w	r3, #768	; 0x300
{
900019ca:	b091      	sub	sp, #68	; 0x44
  s_command.Instruction = W25X_FastReadQuadIO;
  s_command.AddressMode = QSPI_ADDRESS_4_LINES;
  s_command.AddressSize = QSPI_ADDRESS_24_BITS;
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode = QSPI_DATA_4_LINES;
900019cc:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
 
  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
  s_mem_mapped_cfg.TimeOutPeriod = 0;
 
  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)
900019d0:	480d      	ldr	r0, [pc, #52]	; (90001a08 <W25Q_Memory_Mapped_Enable+0x44>)
  s_command.InstructionMode = QSPI_INSTRUCTION_4_LINES;
900019d2:	9308      	str	r3, [sp, #32]
  s_command.Instruction = W25X_FastReadQuadIO;
900019d4:	23eb      	movs	r3, #235	; 0xeb
  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)
900019d6:	a902      	add	r1, sp, #8
  s_command.Instruction = W25X_FastReadQuadIO;
900019d8:	9302      	str	r3, [sp, #8]
  s_command.AddressMode = QSPI_ADDRESS_4_LINES;
900019da:	f44f 6340 	mov.w	r3, #3072	; 0xc00
900019de:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize = QSPI_ADDRESS_24_BITS;
900019e0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
900019e4:	9305      	str	r3, [sp, #20]
  s_command.DataMode = QSPI_DATA_4_LINES;
900019e6:	2300      	movs	r3, #0
900019e8:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
  s_command.DummyCycles = 8;
900019ec:	2208      	movs	r2, #8
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
900019ee:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DummyCycles = 8;
900019f0:	9207      	str	r2, [sp, #28]
  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)
900019f2:	466a      	mov	r2, sp
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
900019f4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_mem_mapped_cfg.TimeOutPeriod = 0;
900019f8:	e9cd 3300 	strd	r3, r3, [sp]
  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)
900019fc:	f001 fd61 	bl	900034c2 <HAL_QSPI_MemoryMapped>
  {

  }
}
90001a00:	b011      	add	sp, #68	; 0x44
90001a02:	f85d fb04 	ldr.w	pc, [sp], #4
90001a06:	bf00      	nop
90001a08:	240001b4 	.word	0x240001b4

90001a0c <LAN8742_RegisterBusIO>:
  * @param  ioctx: holds device IO functions.  
  * @retval LAN8742_STATUS_OK  if OK
  *         LAN8742_STATUS_ERROR if missing mandatory function
  */
int32_t  LAN8742_RegisterBusIO(lan8742_Object_t *pObj, lan8742_IOCtx_t *ioctx)
{
90001a0c:	b530      	push	{r4, r5, lr}
  if(!pObj || !ioctx->ReadReg || !ioctx->WriteReg || !ioctx->GetTick)
90001a0e:	b170      	cbz	r0, 90001a2e <LAN8742_RegisterBusIO+0x22>
90001a10:	68cc      	ldr	r4, [r1, #12]
90001a12:	b164      	cbz	r4, 90001a2e <LAN8742_RegisterBusIO+0x22>
90001a14:	688a      	ldr	r2, [r1, #8]
90001a16:	b152      	cbz	r2, 90001a2e <LAN8742_RegisterBusIO+0x22>
90001a18:	690b      	ldr	r3, [r1, #16]
90001a1a:	b143      	cbz	r3, 90001a2e <LAN8742_RegisterBusIO+0x22>
  {
    return LAN8742_STATUS_ERROR;
  }
  
  pObj->IO.Init = ioctx->Init;
90001a1c:	680d      	ldr	r5, [r1, #0]
  pObj->IO.DeInit = ioctx->DeInit;
90001a1e:	6849      	ldr	r1, [r1, #4]
  pObj->IO.Init = ioctx->Init;
90001a20:	6085      	str	r5, [r0, #8]
  pObj->IO.DeInit = ioctx->DeInit;
90001a22:	60c1      	str	r1, [r0, #12]
  pObj->IO.ReadReg = ioctx->ReadReg;
  pObj->IO.WriteReg = ioctx->WriteReg;
  pObj->IO.GetTick = ioctx->GetTick;
90001a24:	6183      	str	r3, [r0, #24]
  pObj->IO.WriteReg = ioctx->WriteReg;
90001a26:	e9c0 2404 	strd	r2, r4, [r0, #16]
  
  return LAN8742_STATUS_OK;
90001a2a:	2000      	movs	r0, #0
}
90001a2c:	bd30      	pop	{r4, r5, pc}
    return LAN8742_STATUS_ERROR;
90001a2e:	f04f 30ff 	mov.w	r0, #4294967295
90001a32:	e7fb      	b.n	90001a2c <LAN8742_RegisterBusIO+0x20>

90001a34 <LAN8742_Init>:
  *         LAN8742_STATUS_READ_ERROR if connot read register
  *         LAN8742_STATUS_WRITE_ERROR if connot write to register
  *         LAN8742_STATUS_RESET_TIMEOUT if cannot perform a software reset
  */
 int32_t LAN8742_Init(lan8742_Object_t *pObj)
 {
90001a34:	b573      	push	{r0, r1, r4, r5, r6, lr}
   uint32_t tickstart = 0, regvalue = 0, addr = 0;
90001a36:	2300      	movs	r3, #0
   int32_t status = LAN8742_STATUS_OK;
   
   if(pObj->Is_Initialized == 0)
90001a38:	6846      	ldr	r6, [r0, #4]
 {
90001a3a:	4604      	mov	r4, r0
   uint32_t tickstart = 0, regvalue = 0, addr = 0;
90001a3c:	9301      	str	r3, [sp, #4]
   if(pObj->Is_Initialized == 0)
90001a3e:	b166      	cbz	r6, 90001a5a <LAN8742_Init+0x26>
     }
   }
      
   if(status == LAN8742_STATUS_OK)
   {
     tickstart =  pObj->IO.GetTick();
90001a40:	69a3      	ldr	r3, [r4, #24]
90001a42:	4798      	blx	r3
90001a44:	4605      	mov	r5, r0
     
     /* Wait for 2s to perform initialization */
     while((pObj->IO.GetTick() - tickstart) <= LAN8742_INIT_TO)
90001a46:	69a3      	ldr	r3, [r4, #24]
90001a48:	4798      	blx	r3
90001a4a:	1b43      	subs	r3, r0, r5
90001a4c:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
90001a50:	d9f9      	bls.n	90001a46 <LAN8742_Init+0x12>
     {
     }
     pObj->Is_Initialized = 1;
90001a52:	2301      	movs	r3, #1
90001a54:	2500      	movs	r5, #0
90001a56:	6063      	str	r3, [r4, #4]
90001a58:	e027      	b.n	90001aaa <LAN8742_Init+0x76>
     if(pObj->IO.Init != 0)
90001a5a:	6883      	ldr	r3, [r0, #8]
90001a5c:	b103      	cbz	r3, 90001a60 <LAN8742_Init+0x2c>
       pObj->IO.Init();
90001a5e:	4798      	blx	r3
     pObj->DevAddr = LAN8742_MAX_DEV_ADDR + 1;
90001a60:	2320      	movs	r3, #32
   int32_t status = LAN8742_STATUS_OK;
90001a62:	2500      	movs	r5, #0
     pObj->DevAddr = LAN8742_MAX_DEV_ADDR + 1;
90001a64:	6023      	str	r3, [r4, #0]
       if(pObj->IO.ReadReg(addr, LAN8742_SMR, &regvalue) < 0)
90001a66:	6963      	ldr	r3, [r4, #20]
90001a68:	aa01      	add	r2, sp, #4
90001a6a:	2112      	movs	r1, #18
90001a6c:	4630      	mov	r0, r6
90001a6e:	4798      	blx	r3
90001a70:	2800      	cmp	r0, #0
90001a72:	db1d      	blt.n	90001ab0 <LAN8742_Init+0x7c>
       if((regvalue & LAN8742_SMR_PHY_ADDR) == addr)
90001a74:	9b01      	ldr	r3, [sp, #4]
90001a76:	f003 031f 	and.w	r3, r3, #31
90001a7a:	42b3      	cmp	r3, r6
90001a7c:	d11a      	bne.n	90001ab4 <LAN8742_Init+0x80>
         status = LAN8742_STATUS_OK;
90001a7e:	2500      	movs	r5, #0
         pObj->DevAddr = addr;
90001a80:	6026      	str	r6, [r4, #0]
     if(pObj->DevAddr > LAN8742_MAX_DEV_ADDR)
90001a82:	6820      	ldr	r0, [r4, #0]
90001a84:	281f      	cmp	r0, #31
90001a86:	d82d      	bhi.n	90001ae4 <LAN8742_Init+0xb0>
     if(status == LAN8742_STATUS_OK)
90001a88:	b97d      	cbnz	r5, 90001aaa <LAN8742_Init+0x76>
       if(pObj->IO.WriteReg(pObj->DevAddr, LAN8742_BCR, LAN8742_BCR_SOFT_RESET) >= 0)
90001a8a:	6923      	ldr	r3, [r4, #16]
90001a8c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
90001a90:	4629      	mov	r1, r5
90001a92:	4798      	blx	r3
90001a94:	2800      	cmp	r0, #0
90001a96:	db28      	blt.n	90001aea <LAN8742_Init+0xb6>
         if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &regvalue) >= 0)
90001a98:	6963      	ldr	r3, [r4, #20]
90001a9a:	aa01      	add	r2, sp, #4
90001a9c:	4629      	mov	r1, r5
90001a9e:	6820      	ldr	r0, [r4, #0]
90001aa0:	4798      	blx	r3
90001aa2:	2800      	cmp	r0, #0
90001aa4:	da0a      	bge.n	90001abc <LAN8742_Init+0x88>
           status = LAN8742_STATUS_READ_ERROR;
90001aa6:	f06f 0504 	mvn.w	r5, #4
   }
   
   return status;
 }
90001aaa:	4628      	mov	r0, r5
90001aac:	b002      	add	sp, #8
90001aae:	bd70      	pop	{r4, r5, r6, pc}
         status = LAN8742_STATUS_READ_ERROR;
90001ab0:	f06f 0504 	mvn.w	r5, #4
     for(addr = 0; addr <= LAN8742_MAX_DEV_ADDR; addr ++)
90001ab4:	3601      	adds	r6, #1
90001ab6:	2e20      	cmp	r6, #32
90001ab8:	d1d5      	bne.n	90001a66 <LAN8742_Init+0x32>
90001aba:	e7e2      	b.n	90001a82 <LAN8742_Init+0x4e>
           tickstart = pObj->IO.GetTick();
90001abc:	69a3      	ldr	r3, [r4, #24]
90001abe:	4798      	blx	r3
90001ac0:	4605      	mov	r5, r0
           while(regvalue & LAN8742_BCR_SOFT_RESET)
90001ac2:	9b01      	ldr	r3, [sp, #4]
             if((pObj->IO.GetTick() - tickstart) <= LAN8742_SW_RESET_TO)
90001ac4:	69a2      	ldr	r2, [r4, #24]
           while(regvalue & LAN8742_BCR_SOFT_RESET)
90001ac6:	041b      	lsls	r3, r3, #16
90001ac8:	d5ba      	bpl.n	90001a40 <LAN8742_Init+0xc>
             if((pObj->IO.GetTick() - tickstart) <= LAN8742_SW_RESET_TO)
90001aca:	4790      	blx	r2
90001acc:	1b40      	subs	r0, r0, r5
90001ace:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
90001ad2:	d80d      	bhi.n	90001af0 <LAN8742_Init+0xbc>
               if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &regvalue) < 0)
90001ad4:	6963      	ldr	r3, [r4, #20]
90001ad6:	aa01      	add	r2, sp, #4
90001ad8:	2100      	movs	r1, #0
90001ada:	6820      	ldr	r0, [r4, #0]
90001adc:	4798      	blx	r3
90001ade:	2800      	cmp	r0, #0
90001ae0:	daef      	bge.n	90001ac2 <LAN8742_Init+0x8e>
90001ae2:	e7e0      	b.n	90001aa6 <LAN8742_Init+0x72>
       status = LAN8742_STATUS_ADDRESS_ERROR;
90001ae4:	f06f 0502 	mvn.w	r5, #2
90001ae8:	e7df      	b.n	90001aaa <LAN8742_Init+0x76>
         status = LAN8742_STATUS_WRITE_ERROR;
90001aea:	f06f 0503 	mvn.w	r5, #3
90001aee:	e7dc      	b.n	90001aaa <LAN8742_Init+0x76>
               status = LAN8742_STATUS_RESET_TIMEOUT;
90001af0:	f06f 0501 	mvn.w	r5, #1
   return status;
90001af4:	e7d9      	b.n	90001aaa <LAN8742_Init+0x76>

90001af6 <LAN8742_GetLinkState>:
  *         LAN8742_STATUS_10MBITS_HALFDUPLEX  if 10Mb/s HD       
  *         LAN8742_STATUS_READ_ERROR if connot read register
  *         LAN8742_STATUS_WRITE_ERROR if connot write to register
  */
int32_t LAN8742_GetLinkState(lan8742_Object_t *pObj)
{
90001af6:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t readval = 0;
90001af8:	2500      	movs	r5, #0
  
  /* Read Status register  */
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
90001afa:	6943      	ldr	r3, [r0, #20]
{
90001afc:	4604      	mov	r4, r0
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
90001afe:	aa01      	add	r2, sp, #4
90001b00:	2101      	movs	r1, #1
90001b02:	6800      	ldr	r0, [r0, #0]
  uint32_t readval = 0;
90001b04:	9501      	str	r5, [sp, #4]
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
90001b06:	4798      	blx	r3
90001b08:	42a8      	cmp	r0, r5
90001b0a:	da03      	bge.n	90001b14 <LAN8742_GetLinkState+0x1e>
  {
    return LAN8742_STATUS_READ_ERROR;
90001b0c:	f06f 0004 	mvn.w	r0, #4
    else
    {
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
    }				
  }
}
90001b10:	b003      	add	sp, #12
90001b12:	bd30      	pop	{r4, r5, pc}
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BSR, &readval) < 0)
90001b14:	6963      	ldr	r3, [r4, #20]
90001b16:	aa01      	add	r2, sp, #4
90001b18:	2101      	movs	r1, #1
90001b1a:	6820      	ldr	r0, [r4, #0]
90001b1c:	4798      	blx	r3
90001b1e:	2800      	cmp	r0, #0
90001b20:	dbf4      	blt.n	90001b0c <LAN8742_GetLinkState+0x16>
  if((readval & LAN8742_BSR_LINK_STATUS) == 0)
90001b22:	9b01      	ldr	r3, [sp, #4]
90001b24:	075b      	lsls	r3, r3, #29
90001b26:	d52c      	bpl.n	90001b82 <LAN8742_GetLinkState+0x8c>
  if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_BCR, &readval) < 0)
90001b28:	6963      	ldr	r3, [r4, #20]
90001b2a:	aa01      	add	r2, sp, #4
90001b2c:	4629      	mov	r1, r5
90001b2e:	6820      	ldr	r0, [r4, #0]
90001b30:	4798      	blx	r3
90001b32:	2800      	cmp	r0, #0
90001b34:	dbea      	blt.n	90001b0c <LAN8742_GetLinkState+0x16>
  if((readval & LAN8742_BCR_AUTONEGO_EN) != LAN8742_BCR_AUTONEGO_EN)
90001b36:	9b01      	ldr	r3, [sp, #4]
90001b38:	04dd      	lsls	r5, r3, #19
90001b3a:	d40e      	bmi.n	90001b5a <LAN8742_GetLinkState+0x64>
    if(((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT) && ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE)) 
90001b3c:	f403 5204 	and.w	r2, r3, #8448	; 0x2100
90001b40:	f5b2 5f04 	cmp.w	r2, #8448	; 0x2100
90001b44:	d101      	bne.n	90001b4a <LAN8742_GetLinkState+0x54>
      return LAN8742_STATUS_100MBITS_FULLDUPLEX;
90001b46:	2002      	movs	r0, #2
90001b48:	e7e2      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
    else if ((readval & LAN8742_BCR_SPEED_SELECT) == LAN8742_BCR_SPEED_SELECT)
90001b4a:	0498      	lsls	r0, r3, #18
90001b4c:	d501      	bpl.n	90001b52 <LAN8742_GetLinkState+0x5c>
      return LAN8742_STATUS_100MBITS_HALFDUPLEX;
90001b4e:	2003      	movs	r0, #3
90001b50:	e7de      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
    else if ((readval & LAN8742_BCR_DUPLEX_MODE) == LAN8742_BCR_DUPLEX_MODE)
90001b52:	05d9      	lsls	r1, r3, #23
90001b54:	d513      	bpl.n	90001b7e <LAN8742_GetLinkState+0x88>
      return LAN8742_STATUS_10MBITS_FULLDUPLEX;
90001b56:	2004      	movs	r0, #4
90001b58:	e7da      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
    if(pObj->IO.ReadReg(pObj->DevAddr, LAN8742_PHYSCSR, &readval) < 0)
90001b5a:	6963      	ldr	r3, [r4, #20]
90001b5c:	aa01      	add	r2, sp, #4
90001b5e:	211f      	movs	r1, #31
90001b60:	6820      	ldr	r0, [r4, #0]
90001b62:	4798      	blx	r3
90001b64:	2800      	cmp	r0, #0
90001b66:	dbd1      	blt.n	90001b0c <LAN8742_GetLinkState+0x16>
    if((readval & LAN8742_PHYSCSR_AUTONEGO_DONE) == 0)
90001b68:	9b01      	ldr	r3, [sp, #4]
90001b6a:	04da      	lsls	r2, r3, #19
90001b6c:	d50b      	bpl.n	90001b86 <LAN8742_GetLinkState+0x90>
    if((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_FD)
90001b6e:	f003 031c 	and.w	r3, r3, #28
90001b72:	2b18      	cmp	r3, #24
90001b74:	d0e7      	beq.n	90001b46 <LAN8742_GetLinkState+0x50>
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_100BTX_HD)
90001b76:	2b08      	cmp	r3, #8
90001b78:	d0e9      	beq.n	90001b4e <LAN8742_GetLinkState+0x58>
    else if ((readval & LAN8742_PHYSCSR_HCDSPEEDMASK) == LAN8742_PHYSCSR_10BT_FD)
90001b7a:	2b14      	cmp	r3, #20
90001b7c:	d0eb      	beq.n	90001b56 <LAN8742_GetLinkState+0x60>
      return LAN8742_STATUS_10MBITS_HALFDUPLEX;
90001b7e:	2005      	movs	r0, #5
90001b80:	e7c6      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
    return LAN8742_STATUS_LINK_DOWN;    
90001b82:	2001      	movs	r0, #1
90001b84:	e7c4      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
      return LAN8742_STATUS_AUTONEGO_NOTDONE;
90001b86:	2006      	movs	r0, #6
90001b88:	e7c2      	b.n	90001b10 <LAN8742_GetLinkState+0x1a>
	...

90001b8c <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
90001b8c:	4a25      	ldr	r2, [pc, #148]	; (90001c24 <SystemInit+0x98>)
90001b8e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
90001b92:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
90001b96:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
90001b9a:	4a23      	ldr	r2, [pc, #140]	; (90001c28 <SystemInit+0x9c>)
90001b9c:	6813      	ldr	r3, [r2, #0]
90001b9e:	f003 030f 	and.w	r3, r3, #15
90001ba2:	2b06      	cmp	r3, #6
90001ba4:	d805      	bhi.n	90001bb2 <SystemInit+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
90001ba6:	6813      	ldr	r3, [r2, #0]
90001ba8:	f023 030f 	bic.w	r3, r3, #15
90001bac:	f043 0307 	orr.w	r3, r3, #7
90001bb0:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
90001bb2:	4b1e      	ldr	r3, [pc, #120]	; (90001c2c <SystemInit+0xa0>)
90001bb4:	681a      	ldr	r2, [r3, #0]
90001bb6:	f042 0201 	orr.w	r2, r2, #1
90001bba:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
90001bbc:	2200      	movs	r2, #0
90001bbe:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
90001bc0:	4a1b      	ldr	r2, [pc, #108]	; (90001c30 <SystemInit+0xa4>)
90001bc2:	6819      	ldr	r1, [r3, #0]
90001bc4:	400a      	ands	r2, r1

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
90001bc6:	4918      	ldr	r1, [pc, #96]	; (90001c28 <SystemInit+0x9c>)
  RCC->CR &= 0xEAF6ED7FU;
90001bc8:	601a      	str	r2, [r3, #0]
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
90001bca:	680a      	ldr	r2, [r1, #0]
90001bcc:	0712      	lsls	r2, r2, #28
90001bce:	d505      	bpl.n	90001bdc <SystemInit+0x50>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
90001bd0:	680a      	ldr	r2, [r1, #0]
90001bd2:	f022 020f 	bic.w	r2, r2, #15
90001bd6:	f042 0207 	orr.w	r2, r2, #7
90001bda:	600a      	str	r2, [r1, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
90001bdc:	2200      	movs	r2, #0

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
90001bde:	4915      	ldr	r1, [pc, #84]	; (90001c34 <SystemInit+0xa8>)
  RCC->D1CFGR = 0x00000000;
90001be0:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
90001be2:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
90001be4:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x02020200;
90001be6:	6299      	str	r1, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
90001be8:	4913      	ldr	r1, [pc, #76]	; (90001c38 <SystemInit+0xac>)
90001bea:	62d9      	str	r1, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
90001bec:	4913      	ldr	r1, [pc, #76]	; (90001c3c <SystemInit+0xb0>)
90001bee:	6319      	str	r1, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
90001bf0:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
90001bf2:	6399      	str	r1, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
90001bf4:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
90001bf6:	6419      	str	r1, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
90001bf8:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
90001bfa:	6819      	ldr	r1, [r3, #0]
90001bfc:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
90001c00:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
90001c02:	661a      	str	r2, [r3, #96]	; 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
90001c04:	4b0e      	ldr	r3, [pc, #56]	; (90001c40 <SystemInit+0xb4>)
90001c06:	681b      	ldr	r3, [r3, #0]
90001c08:	0c1b      	lsrs	r3, r3, #16
90001c0a:	041b      	lsls	r3, r3, #16
90001c0c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90001c10:	d203      	bcs.n	90001c1a <SystemInit+0x8e>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
90001c12:	4b0c      	ldr	r3, [pc, #48]	; (90001c44 <SystemInit+0xb8>)
90001c14:	2201      	movs	r2, #1
90001c16:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
90001c1a:	4b0b      	ldr	r3, [pc, #44]	; (90001c48 <SystemInit+0xbc>)
90001c1c:	f243 02d2 	movw	r2, #12498	; 0x30d2
90001c20:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
90001c22:	4770      	bx	lr
90001c24:	e000ed00 	.word	0xe000ed00
90001c28:	52002000 	.word	0x52002000
90001c2c:	58024400 	.word	0x58024400
90001c30:	eaf6ed7f 	.word	0xeaf6ed7f
90001c34:	02020200 	.word	0x02020200
90001c38:	01ff0000 	.word	0x01ff0000
90001c3c:	01010280 	.word	0x01010280
90001c40:	5c001000 	.word	0x5c001000
90001c44:	51008000 	.word	0x51008000
90001c48:	52004000 	.word	0x52004000

90001c4c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
90001c4c:	b538      	push	{r3, r4, r5, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
90001c4e:	4b0f      	ldr	r3, [pc, #60]	; (90001c8c <HAL_InitTick+0x40>)
{
90001c50:	4605      	mov	r5, r0
  if((uint32_t)uwTickFreq == 0UL)
90001c52:	7818      	ldrb	r0, [r3, #0]
90001c54:	b908      	cbnz	r0, 90001c5a <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
90001c56:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
90001c58:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
90001c5a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90001c5e:	4a0c      	ldr	r2, [pc, #48]	; (90001c90 <HAL_InitTick+0x44>)
90001c60:	fbb3 f3f0 	udiv	r3, r3, r0
90001c64:	6810      	ldr	r0, [r2, #0]
90001c66:	fbb0 f0f3 	udiv	r0, r0, r3
90001c6a:	f000 f8c9 	bl	90001e00 <HAL_SYSTICK_Config>
90001c6e:	4604      	mov	r4, r0
90001c70:	2800      	cmp	r0, #0
90001c72:	d1f0      	bne.n	90001c56 <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
90001c74:	2d0f      	cmp	r5, #15
90001c76:	d8ee      	bhi.n	90001c56 <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
90001c78:	4602      	mov	r2, r0
90001c7a:	4629      	mov	r1, r5
90001c7c:	f04f 30ff 	mov.w	r0, #4294967295
90001c80:	f000 f87e 	bl	90001d80 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
90001c84:	4b03      	ldr	r3, [pc, #12]	; (90001c94 <HAL_InitTick+0x48>)
90001c86:	4620      	mov	r0, r4
90001c88:	601d      	str	r5, [r3, #0]
  return HAL_OK;
90001c8a:	e7e5      	b.n	90001c58 <HAL_InitTick+0xc>
90001c8c:	24000024 	.word	0x24000024
90001c90:	2400001c 	.word	0x2400001c
90001c94:	24000028 	.word	0x24000028

90001c98 <HAL_Init>:
{
90001c98:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
90001c9a:	2003      	movs	r0, #3
90001c9c:	f000 f85e 	bl	90001d5c <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
90001ca0:	f001 fee2 	bl	90003a68 <HAL_RCC_GetSysClockFreq>
90001ca4:	490f      	ldr	r1, [pc, #60]	; (90001ce4 <HAL_Init+0x4c>)
90001ca6:	4a10      	ldr	r2, [pc, #64]	; (90001ce8 <HAL_Init+0x50>)
90001ca8:	698b      	ldr	r3, [r1, #24]
90001caa:	f3c3 2303 	ubfx	r3, r3, #8, #4
90001cae:	5cd3      	ldrb	r3, [r2, r3]
90001cb0:	f003 031f 	and.w	r3, r3, #31
90001cb4:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90001cb6:	698b      	ldr	r3, [r1, #24]
90001cb8:	f003 030f 	and.w	r3, r3, #15
90001cbc:	5cd3      	ldrb	r3, [r2, r3]
90001cbe:	4a0b      	ldr	r2, [pc, #44]	; (90001cec <HAL_Init+0x54>)
90001cc0:	f003 031f 	and.w	r3, r3, #31
90001cc4:	fa20 f303 	lsr.w	r3, r0, r3
90001cc8:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
90001cca:	4b09      	ldr	r3, [pc, #36]	; (90001cf0 <HAL_Init+0x58>)
90001ccc:	6018      	str	r0, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
90001cce:	200f      	movs	r0, #15
90001cd0:	f7ff ffbc 	bl	90001c4c <HAL_InitTick>
90001cd4:	4604      	mov	r4, r0
90001cd6:	b918      	cbnz	r0, 90001ce0 <HAL_Init+0x48>
  HAL_MspInit();
90001cd8:	f7fe fecc 	bl	90000a74 <HAL_MspInit>
}
90001cdc:	4620      	mov	r0, r4
90001cde:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
90001ce0:	2401      	movs	r4, #1
90001ce2:	e7fb      	b.n	90001cdc <HAL_Init+0x44>
90001ce4:	58024400 	.word	0x58024400
90001ce8:	90012b61 	.word	0x90012b61
90001cec:	24000020 	.word	0x24000020
90001cf0:	2400001c 	.word	0x2400001c

90001cf4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
90001cf4:	4a03      	ldr	r2, [pc, #12]	; (90001d04 <HAL_IncTick+0x10>)
90001cf6:	4b04      	ldr	r3, [pc, #16]	; (90001d08 <HAL_IncTick+0x14>)
90001cf8:	6811      	ldr	r1, [r2, #0]
90001cfa:	781b      	ldrb	r3, [r3, #0]
90001cfc:	440b      	add	r3, r1
90001cfe:	6013      	str	r3, [r2, #0]
}
90001d00:	4770      	bx	lr
90001d02:	bf00      	nop
90001d04:	24004dd0 	.word	0x24004dd0
90001d08:	24000024 	.word	0x24000024

90001d0c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
90001d0c:	4b01      	ldr	r3, [pc, #4]	; (90001d14 <HAL_GetTick+0x8>)
90001d0e:	6818      	ldr	r0, [r3, #0]
}
90001d10:	4770      	bx	lr
90001d12:	bf00      	nop
90001d14:	24004dd0 	.word	0x24004dd0

90001d18 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
90001d18:	b538      	push	{r3, r4, r5, lr}
90001d1a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
90001d1c:	f7ff fff6 	bl	90001d0c <HAL_GetTick>
90001d20:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
90001d22:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
90001d24:	bf1e      	ittt	ne
90001d26:	4b04      	ldrne	r3, [pc, #16]	; (90001d38 <HAL_Delay+0x20>)
90001d28:	781b      	ldrbne	r3, [r3, #0]
90001d2a:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
90001d2c:	f7ff ffee 	bl	90001d0c <HAL_GetTick>
90001d30:	1b43      	subs	r3, r0, r5
90001d32:	42a3      	cmp	r3, r4
90001d34:	d3fa      	bcc.n	90001d2c <HAL_Delay+0x14>
  {
  }
}
90001d36:	bd38      	pop	{r3, r4, r5, pc}
90001d38:	24000024 	.word	0x24000024

90001d3c <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
90001d3c:	4b01      	ldr	r3, [pc, #4]	; (90001d44 <HAL_GetREVID+0x8>)
90001d3e:	6818      	ldr	r0, [r3, #0]
}
90001d40:	0c00      	lsrs	r0, r0, #16
90001d42:	4770      	bx	lr
90001d44:	5c001000 	.word	0x5c001000

90001d48 <HAL_SYSCFG_ETHInterfaceSelect>:
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
90001d48:	4a03      	ldr	r2, [pc, #12]	; (90001d58 <HAL_SYSCFG_ETHInterfaceSelect+0x10>)
90001d4a:	6853      	ldr	r3, [r2, #4]
90001d4c:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
90001d50:	4318      	orrs	r0, r3
90001d52:	6050      	str	r0, [r2, #4]
}
90001d54:	4770      	bx	lr
90001d56:	bf00      	nop
90001d58:	58000400 	.word	0x58000400

90001d5c <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
90001d5c:	4907      	ldr	r1, [pc, #28]	; (90001d7c <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
90001d5e:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
90001d60:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
90001d62:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
90001d66:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
90001d6a:	0412      	lsls	r2, r2, #16
90001d6c:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
90001d6e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
90001d70:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
90001d74:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
90001d78:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
90001d7a:	4770      	bx	lr
90001d7c:	e000ed00 	.word	0xe000ed00

90001d80 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
90001d80:	4b16      	ldr	r3, [pc, #88]	; (90001ddc <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
90001d82:	b530      	push	{r4, r5, lr}
90001d84:	68dc      	ldr	r4, [r3, #12]
90001d86:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
90001d8a:	f1c4 0507 	rsb	r5, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90001d8e:	1d23      	adds	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
90001d90:	2d04      	cmp	r5, #4
90001d92:	bf28      	it	cs
90001d94:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90001d96:	2b06      	cmp	r3, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001d98:	f04f 33ff 	mov.w	r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90001d9c:	bf8c      	ite	hi
90001d9e:	3c03      	subhi	r4, #3
90001da0:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001da2:	fa03 f505 	lsl.w	r5, r3, r5
  if ((int32_t)(IRQn) >= 0)
90001da6:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
90001da8:	fa03 f304 	lsl.w	r3, r3, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001dac:	ea21 0105 	bic.w	r1, r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
90001db0:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001db4:	fa01 f104 	lsl.w	r1, r1, r4
90001db8:	ea41 0302 	orr.w	r3, r1, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001dbc:	ea4f 1303 	mov.w	r3, r3, lsl #4
90001dc0:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
90001dc2:	db06      	blt.n	90001dd2 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001dc4:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
90001dc8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
90001dcc:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
90001dd0:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001dd2:	f000 000f 	and.w	r0, r0, #15
90001dd6:	4a02      	ldr	r2, [pc, #8]	; (90001de0 <HAL_NVIC_SetPriority+0x60>)
90001dd8:	5413      	strb	r3, [r2, r0]
90001dda:	e7f9      	b.n	90001dd0 <HAL_NVIC_SetPriority+0x50>
90001ddc:	e000ed00 	.word	0xe000ed00
90001de0:	e000ed14 	.word	0xe000ed14

90001de4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
90001de4:	2800      	cmp	r0, #0
90001de6:	db08      	blt.n	90001dfa <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
90001de8:	2301      	movs	r3, #1
90001dea:	0942      	lsrs	r2, r0, #5
90001dec:	f000 001f 	and.w	r0, r0, #31
90001df0:	fa03 f000 	lsl.w	r0, r3, r0
90001df4:	4b01      	ldr	r3, [pc, #4]	; (90001dfc <HAL_NVIC_EnableIRQ+0x18>)
90001df6:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
90001dfa:	4770      	bx	lr
90001dfc:	e000e100 	.word	0xe000e100

90001e00 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
90001e00:	3801      	subs	r0, #1
90001e02:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
90001e06:	d20b      	bcs.n	90001e20 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
90001e08:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001e0c:	4a05      	ldr	r2, [pc, #20]	; (90001e24 <HAL_SYSTICK_Config+0x24>)
90001e0e:	21f0      	movs	r1, #240	; 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
90001e10:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
90001e12:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001e14:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
90001e18:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
90001e1a:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
90001e1c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
90001e1e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
90001e20:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
90001e22:	4770      	bx	lr
90001e24:	e000ed00 	.word	0xe000ed00

90001e28 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
90001e28:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
90001e2c:	4b04      	ldr	r3, [pc, #16]	; (90001e40 <HAL_MPU_Disable+0x18>)
90001e2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
90001e30:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90001e34:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
90001e36:	2200      	movs	r2, #0
90001e38:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
90001e3c:	4770      	bx	lr
90001e3e:	bf00      	nop
90001e40:	e000ed00 	.word	0xe000ed00

90001e44 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
90001e44:	4b06      	ldr	r3, [pc, #24]	; (90001e60 <HAL_MPU_Enable+0x1c>)
90001e46:	f040 0001 	orr.w	r0, r0, #1
90001e4a:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
90001e4e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
90001e50:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90001e54:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
90001e56:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90001e5a:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
90001e5e:	4770      	bx	lr
90001e60:	e000ed00 	.word	0xe000ed00

90001e64 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
90001e64:	7843      	ldrb	r3, [r0, #1]
90001e66:	4a14      	ldr	r2, [pc, #80]	; (90001eb8 <HAL_MPU_ConfigRegion+0x54>)
{
90001e68:	b510      	push	{r4, lr}
  MPU->RNR = MPU_Init->Number;
90001e6a:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

  if ((MPU_Init->Enable) != 0UL)
90001e6e:	7801      	ldrb	r1, [r0, #0]
90001e70:	b1e9      	cbz	r1, 90001eae <HAL_MPU_ConfigRegion+0x4a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
90001e72:	6843      	ldr	r3, [r0, #4]
90001e74:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
90001e78:	7ac3      	ldrb	r3, [r0, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
90001e7a:	7b04      	ldrb	r4, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
90001e7c:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
90001e7e:	ea43 7304 	orr.w	r3, r3, r4, lsl #28
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e82:	430b      	orrs	r3, r1
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
90001e84:	7a81      	ldrb	r1, [r0, #10]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e86:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
90001e8a:	7b41      	ldrb	r1, [r0, #13]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e8c:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
90001e90:	7b81      	ldrb	r1, [r0, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e92:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
90001e96:	7bc1      	ldrb	r1, [r0, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e98:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
90001e9c:	7a41      	ldrb	r1, [r0, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
90001e9e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
90001ea2:	7a01      	ldrb	r1, [r0, #8]
90001ea4:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
90001ea8:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
90001eac:	bd10      	pop	{r4, pc}
    MPU->RBAR = 0x00;
90001eae:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
    MPU->RASR = 0x00;
90001eb2:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
}
90001eb6:	e7f9      	b.n	90001eac <HAL_MPU_ConfigRegion+0x48>
90001eb8:	e000ed00 	.word	0xe000ed00

90001ebc <ETH_SetMACConfig>:
static void ETH_SetMACConfig(ETH_HandleTypeDef *heth,  ETH_MACConfigTypeDef *macconf)
{
  uint32_t macregval;

  /*------------------------ MACCR Configuration --------------------*/
  macregval = (macconf->InterPacketGapVal |
90001ebc:	688b      	ldr	r3, [r1, #8]
90001ebe:	680a      	ldr	r2, [r1, #0]
{
90001ec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001ec4:	431a      	orrs	r2, r3
               ((uint32_t)macconf->ChecksumOffload << 27) |
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
               ((uint32_t)macconf->Support2KPacket  << 22) |
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
90001ec6:	7c0b      	ldrb	r3, [r1, #16]
{
90001ec8:	b085      	sub	sp, #20
               ((uint32_t)macconf->ChecksumOffload << 27) |
90001eca:	f891 a004 	ldrb.w	sl, [r1, #4]
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
90001ece:	2b00      	cmp	r3, #0
               ((uint32_t)macconf->GiantPacketSizeLimitControl << 23) |
90001ed0:	f891 900c 	ldrb.w	r9, [r1, #12]
               ((uint32_t)macconf->Support2KPacket  << 22) |
90001ed4:	f891 800d 	ldrb.w	r8, [r1, #13]
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
90001ed8:	bf0c      	ite	eq
90001eda:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
90001ede:	2300      	movne	r3, #0
               ((uint32_t)macconf->CRCStripTypePacket << 21) |
90001ee0:	f891 e00e 	ldrb.w	lr, [r1, #14]
               ((uint32_t)((macconf->Watchdog == DISABLE) ? 1U : 0U) << 19) |
90001ee4:	9301      	str	r3, [sp, #4]
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
90001ee6:	7c4b      	ldrb	r3, [r1, #17]
               ((uint32_t)macconf->AutomaticPadCRCStrip << 20) |
90001ee8:	f891 c00f 	ldrb.w	ip, [r1, #15]
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
90001eec:	2b00      	cmp	r3, #0
               ((uint32_t)macconf->JumboPacket << 16) |
90001eee:	7c8e      	ldrb	r6, [r1, #18]
               macconf->Speed |
               macconf->DuplexMode |
               ((uint32_t)macconf->LoopbackMode << 12) |
90001ef0:	7f0d      	ldrb	r5, [r1, #28]
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
90001ef2:	bf0c      	ite	eq
90001ef4:	f44f 3300 	moveq.w	r3, #131072	; 0x20000
90001ef8:	2300      	movne	r3, #0
               ((uint32_t)macconf->CarrierSenseBeforeTransmit << 11) |
90001efa:	f891 b01d 	ldrb.w	fp, [r1, #29]
               ((uint32_t)((macconf->Jabber == DISABLE) ? 1U : 0U) << 17) |
90001efe:	9302      	str	r3, [sp, #8]
90001f00:	694b      	ldr	r3, [r1, #20]
90001f02:	431a      	orrs	r2, r3
90001f04:	698b      	ldr	r3, [r1, #24]
90001f06:	4313      	orrs	r3, r2
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
90001f08:	7f8a      	ldrb	r2, [r1, #30]
90001f0a:	2a00      	cmp	r2, #0
               ((uint32_t)macconf->CarrierSenseDuringTransmit << 9) |
90001f0c:	7fca      	ldrb	r2, [r1, #31]
90001f0e:	9203      	str	r2, [sp, #12]
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
90001f10:	bf08      	it	eq
90001f12:	f44f 6780 	moveq.w	r7, #1024	; 0x400
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
90001f16:	f891 2020 	ldrb.w	r2, [r1, #32]
               ((uint32_t)((macconf->ReceiveOwn == DISABLE) ? 1U : 0U) << 10) |
90001f1a:	bf18      	it	ne
90001f1c:	2700      	movne	r7, #0
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
90001f1e:	2a00      	cmp	r2, #0
               macconf->BackOffLimit |
               ((uint32_t)macconf->DeferralCheck << 4) |
               macconf->PreambleLength);

  /* Write to MACCR */
  MODIFY_REG(heth->Instance->MACCR, ETH_MACCR_MASK, macregval);
90001f20:	6802      	ldr	r2, [r0, #0]
90001f22:	6810      	ldr	r0, [r2, #0]
               ((uint32_t)((macconf->RetryTransmission == DISABLE) ? 1U : 0U) << 8) |
90001f24:	bf0c      	ite	eq
90001f26:	f44f 7480 	moveq.w	r4, #256	; 0x100
90001f2a:	2400      	movne	r4, #0
  MODIFY_REG(heth->Instance->MACCR, ETH_MACCR_MASK, macregval);
90001f2c:	9000      	str	r0, [sp, #0]
90001f2e:	6a48      	ldr	r0, [r1, #36]	; 0x24
90001f30:	4303      	orrs	r3, r0
90001f32:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
90001f34:	4303      	orrs	r3, r0
90001f36:	9800      	ldr	r0, [sp, #0]
90001f38:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
90001f3c:	f420 007b 	bic.w	r0, r0, #16449536	; 0xfb0000
90001f40:	f420 40fe 	bic.w	r0, r0, #32512	; 0x7f00
90001f44:	f020 007c 	bic.w	r0, r0, #124	; 0x7c
90001f48:	4303      	orrs	r3, r0
90001f4a:	9803      	ldr	r0, [sp, #12]
90001f4c:	ea43 63ca 	orr.w	r3, r3, sl, lsl #27
90001f50:	ea43 53c9 	orr.w	r3, r3, r9, lsl #23
90001f54:	ea43 5388 	orr.w	r3, r3, r8, lsl #22
90001f58:	ea43 534e 	orr.w	r3, r3, lr, lsl #21
90001f5c:	ea43 530c 	orr.w	r3, r3, ip, lsl #20
90001f60:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
90001f64:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
90001f68:	ea43 23cb 	orr.w	r3, r3, fp, lsl #11
               ((uint32_t)macconf->DeferralCheck << 4) |
90001f6c:	f891 b028 	ldrb.w	fp, [r1, #40]	; 0x28
  MODIFY_REG(heth->Instance->MACCR, ETH_MACCR_MASK, macregval);
90001f70:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
90001f74:	9801      	ldr	r0, [sp, #4]
90001f76:	ea43 130b 	orr.w	r3, r3, fp, lsl #4
90001f7a:	4303      	orrs	r3, r0
90001f7c:	9802      	ldr	r0, [sp, #8]
90001f7e:	4303      	orrs	r3, r0
90001f80:	433b      	orrs	r3, r7
90001f82:	431c      	orrs	r4, r3
90001f84:	6014      	str	r4, [r2, #0]

  /*------------------------ MACECR Configuration --------------------*/
  macregval = ((macconf->ExtendedInterPacketGapVal << 25) |
90001f86:	6bce      	ldr	r6, [r1, #60]	; 0x3c
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
90001f88:	f891 3032 	ldrb.w	r3, [r1, #50]	; 0x32
               ((uint32_t)macconf->ExtendedInterPacketGap << 24) |
90001f8c:	f891 7038 	ldrb.w	r7, [r1, #56]	; 0x38
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
90001f90:	2b00      	cmp	r3, #0
               macconf->GiantPacketSizeLimit);

  /* Write to MACECR */
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001f92:	6853      	ldr	r3, [r2, #4]
               ((uint32_t)macconf->UnicastSlowProtocolPacketDetect << 18) |
90001f94:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001f98:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
               ((uint32_t)macconf->SlowProtocolDetect << 17) |
90001f9c:	f891 4031 	ldrb.w	r4, [r1, #49]	; 0x31
               ((uint32_t)((macconf->CRCCheckingRxPackets == DISABLE) ? 1U : 0U) << 16) |
90001fa0:	bf0c      	ite	eq
90001fa2:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
90001fa6:	2000      	movne	r0, #0
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001fa8:	f423 23ef 	bic.w	r3, r3, #489472	; 0x77800
90001fac:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
90001fb0:	f023 0307 	bic.w	r3, r3, #7
90001fb4:	ea43 6346 	orr.w	r3, r3, r6, lsl #25
90001fb8:	6b4e      	ldr	r6, [r1, #52]	; 0x34
90001fba:	4333      	orrs	r3, r6

  /*------------------------ MACTFCR Configuration --------------------*/
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
               macconf->PauseLowThreshold |
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
               (macconf->PauseTime << 16));
90001fbc:	6c8e      	ldr	r6, [r1, #72]	; 0x48
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001fbe:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
90001fc2:	ea43 4385 	orr.w	r3, r3, r5, lsl #18
               macconf->PauseLowThreshold |
90001fc6:	6d0d      	ldr	r5, [r1, #80]	; 0x50
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001fc8:	ea43 4344 	orr.w	r3, r3, r4, lsl #17
90001fcc:	4303      	orrs	r3, r0
  MODIFY_REG(heth->Instance->MACWTR, ETH_MACWTR_MASK, macregval);
90001fce:	6c48      	ldr	r0, [r1, #68]	; 0x44
  MODIFY_REG(heth->Instance->MACECR, ETH_MACECR_MASK, macregval);
90001fd0:	6053      	str	r3, [r2, #4]
  MODIFY_REG(heth->Instance->MACWTR, ETH_MACWTR_MASK, macregval);
90001fd2:	68d3      	ldr	r3, [r2, #12]
90001fd4:	f423 7387 	bic.w	r3, r3, #270	; 0x10e
90001fd8:	f023 0301 	bic.w	r3, r3, #1
90001fdc:	4303      	orrs	r3, r0
  macregval = (((uint32_t)macconf->ProgrammableWatchdog << 8) |
90001fde:	f891 0040 	ldrb.w	r0, [r1, #64]	; 0x40
  MODIFY_REG(heth->Instance->MACWTR, ETH_MACWTR_MASK, macregval);
90001fe2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
90001fe6:	60d3      	str	r3, [r2, #12]
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
90001fe8:	f891 304c 	ldrb.w	r3, [r1, #76]	; 0x4c
  macregval = (((uint32_t)macconf->TransmitFlowControl << 1) |
90001fec:	f891 4054 	ldrb.w	r4, [r1, #84]	; 0x54
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
90001ff0:	2b00      	cmp	r3, #0

  /* Write to MACTFCR */
  MODIFY_REG(heth->Instance->MACTFCR, ETH_MACTFCR_MASK, macregval);
90001ff2:	6f13      	ldr	r3, [r2, #112]	; 0x70
90001ff4:	f023 03f2 	bic.w	r3, r3, #242	; 0xf2
               ((uint32_t)((macconf->ZeroQuantaPause == DISABLE) ? 1U : 0U) << 7) |
90001ff8:	bf0c      	ite	eq
90001ffa:	2080      	moveq	r0, #128	; 0x80
90001ffc:	2000      	movne	r0, #0
  MODIFY_REG(heth->Instance->MACTFCR, ETH_MACTFCR_MASK, macregval);
90001ffe:	041b      	lsls	r3, r3, #16
90002000:	0c1b      	lsrs	r3, r3, #16
90002002:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
90002006:	432b      	orrs	r3, r5
  /*------------------------ MTLTQOMR Configuration --------------------*/
  /* Write to MTLTQOMR */
  MODIFY_REG(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_MASK, macconf->TransmitQueueMode);

  /*------------------------ MTLRQOMR Configuration --------------------*/
  macregval = (macconf->ReceiveQueueMode |
90002008:	6dcd      	ldr	r5, [r1, #92]	; 0x5c
  MODIFY_REG(heth->Instance->MACTFCR, ETH_MACTFCR_MASK, macregval);
9000200a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
9000200e:	4303      	orrs	r3, r0
90002010:	6713      	str	r3, [r2, #112]	; 0x70
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
90002012:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
  macregval = ((uint32_t)macconf->ReceiveFlowControl |
90002016:	f891 3056 	ldrb.w	r3, [r1, #86]	; 0x56
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
9000201a:	f020 0003 	bic.w	r0, r0, #3
9000201e:	4303      	orrs	r3, r0
               ((uint32_t)macconf->UnicastPausePacketDetect << 1));
90002020:	f891 0055 	ldrb.w	r0, [r1, #85]	; 0x55
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
90002024:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
  MODIFY_REG(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_MASK, macconf->TransmitQueueMode);
90002028:	6d88      	ldr	r0, [r1, #88]	; 0x58
  MODIFY_REG(heth->Instance->MACRFCR, ETH_MACRFCR_MASK, macregval);
9000202a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_MASK, macconf->TransmitQueueMode);
9000202e:	f8d2 3d00 	ldr.w	r3, [r2, #3328]	; 0xd00
90002032:	f023 0372 	bic.w	r3, r3, #114	; 0x72
90002036:	4303      	orrs	r3, r0
90002038:	f8c2 3d00 	str.w	r3, [r2, #3328]	; 0xd00
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
9000203c:	f891 3060 	ldrb.w	r3, [r1, #96]	; 0x60
               ((uint32_t)macconf->ForwardRxErrorPacket << 4) |
90002040:	f891 4061 	ldrb.w	r4, [r1, #97]	; 0x61
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
90002044:	2b00      	cmp	r3, #0
               ((uint32_t)macconf->ForwardRxUndersizedGoodPacket << 3));

  /* Write to MTLRQOMR */
  MODIFY_REG(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_MASK, macregval);
90002046:	f8d2 3d30 	ldr.w	r3, [r2, #3376]	; 0xd30
               ((uint32_t)macconf->ForwardRxUndersizedGoodPacket << 3));
9000204a:	f891 1062 	ldrb.w	r1, [r1, #98]	; 0x62
  MODIFY_REG(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_MASK, macregval);
9000204e:	f023 037b 	bic.w	r3, r3, #123	; 0x7b
               ((uint32_t)((macconf->DropTCPIPChecksumErrorPacket == DISABLE) ? 1U : 0U) << 6) |
90002052:	bf0c      	ite	eq
90002054:	2040      	moveq	r0, #64	; 0x40
90002056:	2000      	movne	r0, #0
  MODIFY_REG(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_MASK, macregval);
90002058:	432b      	orrs	r3, r5
9000205a:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
9000205e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
90002062:	4303      	orrs	r3, r0
90002064:	f8c2 3d30 	str.w	r3, [r2, #3376]	; 0xd30
}
90002068:	b005      	add	sp, #20
9000206a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90002070 <ETH_SetDMAConfig>:
static void ETH_SetDMAConfig(ETH_HandleTypeDef *heth,  ETH_DMAConfigTypeDef *dmaconf)
{
  uint32_t dmaregval;

  /*------------------------ DMAMR Configuration --------------------*/
  MODIFY_REG(heth->Instance->DMAMR, ETH_DMAMR_MASK, dmaconf->DMAArbitration);
90002070:	6803      	ldr	r3, [r0, #0]
90002072:	6808      	ldr	r0, [r1, #0]
90002074:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002078:	681a      	ldr	r2, [r3, #0]
9000207a:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
9000207e:	f022 0202 	bic.w	r2, r2, #2
90002082:	4302      	orrs	r2, r0
{
90002084:	b510      	push	{r4, lr}
  MODIFY_REG(heth->Instance->DMAMR, ETH_DMAMR_MASK, dmaconf->DMAArbitration);
90002086:	601a      	str	r2, [r3, #0]

  /*------------------------ DMASBMR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
               dmaconf->BurstMode |
               ((uint32_t)dmaconf->RebuildINCRxBurst << 15));
90002088:	7b0a      	ldrb	r2, [r1, #12]

  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
9000208a:	6858      	ldr	r0, [r3, #4]
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
9000208c:	790c      	ldrb	r4, [r1, #4]
               ((uint32_t)dmaconf->RebuildINCRxBurst << 15));
9000208e:	03d2      	lsls	r2, r2, #15
  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
90002090:	f420 4050 	bic.w	r0, r0, #53248	; 0xd000
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
90002094:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
90002098:	688c      	ldr	r4, [r1, #8]
  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
9000209a:	f020 0001 	bic.w	r0, r0, #1
  dmaregval = (((uint32_t)dmaconf->AddressAlignedBeats << 12) |
9000209e:	4322      	orrs	r2, r4
  MODIFY_REG(heth->Instance->DMASBMR, ETH_DMASBMR_MASK, dmaregval);
900020a0:	4302      	orrs	r2, r0
900020a2:	605a      	str	r2, [r3, #4]

  /*------------------------ DMACCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
900020a4:	6a0a      	ldr	r2, [r1, #32]
900020a6:	7b48      	ldrb	r0, [r1, #13]
               dmaconf->MaximumSegmentSize);

  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_MASK, dmaregval);
900020a8:	f8d3 4100 	ldr.w	r4, [r3, #256]	; 0x100
  dmaregval = (((uint32_t)dmaconf->PBLx8Mode << 16) |
900020ac:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_MASK, dmaregval);
900020b0:	4810      	ldr	r0, [pc, #64]	; (900020f4 <ETH_SetDMAConfig+0x84>)
900020b2:	4020      	ands	r0, r4
900020b4:	4302      	orrs	r2, r0
900020b6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

  /*------------------------ DMACTCR Configuration --------------------*/
  dmaregval = (dmaconf->TxDMABurstLength |
               ((uint32_t)dmaconf->SecondPacketOperate << 4) |
               ((uint32_t)dmaconf->TCPSegmentation << 12));
900020ba:	7f4a      	ldrb	r2, [r1, #29]
               ((uint32_t)dmaconf->SecondPacketOperate << 4) |
900020bc:	7d08      	ldrb	r0, [r1, #20]
               ((uint32_t)dmaconf->TCPSegmentation << 12));
900020be:	0312      	lsls	r2, r2, #12

  MODIFY_REG(heth->Instance->DMACTCR, ETH_DMACTCR_MASK, dmaregval);
900020c0:	f8d3 4104 	ldr.w	r4, [r3, #260]	; 0x104
  dmaregval = (dmaconf->TxDMABurstLength |
900020c4:	ea42 1200 	orr.w	r2, r2, r0, lsl #4
900020c8:	6908      	ldr	r0, [r1, #16]
900020ca:	4302      	orrs	r2, r0
  MODIFY_REG(heth->Instance->DMACTCR, ETH_DMACTCR_MASK, dmaregval);
900020cc:	480a      	ldr	r0, [pc, #40]	; (900020f8 <ETH_SetDMAConfig+0x88>)
900020ce:	4020      	ands	r0, r4
900020d0:	4302      	orrs	r2, r0
900020d2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  /*------------------------ DMACRCR Configuration --------------------*/
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
               dmaconf->RxDMABurstLength);

  /* Write to DMACRCR */
  MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_MASK, dmaregval);
900020d6:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
900020da:	7f0c      	ldrb	r4, [r1, #28]
900020dc:	698a      	ldr	r2, [r1, #24]
  MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_MASK, dmaregval);
900020de:	f020 4100 	bic.w	r1, r0, #2147483648	; 0x80000000
  dmaregval = (((uint32_t)dmaconf->FlushRxPacket  << 31) |
900020e2:	ea42 72c4 	orr.w	r2, r2, r4, lsl #31
  MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_MASK, dmaregval);
900020e6:	f421 117c 	bic.w	r1, r1, #4128768	; 0x3f0000
900020ea:	430a      	orrs	r2, r1
900020ec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
}
900020f0:	bd10      	pop	{r4, pc}
900020f2:	bf00      	nop
900020f4:	fffec000 	.word	0xfffec000
900020f8:	ffc0efef 	.word	0xffc0efef

900020fc <ETH_Prepare_Tx_Descriptors>:
  * @param  pTxConfig: Tx packet configuration
  * @param  ItMode: Enable or disable Tx EOT interrept
  * @retval Status
  */
static uint32_t ETH_Prepare_Tx_Descriptors(ETH_HandleTypeDef *heth, ETH_TxPacketConfig *pTxConfig, uint32_t ItMode)
{
900020fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90002100:	9201      	str	r2, [sp, #4]
  ETH_TxDescListTypeDef *dmatxdesclist = &heth->TxDescList;
  uint32_t descidx = dmatxdesclist->CurTxDesc;
90002102:	6a82      	ldr	r2, [r0, #40]	; 0x28
  uint32_t firstdescidx = dmatxdesclist->CurTxDesc;
  uint32_t idx;
  uint32_t descnbr = 0;
  ETH_DMADescTypeDef *dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
90002104:	eb00 0582 	add.w	r5, r0, r2, lsl #2
90002108:	69ab      	ldr	r3, [r5, #24]

  ETH_BufferTypeDef  *txbuffer = pTxConfig->TxBuffer;
  uint32_t           bd_count = 0;

  /* Current Tx Descriptor Owned by DMA: cannot be used by the application  */
  if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
9000210a:	68dc      	ldr	r4, [r3, #12]
9000210c:	2c00      	cmp	r4, #0
9000210e:	da03      	bge.n	90002118 <ETH_Prepare_Tx_Descriptors+0x1c>
      /* Ensure rest of descriptor is written to RAM before the OWN bit */
      __DMB();
      /* Clear own bit */
      CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);

      return HAL_ETH_ERROR_BUSY;
90002110:	2002      	movs	r0, #2
  __enable_irq();


  /* Return function status */
  return HAL_ETH_ERROR_NONE;
}
90002112:	b003      	add	sp, #12
90002114:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      || (dmatxdesclist->PacketAddress[descidx] != NULL))
90002118:	6aec      	ldr	r4, [r5, #44]	; 0x2c
9000211a:	2c00      	cmp	r4, #0
9000211c:	d1f8      	bne.n	90002110 <ETH_Prepare_Tx_Descriptors+0x14>
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
9000211e:	680f      	ldr	r7, [r1, #0]
  ETH_BufferTypeDef  *txbuffer = pTxConfig->TxBuffer;
90002120:	688e      	ldr	r6, [r1, #8]
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
90002122:	077c      	lsls	r4, r7, #29
90002124:	d534      	bpl.n	90002190 <ETH_Prepare_Tx_Descriptors+0x94>
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_VT, pTxConfig->VlanTag);
90002126:	68dc      	ldr	r4, [r3, #12]
90002128:	ea4f 4c14 	mov.w	ip, r4, lsr #16
9000212c:	6a4c      	ldr	r4, [r1, #36]	; 0x24
9000212e:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
90002132:	ea4c 0404 	orr.w	r4, ip, r4
    SET_BIT(heth->Instance->MACVIR, ETH_MACVIR_VLTI);
90002136:	f8d0 c000 	ldr.w	ip, [r0]
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_VT, pTxConfig->VlanTag);
9000213a:	60dc      	str	r4, [r3, #12]
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_VLTV);
9000213c:	68dc      	ldr	r4, [r3, #12]
9000213e:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
90002142:	60dc      	str	r4, [r3, #12]
    SET_BIT(heth->Instance->MACVIR, ETH_MACVIR_VLTI);
90002144:	f8dc 4060 	ldr.w	r4, [ip, #96]	; 0x60
90002148:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
9000214c:	f8cc 4060 	str.w	r4, [ip, #96]	; 0x60
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_INNERVLANTAG) != (uint32_t)RESET)
90002150:	073c      	lsls	r4, r7, #28
90002152:	d51d      	bpl.n	90002190 <ETH_Prepare_Tx_Descriptors+0x94>
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_IVT, (pTxConfig->InnerVlanTag << 16));
90002154:	689c      	ldr	r4, [r3, #8]
90002156:	fa1f fe84 	uxth.w	lr, r4
9000215a:	6acc      	ldr	r4, [r1, #44]	; 0x2c
9000215c:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
90002160:	609c      	str	r4, [r3, #8]
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_IVLTV);
90002162:	68dc      	ldr	r4, [r3, #12]
90002164:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
90002168:	60dc      	str	r4, [r3, #12]
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXCDESC_IVTIR, pTxConfig->InnerVlanCtrl);
9000216a:	68dc      	ldr	r4, [r3, #12]
9000216c:	f424 2e40 	bic.w	lr, r4, #786432	; 0xc0000
90002170:	6b0c      	ldr	r4, [r1, #48]	; 0x30
90002172:	ea4e 0404 	orr.w	r4, lr, r4
90002176:	60dc      	str	r4, [r3, #12]
      SET_BIT(heth->Instance->MACIVIR, ETH_MACIVIR_VLTI);
90002178:	f8dc 4064 	ldr.w	r4, [ip, #100]	; 0x64
9000217c:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
90002180:	f8cc 4064 	str.w	r4, [ip, #100]	; 0x64
      SET_BIT(heth->Instance->MACVTR, ETH_MACVTR_EDVLP);
90002184:	f8dc 4050 	ldr.w	r4, [ip, #80]	; 0x50
90002188:	f044 6480 	orr.w	r4, r4, #67108864	; 0x4000000
9000218c:	f8cc 4050 	str.w	r4, [ip, #80]	; 0x50
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
90002190:	06fc      	lsls	r4, r7, #27
90002192:	d50c      	bpl.n	900021ae <ETH_Prepare_Tx_Descriptors+0xb2>
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXCDESC_MSS, pTxConfig->MaxSegmentSize);
90002194:	689c      	ldr	r4, [r3, #8]
90002196:	f424 5c7f 	bic.w	ip, r4, #16320	; 0x3fc0
9000219a:	698c      	ldr	r4, [r1, #24]
9000219c:	f02c 0c3f 	bic.w	ip, ip, #63	; 0x3f
900021a0:	ea4c 0404 	orr.w	r4, ip, r4
900021a4:	609c      	str	r4, [r3, #8]
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_TCMSSV);
900021a6:	68dc      	ldr	r4, [r3, #12]
900021a8:	f044 6480 	orr.w	r4, r4, #67108864	; 0x4000000
900021ac:	60dc      	str	r4, [r3, #12]
  if ((READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
900021ae:	f017 0414 	ands.w	r4, r7, #20
900021b2:	d01c      	beq.n	900021ee <ETH_Prepare_Tx_Descriptors+0xf2>
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_CTXT);
900021b4:	68dc      	ldr	r4, [r3, #12]
900021b6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
900021ba:	60dc      	str	r4, [r3, #12]
  __ASM volatile ("dmb 0xF":::"memory");
900021bc:	f3bf 8f5f 	dmb	sy
    INCR_TX_DESC_INDEX(descidx, 1U);
900021c0:	1c57      	adds	r7, r2, #1
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
900021c2:	68dc      	ldr	r4, [r3, #12]
    INCR_TX_DESC_INDEX(descidx, 1U);
900021c4:	2f03      	cmp	r7, #3
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
900021c6:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
    INCR_TX_DESC_INDEX(descidx, 1U);
900021ca:	bf88      	it	hi
900021cc:	1ed7      	subhi	r7, r2, #3
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
900021ce:	60dc      	str	r4, [r3, #12]
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
900021d0:	eb00 0387 	add.w	r3, r0, r7, lsl #2
900021d4:	699b      	ldr	r3, [r3, #24]
    if (READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCWBF_OWN) == ETH_DMATXNDESCWBF_OWN)
900021d6:	68dc      	ldr	r4, [r3, #12]
900021d8:	2c00      	cmp	r4, #0
900021da:	f280 8084 	bge.w	900022e6 <ETH_Prepare_Tx_Descriptors+0x1ea>
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[firstdescidx];
900021de:	69aa      	ldr	r2, [r5, #24]
900021e0:	f3bf 8f5f 	dmb	sy
      CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXCDESC_OWN);
900021e4:	68d3      	ldr	r3, [r2, #12]
900021e6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
900021ea:	60d3      	str	r3, [r2, #12]
900021ec:	e790      	b.n	90002110 <ETH_Prepare_Tx_Descriptors+0x14>
  uint32_t descidx = dmatxdesclist->CurTxDesc;
900021ee:	4617      	mov	r7, r2
  descnbr += 1U;
900021f0:	f104 0e01 	add.w	lr, r4, #1
  WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
900021f4:	6834      	ldr	r4, [r6, #0]
  if (txbuffer->next != NULL)
900021f6:	f8d6 8008 	ldr.w	r8, [r6, #8]
  WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
900021fa:	601c      	str	r4, [r3, #0]
  MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
900021fc:	689c      	ldr	r4, [r3, #8]
900021fe:	f424 5c7f 	bic.w	ip, r4, #16320	; 0x3fc0
90002202:	6874      	ldr	r4, [r6, #4]
90002204:	f02c 0c3f 	bic.w	ip, ip, #63	; 0x3f
90002208:	ea4c 0404 	orr.w	r4, ip, r4
9000220c:	f8df c228 	ldr.w	ip, [pc, #552]	; 90002438 <ETH_Prepare_Tx_Descriptors+0x33c>
90002210:	609c      	str	r4, [r3, #8]
  if (txbuffer->next != NULL)
90002212:	f1b8 0f00 	cmp.w	r8, #0
90002216:	d068      	beq.n	900022ea <ETH_Prepare_Tx_Descriptors+0x1ee>
    WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
90002218:	f8d8 4000 	ldr.w	r4, [r8]
9000221c:	605c      	str	r4, [r3, #4]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
9000221e:	689e      	ldr	r6, [r3, #8]
90002220:	f8d8 4004 	ldr.w	r4, [r8, #4]
90002224:	ea06 060c 	and.w	r6, r6, ip
90002228:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
9000222c:	609c      	str	r4, [r3, #8]
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
9000222e:	680e      	ldr	r6, [r1, #0]
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_THL, (pTxConfig->TCPHeaderLen << 19));
90002230:	68dc      	ldr	r4, [r3, #12]
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
90002232:	f016 0f10 	tst.w	r6, #16
90002236:	d060      	beq.n	900022fa <ETH_Prepare_Tx_Descriptors+0x1fe>
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_THL, (pTxConfig->TCPHeaderLen << 19));
90002238:	f424 0cf0 	bic.w	ip, r4, #7864320	; 0x780000
9000223c:	6a0c      	ldr	r4, [r1, #32]
9000223e:	ea4c 44c4 	orr.w	r4, ip, r4, lsl #19
90002242:	60dc      	str	r4, [r3, #12]
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
90002244:	68dc      	ldr	r4, [r3, #12]
90002246:	ea4f 4c94 	mov.w	ip, r4, lsr #18
9000224a:	69cc      	ldr	r4, [r1, #28]
9000224c:	ea4f 4c8c 	mov.w	ip, ip, lsl #18
90002250:	ea4c 0404 	orr.w	r4, ip, r4
90002254:	60dc      	str	r4, [r3, #12]
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
90002256:	68dc      	ldr	r4, [r3, #12]
90002258:	f444 2480 	orr.w	r4, r4, #262144	; 0x40000
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CPC, pTxConfig->CRCPadCtrl);
9000225c:	60dc      	str	r4, [r3, #12]
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_VLANTAG) != (uint32_t)RESET)
9000225e:	0776      	lsls	r6, r6, #29
90002260:	d505      	bpl.n	9000226e <ETH_Prepare_Tx_Descriptors+0x172>
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_VTIR, pTxConfig->VlanCtrl);
90002262:	689e      	ldr	r6, [r3, #8]
90002264:	6a8c      	ldr	r4, [r1, #40]	; 0x28
90002266:	f426 4640 	bic.w	r6, r6, #49152	; 0xc000
9000226a:	4334      	orrs	r4, r6
9000226c:	609c      	str	r4, [r3, #8]
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
9000226e:	68dc      	ldr	r4, [r3, #12]
90002270:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
90002274:	60dc      	str	r4, [r3, #12]
  CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
90002276:	68dc      	ldr	r4, [r3, #12]
90002278:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
9000227c:	60dc      	str	r4, [r3, #12]
9000227e:	f3bf 8f5f 	dmb	sy
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
90002282:	68dc      	ldr	r4, [r3, #12]
90002284:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
90002288:	60dc      	str	r4, [r3, #12]
  if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_SAIC) != (uint32_t)RESET)
9000228a:	680c      	ldr	r4, [r1, #0]
9000228c:	07a4      	lsls	r4, r4, #30
9000228e:	d505      	bpl.n	9000229c <ETH_Prepare_Tx_Descriptors+0x1a0>
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_SAIC, pTxConfig->SrcAddrCtrl);
90002290:	68de      	ldr	r6, [r3, #12]
90002292:	68cc      	ldr	r4, [r1, #12]
90002294:	f026 7660 	bic.w	r6, r6, #58720256	; 0x3800000
90002298:	4334      	orrs	r4, r6
9000229a:	60dc      	str	r4, [r3, #12]
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
9000229c:	2400      	movs	r4, #0
9000229e:	f8df c198 	ldr.w	ip, [pc, #408]	; 90002438 <ETH_Prepare_Tx_Descriptors+0x33c>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
900022a2:	f8df 9198 	ldr.w	r9, [pc, #408]	; 9000243c <ETH_Prepare_Tx_Descriptors+0x340>
  while (txbuffer->next != NULL)
900022a6:	f8d8 a008 	ldr.w	sl, [r8, #8]
900022aa:	eb04 0b0e 	add.w	fp, r4, lr
900022ae:	f1ba 0f00 	cmp.w	sl, #0
900022b2:	d13c      	bne.n	9000232e <ETH_Prepare_Tx_Descriptors+0x232>
  if (ItMode != ((uint32_t)RESET))
900022b4:	9a01      	ldr	r2, [sp, #4]
900022b6:	2a00      	cmp	r2, #0
900022b8:	f000 80b9 	beq.w	9000242e <ETH_Prepare_Tx_Descriptors+0x332>
    SET_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
900022bc:	689a      	ldr	r2, [r3, #8]
900022be:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    CLEAR_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
900022c2:	609a      	str	r2, [r3, #8]
  SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
900022c4:	68da      	ldr	r2, [r3, #12]
900022c6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
900022ca:	60da      	str	r2, [r3, #12]
  dmatxdesclist->PacketAddress[descidx] = dmatxdesclist->CurrentPacketAddress;
900022cc:	eb00 0387 	add.w	r3, r0, r7, lsl #2
900022d0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
900022d2:	62da      	str	r2, [r3, #44]	; 0x2c
  dmatxdesclist->CurTxDesc = descidx;
900022d4:	6287      	str	r7, [r0, #40]	; 0x28
  __ASM volatile ("cpsid i" : : : "memory");
900022d6:	b672      	cpsid	i
  dmatxdesclist->BuffersInUse += bd_count + 1U;
900022d8:	6c03      	ldr	r3, [r0, #64]	; 0x40
900022da:	3301      	adds	r3, #1
900022dc:	441c      	add	r4, r3
900022de:	6404      	str	r4, [r0, #64]	; 0x40
  __ASM volatile ("cpsie i" : : : "memory");
900022e0:	b662      	cpsie	i
  return HAL_ETH_ERROR_NONE;
900022e2:	2000      	movs	r0, #0
900022e4:	e715      	b.n	90002112 <ETH_Prepare_Tx_Descriptors+0x16>
    descnbr += 1U;
900022e6:	2401      	movs	r4, #1
900022e8:	e782      	b.n	900021f0 <ETH_Prepare_Tx_Descriptors+0xf4>
    WRITE_REG(dmatxdesc->DESC1, 0x0);
900022ea:	f8c3 8004 	str.w	r8, [r3, #4]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
900022ee:	46b0      	mov	r8, r6
900022f0:	689c      	ldr	r4, [r3, #8]
900022f2:	ea04 040c 	and.w	r4, r4, ip
900022f6:	609c      	str	r4, [r3, #8]
900022f8:	e799      	b.n	9000222e <ETH_Prepare_Tx_Descriptors+0x132>
    MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
900022fa:	f424 4cff 	bic.w	ip, r4, #32640	; 0x7f80
900022fe:	684c      	ldr	r4, [r1, #4]
90002300:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
90002304:	ea4c 0404 	orr.w	r4, ip, r4
90002308:	60dc      	str	r4, [r3, #12]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
9000230a:	07f4      	lsls	r4, r6, #31
9000230c:	d506      	bpl.n	9000231c <ETH_Prepare_Tx_Descriptors+0x220>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
9000230e:	68dc      	ldr	r4, [r3, #12]
90002310:	f424 3c40 	bic.w	ip, r4, #196608	; 0x30000
90002314:	694c      	ldr	r4, [r1, #20]
90002316:	ea4c 0404 	orr.w	r4, ip, r4
9000231a:	60dc      	str	r4, [r3, #12]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CRCPAD) != (uint32_t)RESET)
9000231c:	06b4      	lsls	r4, r6, #26
9000231e:	d59e      	bpl.n	9000225e <ETH_Prepare_Tx_Descriptors+0x162>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CPC, pTxConfig->CRCPadCtrl);
90002320:	68dc      	ldr	r4, [r3, #12]
90002322:	f024 6c40 	bic.w	ip, r4, #201326592	; 0xc000000
90002326:	690c      	ldr	r4, [r1, #16]
90002328:	ea4c 0404 	orr.w	r4, ip, r4
9000232c:	e796      	b.n	9000225c <ETH_Prepare_Tx_Descriptors+0x160>
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_LD);
9000232e:	68de      	ldr	r6, [r3, #12]
90002330:	f026 5680 	bic.w	r6, r6, #268435456	; 0x10000000
90002334:	60de      	str	r6, [r3, #12]
    INCR_TX_DESC_INDEX(descidx, 1U);
90002336:	1c7e      	adds	r6, r7, #1
90002338:	2e03      	cmp	r6, #3
9000233a:	bf88      	it	hi
9000233c:	1efe      	subhi	r6, r7, #3
    dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
9000233e:	eb00 0886 	add.w	r8, r0, r6, lsl #2
90002342:	f8d8 3018 	ldr.w	r3, [r8, #24]
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FD);
90002346:	68df      	ldr	r7, [r3, #12]
90002348:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
9000234c:	60df      	str	r7, [r3, #12]
    if ((READ_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN) == ETH_DMATXNDESCRF_OWN)
9000234e:	68df      	ldr	r7, [r3, #12]
90002350:	2f00      	cmp	r7, #0
90002352:	da14      	bge.n	9000237e <ETH_Prepare_Tx_Descriptors+0x282>
      dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
90002354:	69ac      	ldr	r4, [r5, #24]
      for (idx = 0; idx < descnbr; idx ++)
90002356:	2100      	movs	r1, #0
90002358:	458b      	cmp	fp, r1
9000235a:	f43f aed9 	beq.w	90002110 <ETH_Prepare_Tx_Descriptors+0x14>
  __ASM volatile ("dmb 0xF":::"memory");
9000235e:	f3bf 8f5f 	dmb	sy
        CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
90002362:	68e3      	ldr	r3, [r4, #12]
      for (idx = 0; idx < descnbr; idx ++)
90002364:	3101      	adds	r1, #1
        CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
90002366:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
9000236a:	60e3      	str	r3, [r4, #12]
        INCR_TX_DESC_INDEX(descidx, 1U);
9000236c:	1c53      	adds	r3, r2, #1
9000236e:	2b03      	cmp	r3, #3
90002370:	bf88      	it	hi
90002372:	1ed3      	subhi	r3, r2, #3
        dmatxdesc = (ETH_DMADescTypeDef *)dmatxdesclist->TxDesc[descidx];
90002374:	eb00 0283 	add.w	r2, r0, r3, lsl #2
90002378:	6994      	ldr	r4, [r2, #24]
      for (idx = 0; idx < descnbr; idx ++)
9000237a:	461a      	mov	r2, r3
9000237c:	e7ec      	b.n	90002358 <ETH_Prepare_Tx_Descriptors+0x25c>
        || (dmatxdesclist->PacketAddress[descidx] != NULL))
9000237e:	f8d8 702c 	ldr.w	r7, [r8, #44]	; 0x2c
90002382:	2f00      	cmp	r7, #0
90002384:	d1e6      	bne.n	90002354 <ETH_Prepare_Tx_Descriptors+0x258>
    WRITE_REG(dmatxdesc->DESC0, (uint32_t)txbuffer->buffer);
90002386:	f8da 7000 	ldr.w	r7, [sl]
9000238a:	601f      	str	r7, [r3, #0]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
9000238c:	689f      	ldr	r7, [r3, #8]
9000238e:	f427 587f 	bic.w	r8, r7, #16320	; 0x3fc0
90002392:	f8da 7004 	ldr.w	r7, [sl, #4]
90002396:	f028 083f 	bic.w	r8, r8, #63	; 0x3f
9000239a:	ea48 0707 	orr.w	r7, r8, r7
    if (txbuffer->next != NULL)
9000239e:	f8da 8008 	ldr.w	r8, [sl, #8]
    MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B1L, txbuffer->len);
900023a2:	609f      	str	r7, [r3, #8]
    if (txbuffer->next != NULL)
900023a4:	f1b8 0f00 	cmp.w	r8, #0
900023a8:	d029      	beq.n	900023fe <ETH_Prepare_Tx_Descriptors+0x302>
      WRITE_REG(dmatxdesc->DESC1, (uint32_t)txbuffer->buffer);
900023aa:	f8d8 7000 	ldr.w	r7, [r8]
900023ae:	605f      	str	r7, [r3, #4]
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, (txbuffer->len << 16));
900023b0:	689f      	ldr	r7, [r3, #8]
900023b2:	ea07 0a0c 	and.w	sl, r7, ip
900023b6:	f8d8 7004 	ldr.w	r7, [r8, #4]
900023ba:	ea4a 4707 	orr.w	r7, sl, r7, lsl #16
900023be:	609f      	str	r7, [r3, #8]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
900023c0:	f8d1 b000 	ldr.w	fp, [r1]
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
900023c4:	68df      	ldr	r7, [r3, #12]
    if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_TSO) != (uint32_t)RESET)
900023c6:	f01b 0f10 	tst.w	fp, #16
900023ca:	d020      	beq.n	9000240e <ETH_Prepare_Tx_Descriptors+0x312>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TPL, pTxConfig->PayloadLen);
900023cc:	ea4f 4a97 	mov.w	sl, r7, lsr #18
900023d0:	69cf      	ldr	r7, [r1, #28]
900023d2:	ea4f 4a8a 	mov.w	sl, sl, lsl #18
900023d6:	ea4a 0707 	orr.w	r7, sl, r7
900023da:	60df      	str	r7, [r3, #12]
      SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_TSE);
900023dc:	68df      	ldr	r7, [r3, #12]
900023de:	f447 2780 	orr.w	r7, r7, #262144	; 0x40000
        MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
900023e2:	60df      	str	r7, [r3, #12]
    bd_count += 1U;
900023e4:	3401      	adds	r4, #1
900023e6:	f3bf 8f5f 	dmb	sy
    SET_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_OWN);
900023ea:	68df      	ldr	r7, [r3, #12]
900023ec:	f047 4700 	orr.w	r7, r7, #2147483648	; 0x80000000
900023f0:	60df      	str	r7, [r3, #12]
    CLEAR_BIT(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CTXT);
900023f2:	68df      	ldr	r7, [r3, #12]
900023f4:	f027 4780 	bic.w	r7, r7, #1073741824	; 0x40000000
900023f8:	60df      	str	r7, [r3, #12]
900023fa:	4637      	mov	r7, r6
900023fc:	e753      	b.n	900022a6 <ETH_Prepare_Tx_Descriptors+0x1aa>
      WRITE_REG(dmatxdesc->DESC1, 0x0);
900023fe:	f8c3 8004 	str.w	r8, [r3, #4]
      MODIFY_REG(dmatxdesc->DESC2, ETH_DMATXNDESCRF_B2L, 0x0U);
90002402:	46d0      	mov	r8, sl
90002404:	689f      	ldr	r7, [r3, #8]
90002406:	ea07 070c 	and.w	r7, r7, ip
9000240a:	609f      	str	r7, [r3, #8]
9000240c:	e7d8      	b.n	900023c0 <ETH_Prepare_Tx_Descriptors+0x2c4>
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
9000240e:	ea07 0a09 	and.w	sl, r7, r9
90002412:	684f      	ldr	r7, [r1, #4]
      if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
90002414:	f01b 0f01 	tst.w	fp, #1
      MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_FL, pTxConfig->Length);
90002418:	ea4a 0707 	orr.w	r7, sl, r7
9000241c:	60df      	str	r7, [r3, #12]
      if (READ_BIT(pTxConfig->Attributes, ETH_TX_PACKETS_FEATURES_CSUM) != (uint32_t)RESET)
9000241e:	d0e1      	beq.n	900023e4 <ETH_Prepare_Tx_Descriptors+0x2e8>
        MODIFY_REG(dmatxdesc->DESC3, ETH_DMATXNDESCRF_CIC, pTxConfig->ChecksumCtrl);
90002420:	68df      	ldr	r7, [r3, #12]
90002422:	f427 3a40 	bic.w	sl, r7, #196608	; 0x30000
90002426:	694f      	ldr	r7, [r1, #20]
90002428:	ea4a 0707 	orr.w	r7, sl, r7
9000242c:	e7d9      	b.n	900023e2 <ETH_Prepare_Tx_Descriptors+0x2e6>
    CLEAR_BIT(dmatxdesc->DESC2, ETH_DMATXNDESCRF_IOC);
9000242e:	689a      	ldr	r2, [r3, #8]
90002430:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
90002434:	e745      	b.n	900022c2 <ETH_Prepare_Tx_Descriptors+0x1c6>
90002436:	bf00      	nop
90002438:	c000ffff 	.word	0xc000ffff
9000243c:	ffff8000 	.word	0xffff8000

90002440 <ETH_UpdateDescriptor>:
{
90002440:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  uint8_t *buff = NULL;
90002444:	2300      	movs	r3, #0
  descidx = heth->RxDescList.RxBuildDescIdx;
90002446:	6e87      	ldr	r7, [r0, #104]	; 0x68
{
90002448:	4604      	mov	r4, r0
  desccount = heth->RxDescList.RxBuildDescCnt;
9000244a:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  uint8_t *buff = NULL;
9000244c:	9301      	str	r3, [sp, #4]
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
9000244e:	f107 0312 	add.w	r3, r7, #18
  uint8_t allocStatus = 1U;
90002452:	f04f 0801 	mov.w	r8, #1
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V);
90002456:	f04f 4901 	mov.w	r9, #2164260864	; 0x81000000
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
9000245a:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V | ETH_DMARXNDESCRF_IOC);
9000245e:	f04f 4a41 	mov.w	sl, #3238002688	; 0xc1000000
  while ((desccount > 0U) && (allocStatus != 0U))
90002462:	b116      	cbz	r6, 9000246a <ETH_UpdateDescriptor+0x2a>
90002464:	f1b8 0f00 	cmp.w	r8, #0
90002468:	d10d      	bne.n	90002486 <ETH_UpdateDescriptor+0x46>
  if (heth->RxDescList.RxBuildDescCnt != desccount)
9000246a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000246c:	42b3      	cmp	r3, r6
9000246e:	d007      	beq.n	90002480 <ETH_UpdateDescriptor+0x40>
    WRITE_REG(heth->Instance->DMACRDTPR, 0);
90002470:	6823      	ldr	r3, [r4, #0]
90002472:	2200      	movs	r2, #0
90002474:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002478:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    heth->RxDescList.RxBuildDescCnt = desccount;
9000247c:	e9c4 761a 	strd	r7, r6, [r4, #104]	; 0x68
}
90002480:	b002      	add	sp, #8
90002482:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (READ_REG(dmarxdesc->BackupAddr0) == 0U)
90002486:	692b      	ldr	r3, [r5, #16]
90002488:	b933      	cbnz	r3, 90002498 <ETH_UpdateDescriptor+0x58>
      HAL_ETH_RxAllocateCallback(&buff);
9000248a:	a801      	add	r0, sp, #4
9000248c:	f7fe ffea 	bl	90001464 <HAL_ETH_RxAllocateCallback>
      if (buff == NULL)
90002490:	9b01      	ldr	r3, [sp, #4]
90002492:	b1ab      	cbz	r3, 900024c0 <ETH_UpdateDescriptor+0x80>
        WRITE_REG(dmarxdesc->BackupAddr0, (uint32_t)buff);
90002494:	612b      	str	r3, [r5, #16]
        WRITE_REG(dmarxdesc->DESC0, (uint32_t)buff);
90002496:	602b      	str	r3, [r5, #0]
90002498:	f3bf 8f5f 	dmb	sy
      if (heth->RxDescList.ItMode != 0U)
9000249c:	6da3      	ldr	r3, [r4, #88]	; 0x58
9000249e:	b163      	cbz	r3, 900024ba <ETH_UpdateDescriptor+0x7a>
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V | ETH_DMARXNDESCRF_IOC);
900024a0:	f8c5 a00c 	str.w	sl, [r5, #12]
      INCR_RX_DESC_INDEX(descidx, 1U);
900024a4:	1c7b      	adds	r3, r7, #1
      desccount--;
900024a6:	3e01      	subs	r6, #1
      INCR_RX_DESC_INDEX(descidx, 1U);
900024a8:	2b03      	cmp	r3, #3
900024aa:	bf88      	it	hi
900024ac:	1efb      	subhi	r3, r7, #3
      dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
900024ae:	f103 0212 	add.w	r2, r3, #18
      desccount--;
900024b2:	461f      	mov	r7, r3
      dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
900024b4:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
      desccount--;
900024b8:	e7d3      	b.n	90002462 <ETH_UpdateDescriptor+0x22>
        WRITE_REG(dmarxdesc->DESC3, ETH_DMARXNDESCRF_OWN | ETH_DMARXNDESCRF_BUF1V);
900024ba:	f8c5 900c 	str.w	r9, [r5, #12]
900024be:	e7f1      	b.n	900024a4 <ETH_UpdateDescriptor+0x64>
        allocStatus = 0U;
900024c0:	4698      	mov	r8, r3
900024c2:	e7ce      	b.n	90002462 <ETH_UpdateDescriptor+0x22>

900024c4 <HAL_ETH_Start>:
{
900024c4:	b538      	push	{r3, r4, r5, lr}
  if (heth->gState == HAL_ETH_STATE_READY)
900024c6:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
900024ca:	4604      	mov	r4, r0
  if (heth->gState == HAL_ETH_STATE_READY)
900024cc:	2b10      	cmp	r3, #16
900024ce:	d12d      	bne.n	9000252c <HAL_ETH_Start+0x68>
    heth->RxDescList.RxBuildDescCnt = ETH_RX_DESC_CNT;
900024d0:	2304      	movs	r3, #4
    heth->gState = HAL_ETH_STATE_BUSY;
900024d2:	2523      	movs	r5, #35	; 0x23
    heth->RxDescList.RxBuildDescCnt = ETH_RX_DESC_CNT;
900024d4:	66c3      	str	r3, [r0, #108]	; 0x6c
    heth->gState = HAL_ETH_STATE_BUSY;
900024d6:	f8c0 5084 	str.w	r5, [r0, #132]	; 0x84
    ETH_UpdateDescriptor(heth);
900024da:	f7ff ffb1 	bl	90002440 <ETH_UpdateDescriptor>
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
900024de:	6823      	ldr	r3, [r4, #0]
    return HAL_OK;
900024e0:	2000      	movs	r0, #0
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
900024e2:	681a      	ldr	r2, [r3, #0]
900024e4:	f042 0202 	orr.w	r2, r2, #2
900024e8:	601a      	str	r2, [r3, #0]
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
900024ea:	681a      	ldr	r2, [r3, #0]
900024ec:	f042 0201 	orr.w	r2, r2, #1
900024f0:	601a      	str	r2, [r3, #0]
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
900024f2:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
900024f6:	f042 0201 	orr.w	r2, r2, #1
900024fa:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00
    SET_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
900024fe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002502:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
90002506:	f042 0201 	orr.w	r2, r2, #1
9000250a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    SET_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
9000250e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
90002512:	f042 0201 	orr.w	r2, r2, #1
90002516:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    heth->Instance->DMACSR |= (ETH_DMACSR_TPS | ETH_DMACSR_RPS);
9000251a:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
9000251e:	f442 7281 	orr.w	r2, r2, #258	; 0x102
90002522:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    heth->gState = HAL_ETH_STATE_STARTED;
90002526:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
}
9000252a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
9000252c:	2001      	movs	r0, #1
9000252e:	e7fc      	b.n	9000252a <HAL_ETH_Start+0x66>

90002530 <HAL_ETH_Start_IT>:
{
90002530:	b538      	push	{r3, r4, r5, lr}
  if (heth->gState == HAL_ETH_STATE_READY)
90002532:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
90002536:	4604      	mov	r4, r0
  if (heth->gState == HAL_ETH_STATE_READY)
90002538:	2b10      	cmp	r3, #16
9000253a:	f04f 0301 	mov.w	r3, #1
9000253e:	d145      	bne.n	900025cc <HAL_ETH_Start_IT+0x9c>
    SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RXLPITRCIM | ETH_MMCRIMR_RXLPIUSCIM | \
90002540:	6802      	ldr	r2, [r0, #0]
    heth->gState = HAL_ETH_STATE_BUSY;
90002542:	2523      	movs	r5, #35	; 0x23
    heth->RxDescList.ItMode = 1U;
90002544:	6583      	str	r3, [r0, #88]	; 0x58
    heth->gState = HAL_ETH_STATE_BUSY;
90002546:	f8c0 5084 	str.w	r5, [r0, #132]	; 0x84
    SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RXLPITRCIM | ETH_MMCRIMR_RXLPIUSCIM | \
9000254a:	4b21      	ldr	r3, [pc, #132]	; (900025d0 <HAL_ETH_Start_IT+0xa0>)
9000254c:	f8d2 170c 	ldr.w	r1, [r2, #1804]	; 0x70c
90002550:	430b      	orrs	r3, r1
90002552:	f8c2 370c 	str.w	r3, [r2, #1804]	; 0x70c
    SET_BIT(heth->Instance->MMCTIMR, ETH_MMCTIMR_TXLPITRCIM | ETH_MMCTIMR_TXLPIUSCIM | \
90002556:	f8d2 3710 	ldr.w	r3, [r2, #1808]	; 0x710
9000255a:	f043 6342 	orr.w	r3, r3, #203423744	; 0xc200000
9000255e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
90002562:	f8c2 3710 	str.w	r3, [r2, #1808]	; 0x710
    heth->RxDescList.RxBuildDescCnt = ETH_RX_DESC_CNT;
90002566:	2304      	movs	r3, #4
90002568:	66c3      	str	r3, [r0, #108]	; 0x6c
    ETH_UpdateDescriptor(heth);
9000256a:	f7ff ff69 	bl	90002440 <ETH_UpdateDescriptor>
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
9000256e:	6823      	ldr	r3, [r4, #0]
    return HAL_OK;
90002570:	2000      	movs	r0, #0
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
90002572:	681a      	ldr	r2, [r3, #0]
90002574:	f042 0202 	orr.w	r2, r2, #2
90002578:	601a      	str	r2, [r3, #0]
    SET_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
9000257a:	681a      	ldr	r2, [r3, #0]
9000257c:	f042 0201 	orr.w	r2, r2, #1
90002580:	601a      	str	r2, [r3, #0]
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
90002582:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
90002586:	f042 0201 	orr.w	r2, r2, #1
9000258a:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00
    SET_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
9000258e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002592:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
90002596:	f042 0201 	orr.w	r2, r2, #1
9000259a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    SET_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
9000259e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
900025a2:	f042 0201 	orr.w	r2, r2, #1
900025a6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    heth->Instance->DMACSR |= (ETH_DMACSR_TPS | ETH_DMACSR_RPS);
900025aa:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
900025ae:	f442 7281 	orr.w	r2, r2, #258	; 0x102
900025b2:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    __HAL_ETH_DMA_ENABLE_IT(heth, (ETH_DMACIER_NIE | ETH_DMACIER_RIE | ETH_DMACIER_TIE  |
900025b6:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
900025ba:	f442 4250 	orr.w	r2, r2, #53248	; 0xd000
900025be:	f042 02c1 	orr.w	r2, r2, #193	; 0xc1
900025c2:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
    heth->gState = HAL_ETH_STATE_STARTED;
900025c6:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
}
900025ca:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
900025cc:	4618      	mov	r0, r3
900025ce:	e7fc      	b.n	900025ca <HAL_ETH_Start_IT+0x9a>
900025d0:	0c020060 	.word	0x0c020060

900025d4 <HAL_ETH_Stop_IT>:
  if (heth->gState == HAL_ETH_STATE_STARTED)
900025d4:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
900025d8:	2b23      	cmp	r3, #35	; 0x23
{
900025da:	b510      	push	{r4, lr}
  if (heth->gState == HAL_ETH_STATE_STARTED)
900025dc:	d139      	bne.n	90002652 <HAL_ETH_Stop_IT+0x7e>
    __HAL_ETH_DMA_DISABLE_IT(heth, (ETH_DMACIER_NIE | ETH_DMACIER_RIE | ETH_DMACIER_TIE  |
900025de:	4601      	mov	r1, r0
    heth->gState = HAL_ETH_STATE_BUSY;
900025e0:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    __HAL_ETH_DMA_DISABLE_IT(heth, (ETH_DMACIER_NIE | ETH_DMACIER_RIE | ETH_DMACIER_TIE  |
900025e4:	f851 3b48 	ldr.w	r3, [r1], #72
900025e8:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
900025ec:	f8d2 4134 	ldr.w	r4, [r2, #308]	; 0x134
900025f0:	f424 4450 	bic.w	r4, r4, #53248	; 0xd000
900025f4:	f024 04c1 	bic.w	r4, r4, #193	; 0xc1
900025f8:	f8c2 4134 	str.w	r4, [r2, #308]	; 0x134
    CLEAR_BIT(heth->Instance->DMACTCR, ETH_DMACTCR_ST);
900025fc:	f8d2 4104 	ldr.w	r4, [r2, #260]	; 0x104
90002600:	f024 0401 	bic.w	r4, r4, #1
90002604:	f8c2 4104 	str.w	r4, [r2, #260]	; 0x104
    CLEAR_BIT(heth->Instance->DMACRCR, ETH_DMACRCR_SR);
90002608:	f8d2 4108 	ldr.w	r4, [r2, #264]	; 0x108
9000260c:	f024 0401 	bic.w	r4, r4, #1
90002610:	f8c2 4108 	str.w	r4, [r2, #264]	; 0x108
    CLEAR_BIT(heth->Instance->MACCR, ETH_MACCR_RE);
90002614:	f100 0458 	add.w	r4, r0, #88	; 0x58
90002618:	681a      	ldr	r2, [r3, #0]
9000261a:	f022 0201 	bic.w	r2, r2, #1
9000261e:	601a      	str	r2, [r3, #0]
    SET_BIT(heth->Instance->MTLTQOMR, ETH_MTLTQOMR_FTQ);
90002620:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
90002624:	f042 0201 	orr.w	r2, r2, #1
90002628:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00
    CLEAR_BIT(heth->Instance->MACCR, ETH_MACCR_TE);
9000262c:	681a      	ldr	r2, [r3, #0]
9000262e:	f022 0202 	bic.w	r2, r2, #2
90002632:	601a      	str	r2, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descindex];
90002634:	f851 2b04 	ldr.w	r2, [r1], #4
      CLEAR_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCRF_IOC);
90002638:	68d3      	ldr	r3, [r2, #12]
    for (descindex = 0; descindex < (uint32_t)ETH_RX_DESC_CNT; descindex++)
9000263a:	42a1      	cmp	r1, r4
      CLEAR_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCRF_IOC);
9000263c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
90002640:	60d3      	str	r3, [r2, #12]
    for (descindex = 0; descindex < (uint32_t)ETH_RX_DESC_CNT; descindex++)
90002642:	d1f7      	bne.n	90002634 <HAL_ETH_Stop_IT+0x60>
    heth->RxDescList.ItMode = 0U;
90002644:	2300      	movs	r3, #0
    heth->gState = HAL_ETH_STATE_READY;
90002646:	2210      	movs	r2, #16
    heth->RxDescList.ItMode = 0U;
90002648:	6583      	str	r3, [r0, #88]	; 0x58
    heth->gState = HAL_ETH_STATE_READY;
9000264a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    return HAL_OK;
9000264e:	4618      	mov	r0, r3
}
90002650:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
90002652:	2001      	movs	r0, #1
90002654:	e7fc      	b.n	90002650 <HAL_ETH_Stop_IT+0x7c>

90002656 <HAL_ETH_Transmit_IT>:
{
90002656:	b510      	push	{r4, lr}
90002658:	4604      	mov	r4, r0
  if (pTxConfig == NULL)
9000265a:	b939      	cbnz	r1, 9000266c <HAL_ETH_Transmit_IT+0x16>
    heth->ErrorCode |= HAL_ETH_ERROR_PARAM;
9000265c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
90002660:	f043 0301 	orr.w	r3, r3, #1
      heth->ErrorCode |= HAL_ETH_ERROR_BUSY;
90002664:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    return HAL_ERROR;
90002668:	2001      	movs	r0, #1
9000266a:	e021      	b.n	900026b0 <HAL_ETH_Transmit_IT+0x5a>
  if (heth->gState == HAL_ETH_STATE_STARTED)
9000266c:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
90002670:	2a23      	cmp	r2, #35	; 0x23
90002672:	d1f9      	bne.n	90002668 <HAL_ETH_Transmit_IT+0x12>
    heth->TxDescList.CurrentPacketAddress = (uint32_t *)pTxConfig->pData;
90002674:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    if (ETH_Prepare_Tx_Descriptors(heth, pTxConfig, 1) != HAL_ETH_ERROR_NONE)
90002676:	2201      	movs	r2, #1
    heth->TxDescList.CurrentPacketAddress = (uint32_t *)pTxConfig->pData;
90002678:	63c3      	str	r3, [r0, #60]	; 0x3c
    if (ETH_Prepare_Tx_Descriptors(heth, pTxConfig, 1) != HAL_ETH_ERROR_NONE)
9000267a:	f7ff fd3f 	bl	900020fc <ETH_Prepare_Tx_Descriptors>
9000267e:	b120      	cbz	r0, 9000268a <HAL_ETH_Transmit_IT+0x34>
      heth->ErrorCode |= HAL_ETH_ERROR_BUSY;
90002680:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
90002684:	f043 0302 	orr.w	r3, r3, #2
90002688:	e7ec      	b.n	90002664 <HAL_ETH_Transmit_IT+0xe>
  __ASM volatile ("dsb 0xF":::"memory");
9000268a:	f3bf 8f4f 	dsb	sy
    INCR_TX_DESC_INDEX(heth->TxDescList.CurTxDesc, 1U);
9000268e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    return HAL_OK;
90002690:	2000      	movs	r0, #0
    INCR_TX_DESC_INDEX(heth->TxDescList.CurTxDesc, 1U);
90002692:	1c5a      	adds	r2, r3, #1
90002694:	2a03      	cmp	r2, #3
90002696:	bf8a      	itet	hi
90002698:	3b03      	subhi	r3, #3
9000269a:	62a2      	strls	r2, [r4, #40]	; 0x28
9000269c:	62a3      	strhi	r3, [r4, #40]	; 0x28
    WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t)(heth->TxDescList.TxDesc[heth->TxDescList.CurTxDesc]));
9000269e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
900026a0:	6823      	ldr	r3, [r4, #0]
900026a2:	3206      	adds	r2, #6
900026a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
900026a8:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
900026ac:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
}
900026b0:	bd10      	pop	{r4, pc}

900026b2 <HAL_ETH_ReadData>:
{
900026b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900026b6:	4604      	mov	r4, r0
900026b8:	b085      	sub	sp, #20
  if (pAppBuff == NULL)
900026ba:	468a      	mov	sl, r1
900026bc:	b949      	cbnz	r1, 900026d2 <HAL_ETH_ReadData+0x20>
    heth->ErrorCode |= HAL_ETH_ERROR_PARAM;
900026be:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
900026c2:	f043 0301 	orr.w	r3, r3, #1
900026c6:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    return HAL_ERROR;
900026ca:	2001      	movs	r0, #1
}
900026cc:	b005      	add	sp, #20
900026ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (heth->gState != HAL_ETH_STATE_STARTED)
900026d2:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
900026d6:	2b23      	cmp	r3, #35	; 0x23
900026d8:	d1f7      	bne.n	900026ca <HAL_ETH_ReadData+0x18>
  descidx = heth->RxDescList.RxDescIdx;
900026da:	f8d0 905c 	ldr.w	r9, [r0, #92]	; 0x5c
  uint8_t rxdataready = 0U;
900026de:	f04f 0800 	mov.w	r8, #0
      HAL_ETH_RxLinkCallback(&heth->RxDescList.pRxStart, &heth->RxDescList.pRxEnd,
900026e2:	f100 0180 	add.w	r1, r0, #128	; 0x80
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
900026e6:	f109 0312 	add.w	r3, r9, #18
  uint32_t desccnt = 0U;
900026ea:	4646      	mov	r6, r8
      dmarxdesc->BackupAddr0 = 0;
900026ec:	46c3      	mov	fp, r8
  dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
900026ee:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
      HAL_ETH_RxLinkCallback(&heth->RxDescList.pRxStart, &heth->RxDescList.pRxEnd,
900026f2:	307c      	adds	r0, #124	; 0x7c
  desccntmax = ETH_RX_DESC_CNT - heth->RxDescList.RxBuildDescCnt;
900026f4:	f850 3c10 	ldr.w	r3, [r0, #-16]
900026f8:	f1c3 0304 	rsb	r3, r3, #4
900026fc:	9301      	str	r3, [sp, #4]
  while ((READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_OWN) == (uint32_t)RESET) && (desccnt < desccntmax)
900026fe:	68eb      	ldr	r3, [r5, #12]
90002700:	2b00      	cmp	r3, #0
90002702:	db05      	blt.n	90002710 <HAL_ETH_ReadData+0x5e>
90002704:	9b01      	ldr	r3, [sp, #4]
90002706:	429e      	cmp	r6, r3
90002708:	d002      	beq.n	90002710 <HAL_ETH_ReadData+0x5e>
         && (rxdataready == 0U))
9000270a:	f1b8 0f00 	cmp.w	r8, #0
9000270e:	d011      	beq.n	90002734 <HAL_ETH_ReadData+0x82>
  heth->RxDescList.RxBuildDescCnt += desccnt;
90002710:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
90002712:	441e      	add	r6, r3
90002714:	66e6      	str	r6, [r4, #108]	; 0x6c
  if ((heth->RxDescList.RxBuildDescCnt) != 0U)
90002716:	b116      	cbz	r6, 9000271e <HAL_ETH_ReadData+0x6c>
    ETH_UpdateDescriptor(heth);
90002718:	4620      	mov	r0, r4
9000271a:	f7ff fe91 	bl	90002440 <ETH_UpdateDescriptor>
  heth->RxDescList.RxDescIdx = descidx;
9000271e:	f8c4 905c 	str.w	r9, [r4, #92]	; 0x5c
  if (rxdataready == 1U)
90002722:	f1b8 0f00 	cmp.w	r8, #0
90002726:	d0d0      	beq.n	900026ca <HAL_ETH_ReadData+0x18>
    *pAppBuff = heth->RxDescList.pRxStart;
90002728:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    heth->RxDescList.pRxStart = NULL;
9000272a:	2000      	movs	r0, #0
    *pAppBuff = heth->RxDescList.pRxStart;
9000272c:	f8ca 3000 	str.w	r3, [sl]
    heth->RxDescList.pRxStart = NULL;
90002730:	67e0      	str	r0, [r4, #124]	; 0x7c
    return HAL_OK;
90002732:	e7cb      	b.n	900026cc <HAL_ETH_ReadData+0x1a>
    if (READ_BIT(dmarxdesc->DESC3,  ETH_DMARXNDESCWBF_CTXT)  != (uint32_t)RESET)
90002734:	68eb      	ldr	r3, [r5, #12]
90002736:	005b      	lsls	r3, r3, #1
90002738:	d503      	bpl.n	90002742 <HAL_ETH_ReadData+0x90>
      heth->RxDescList.TimeStamp.TimeStampHigh = dmarxdesc->DESC1;
9000273a:	686b      	ldr	r3, [r5, #4]
9000273c:	67a3      	str	r3, [r4, #120]	; 0x78
      heth->RxDescList.TimeStamp.TimeStampLow  = dmarxdesc->DESC0;
9000273e:	682b      	ldr	r3, [r5, #0]
90002740:	6763      	str	r3, [r4, #116]	; 0x74
    if ((READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_FD) != (uint32_t)RESET) || (heth->RxDescList.pRxStart != NULL))
90002742:	68eb      	ldr	r3, [r5, #12]
90002744:	009f      	lsls	r7, r3, #2
90002746:	d401      	bmi.n	9000274c <HAL_ETH_ReadData+0x9a>
90002748:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
9000274a:	b1c3      	cbz	r3, 9000277e <HAL_ETH_ReadData+0xcc>
      if (READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_FD) != (uint32_t)RESET)
9000274c:	68eb      	ldr	r3, [r5, #12]
9000274e:	009a      	lsls	r2, r3, #2
      if (READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_LD) != (uint32_t)RESET)
90002750:	68eb      	ldr	r3, [r5, #12]
        heth->RxDescList.RxDataLength = 0;
90002752:	bf48      	it	mi
90002754:	e9c4 bb18 	strdmi	fp, fp, [r4, #96]	; 0x60
      if (READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_LD) != (uint32_t)RESET)
90002758:	00db      	lsls	r3, r3, #3
9000275a:	d41d      	bmi.n	90002798 <HAL_ETH_ReadData+0xe6>
      bufflength = heth->Init.RxBuffLen;
9000275c:	6967      	ldr	r7, [r4, #20]
      HAL_ETH_RxLinkCallback(&heth->RxDescList.pRxStart, &heth->RxDescList.pRxEnd,
9000275e:	b2bb      	uxth	r3, r7
90002760:	692a      	ldr	r2, [r5, #16]
90002762:	e9cd 0102 	strd	r0, r1, [sp, #8]
90002766:	f7fe fe9f 	bl	900014a8 <HAL_ETH_RxLinkCallback>
      heth->RxDescList.RxDescCnt++;
9000276a:	6e23      	ldr	r3, [r4, #96]	; 0x60
9000276c:	3301      	adds	r3, #1
9000276e:	6623      	str	r3, [r4, #96]	; 0x60
      heth->RxDescList.RxDataLength += bufflength;
90002770:	6e63      	ldr	r3, [r4, #100]	; 0x64
      dmarxdesc->BackupAddr0 = 0;
90002772:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
      heth->RxDescList.RxDataLength += bufflength;
90002776:	443b      	add	r3, r7
90002778:	6663      	str	r3, [r4, #100]	; 0x64
      dmarxdesc->BackupAddr0 = 0;
9000277a:	f8c5 b010 	str.w	fp, [r5, #16]
    INCR_RX_DESC_INDEX(descidx, 1U);
9000277e:	f109 0301 	add.w	r3, r9, #1
    desccnt++;
90002782:	3601      	adds	r6, #1
    INCR_RX_DESC_INDEX(descidx, 1U);
90002784:	2b03      	cmp	r3, #3
90002786:	bf88      	it	hi
90002788:	f1a9 0303 	subhi.w	r3, r9, #3
    dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
9000278c:	f103 0212 	add.w	r2, r3, #18
    desccnt++;
90002790:	4699      	mov	r9, r3
    dmarxdesc = (ETH_DMADescTypeDef *)heth->RxDescList.RxDesc[descidx];
90002792:	f854 5022 	ldr.w	r5, [r4, r2, lsl #2]
    desccnt++;
90002796:	e7b2      	b.n	900026fe <HAL_ETH_ReadData+0x4c>
        bufflength = READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_PL) - heth->RxDescList.RxDataLength;
90002798:	68ef      	ldr	r7, [r5, #12]
        rxdataready = 1;
9000279a:	f04f 0801 	mov.w	r8, #1
        bufflength = READ_BIT(dmarxdesc->DESC3, ETH_DMARXNDESCWBF_PL) - heth->RxDescList.RxDataLength;
9000279e:	6e63      	ldr	r3, [r4, #100]	; 0x64
900027a0:	f3c7 070e 	ubfx	r7, r7, #0, #15
900027a4:	1aff      	subs	r7, r7, r3
        heth->RxDescList.pRxLastRxDesc = dmarxdesc->DESC3;
900027a6:	68eb      	ldr	r3, [r5, #12]
900027a8:	6723      	str	r3, [r4, #112]	; 0x70
        rxdataready = 1;
900027aa:	e7d8      	b.n	9000275e <HAL_ETH_ReadData+0xac>

900027ac <HAL_ETH_ReleaseTxPacket>:
{
900027ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
900027b0:	4605      	mov	r5, r0
  uint8_t pktTxStatus = 1U;
900027b2:	2701      	movs	r7, #1
      if ((heth->Init.TxDesc[idx].DESC3 & ETH_DMATXNDESCRF_OWN) == 0U)
900027b4:	f04f 0918 	mov.w	r9, #24
900027b8:	f04f 0a00 	mov.w	sl, #0
  uint32_t idx =       dmatxdesclist->releaseIndex;
900027bc:	e9d0 6410 	ldrd	r6, r4, [r0, #64]	; 0x40
  while ((numOfBuf != 0U) && (pktTxStatus != 0U))
900027c0:	b106      	cbz	r6, 900027c4 <HAL_ETH_ReleaseTxPacket+0x18>
900027c2:	b917      	cbnz	r7, 900027ca <HAL_ETH_ReleaseTxPacket+0x1e>
}
900027c4:	2000      	movs	r0, #0
900027c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    numOfBuf--;
900027ca:	eb05 0884 	add.w	r8, r5, r4, lsl #2
900027ce:	3e01      	subs	r6, #1
    if (dmatxdesclist->PacketAddress[idx] == NULL)
900027d0:	f8d8 002c 	ldr.w	r0, [r8, #44]	; 0x2c
900027d4:	b138      	cbz	r0, 900027e6 <HAL_ETH_ReleaseTxPacket+0x3a>
      if ((heth->Init.TxDesc[idx].DESC3 & ETH_DMATXNDESCRF_OWN) == 0U)
900027d6:	68eb      	ldr	r3, [r5, #12]
900027d8:	fb09 3304 	mla	r3, r9, r4, r3
900027dc:	68db      	ldr	r3, [r3, #12]
900027de:	2b00      	cmp	r3, #0
900027e0:	da05      	bge.n	900027ee <HAL_ETH_ReleaseTxPacket+0x42>
        pktTxStatus = 0U;
900027e2:	2700      	movs	r7, #0
900027e4:	e7ec      	b.n	900027c0 <HAL_ETH_ReleaseTxPacket+0x14>
      idx = (idx + 1U) & (ETH_TX_DESC_CNT - 1U);
900027e6:	3401      	adds	r4, #1
900027e8:	f004 0403 	and.w	r4, r4, #3
    if (pktInUse != 0U)
900027ec:	e7e8      	b.n	900027c0 <HAL_ETH_ReleaseTxPacket+0x14>
        idx = (idx + 1U) & (ETH_TX_DESC_CNT - 1U);
900027ee:	3401      	adds	r4, #1
        HAL_ETH_TxFreeCallback(dmatxdesclist->PacketAddress[idx]);
900027f0:	f7fe fe88 	bl	90001504 <HAL_ETH_TxFreeCallback>
        dmatxdesclist->PacketAddress[idx] = NULL;
900027f4:	f8c8 a02c 	str.w	sl, [r8, #44]	; 0x2c
        idx = (idx + 1U) & (ETH_TX_DESC_CNT - 1U);
900027f8:	f004 0403 	and.w	r4, r4, #3
        dmatxdesclist->releaseIndex = idx;
900027fc:	e9c5 6410 	strd	r6, r4, [r5, #64]	; 0x40
90002800:	e7de      	b.n	900027c0 <HAL_ETH_ReleaseTxPacket+0x14>

90002802 <HAL_ETH_PMTCallback>:
90002802:	4770      	bx	lr

90002804 <HAL_ETH_EEECallback>:
90002804:	4770      	bx	lr

90002806 <HAL_ETH_WakeUpCallback>:
90002806:	4770      	bx	lr

90002808 <HAL_ETH_IRQHandler>:
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_RI))
90002808:	6803      	ldr	r3, [r0, #0]
9000280a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
9000280e:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
90002812:	0652      	lsls	r2, r2, #25
{
90002814:	b510      	push	{r4, lr}
90002816:	4604      	mov	r4, r0
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_RI))
90002818:	d509      	bpl.n	9000282e <HAL_ETH_IRQHandler+0x26>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_RIE))
9000281a:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
9000281e:	0651      	lsls	r1, r2, #25
90002820:	d505      	bpl.n	9000282e <HAL_ETH_IRQHandler+0x26>
      __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_RI | ETH_DMACSR_NIS);
90002822:	f248 0240 	movw	r2, #32832	; 0x8040
90002826:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
      HAL_ETH_RxCpltCallback(heth);
9000282a:	f7fe fc19 	bl	90001060 <HAL_ETH_RxCpltCallback>
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_TI))
9000282e:	6823      	ldr	r3, [r4, #0]
90002830:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002834:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
90002838:	07d2      	lsls	r2, r2, #31
9000283a:	d50a      	bpl.n	90002852 <HAL_ETH_IRQHandler+0x4a>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_TIE))
9000283c:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
90002840:	07d0      	lsls	r0, r2, #31
90002842:	d506      	bpl.n	90002852 <HAL_ETH_IRQHandler+0x4a>
      __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_TI | ETH_DMACSR_NIS);
90002844:	f248 0201 	movw	r2, #32769	; 0x8001
      HAL_ETH_TxCpltCallback(heth);
90002848:	4620      	mov	r0, r4
      __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMACSR_TI | ETH_DMACSR_NIS);
9000284a:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
      HAL_ETH_TxCpltCallback(heth);
9000284e:	f7fe fc0d 	bl	9000106c <HAL_ETH_TxCpltCallback>
  if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_AIS))
90002852:	6823      	ldr	r3, [r4, #0]
90002854:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002858:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
9000285c:	0451      	lsls	r1, r2, #17
9000285e:	d524      	bpl.n	900028aa <HAL_ETH_IRQHandler+0xa2>
    if (__HAL_ETH_DMA_GET_IT_SOURCE(heth, ETH_DMACIER_AIE))
90002860:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
90002864:	0452      	lsls	r2, r2, #17
90002866:	d520      	bpl.n	900028aa <HAL_ETH_IRQHandler+0xa2>
      heth->ErrorCode |= HAL_ETH_ERROR_DMA;
90002868:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
9000286c:	f042 0208 	orr.w	r2, r2, #8
90002870:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
      if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_FBE))
90002874:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
90002878:	f412 5f80 	tst.w	r2, #4096	; 0x1000
        heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_FBE | ETH_DMACSR_TPS | ETH_DMACSR_RPS));
9000287c:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
      if (__HAL_ETH_DMA_GET_IT(heth, ETH_DMACSR_FBE))
90002880:	d05c      	beq.n	9000293c <HAL_ETH_IRQHandler+0x134>
        heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_FBE | ETH_DMACSR_TPS | ETH_DMACSR_RPS));
90002882:	f422 626f 	bic.w	r2, r2, #3824	; 0xef0
90002886:	f022 020d 	bic.w	r2, r2, #13
9000288a:	04d2      	lsls	r2, r2, #19
9000288c:	0cd2      	lsrs	r2, r2, #19
9000288e:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        __HAL_ETH_DMA_DISABLE_IT(heth, ETH_DMACIER_NIE | ETH_DMACIER_AIE);
90002892:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
90002896:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
9000289a:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
        heth->gState = HAL_ETH_STATE_ERROR;
9000289e:	23e0      	movs	r3, #224	; 0xe0
900028a0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
      HAL_ETH_ErrorCallback(heth);
900028a4:	4620      	mov	r0, r4
900028a6:	f7fe fbe7 	bl	90001078 <HAL_ETH_ErrorCallback>
  macirqenable = heth->Instance->MACIER;
900028aa:	6822      	ldr	r2, [r4, #0]
900028ac:	f8d2 30b4 	ldr.w	r3, [r2, #180]	; 0xb4
  if (((macirqenable & ETH_MACIER_RXSTSIE) == ETH_MACIER_RXSTSIE) || \
900028b0:	f413 4fc0 	tst.w	r3, #24576	; 0x6000
900028b4:	d012      	beq.n	900028dc <HAL_ETH_IRQHandler+0xd4>
    heth->ErrorCode |= HAL_ETH_ERROR_MAC;
900028b6:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    HAL_ETH_ErrorCallback(heth);
900028ba:	4620      	mov	r0, r4
    heth->ErrorCode |= HAL_ETH_ERROR_MAC;
900028bc:	f043 0310 	orr.w	r3, r3, #16
900028c0:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    heth->MACErrorCode = READ_REG(heth->Instance->MACRXTXSR);
900028c4:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
900028c8:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    heth->gState = HAL_ETH_STATE_ERROR;
900028cc:	23e0      	movs	r3, #224	; 0xe0
900028ce:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    HAL_ETH_ErrorCallback(heth);
900028d2:	f7fe fbd1 	bl	90001078 <HAL_ETH_ErrorCallback>
    heth->MACErrorCode = (uint32_t)(0x0U);
900028d6:	2300      	movs	r3, #0
900028d8:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  if (__HAL_ETH_MAC_GET_IT(heth, ETH_MAC_PMT_IT))
900028dc:	6823      	ldr	r3, [r4, #0]
900028de:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
900028e2:	06d0      	lsls	r0, r2, #27
900028e4:	d50b      	bpl.n	900028fe <HAL_ETH_IRQHandler+0xf6>
    heth->MACWakeUpEvent = READ_BIT(heth->Instance->MACPCSR, (ETH_MACPCSR_RWKPRCVD | ETH_MACPCSR_MGKPRCVD));
900028e6:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    HAL_ETH_PMTCallback(heth);
900028ea:	4620      	mov	r0, r4
    heth->MACWakeUpEvent = READ_BIT(heth->Instance->MACPCSR, (ETH_MACPCSR_RWKPRCVD | ETH_MACPCSR_MGKPRCVD));
900028ec:	f003 0360 	and.w	r3, r3, #96	; 0x60
900028f0:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    HAL_ETH_PMTCallback(heth);
900028f4:	f7ff ff85 	bl	90002802 <HAL_ETH_PMTCallback>
    heth->MACWakeUpEvent = (uint32_t)(0x0U);
900028f8:	2300      	movs	r3, #0
900028fa:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  if (__HAL_ETH_MAC_GET_IT(heth, ETH_MAC_LPI_IT))
900028fe:	6823      	ldr	r3, [r4, #0]
90002900:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
90002904:	0691      	lsls	r1, r2, #26
90002906:	d50b      	bpl.n	90002920 <HAL_ETH_IRQHandler+0x118>
    heth->MACLPIEvent = READ_BIT(heth->Instance->MACPCSR, 0x0000000FU);
90002908:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    HAL_ETH_EEECallback(heth);
9000290c:	4620      	mov	r0, r4
    heth->MACLPIEvent = READ_BIT(heth->Instance->MACPCSR, 0x0000000FU);
9000290e:	f003 030f 	and.w	r3, r3, #15
90002912:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    HAL_ETH_EEECallback(heth);
90002916:	f7ff ff75 	bl	90002804 <HAL_ETH_EEECallback>
    heth->MACLPIEvent = (uint32_t)(0x0U);
9000291a:	2300      	movs	r3, #0
9000291c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
  if (__HAL_ETH_WAKEUP_EXTI_GET_FLAG(ETH_WAKEUP_EXTI_LINE) != (uint32_t)RESET)
90002920:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
90002924:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
90002928:	0252      	lsls	r2, r2, #9
9000292a:	d506      	bpl.n	9000293a <HAL_ETH_IRQHandler+0x132>
    __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(ETH_WAKEUP_EXTI_LINE);
9000292c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    HAL_ETH_WakeUpCallback(heth);
90002930:	4620      	mov	r0, r4
    __HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(ETH_WAKEUP_EXTI_LINE);
90002932:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    HAL_ETH_WakeUpCallback(heth);
90002936:	f7ff ff66 	bl	90002806 <HAL_ETH_WakeUpCallback>
}
9000293a:	bd10      	pop	{r4, pc}
        heth->DMAErrorCode = READ_BIT(heth->Instance->DMACSR, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
9000293c:	f402 42cd 	and.w	r2, r2, #26240	; 0x6680
90002940:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        __HAL_ETH_DMA_CLEAR_IT(heth, (ETH_DMACSR_CDE | ETH_DMACSR_ETI | ETH_DMACSR_RWT |
90002944:	f44f 42cd 	mov.w	r2, #26240	; 0x6680
90002948:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
9000294c:	e7aa      	b.n	900028a4 <HAL_ETH_IRQHandler+0x9c>

9000294e <HAL_ETH_ReadPHYRegister>:
{
9000294e:	b570      	push	{r4, r5, r6, lr}
90002950:	461e      	mov	r6, r3
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
90002952:	6803      	ldr	r3, [r0, #0]
{
90002954:	4605      	mov	r5, r0
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
90002956:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
9000295a:	07c0      	lsls	r0, r0, #31
9000295c:	d501      	bpl.n	90002962 <HAL_ETH_ReadPHYRegister+0x14>
    return HAL_ERROR;
9000295e:	2001      	movs	r0, #1
}
90002960:	bd70      	pop	{r4, r5, r6, pc}
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
90002962:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
90002966:	f024 7478 	bic.w	r4, r4, #65011712	; 0x3e00000
9000296a:	ea44 5141 	orr.w	r1, r4, r1, lsl #21
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
9000296e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
90002972:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
90002976:	f042 020d 	orr.w	r2, r2, #13
  WRITE_REG(heth->Instance->MACMDIOAR, tmpreg);
9000297a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  tickstart = HAL_GetTick();
9000297e:	f7ff f9c5 	bl	90001d0c <HAL_GetTick>
90002982:	4604      	mov	r4, r0
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
90002984:	682a      	ldr	r2, [r5, #0]
90002986:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
9000298a:	f013 0301 	ands.w	r3, r3, #1
9000298e:	d105      	bne.n	9000299c <HAL_ETH_ReadPHYRegister+0x4e>
  WRITE_REG(*pRegValue, (uint16_t)heth->Instance->MACMDIODR);
90002990:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
  return HAL_OK;
90002994:	4618      	mov	r0, r3
  WRITE_REG(*pRegValue, (uint16_t)heth->Instance->MACMDIODR);
90002996:	b292      	uxth	r2, r2
90002998:	6032      	str	r2, [r6, #0]
  return HAL_OK;
9000299a:	e7e1      	b.n	90002960 <HAL_ETH_ReadPHYRegister+0x12>
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
9000299c:	f7ff f9b6 	bl	90001d0c <HAL_GetTick>
900029a0:	1b00      	subs	r0, r0, r4
900029a2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
900029a6:	d9ed      	bls.n	90002984 <HAL_ETH_ReadPHYRegister+0x36>
900029a8:	e7d9      	b.n	9000295e <HAL_ETH_ReadPHYRegister+0x10>
	...

900029ac <HAL_ETH_WritePHYRegister>:
{
900029ac:	b538      	push	{r3, r4, r5, lr}
900029ae:	4605      	mov	r5, r0
  if (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) != (uint32_t)RESET)
900029b0:	6800      	ldr	r0, [r0, #0]
900029b2:	f8d0 4200 	ldr.w	r4, [r0, #512]	; 0x200
900029b6:	07e4      	lsls	r4, r4, #31
900029b8:	d501      	bpl.n	900029be <HAL_ETH_WritePHYRegister+0x12>
    return HAL_ERROR;
900029ba:	2001      	movs	r0, #1
}
900029bc:	bd38      	pop	{r3, r4, r5, pc}
  WRITE_REG(tmpreg, heth->Instance->MACMDIOAR);
900029be:	f8d0 4200 	ldr.w	r4, [r0, #512]	; 0x200
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_PA, (PHYAddr << 21));
900029c2:	b29b      	uxth	r3, r3
900029c4:	f024 7478 	bic.w	r4, r4, #65011712	; 0x3e00000
900029c8:	ea44 5141 	orr.w	r1, r4, r1, lsl #21
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_RDA, (PHYReg << 16));
900029cc:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
900029d0:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
  WRITE_REG(ETH->MACMDIODR, (uint16_t)RegValue);
900029d4:	490d      	ldr	r1, [pc, #52]	; (90002a0c <HAL_ETH_WritePHYRegister+0x60>)
  MODIFY_REG(tmpreg, ETH_MACMDIOAR_MOC, ETH_MACMDIOAR_MOC_WR);
900029d6:	f022 020c 	bic.w	r2, r2, #12
  WRITE_REG(ETH->MACMDIODR, (uint16_t)RegValue);
900029da:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
  SET_BIT(tmpreg, ETH_MACMDIOAR_MB);
900029de:	f042 0205 	orr.w	r2, r2, #5
  WRITE_REG(ETH->MACMDIOAR, tmpreg);
900029e2:	f8c1 2200 	str.w	r2, [r1, #512]	; 0x200
  tickstart = HAL_GetTick();
900029e6:	f7ff f991 	bl	90001d0c <HAL_GetTick>
900029ea:	4604      	mov	r4, r0
  while (READ_BIT(heth->Instance->MACMDIOAR, ETH_MACMDIOAR_MB) > 0U)
900029ec:	682b      	ldr	r3, [r5, #0]
900029ee:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
900029f2:	f013 0301 	ands.w	r3, r3, #1
900029f6:	d101      	bne.n	900029fc <HAL_ETH_WritePHYRegister+0x50>
  return HAL_OK;
900029f8:	4618      	mov	r0, r3
900029fa:	e7df      	b.n	900029bc <HAL_ETH_WritePHYRegister+0x10>
    if (((HAL_GetTick() - tickstart) > ETH_MDIO_BUS_TIMEOUT))
900029fc:	f7ff f986 	bl	90001d0c <HAL_GetTick>
90002a00:	1b00      	subs	r0, r0, r4
90002a02:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
90002a06:	d9f1      	bls.n	900029ec <HAL_ETH_WritePHYRegister+0x40>
90002a08:	e7d7      	b.n	900029ba <HAL_ETH_WritePHYRegister+0xe>
90002a0a:	bf00      	nop
90002a0c:	40028000 	.word	0x40028000

90002a10 <HAL_ETH_GetMACConfig>:
  if (macconf == NULL)
90002a10:	2900      	cmp	r1, #0
90002a12:	f000 80c1 	beq.w	90002b98 <HAL_ETH_GetMACConfig+0x188>
  macconf->PreambleLength = READ_BIT(heth->Instance->MACCR, ETH_MACCR_PRELEN);
90002a16:	6803      	ldr	r3, [r0, #0]
  return HAL_OK;
90002a18:	2000      	movs	r0, #0
  macconf->PreambleLength = READ_BIT(heth->Instance->MACCR, ETH_MACCR_PRELEN);
90002a1a:	681a      	ldr	r2, [r3, #0]
90002a1c:	f002 020c 	and.w	r2, r2, #12
90002a20:	62ca      	str	r2, [r1, #44]	; 0x2c
  macconf->DeferralCheck = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DC) >> 4) > 0U) ? ENABLE : DISABLE;
90002a22:	681a      	ldr	r2, [r3, #0]
90002a24:	f3c2 1200 	ubfx	r2, r2, #4, #1
90002a28:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  macconf->BackOffLimit = READ_BIT(heth->Instance->MACCR, ETH_MACCR_BL);
90002a2c:	681a      	ldr	r2, [r3, #0]
90002a2e:	f002 0260 	and.w	r2, r2, #96	; 0x60
90002a32:	624a      	str	r2, [r1, #36]	; 0x24
  macconf->RetryTransmission = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DR) >> 8) == 0U) ? ENABLE : DISABLE;
90002a34:	681a      	ldr	r2, [r3, #0]
90002a36:	f482 7280 	eor.w	r2, r2, #256	; 0x100
90002a3a:	f3c2 2200 	ubfx	r2, r2, #8, #1
90002a3e:	f881 2020 	strb.w	r2, [r1, #32]
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
90002a42:	681a      	ldr	r2, [r3, #0]
                                        ? ENABLE : DISABLE;
90002a44:	f3c2 2240 	ubfx	r2, r2, #9, #1
  macconf->CarrierSenseDuringTransmit = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DCRS) >> 9) > 0U)
90002a48:	77ca      	strb	r2, [r1, #31]
  macconf->ReceiveOwn = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_DO) >> 10) == 0U) ? ENABLE : DISABLE;
90002a4a:	681a      	ldr	r2, [r3, #0]
90002a4c:	f482 6280 	eor.w	r2, r2, #1024	; 0x400
90002a50:	f3c2 2280 	ubfx	r2, r2, #10, #1
90002a54:	778a      	strb	r2, [r1, #30]
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
90002a56:	681a      	ldr	r2, [r3, #0]
                                                   ETH_MACCR_ECRSFD) >> 11) > 0U) ? ENABLE : DISABLE;
90002a58:	f3c2 22c0 	ubfx	r2, r2, #11, #1
  macconf->CarrierSenseBeforeTransmit = ((READ_BIT(heth->Instance->MACCR,
90002a5c:	774a      	strb	r2, [r1, #29]
  macconf->LoopbackMode = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_LM) >> 12) > 0U) ? ENABLE : DISABLE;
90002a5e:	681a      	ldr	r2, [r3, #0]
90002a60:	f3c2 3200 	ubfx	r2, r2, #12, #1
90002a64:	770a      	strb	r2, [r1, #28]
  macconf->DuplexMode = READ_BIT(heth->Instance->MACCR, ETH_MACCR_DM);
90002a66:	681a      	ldr	r2, [r3, #0]
90002a68:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
90002a6c:	618a      	str	r2, [r1, #24]
  macconf->Speed = READ_BIT(heth->Instance->MACCR, ETH_MACCR_FES);
90002a6e:	681a      	ldr	r2, [r3, #0]
90002a70:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
90002a74:	614a      	str	r2, [r1, #20]
  macconf->JumboPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JE) >> 16) > 0U) ? ENABLE : DISABLE;
90002a76:	681a      	ldr	r2, [r3, #0]
90002a78:	f3c2 4200 	ubfx	r2, r2, #16, #1
90002a7c:	748a      	strb	r2, [r1, #18]
  macconf->Jabber = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_JD) >> 17) == 0U) ? ENABLE : DISABLE;
90002a7e:	681a      	ldr	r2, [r3, #0]
90002a80:	f482 3200 	eor.w	r2, r2, #131072	; 0x20000
90002a84:	f3c2 4240 	ubfx	r2, r2, #17, #1
90002a88:	744a      	strb	r2, [r1, #17]
  macconf->Watchdog = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_WD) >> 19) == 0U) ? ENABLE : DISABLE;
90002a8a:	681a      	ldr	r2, [r3, #0]
90002a8c:	f482 2200 	eor.w	r2, r2, #524288	; 0x80000
90002a90:	f3c2 42c0 	ubfx	r2, r2, #19, #1
90002a94:	740a      	strb	r2, [r1, #16]
  macconf->AutomaticPadCRCStrip = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_ACS) >> 20) > 0U) ? ENABLE : DISABLE;
90002a96:	681a      	ldr	r2, [r3, #0]
90002a98:	f3c2 5200 	ubfx	r2, r2, #20, #1
90002a9c:	73ca      	strb	r2, [r1, #15]
  macconf->CRCStripTypePacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_CST) >> 21) > 0U) ? ENABLE : DISABLE;
90002a9e:	681a      	ldr	r2, [r3, #0]
90002aa0:	f3c2 5240 	ubfx	r2, r2, #21, #1
90002aa4:	738a      	strb	r2, [r1, #14]
  macconf->Support2KPacket = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_S2KP) >> 22) > 0U) ? ENABLE : DISABLE;
90002aa6:	681a      	ldr	r2, [r3, #0]
90002aa8:	f3c2 5280 	ubfx	r2, r2, #22, #1
90002aac:	734a      	strb	r2, [r1, #13]
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
90002aae:	681a      	ldr	r2, [r3, #0]
                                                    ETH_MACCR_GPSLCE) >> 23) > 0U) ? ENABLE : DISABLE;
90002ab0:	f3c2 52c0 	ubfx	r2, r2, #23, #1
  macconf->GiantPacketSizeLimitControl = ((READ_BIT(heth->Instance->MACCR,
90002ab4:	730a      	strb	r2, [r1, #12]
  macconf->InterPacketGapVal = READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPG);
90002ab6:	681a      	ldr	r2, [r3, #0]
90002ab8:	f002 62e0 	and.w	r2, r2, #117440512	; 0x7000000
90002abc:	608a      	str	r2, [r1, #8]
  macconf->ChecksumOffload = ((READ_BIT(heth->Instance->MACCR, ETH_MACCR_IPC) >> 27) > 0U) ? ENABLE : DISABLE;
90002abe:	681a      	ldr	r2, [r3, #0]
90002ac0:	f3c2 62c0 	ubfx	r2, r2, #27, #1
90002ac4:	710a      	strb	r2, [r1, #4]
  macconf->SourceAddrControl = READ_BIT(heth->Instance->MACCR, ETH_MACCR_SARC);
90002ac6:	681a      	ldr	r2, [r3, #0]
90002ac8:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
90002acc:	600a      	str	r2, [r1, #0]
  macconf->GiantPacketSizeLimit = READ_BIT(heth->Instance->MACECR, ETH_MACECR_GPSL);
90002ace:	685a      	ldr	r2, [r3, #4]
90002ad0:	f3c2 020d 	ubfx	r2, r2, #0, #14
90002ad4:	634a      	str	r2, [r1, #52]	; 0x34
  macconf->CRCCheckingRxPackets = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_DCRCC) >> 16) == 0U) ? ENABLE : DISABLE;
90002ad6:	685a      	ldr	r2, [r3, #4]
90002ad8:	f482 3280 	eor.w	r2, r2, #65536	; 0x10000
90002adc:	f3c2 4200 	ubfx	r2, r2, #16, #1
90002ae0:	f881 2032 	strb.w	r2, [r1, #50]	; 0x32
  macconf->SlowProtocolDetect = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_SPEN) >> 17) > 0U) ? ENABLE : DISABLE;
90002ae4:	685a      	ldr	r2, [r3, #4]
90002ae6:	f3c2 4240 	ubfx	r2, r2, #17, #1
90002aea:	f881 2031 	strb.w	r2, [r1, #49]	; 0x31
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
90002aee:	685a      	ldr	r2, [r3, #4]
                                                        ETH_MACECR_USP) >> 18) > 0U) ? ENABLE : DISABLE;
90002af0:	f3c2 4280 	ubfx	r2, r2, #18, #1
  macconf->UnicastSlowProtocolPacketDetect = ((READ_BIT(heth->Instance->MACECR,
90002af4:	f881 2030 	strb.w	r2, [r1, #48]	; 0x30
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
90002af8:	685a      	ldr	r2, [r3, #4]
                                    ? ENABLE : DISABLE;
90002afa:	f3c2 6200 	ubfx	r2, r2, #24, #1
  macconf->ExtendedInterPacketGap = ((READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPGEN) >> 24) > 0U)
90002afe:	f881 2038 	strb.w	r2, [r1, #56]	; 0x38
  macconf->ExtendedInterPacketGapVal = READ_BIT(heth->Instance->MACECR, ETH_MACECR_EIPG) >> 25;
90002b02:	685a      	ldr	r2, [r3, #4]
90002b04:	f3c2 6244 	ubfx	r2, r2, #25, #5
90002b08:	63ca      	str	r2, [r1, #60]	; 0x3c
  macconf->ProgrammableWatchdog = ((READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_PWE) >> 8) > 0U) ? ENABLE : DISABLE;
90002b0a:	68da      	ldr	r2, [r3, #12]
90002b0c:	f3c2 2200 	ubfx	r2, r2, #8, #1
90002b10:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
  macconf->WatchdogTimeout = READ_BIT(heth->Instance->MACWTR, ETH_MACWTR_WTO);
90002b14:	68da      	ldr	r2, [r3, #12]
90002b16:	f002 020f 	and.w	r2, r2, #15
90002b1a:	644a      	str	r2, [r1, #68]	; 0x44
  macconf->TransmitFlowControl = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_TFE) >> 1) > 0U) ? ENABLE : DISABLE;
90002b1c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
90002b1e:	f3c2 0240 	ubfx	r2, r2, #1, #1
90002b22:	f881 2054 	strb.w	r2, [r1, #84]	; 0x54
  macconf->ZeroQuantaPause = ((READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_DZPQ) >> 7) == 0U) ? ENABLE : DISABLE;
90002b26:	6f1a      	ldr	r2, [r3, #112]	; 0x70
90002b28:	f082 0280 	eor.w	r2, r2, #128	; 0x80
90002b2c:	f3c2 12c0 	ubfx	r2, r2, #7, #1
90002b30:	f881 204c 	strb.w	r2, [r1, #76]	; 0x4c
  macconf->PauseLowThreshold = READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PLT);
90002b34:	6f1a      	ldr	r2, [r3, #112]	; 0x70
90002b36:	f002 0270 	and.w	r2, r2, #112	; 0x70
90002b3a:	650a      	str	r2, [r1, #80]	; 0x50
  macconf->PauseTime = (READ_BIT(heth->Instance->MACTFCR, ETH_MACTFCR_PT) >> 16);
90002b3c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
90002b3e:	0c12      	lsrs	r2, r2, #16
90002b40:	648a      	str	r2, [r1, #72]	; 0x48
  macconf->ReceiveFlowControl = (READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_RFE) > 0U) ? ENABLE : DISABLE;
90002b42:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
90002b46:	f002 0201 	and.w	r2, r2, #1
90002b4a:	f881 2056 	strb.w	r2, [r1, #86]	; 0x56
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
90002b4e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
                                      ? ENABLE : DISABLE;
90002b52:	f3c2 0240 	ubfx	r2, r2, #1, #1
  macconf->UnicastPausePacketDetect = ((READ_BIT(heth->Instance->MACRFCR, ETH_MACRFCR_UP) >> 1) > 0U)
90002b56:	f881 2055 	strb.w	r2, [r1, #85]	; 0x55
  macconf->TransmitQueueMode = READ_BIT(heth->Instance->MTLTQOMR, (ETH_MTLTQOMR_TTC | ETH_MTLTQOMR_TSF));
90002b5a:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
90002b5e:	f002 0272 	and.w	r2, r2, #114	; 0x72
90002b62:	658a      	str	r2, [r1, #88]	; 0x58
  macconf->ReceiveQueueMode = READ_BIT(heth->Instance->MTLRQOMR, (ETH_MTLRQOMR_RTC | ETH_MTLRQOMR_RSF));
90002b64:	f8d3 2d30 	ldr.w	r2, [r3, #3376]	; 0xd30
90002b68:	f002 0223 	and.w	r2, r2, #35	; 0x23
90002b6c:	65ca      	str	r2, [r1, #92]	; 0x5c
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
90002b6e:	f8d3 2d30 	ldr.w	r2, [r3, #3376]	; 0xd30
                                                      ETH_MTLRQOMR_FUP) >> 3) > 0U) ? ENABLE : DISABLE;
90002b72:	f3c2 02c0 	ubfx	r2, r2, #3, #1
  macconf->ForwardRxUndersizedGoodPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
90002b76:	f881 2062 	strb.w	r2, [r1, #98]	; 0x62
  macconf->ForwardRxErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR, ETH_MTLRQOMR_FEP) >> 4) > 0U) ? ENABLE : DISABLE;
90002b7a:	f8d3 2d30 	ldr.w	r2, [r3, #3376]	; 0xd30
90002b7e:	f3c2 1200 	ubfx	r2, r2, #4, #1
90002b82:	f881 2061 	strb.w	r2, [r1, #97]	; 0x61
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
90002b86:	f8d3 3d30 	ldr.w	r3, [r3, #3376]	; 0xd30
                                                     ETH_MTLRQOMR_DISTCPEF) >> 6) == 0U) ? ENABLE : DISABLE;
90002b8a:	f083 0340 	eor.w	r3, r3, #64	; 0x40
90002b8e:	f3c3 1380 	ubfx	r3, r3, #6, #1
  macconf->DropTCPIPChecksumErrorPacket = ((READ_BIT(heth->Instance->MTLRQOMR,
90002b92:	f881 3060 	strb.w	r3, [r1, #96]	; 0x60
  return HAL_OK;
90002b96:	4770      	bx	lr
    return HAL_ERROR;
90002b98:	2001      	movs	r0, #1
}
90002b9a:	4770      	bx	lr

90002b9c <HAL_ETH_SetMACConfig>:
{
90002b9c:	b508      	push	{r3, lr}
  if (macconf == NULL)
90002b9e:	b139      	cbz	r1, 90002bb0 <HAL_ETH_SetMACConfig+0x14>
  if (heth->gState == HAL_ETH_STATE_READY)
90002ba0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
90002ba4:	2b10      	cmp	r3, #16
90002ba6:	d103      	bne.n	90002bb0 <HAL_ETH_SetMACConfig+0x14>
    ETH_SetMACConfig(heth, macconf);
90002ba8:	f7ff f988 	bl	90001ebc <ETH_SetMACConfig>
    return HAL_OK;
90002bac:	2000      	movs	r0, #0
}
90002bae:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
90002bb0:	2001      	movs	r0, #1
90002bb2:	e7fc      	b.n	90002bae <HAL_ETH_SetMACConfig+0x12>

90002bb4 <HAL_ETH_SetMDIOClockRange>:
{
90002bb4:	b538      	push	{r3, r4, r5, lr}
  tmpreg = (heth->Instance)->MACMDIOAR;
90002bb6:	6803      	ldr	r3, [r0, #0]
{
90002bb8:	4605      	mov	r5, r0
  tmpreg = (heth->Instance)->MACMDIOAR;
90002bba:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
  hclk = HAL_RCC_GetHCLKFreq();
90002bbe:	f001 f919 	bl	90003df4 <HAL_RCC_GetHCLKFreq>
  if ((hclk >= 20000000U) && (hclk < 35000000U))
90002bc2:	4b12      	ldr	r3, [pc, #72]	; (90002c0c <HAL_ETH_SetMDIOClockRange+0x58>)
90002bc4:	4a12      	ldr	r2, [pc, #72]	; (90002c10 <HAL_ETH_SetMDIOClockRange+0x5c>)
  tmpreg &= ~ETH_MACMDIOAR_CR;
90002bc6:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
  if ((hclk >= 20000000U) && (hclk < 35000000U))
90002bca:	4403      	add	r3, r0
90002bcc:	4293      	cmp	r3, r2
90002bce:	d205      	bcs.n	90002bdc <HAL_ETH_SetMDIOClockRange+0x28>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV16;
90002bd0:	f444 7400 	orr.w	r4, r4, #512	; 0x200
  (heth->Instance)->MACMDIOAR = (uint32_t)tmpreg;
90002bd4:	682b      	ldr	r3, [r5, #0]
90002bd6:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
}
90002bda:	bd38      	pop	{r3, r4, r5, pc}
  else if ((hclk >= 35000000U) && (hclk < 60000000U))
90002bdc:	4b0d      	ldr	r3, [pc, #52]	; (90002c14 <HAL_ETH_SetMDIOClockRange+0x60>)
90002bde:	4a0e      	ldr	r2, [pc, #56]	; (90002c18 <HAL_ETH_SetMDIOClockRange+0x64>)
90002be0:	4403      	add	r3, r0
90002be2:	4293      	cmp	r3, r2
90002be4:	d802      	bhi.n	90002bec <HAL_ETH_SetMDIOClockRange+0x38>
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV26;
90002be6:	f444 7440 	orr.w	r4, r4, #768	; 0x300
90002bea:	e7f3      	b.n	90002bd4 <HAL_ETH_SetMDIOClockRange+0x20>
  else if ((hclk >= 60000000U) && (hclk < 100000000U))
90002bec:	4b0b      	ldr	r3, [pc, #44]	; (90002c1c <HAL_ETH_SetMDIOClockRange+0x68>)
90002bee:	4a0c      	ldr	r2, [pc, #48]	; (90002c20 <HAL_ETH_SetMDIOClockRange+0x6c>)
90002bf0:	4403      	add	r3, r0
90002bf2:	4293      	cmp	r3, r2
90002bf4:	d3ee      	bcc.n	90002bd4 <HAL_ETH_SetMDIOClockRange+0x20>
  else if ((hclk >= 100000000U) && (hclk < 150000000U))
90002bf6:	4b0b      	ldr	r3, [pc, #44]	; (90002c24 <HAL_ETH_SetMDIOClockRange+0x70>)
90002bf8:	4a0b      	ldr	r2, [pc, #44]	; (90002c28 <HAL_ETH_SetMDIOClockRange+0x74>)
90002bfa:	4403      	add	r3, r0
90002bfc:	4293      	cmp	r3, r2
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV62;
90002bfe:	bf94      	ite	ls
90002c00:	f444 7480 	orrls.w	r4, r4, #256	; 0x100
    tmpreg |= (uint32_t)ETH_MACMDIOAR_CR_DIV102;
90002c04:	f444 6480 	orrhi.w	r4, r4, #1024	; 0x400
90002c08:	e7e4      	b.n	90002bd4 <HAL_ETH_SetMDIOClockRange+0x20>
90002c0a:	bf00      	nop
90002c0c:	feced300 	.word	0xfeced300
90002c10:	00e4e1c0 	.word	0x00e4e1c0
90002c14:	fde9f140 	.word	0xfde9f140
90002c18:	017d783f 	.word	0x017d783f
90002c1c:	fc6c7900 	.word	0xfc6c7900
90002c20:	02625a00 	.word	0x02625a00
90002c24:	fa0a1f00 	.word	0xfa0a1f00
90002c28:	02faf07f 	.word	0x02faf07f

90002c2c <HAL_ETH_Init>:
{
90002c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (heth == NULL)
90002c2e:	4604      	mov	r4, r0
{
90002c30:	b0a5      	sub	sp, #148	; 0x94
  if (heth == NULL)
90002c32:	2800      	cmp	r0, #0
90002c34:	f000 80b0 	beq.w	90002d98 <HAL_ETH_Init+0x16c>
  if (heth->gState == HAL_ETH_STATE_RESET)
90002c38:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
90002c3c:	b923      	cbnz	r3, 90002c48 <HAL_ETH_Init+0x1c>
    heth->gState = HAL_ETH_STATE_BUSY;
90002c3e:	2323      	movs	r3, #35	; 0x23
90002c40:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    HAL_ETH_MspInit(heth);
90002c44:	f7fe fb16 	bl	90001274 <HAL_ETH_MspInit>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
90002c48:	4b7c      	ldr	r3, [pc, #496]	; (90002e3c <HAL_ETH_Init+0x210>)
90002c4a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
90002c4e:	f042 0202 	orr.w	r2, r2, #2
90002c52:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
90002c56:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
  if (heth->Init.MediaInterface == HAL_ETH_MII_MODE)
90002c5a:	7a20      	ldrb	r0, [r4, #8]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
90002c5c:	f003 0302 	and.w	r3, r3, #2
90002c60:	9301      	str	r3, [sp, #4]
90002c62:	9b01      	ldr	r3, [sp, #4]
  if (heth->Init.MediaInterface == HAL_ETH_MII_MODE)
90002c64:	2800      	cmp	r0, #0
90002c66:	f040 8087 	bne.w	90002d78 <HAL_ETH_Init+0x14c>
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);
90002c6a:	f7ff f86d 	bl	90001d48 <HAL_SYSCFG_ETHInterfaceSelect>
  (void)SYSCFG->PMCR;
90002c6e:	4b74      	ldr	r3, [pc, #464]	; (90002e40 <HAL_ETH_Init+0x214>)
90002c70:	685b      	ldr	r3, [r3, #4]
  SET_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR);
90002c72:	6823      	ldr	r3, [r4, #0]
90002c74:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002c78:	681a      	ldr	r2, [r3, #0]
90002c7a:	f042 0201 	orr.w	r2, r2, #1
90002c7e:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
90002c80:	f7ff f844 	bl	90001d0c <HAL_GetTick>
90002c84:	4606      	mov	r6, r0
  while (READ_BIT(heth->Instance->DMAMR, ETH_DMAMR_SWR) > 0U)
90002c86:	6823      	ldr	r3, [r4, #0]
90002c88:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
90002c8c:	681d      	ldr	r5, [r3, #0]
90002c8e:	f015 0501 	ands.w	r5, r5, #1
90002c92:	d174      	bne.n	90002d7e <HAL_ETH_Init+0x152>
  HAL_ETH_SetMDIOClockRange(heth);
90002c94:	4620      	mov	r0, r4
  macDefaultConf.ChecksumOffload = ENABLE;
90002c96:	2601      	movs	r6, #1
  HAL_ETH_SetMDIOClockRange(heth);
90002c98:	f7ff ff8c 	bl	90002bb4 <HAL_ETH_SetMDIOClockRange>
  WRITE_REG(heth->Instance->MAC1USTCR, (((uint32_t)HAL_RCC_GetHCLKFreq() / ETH_MAC_US_TICK) - 1U));
90002c9c:	f001 f8aa 	bl	90003df4 <HAL_RCC_GetHCLKFreq>
90002ca0:	4a68      	ldr	r2, [pc, #416]	; (90002e44 <HAL_ETH_Init+0x218>)
90002ca2:	6823      	ldr	r3, [r4, #0]
  macDefaultConf.DuplexMode = ETH_FULLDUPLEX_MODE;
90002ca4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  macDefaultConf.BackOffLimit = ETH_BACKOFFLIMIT_10;
90002ca8:	9514      	str	r5, [sp, #80]	; 0x50
  macDefaultConf.DeferralCheck = DISABLE;
90002caa:	f88d 5054 	strb.w	r5, [sp, #84]	; 0x54
  macDefaultConf.ExtendedInterPacketGap = DISABLE;
90002cae:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
  macDefaultConf.ExtendedInterPacketGapVal = 0x0;
90002cb2:	951a      	str	r5, [sp, #104]	; 0x68
  macDefaultConf.PauseTime = 0x0;
90002cb4:	951d      	str	r5, [sp, #116]	; 0x74
  macDefaultConf.ProgrammableWatchdog = DISABLE;
90002cb6:	f88d 506c 	strb.w	r5, [sp, #108]	; 0x6c
  macDefaultConf.ForwardRxUndersizedGoodPacket = DISABLE;
90002cba:	f88d 508e 	strb.w	r5, [sp, #142]	; 0x8e
  macDefaultConf.PauseLowThreshold = ETH_PAUSELOWTHRESHOLD_MINUS_4;
90002cbe:	951f      	str	r5, [sp, #124]	; 0x7c
  macDefaultConf.TransmitFlowControl = DISABLE;
90002cc0:	f8ad 5080 	strh.w	r5, [sp, #128]	; 0x80
  macDefaultConf.ReceiveFlowControl = DISABLE;
90002cc4:	f88d 5082 	strb.w	r5, [sp, #130]	; 0x82
  macDefaultConf.PreambleLength = ETH_PREAMBLELENGTH_7;
90002cc8:	9516      	str	r5, [sp, #88]	; 0x58
  macDefaultConf.UnicastSlowProtocolPacketDetect = DISABLE;
90002cca:	f8ad 505c 	strh.w	r5, [sp, #92]	; 0x5c
  macDefaultConf.InterPacketGapVal = ETH_INTERPACKETGAP_96BIT;
90002cce:	950d      	str	r5, [sp, #52]	; 0x34
  macDefaultConf.JumboPacket = DISABLE;
90002cd0:	f88d 503e 	strb.w	r5, [sp, #62]	; 0x3e
  macDefaultConf.WatchdogTimeout =  ETH_MACWTR_WTO_2KB;
90002cd4:	951c      	str	r5, [sp, #112]	; 0x70
  macDefaultConf.ChecksumOffload = ENABLE;
90002cd6:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
  macDefaultConf.RetryTransmission = ENABLE;
90002cda:	f88d 604c 	strb.w	r6, [sp, #76]	; 0x4c
  macDefaultConf.DropTCPIPChecksumErrorPacket = ENABLE;
90002cde:	f8ad 608c 	strh.w	r6, [sp, #140]	; 0x8c
  macDefaultConf.CRCCheckingRxPackets = ENABLE;
90002ce2:	f88d 605e 	strb.w	r6, [sp, #94]	; 0x5e
  macDefaultConf.ZeroQuantaPause = ENABLE;
90002ce6:	f88d 6078 	strb.w	r6, [sp, #120]	; 0x78
  WRITE_REG(heth->Instance->MAC1USTCR, (((uint32_t)HAL_RCC_GetHCLKFreq() / ETH_MAC_US_TICK) - 1U));
90002cea:	fbb0 f0f2 	udiv	r0, r0, r2
90002cee:	3801      	subs	r0, #1
90002cf0:	f8c3 00dc 	str.w	r0, [r3, #220]	; 0xdc
  macDefaultConf.GiantPacketSizeLimit = 0x618;
90002cf4:	f44f 63c3 	mov.w	r3, #1560	; 0x618
  macDefaultConf.ReceiveQueueMode = ETH_RECEIVESTOREFORWARD;
90002cf8:	2002      	movs	r0, #2
  macDefaultConf.GiantPacketSizeLimit = 0x618;
90002cfa:	9318      	str	r3, [sp, #96]	; 0x60
  macDefaultConf.SourceAddrControl = ETH_SOURCEADDRESS_REPLACE_ADDR0;
90002cfc:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
90002d00:	930b      	str	r3, [sp, #44]	; 0x2c
  macDefaultConf.DuplexMode = ETH_FULLDUPLEX_MODE;
90002d02:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90002d06:	e9cd 1310 	strd	r1, r3, [sp, #64]	; 0x40
  macDefaultConf.LoopbackMode = DISABLE;
90002d0a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  ETH_SetMACConfig(heth, &macDefaultConf);
90002d0e:	a90b      	add	r1, sp, #44	; 0x2c
  macDefaultConf.LoopbackMode = DISABLE;
90002d10:	9312      	str	r3, [sp, #72]	; 0x48
  macDefaultConf.ReceiveQueueMode = ETH_RECEIVESTOREFORWARD;
90002d12:	2320      	movs	r3, #32
90002d14:	e9cd 0321 	strd	r0, r3, [sp, #132]	; 0x84
  macDefaultConf.GiantPacketSizeLimitControl = DISABLE;
90002d18:	4b4b      	ldr	r3, [pc, #300]	; (90002e48 <HAL_ETH_Init+0x21c>)
  ETH_SetMACConfig(heth, &macDefaultConf);
90002d1a:	4620      	mov	r0, r4
  macDefaultConf.GiantPacketSizeLimitControl = DISABLE;
90002d1c:	930e      	str	r3, [sp, #56]	; 0x38
  macDefaultConf.Watchdog = ENABLE;
90002d1e:	f240 1301 	movw	r3, #257	; 0x101
90002d22:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
  ETH_SetMACConfig(heth, &macDefaultConf);
90002d26:	f7ff f8c9 	bl	90001ebc <ETH_SetMACConfig>
  dmaDefaultConf.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
90002d2a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
  ETH_SetDMAConfig(heth, &dmaDefaultConf);
90002d2e:	a902      	add	r1, sp, #8
90002d30:	4620      	mov	r0, r4
  dmaDefaultConf.DMAArbitration = ETH_DMAARBITRATION_RX1_TX1;
90002d32:	9502      	str	r5, [sp, #8]
  dmaDefaultConf.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
90002d34:	9306      	str	r3, [sp, #24]
  dmaDefaultConf.RxDMABurstLength = ETH_RXDMABURSTLENGTH_32BEAT;
90002d36:	9308      	str	r3, [sp, #32]
  dmaDefaultConf.MaximumSegmentSize = ETH_SEGMENT_SIZE_DEFAULT;
90002d38:	f44f 7306 	mov.w	r3, #536	; 0x218
  dmaDefaultConf.RebuildINCRxBurst = DISABLE;
90002d3c:	f8ad 5014 	strh.w	r5, [sp, #20]
  dmaDefaultConf.SecondPacketOperate = DISABLE;
90002d40:	f88d 501c 	strb.w	r5, [sp, #28]
  dmaDefaultConf.FlushRxPacket = DISABLE;
90002d44:	f8ad 5024 	strh.w	r5, [sp, #36]	; 0x24
  dmaDefaultConf.MaximumSegmentSize = ETH_SEGMENT_SIZE_DEFAULT;
90002d48:	930a      	str	r3, [sp, #40]	; 0x28
  dmaDefaultConf.AddressAlignedBeats = ENABLE;
90002d4a:	f88d 600c 	strb.w	r6, [sp, #12]
  dmaDefaultConf.BurstMode = ETH_BURSTLENGTH_FIXED;
90002d4e:	9604      	str	r6, [sp, #16]
  ETH_SetDMAConfig(heth, &dmaDefaultConf);
90002d50:	f7ff f98e 	bl	90002070 <ETH_SetDMAConfig>
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_DSL, ETH_DMACCR_DSL_64BIT);
90002d54:	6825      	ldr	r5, [r4, #0]
  if ((heth->Init.RxBuffLen % 0x4U) != 0x0U)
90002d56:	6960      	ldr	r0, [r4, #20]
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_DSL, ETH_DMACCR_DSL_64BIT);
90002d58:	f505 5280 	add.w	r2, r5, #4096	; 0x1000
  if ((heth->Init.RxBuffLen % 0x4U) != 0x0U)
90002d5c:	f010 0103 	ands.w	r1, r0, #3
  MODIFY_REG(heth->Instance->DMACCR, ETH_DMACCR_DSL, ETH_DMACCR_DSL_64BIT);
90002d60:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
90002d64:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
90002d68:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
90002d6c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
  if ((heth->Init.RxBuffLen % 0x4U) != 0x0U)
90002d70:	d014      	beq.n	90002d9c <HAL_ETH_Init+0x170>
    heth->ErrorCode = HAL_ETH_ERROR_PARAM;
90002d72:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
90002d76:	e00c      	b.n	90002d92 <HAL_ETH_Init+0x166>
    HAL_SYSCFG_ETHInterfaceSelect(SYSCFG_ETH_RMII);
90002d78:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
90002d7c:	e775      	b.n	90002c6a <HAL_ETH_Init+0x3e>
    if (((HAL_GetTick() - tickstart) > ETH_SWRESET_TIMEOUT))
90002d7e:	f7fe ffc5 	bl	90001d0c <HAL_GetTick>
90002d82:	1b80      	subs	r0, r0, r6
90002d84:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
90002d88:	f67f af7d 	bls.w	90002c86 <HAL_ETH_Init+0x5a>
      heth->ErrorCode = HAL_ETH_ERROR_TIMEOUT;
90002d8c:	2304      	movs	r3, #4
90002d8e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    heth->gState = HAL_ETH_STATE_ERROR;
90002d92:	23e0      	movs	r3, #224	; 0xe0
90002d94:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_ERROR;
90002d98:	2001      	movs	r0, #1
90002d9a:	e04c      	b.n	90002e36 <HAL_ETH_Init+0x20a>
    MODIFY_REG(heth->Instance->DMACRCR, ETH_DMACRCR_RBSZ, ((heth->Init.RxBuffLen) << 1));
90002d9c:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
90002da0:	f104 0618 	add.w	r6, r4, #24
90002da4:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
90002da8:	f023 037e 	bic.w	r3, r3, #126	; 0x7e
90002dac:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
90002db0:	68e0      	ldr	r0, [r4, #12]
90002db2:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
90002db6:	f100 0760 	add.w	r7, r0, #96	; 0x60
    dmatxdesc = heth->Init.TxDesc + i;
90002dba:	4603      	mov	r3, r0
    WRITE_REG(dmatxdesc->DESC0, 0x0);
90002dbc:	6019      	str	r1, [r3, #0]
    WRITE_REG(dmatxdesc->DESC1, 0x0);
90002dbe:	6059      	str	r1, [r3, #4]
    WRITE_REG(dmatxdesc->DESC2, 0x0);
90002dc0:	6099      	str	r1, [r3, #8]
    WRITE_REG(dmatxdesc->DESC3, 0x0);
90002dc2:	60d9      	str	r1, [r3, #12]
    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
90002dc4:	f846 3b04 	str.w	r3, [r6], #4
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
90002dc8:	3318      	adds	r3, #24
90002dca:	42bb      	cmp	r3, r7
90002dcc:	d1f6      	bne.n	90002dbc <HAL_ETH_Init+0x190>
  WRITE_REG(heth->Instance->DMACTDRLR, (ETH_TX_DESC_CNT - 1U));
90002dce:	2303      	movs	r3, #3
  heth->TxDescList.CurTxDesc = 0;
90002dd0:	62a1      	str	r1, [r4, #40]	; 0x28
  WRITE_REG(heth->Instance->DMACTDRLR, (ETH_TX_DESC_CNT - 1U));
90002dd2:	f104 0648 	add.w	r6, r4, #72	; 0x48
90002dd6:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
    WRITE_REG(dmarxdesc->DESC0, 0x0);
90002dda:	2300      	movs	r3, #0
  WRITE_REG(heth->Instance->DMACTDLAR, (uint32_t) heth->Init.TxDesc);
90002ddc:	f8c2 0114 	str.w	r0, [r2, #276]	; 0x114
  WRITE_REG(heth->Instance->DMACTDTPR, (uint32_t) heth->Init.TxDesc);
90002de0:	f8c2 0120 	str.w	r0, [r2, #288]	; 0x120
    dmarxdesc =  heth->Init.RxDesc + i;
90002de4:	6920      	ldr	r0, [r4, #16]
90002de6:	f100 0760 	add.w	r7, r0, #96	; 0x60
90002dea:	4601      	mov	r1, r0
    WRITE_REG(dmarxdesc->DESC0, 0x0);
90002dec:	600b      	str	r3, [r1, #0]
    WRITE_REG(dmarxdesc->DESC1, 0x0);
90002dee:	604b      	str	r3, [r1, #4]
    WRITE_REG(dmarxdesc->DESC2, 0x0);
90002df0:	608b      	str	r3, [r1, #8]
    WRITE_REG(dmarxdesc->DESC3, 0x0);
90002df2:	60cb      	str	r3, [r1, #12]
    WRITE_REG(dmarxdesc->BackupAddr1, 0x0);
90002df4:	e9c1 3304 	strd	r3, r3, [r1, #16]
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
90002df8:	f846 1b04 	str.w	r1, [r6], #4
  for (i = 0; i < (uint32_t)ETH_RX_DESC_CNT; i++)
90002dfc:	3118      	adds	r1, #24
90002dfe:	42b9      	cmp	r1, r7
90002e00:	d1f4      	bne.n	90002dec <HAL_ETH_Init+0x1c0>
  WRITE_REG(heth->Instance->DMACRDRLR, ((uint32_t)(ETH_RX_DESC_CNT - 1U)));
90002e02:	2103      	movs	r1, #3
  WRITE_REG(heth->RxDescList.ItMode, 0);
90002e04:	65a3      	str	r3, [r4, #88]	; 0x58
  WRITE_REG(heth->RxDescList.RxDescCnt, 0);
90002e06:	e9c4 3317 	strd	r3, r3, [r4, #92]	; 0x5c
  WRITE_REG(heth->RxDescList.RxBuildDescCnt, 0);
90002e0a:	e9c4 331a 	strd	r3, r3, [r4, #104]	; 0x68
  WRITE_REG(heth->Instance->DMACRDRLR, ((uint32_t)(ETH_RX_DESC_CNT - 1U)));
90002e0e:	f8c2 1130 	str.w	r1, [r2, #304]	; 0x130
  WRITE_REG(heth->Instance->DMACRDLAR, (uint32_t) heth->Init.RxDesc);
90002e12:	f8c2 011c 	str.w	r0, [r2, #284]	; 0x11c
  WRITE_REG(heth->Instance->DMACRDTPR, ((uint32_t)(heth->Init.RxDesc + (uint32_t)(ETH_RX_DESC_CNT - 1U))));
90002e16:	3048      	adds	r0, #72	; 0x48
90002e18:	f8c2 0128 	str.w	r0, [r2, #296]	; 0x128
  return HAL_OK;
90002e1c:	2000      	movs	r0, #0
  heth->Instance->MACA0HR = (((uint32_t)(heth->Init.MACAddr[5]) << 8) | (uint32_t)heth->Init.MACAddr[4]);
90002e1e:	6862      	ldr	r2, [r4, #4]
90002e20:	8891      	ldrh	r1, [r2, #4]
90002e22:	f8c5 1300 	str.w	r1, [r5, #768]	; 0x300
                             ((uint32_t)(heth->Init.MACAddr[1]) << 8) | (uint32_t)heth->Init.MACAddr[0]);
90002e26:	6812      	ldr	r2, [r2, #0]
  heth->Instance->MACA0LR = (((uint32_t)(heth->Init.MACAddr[3]) << 24) | ((uint32_t)(heth->Init.MACAddr[2]) << 16) |
90002e28:	f8c5 2304 	str.w	r2, [r5, #772]	; 0x304
  heth->ErrorCode = HAL_ETH_ERROR_NONE;
90002e2c:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  heth->gState = HAL_ETH_STATE_READY;
90002e30:	2310      	movs	r3, #16
90002e32:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}
90002e36:	b025      	add	sp, #148	; 0x94
90002e38:	bdf0      	pop	{r4, r5, r6, r7, pc}
90002e3a:	bf00      	nop
90002e3c:	58024400 	.word	0x58024400
90002e40:	58000400 	.word	0x58000400
90002e44:	000f4240 	.word	0x000f4240
90002e48:	01010000 	.word	0x01010000

90002e4c <HAL_ETH_GetDMAError>:
  return heth->DMAErrorCode;
90002e4c:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
}
90002e50:	4770      	bx	lr
	...

90002e54 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
90002e54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
90002e58:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90002e5a:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 90003028 <HAL_GPIO_Init+0x1d4>
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
90002e5e:	f04f 44b0 	mov.w	r4, #1476395008	; 0x58000000
  while (((GPIO_Init->Pin) >> position) != 0x00U)
90002e62:	680a      	ldr	r2, [r1, #0]
90002e64:	fa32 f503 	lsrs.w	r5, r2, r3
90002e68:	d102      	bne.n	90002e70 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
90002e6a:	b003      	add	sp, #12
90002e6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
90002e70:	f04f 0e01 	mov.w	lr, #1
90002e74:	fa0e fe03 	lsl.w	lr, lr, r3
    if (iocurrent != 0x00U)
90002e78:	ea1e 0202 	ands.w	r2, lr, r2
90002e7c:	f000 80bd 	beq.w	90002ffa <HAL_GPIO_Init+0x1a6>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
90002e80:	684e      	ldr	r6, [r1, #4]
90002e82:	ea4f 0843 	mov.w	r8, r3, lsl #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
90002e86:	f04f 0c03 	mov.w	ip, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
90002e8a:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
90002e8e:	fa0c fc08 	lsl.w	ip, ip, r8
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
90002e92:	1e6f      	subs	r7, r5, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
90002e94:	ea6f 0c0c 	mvn.w	ip, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
90002e98:	2f01      	cmp	r7, #1
90002e9a:	d834      	bhi.n	90002f06 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
90002e9c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
90002e9e:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
90002ea2:	68cf      	ldr	r7, [r1, #12]
90002ea4:	fa07 f708 	lsl.w	r7, r7, r8
90002ea8:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
90002eac:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
90002eae:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
90002eb0:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
90002eb4:	f3c6 1700 	ubfx	r7, r6, #4, #1
90002eb8:	409f      	lsls	r7, r3
90002eba:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
90002ebe:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
90002ec0:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
90002ec2:	2d02      	cmp	r5, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
90002ec4:	ea07 0e0c 	and.w	lr, r7, ip
      temp |= ((GPIO_Init->Pull) << (position * 2U));
90002ec8:	688f      	ldr	r7, [r1, #8]
90002eca:	fa07 f708 	lsl.w	r7, r7, r8
90002ece:	ea47 070e 	orr.w	r7, r7, lr
      GPIOx->PUPDR = temp;
90002ed2:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
90002ed4:	d119      	bne.n	90002f0a <HAL_GPIO_Init+0xb6>
        temp = GPIOx->AFR[position >> 3U];
90002ed6:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
90002eda:	f003 0b07 	and.w	fp, r3, #7
90002ede:	f04f 0e0f 	mov.w	lr, #15
90002ee2:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
90002ee6:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3U];
90002eea:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
90002eee:	fa0e fe0b 	lsl.w	lr, lr, fp
90002ef2:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
90002ef6:	690f      	ldr	r7, [r1, #16]
90002ef8:	fa07 f70b 	lsl.w	r7, r7, fp
90002efc:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->AFR[position >> 3U] = temp;
90002f00:	f8ca 7020 	str.w	r7, [sl, #32]
90002f04:	e001      	b.n	90002f0a <HAL_GPIO_Init+0xb6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
90002f06:	2d03      	cmp	r5, #3
90002f08:	d1da      	bne.n	90002ec0 <HAL_GPIO_Init+0x6c>
      temp = GPIOx->MODER;
90002f0a:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
90002f0c:	fa05 f508 	lsl.w	r5, r5, r8
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
90002f10:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
90002f14:	ea07 070c 	and.w	r7, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
90002f18:	ea47 0705 	orr.w	r7, r7, r5
      GPIOx->MODER = temp;
90002f1c:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
90002f1e:	d06c      	beq.n	90002ffa <HAL_GPIO_Init+0x1a6>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90002f20:	f8d9 50f4 	ldr.w	r5, [r9, #244]	; 0xf4
90002f24:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
90002f28:	f003 0c03 	and.w	ip, r3, #3
90002f2c:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90002f30:	f045 0502 	orr.w	r5, r5, #2
90002f34:	f107 47b0 	add.w	r7, r7, #1476395008	; 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
90002f38:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90002f3c:	f8c9 50f4 	str.w	r5, [r9, #244]	; 0xf4
90002f40:	f507 6780 	add.w	r7, r7, #1024	; 0x400
90002f44:	f8d9 50f4 	ldr.w	r5, [r9, #244]	; 0xf4
90002f48:	f005 0502 	and.w	r5, r5, #2
90002f4c:	9501      	str	r5, [sp, #4]
90002f4e:	9d01      	ldr	r5, [sp, #4]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
90002f50:	fa0e f50c 	lsl.w	r5, lr, ip
        temp = SYSCFG->EXTICR[position >> 2U];
90002f54:	f8d7 8008 	ldr.w	r8, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
90002f58:	ea28 0e05 	bic.w	lr, r8, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
90002f5c:	4d31      	ldr	r5, [pc, #196]	; (90003024 <HAL_GPIO_Init+0x1d0>)
90002f5e:	42a8      	cmp	r0, r5
90002f60:	d04d      	beq.n	90002ffe <HAL_GPIO_Init+0x1aa>
90002f62:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f66:	42a8      	cmp	r0, r5
90002f68:	d04b      	beq.n	90003002 <HAL_GPIO_Init+0x1ae>
90002f6a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f6e:	42a8      	cmp	r0, r5
90002f70:	d049      	beq.n	90003006 <HAL_GPIO_Init+0x1b2>
90002f72:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f76:	42a8      	cmp	r0, r5
90002f78:	d047      	beq.n	9000300a <HAL_GPIO_Init+0x1b6>
90002f7a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f7e:	42a8      	cmp	r0, r5
90002f80:	d045      	beq.n	9000300e <HAL_GPIO_Init+0x1ba>
90002f82:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f86:	42a8      	cmp	r0, r5
90002f88:	d043      	beq.n	90003012 <HAL_GPIO_Init+0x1be>
90002f8a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f8e:	42a8      	cmp	r0, r5
90002f90:	d041      	beq.n	90003016 <HAL_GPIO_Init+0x1c2>
90002f92:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f96:	42a8      	cmp	r0, r5
90002f98:	d03f      	beq.n	9000301a <HAL_GPIO_Init+0x1c6>
90002f9a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002f9e:	42a8      	cmp	r0, r5
90002fa0:	d03d      	beq.n	9000301e <HAL_GPIO_Init+0x1ca>
90002fa2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90002fa6:	42a8      	cmp	r0, r5
90002fa8:	bf0c      	ite	eq
90002faa:	2509      	moveq	r5, #9
90002fac:	250a      	movne	r5, #10
90002fae:	fa05 f50c 	lsl.w	r5, r5, ip
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
90002fb2:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
90002fb6:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
90002fba:	60bd      	str	r5, [r7, #8]
        temp &= ~(iocurrent);
90002fbc:	ea6f 0702 	mvn.w	r7, r2
        temp = EXTI->RTSR1;
90002fc0:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
90002fc2:	bf0c      	ite	eq
90002fc4:	403d      	andeq	r5, r7
          temp |= iocurrent;
90002fc6:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
90002fc8:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
        EXTI->RTSR1 = temp;
90002fcc:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
90002fce:	6865      	ldr	r5, [r4, #4]
        temp &= ~(iocurrent);
90002fd0:	bf0c      	ite	eq
90002fd2:	403d      	andeq	r5, r7
          temp |= iocurrent;
90002fd4:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
90002fd6:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        EXTI->FTSR1 = temp;
90002fda:	6065      	str	r5, [r4, #4]
        temp = EXTI_CurrentCPU->EMR1;
90002fdc:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        temp &= ~(iocurrent);
90002fe0:	bf0c      	ite	eq
90002fe2:	403d      	andeq	r5, r7
          temp |= iocurrent;
90002fe4:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
90002fe6:	03f6      	lsls	r6, r6, #15
        EXTI_CurrentCPU->EMR1 = temp;
90002fe8:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI_CurrentCPU->IMR1;
90002fec:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
90002ff0:	bf54      	ite	pl
90002ff2:	403d      	andpl	r5, r7
          temp |= iocurrent;
90002ff4:	4315      	orrmi	r5, r2
        EXTI_CurrentCPU->IMR1 = temp;
90002ff6:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    position++;
90002ffa:	3301      	adds	r3, #1
90002ffc:	e731      	b.n	90002e62 <HAL_GPIO_Init+0xe>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
90002ffe:	2500      	movs	r5, #0
90003000:	e7d5      	b.n	90002fae <HAL_GPIO_Init+0x15a>
90003002:	2501      	movs	r5, #1
90003004:	e7d3      	b.n	90002fae <HAL_GPIO_Init+0x15a>
90003006:	2502      	movs	r5, #2
90003008:	e7d1      	b.n	90002fae <HAL_GPIO_Init+0x15a>
9000300a:	2503      	movs	r5, #3
9000300c:	e7cf      	b.n	90002fae <HAL_GPIO_Init+0x15a>
9000300e:	2504      	movs	r5, #4
90003010:	e7cd      	b.n	90002fae <HAL_GPIO_Init+0x15a>
90003012:	2505      	movs	r5, #5
90003014:	e7cb      	b.n	90002fae <HAL_GPIO_Init+0x15a>
90003016:	2506      	movs	r5, #6
90003018:	e7c9      	b.n	90002fae <HAL_GPIO_Init+0x15a>
9000301a:	2507      	movs	r5, #7
9000301c:	e7c7      	b.n	90002fae <HAL_GPIO_Init+0x15a>
9000301e:	2508      	movs	r5, #8
90003020:	e7c5      	b.n	90002fae <HAL_GPIO_Init+0x15a>
90003022:	bf00      	nop
90003024:	58020000 	.word	0x58020000
90003028:	58024400 	.word	0x58024400

9000302c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
9000302c:	b10a      	cbz	r2, 90003032 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
9000302e:	6181      	str	r1, [r0, #24]
  }
}
90003030:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
90003032:	0409      	lsls	r1, r1, #16
90003034:	e7fb      	b.n	9000302e <HAL_GPIO_WritePin+0x2>
	...

90003038 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
90003038:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
9000303a:	4c10      	ldr	r4, [pc, #64]	; (9000307c <HAL_PWREx_ConfigSupply+0x44>)
9000303c:	68e3      	ldr	r3, [r4, #12]
9000303e:	f013 0f04 	tst.w	r3, #4
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
90003042:	68e3      	ldr	r3, [r4, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
90003044:	d105      	bne.n	90003052 <HAL_PWREx_ConfigSupply+0x1a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
90003046:	f003 0307 	and.w	r3, r3, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
9000304a:	1a18      	subs	r0, r3, r0
9000304c:	bf18      	it	ne
9000304e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
90003050:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
90003052:	f023 0307 	bic.w	r3, r3, #7
90003056:	4318      	orrs	r0, r3
90003058:	60e0      	str	r0, [r4, #12]
  tickstart = HAL_GetTick ();
9000305a:	f7fe fe57 	bl	90001d0c <HAL_GetTick>
9000305e:	4605      	mov	r5, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
90003060:	6863      	ldr	r3, [r4, #4]
90003062:	049b      	lsls	r3, r3, #18
90003064:	d501      	bpl.n	9000306a <HAL_PWREx_ConfigSupply+0x32>
  return HAL_OK;
90003066:	2000      	movs	r0, #0
90003068:	e7f2      	b.n	90003050 <HAL_PWREx_ConfigSupply+0x18>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
9000306a:	f7fe fe4f 	bl	90001d0c <HAL_GetTick>
9000306e:	1b40      	subs	r0, r0, r5
90003070:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
90003074:	d9f4      	bls.n	90003060 <HAL_PWREx_ConfigSupply+0x28>
      return HAL_ERROR;
90003076:	2001      	movs	r0, #1
90003078:	e7ea      	b.n	90003050 <HAL_PWREx_ConfigSupply+0x18>
9000307a:	bf00      	nop
9000307c:	58024800 	.word	0x58024800

90003080 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
90003080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
90003084:	6a4e      	ldr	r6, [r1, #36]	; 0x24
90003086:	b136      	cbz	r6, 90003096 <QSPI_Config+0x16>
90003088:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
9000308c:	d003      	beq.n	90003096 <QSPI_Config+0x16>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
9000308e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
90003090:	6804      	ldr	r4, [r0, #0]
90003092:	3b01      	subs	r3, #1
90003094:	6123      	str	r3, [r4, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
90003096:	f8d1 9018 	ldr.w	r9, [r1, #24]
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
9000309a:	e9d1 7507 	ldrd	r7, r5, [r1, #28]
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
9000309e:	f1b9 0f00 	cmp.w	r9, #0
900030a2:	d04f      	beq.n	90003144 <QSPI_Config+0xc4>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030a4:	694b      	ldr	r3, [r1, #20]
900030a6:	ea46 0909 	orr.w	r9, r6, r9
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
900030aa:	6800      	ldr	r0, [r0, #0]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030ac:	f8d1 a000 	ldr.w	sl, [r1]
900030b0:	ea4f 4c83 	mov.w	ip, r3, lsl #18
900030b4:	f8d1 e034 	ldr.w	lr, [r1, #52]	; 0x34
900030b8:	ea49 0902 	orr.w	r9, r9, r2
900030bc:	e9d1 480b 	ldrd	r4, r8, [r1, #44]	; 0x2c
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
900030c0:	b335      	cbz	r5, 90003110 <QSPI_Config+0x90>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
900030c2:	688b      	ldr	r3, [r1, #8]
900030c4:	ea49 0505 	orr.w	r5, r9, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030c8:	690e      	ldr	r6, [r1, #16]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
900030ca:	61c3      	str	r3, [r0, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
900030cc:	b19f      	cbz	r7, 900030f6 <QSPI_Config+0x76>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030ce:	ea4a 0307 	orr.w	r3, sl, r7
900030d2:	4323      	orrs	r3, r4
900030d4:	68cc      	ldr	r4, [r1, #12]
900030d6:	ea43 0308 	orr.w	r3, r3, r8
900030da:	ea43 030e 	orr.w	r3, r3, lr
900030de:	4333      	orrs	r3, r6
900030e0:	4323      	orrs	r3, r4
900030e2:	ea43 030c 	orr.w	r3, r3, ip
900030e6:	432b      	orrs	r3, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateByteMode | cmd->AddressSize |
                                         cmd->AddressMode | cmd->InstructionMode | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
900030e8:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030ec:	6143      	str	r3, [r0, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
900030ee:	d00d      	beq.n	9000310c <QSPI_Config+0x8c>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
900030f0:	684b      	ldr	r3, [r1, #4]
900030f2:	6183      	str	r3, [r0, #24]
900030f4:	e00a      	b.n	9000310c <QSPI_Config+0x8c>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900030f6:	ea4a 0304 	orr.w	r3, sl, r4
900030fa:	ea43 0308 	orr.w	r3, r3, r8
900030fe:	ea43 030e 	orr.w	r3, r3, lr
90003102:	4333      	orrs	r3, r6
90003104:	ea43 030c 	orr.w	r3, r3, ip
90003108:	432b      	orrs	r3, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
9000310a:	6143      	str	r3, [r0, #20]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
9000310c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
90003110:	b16f      	cbz	r7, 9000312e <QSPI_Config+0xae>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
90003112:	ea4a 0307 	orr.w	r3, sl, r7
90003116:	4323      	orrs	r3, r4
90003118:	68cc      	ldr	r4, [r1, #12]
9000311a:	ea43 0308 	orr.w	r3, r3, r8
9000311e:	ea43 030e 	orr.w	r3, r3, lr
90003122:	4323      	orrs	r3, r4
90003124:	ea43 030c 	orr.w	r3, r3, ip
90003128:	ea43 0309 	orr.w	r3, r3, r9
9000312c:	e7dc      	b.n	900030e8 <QSPI_Config+0x68>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
9000312e:	ea4a 0304 	orr.w	r3, sl, r4
90003132:	ea43 0308 	orr.w	r3, r3, r8
90003136:	ea43 030e 	orr.w	r3, r3, lr
9000313a:	ea43 030c 	orr.w	r3, r3, ip
9000313e:	ea43 0309 	orr.w	r3, r3, r9
90003142:	e7e2      	b.n	9000310a <QSPI_Config+0x8a>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
90003144:	b365      	cbz	r5, 900031a0 <QSPI_Config+0x120>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
90003146:	6804      	ldr	r4, [r0, #0]
90003148:	688b      	ldr	r3, [r1, #8]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
9000314a:	6908      	ldr	r0, [r1, #16]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
9000314c:	61e3      	str	r3, [r4, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
9000314e:	ea46 0305 	orr.w	r3, r6, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
90003152:	694e      	ldr	r6, [r1, #20]
90003154:	ea43 0502 	orr.w	r5, r3, r2
90003158:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
9000315c:	04b6      	lsls	r6, r6, #18
9000315e:	e9d1 830b 	ldrd	r8, r3, [r1, #44]	; 0x2c
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
90003162:	b1a7      	cbz	r7, 9000318e <QSPI_Config+0x10e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
90003164:	4338      	orrs	r0, r7
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
90003166:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
9000316a:	ea40 0008 	orr.w	r0, r0, r8
9000316e:	ea43 0300 	orr.w	r3, r3, r0
90003172:	68c8      	ldr	r0, [r1, #12]
90003174:	ea43 030c 	orr.w	r3, r3, ip
90003178:	ea43 0300 	orr.w	r3, r3, r0
9000317c:	ea43 0306 	orr.w	r3, r3, r6
90003180:	ea43 0305 	orr.w	r3, r3, r5
90003184:	6163      	str	r3, [r4, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
90003186:	d0c1      	beq.n	9000310c <QSPI_Config+0x8c>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
90003188:	684b      	ldr	r3, [r1, #4]
9000318a:	61a3      	str	r3, [r4, #24]
9000318c:	e7be      	b.n	9000310c <QSPI_Config+0x8c>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
9000318e:	ea40 0008 	orr.w	r0, r0, r8
90003192:	4303      	orrs	r3, r0
90003194:	ea43 030c 	orr.w	r3, r3, ip
90003198:	4333      	orrs	r3, r6
9000319a:	432b      	orrs	r3, r5
9000319c:	6163      	str	r3, [r4, #20]
9000319e:	e7b5      	b.n	9000310c <QSPI_Config+0x8c>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
900031a0:	b17f      	cbz	r7, 900031c2 <QSPI_Config+0x142>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900031a2:	ea46 0307 	orr.w	r3, r6, r7
900031a6:	6acc      	ldr	r4, [r1, #44]	; 0x2c
900031a8:	6800      	ldr	r0, [r0, #0]
900031aa:	4313      	orrs	r3, r2
900031ac:	4323      	orrs	r3, r4
900031ae:	6b0c      	ldr	r4, [r1, #48]	; 0x30
900031b0:	4323      	orrs	r3, r4
900031b2:	6b4c      	ldr	r4, [r1, #52]	; 0x34
900031b4:	4323      	orrs	r3, r4
900031b6:	68cc      	ldr	r4, [r1, #12]
900031b8:	4323      	orrs	r3, r4
900031ba:	694c      	ldr	r4, [r1, #20]
900031bc:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
900031c0:	e792      	b.n	900030e8 <QSPI_Config+0x68>
        if (cmd->DataMode != QSPI_DATA_NONE)
900031c2:	2e00      	cmp	r6, #0
900031c4:	d0a2      	beq.n	9000310c <QSPI_Config+0x8c>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
900031c6:	6acb      	ldr	r3, [r1, #44]	; 0x2c
900031c8:	6800      	ldr	r0, [r0, #0]
900031ca:	4333      	orrs	r3, r6
900031cc:	6b0e      	ldr	r6, [r1, #48]	; 0x30
900031ce:	431a      	orrs	r2, r3
900031d0:	694b      	ldr	r3, [r1, #20]
900031d2:	4332      	orrs	r2, r6
900031d4:	6b4e      	ldr	r6, [r1, #52]	; 0x34
900031d6:	4332      	orrs	r2, r6
900031d8:	ea42 4283 	orr.w	r2, r2, r3, lsl #18
900031dc:	6142      	str	r2, [r0, #20]
}
900031de:	e795      	b.n	9000310c <QSPI_Config+0x8c>

900031e0 <QSPI_WaitFlagStateUntilTimeout>:
{
900031e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900031e4:	f8dd 8018 	ldr.w	r8, [sp, #24]
900031e8:	4604      	mov	r4, r0
900031ea:	460e      	mov	r6, r1
900031ec:	4615      	mov	r5, r2
900031ee:	461f      	mov	r7, r3
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
900031f0:	6822      	ldr	r2, [r4, #0]
900031f2:	6893      	ldr	r3, [r2, #8]
900031f4:	4233      	tst	r3, r6
900031f6:	bf14      	ite	ne
900031f8:	2301      	movne	r3, #1
900031fa:	2300      	moveq	r3, #0
900031fc:	42ab      	cmp	r3, r5
900031fe:	d101      	bne.n	90003204 <QSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
90003200:	2000      	movs	r0, #0
90003202:	e012      	b.n	9000322a <QSPI_WaitFlagStateUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
90003204:	f1b8 3fff 	cmp.w	r8, #4294967295
90003208:	d0f3      	beq.n	900031f2 <QSPI_WaitFlagStateUntilTimeout+0x12>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
9000320a:	f7fe fd7f 	bl	90001d0c <HAL_GetTick>
9000320e:	1bc0      	subs	r0, r0, r7
90003210:	4540      	cmp	r0, r8
90003212:	d802      	bhi.n	9000321a <QSPI_WaitFlagStateUntilTimeout+0x3a>
90003214:	f1b8 0f00 	cmp.w	r8, #0
90003218:	d1ea      	bne.n	900031f0 <QSPI_WaitFlagStateUntilTimeout+0x10>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
9000321a:	2304      	movs	r3, #4
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
9000321c:	2001      	movs	r0, #1
        hqspi->State     = HAL_QSPI_STATE_ERROR;
9000321e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
90003222:	6c63      	ldr	r3, [r4, #68]	; 0x44
90003224:	f043 0301 	orr.w	r3, r3, #1
90003228:	6463      	str	r3, [r4, #68]	; 0x44
}
9000322a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

90003230 <HAL_QSPI_Init>:
{
90003230:	b530      	push	{r4, r5, lr}
90003232:	4604      	mov	r4, r0
90003234:	b085      	sub	sp, #20
  uint32_t tickstart = HAL_GetTick();
90003236:	f7fe fd69 	bl	90001d0c <HAL_GetTick>
9000323a:	4603      	mov	r3, r0
  if(hqspi == NULL)
9000323c:	2c00      	cmp	r4, #0
9000323e:	d040      	beq.n	900032c2 <HAL_QSPI_Init+0x92>
  if(hqspi->State == HAL_QSPI_STATE_RESET)
90003240:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
90003244:	b93a      	cbnz	r2, 90003256 <HAL_QSPI_Init+0x26>
90003246:	9003      	str	r0, [sp, #12]
    HAL_QSPI_MspInit(hqspi);
90003248:	4620      	mov	r0, r4
9000324a:	f7fd fb29 	bl	900008a0 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
9000324e:	f241 3288 	movw	r2, #5000	; 0x1388
90003252:	9b03      	ldr	r3, [sp, #12]
90003254:	64a2      	str	r2, [r4, #72]	; 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
90003256:	6820      	ldr	r0, [r4, #0]
90003258:	68a1      	ldr	r1, [r4, #8]
9000325a:	6802      	ldr	r2, [r0, #0]
9000325c:	3901      	subs	r1, #1
9000325e:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
90003262:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
90003266:	2120      	movs	r1, #32
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
90003268:	6002      	str	r2, [r0, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
9000326a:	4620      	mov	r0, r4
9000326c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
9000326e:	9200      	str	r2, [sp, #0]
90003270:	2200      	movs	r2, #0
90003272:	f7ff ffb5 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
90003276:	bb10      	cbnz	r0, 900032be <HAL_QSPI_Init+0x8e>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
90003278:	6822      	ldr	r2, [r4, #0]
9000327a:	69e5      	ldr	r5, [r4, #28]
9000327c:	68e3      	ldr	r3, [r4, #12]
9000327e:	6811      	ldr	r1, [r2, #0]
90003280:	432b      	orrs	r3, r5
90003282:	6a25      	ldr	r5, [r4, #32]
90003284:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
90003288:	432b      	orrs	r3, r5
9000328a:	6865      	ldr	r5, [r4, #4]
9000328c:	f021 01d0 	bic.w	r1, r1, #208	; 0xd0
90003290:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
90003294:	430b      	orrs	r3, r1
90003296:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
90003298:	6855      	ldr	r5, [r2, #4]
9000329a:	e9d4 3105 	ldrd	r3, r1, [r4, #20]
9000329e:	430b      	orrs	r3, r1
900032a0:	6921      	ldr	r1, [r4, #16]
900032a2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
900032a6:	4908      	ldr	r1, [pc, #32]	; (900032c8 <HAL_QSPI_Init+0x98>)
900032a8:	4029      	ands	r1, r5
900032aa:	430b      	orrs	r3, r1
900032ac:	6053      	str	r3, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
900032ae:	6813      	ldr	r3, [r2, #0]
900032b0:	f043 0301 	orr.w	r3, r3, #1
900032b4:	6013      	str	r3, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
900032b6:	2301      	movs	r3, #1
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
900032b8:	6460      	str	r0, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
900032ba:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
}
900032be:	b005      	add	sp, #20
900032c0:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
900032c2:	2001      	movs	r0, #1
900032c4:	e7fb      	b.n	900032be <HAL_QSPI_Init+0x8e>
900032c6:	bf00      	nop
900032c8:	ffe0f8fe 	.word	0xffe0f8fe

900032cc <HAL_QSPI_Command>:
{
900032cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
900032d0:	4604      	mov	r4, r0
900032d2:	b085      	sub	sp, #20
900032d4:	4617      	mov	r7, r2
900032d6:	4689      	mov	r9, r1
  uint32_t tickstart = HAL_GetTick();
900032d8:	f7fe fd18 	bl	90001d0c <HAL_GetTick>
  __HAL_LOCK(hqspi);
900032dc:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
900032e0:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
900032e2:	2a01      	cmp	r2, #1
900032e4:	d033      	beq.n	9000334e <HAL_QSPI_Command+0x82>
900032e6:	2201      	movs	r2, #1
900032e8:	2602      	movs	r6, #2
900032ea:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
900032ee:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
900032f2:	2a01      	cmp	r2, #1
900032f4:	fa5f f882 	uxtb.w	r8, r2
900032f8:	d127      	bne.n	9000334a <HAL_QSPI_Command+0x7e>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
900032fa:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
900032fc:	9003      	str	r0, [sp, #12]
900032fe:	2120      	movs	r1, #32
90003300:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
90003302:	6462      	str	r2, [r4, #68]	; 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
90003304:	9700      	str	r7, [sp, #0]
    hqspi->State = HAL_QSPI_STATE_BUSY;
90003306:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
9000330a:	f7ff ff69 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
9000330e:	4605      	mov	r5, r0
90003310:	b9a0      	cbnz	r0, 9000333c <HAL_QSPI_Command+0x70>
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
90003312:	4602      	mov	r2, r0
90003314:	4649      	mov	r1, r9
90003316:	4620      	mov	r0, r4
90003318:	f7ff feb2 	bl	90003080 <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
9000331c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
90003320:	9b03      	ldr	r3, [sp, #12]
90003322:	b94a      	cbnz	r2, 90003338 <HAL_QSPI_Command+0x6c>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
90003324:	4642      	mov	r2, r8
90003326:	4631      	mov	r1, r6
90003328:	4620      	mov	r0, r4
9000332a:	9700      	str	r7, [sp, #0]
9000332c:	f7ff ff58 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
90003330:	4605      	mov	r5, r0
90003332:	b918      	cbnz	r0, 9000333c <HAL_QSPI_Command+0x70>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
90003334:	6823      	ldr	r3, [r4, #0]
90003336:	60de      	str	r6, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
90003338:	f884 8041 	strb.w	r8, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
9000333c:	2300      	movs	r3, #0
9000333e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
90003342:	4628      	mov	r0, r5
90003344:	b005      	add	sp, #20
90003346:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    status = HAL_BUSY;
9000334a:	4635      	mov	r5, r6
9000334c:	e7f6      	b.n	9000333c <HAL_QSPI_Command+0x70>
  __HAL_LOCK(hqspi);
9000334e:	2502      	movs	r5, #2
90003350:	e7f7      	b.n	90003342 <HAL_QSPI_Command+0x76>

90003352 <HAL_QSPI_Transmit>:
{
90003352:	b5f0      	push	{r4, r5, r6, r7, lr}
90003354:	4604      	mov	r4, r0
90003356:	b085      	sub	sp, #20
90003358:	4616      	mov	r6, r2
9000335a:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
9000335c:	f7fe fcd6 	bl	90001d0c <HAL_GetTick>
  __HAL_LOCK(hqspi);
90003360:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
90003364:	4603      	mov	r3, r0
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
90003366:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hqspi);
90003368:	2a01      	cmp	r2, #1
9000336a:	d049      	beq.n	90003400 <HAL_QSPI_Transmit+0xae>
9000336c:	2201      	movs	r2, #1
9000336e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
90003372:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
90003376:	2a01      	cmp	r2, #1
90003378:	b2d0      	uxtb	r0, r2
9000337a:	d13f      	bne.n	900033fc <HAL_QSPI_Transmit+0xaa>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
9000337c:	2200      	movs	r2, #0
9000337e:	6462      	str	r2, [r4, #68]	; 0x44
    if(pData != NULL )
90003380:	2f00      	cmp	r7, #0
90003382:	d036      	beq.n	900033f2 <HAL_QSPI_Transmit+0xa0>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
90003384:	2212      	movs	r2, #18
90003386:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
9000338a:	692a      	ldr	r2, [r5, #16]
9000338c:	3201      	adds	r2, #1
9000338e:	62e2      	str	r2, [r4, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
90003390:	692a      	ldr	r2, [r5, #16]
      hqspi->pTxBuffPtr = pData;
90003392:	6267      	str	r7, [r4, #36]	; 0x24
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
90003394:	3201      	adds	r2, #1
90003396:	62a2      	str	r2, [r4, #40]	; 0x28
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
90003398:	696a      	ldr	r2, [r5, #20]
9000339a:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
9000339e:	616a      	str	r2, [r5, #20]
      while(hqspi->TxXferCount > 0U)
900033a0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
900033a2:	b98a      	cbnz	r2, 900033c8 <HAL_QSPI_Transmit+0x76>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
900033a4:	2201      	movs	r2, #1
900033a6:	2102      	movs	r1, #2
900033a8:	4620      	mov	r0, r4
900033aa:	9600      	str	r6, [sp, #0]
900033ac:	f7ff ff18 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
900033b0:	b910      	cbnz	r0, 900033b8 <HAL_QSPI_Transmit+0x66>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
900033b2:	6823      	ldr	r3, [r4, #0]
900033b4:	2202      	movs	r2, #2
900033b6:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
900033b8:	2301      	movs	r3, #1
900033ba:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
900033be:	2300      	movs	r3, #0
900033c0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
900033c4:	b005      	add	sp, #20
900033c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
900033c8:	2201      	movs	r2, #1
900033ca:	2104      	movs	r1, #4
900033cc:	4620      	mov	r0, r4
900033ce:	9600      	str	r6, [sp, #0]
900033d0:	9303      	str	r3, [sp, #12]
900033d2:	f7ff ff05 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
900033d6:	2800      	cmp	r0, #0
900033d8:	d1ee      	bne.n	900033b8 <HAL_QSPI_Transmit+0x66>
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
900033da:	6a62      	ldr	r2, [r4, #36]	; 0x24
        hqspi->TxXferCount--;
900033dc:	9b03      	ldr	r3, [sp, #12]
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
900033de:	7812      	ldrb	r2, [r2, #0]
900033e0:	f885 2020 	strb.w	r2, [r5, #32]
        hqspi->pTxBuffPtr++;
900033e4:	6a62      	ldr	r2, [r4, #36]	; 0x24
900033e6:	3201      	adds	r2, #1
900033e8:	6262      	str	r2, [r4, #36]	; 0x24
        hqspi->TxXferCount--;
900033ea:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
900033ec:	3a01      	subs	r2, #1
900033ee:	62e2      	str	r2, [r4, #44]	; 0x2c
900033f0:	e7d6      	b.n	900033a0 <HAL_QSPI_Transmit+0x4e>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
900033f2:	6c63      	ldr	r3, [r4, #68]	; 0x44
900033f4:	f043 0308 	orr.w	r3, r3, #8
900033f8:	6463      	str	r3, [r4, #68]	; 0x44
      status = HAL_ERROR;
900033fa:	e7e0      	b.n	900033be <HAL_QSPI_Transmit+0x6c>
    status = HAL_BUSY;
900033fc:	2002      	movs	r0, #2
900033fe:	e7de      	b.n	900033be <HAL_QSPI_Transmit+0x6c>
  __HAL_LOCK(hqspi);
90003400:	2002      	movs	r0, #2
90003402:	e7df      	b.n	900033c4 <HAL_QSPI_Transmit+0x72>

90003404 <HAL_QSPI_Receive>:
{
90003404:	b5f0      	push	{r4, r5, r6, r7, lr}
90003406:	4604      	mov	r4, r0
90003408:	b085      	sub	sp, #20
9000340a:	4616      	mov	r6, r2
9000340c:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
9000340e:	f7fe fc7d 	bl	90001d0c <HAL_GetTick>
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
90003412:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
90003414:	4603      	mov	r3, r0
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
90003416:	f8d5 c018 	ldr.w	ip, [r5, #24]
  __HAL_LOCK(hqspi);
9000341a:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
9000341e:	2a01      	cmp	r2, #1
90003420:	d04d      	beq.n	900034be <HAL_QSPI_Receive+0xba>
90003422:	2201      	movs	r2, #1
90003424:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
90003428:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
9000342c:	2a01      	cmp	r2, #1
9000342e:	b2d0      	uxtb	r0, r2
90003430:	d143      	bne.n	900034ba <HAL_QSPI_Receive+0xb6>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
90003432:	2200      	movs	r2, #0
90003434:	6462      	str	r2, [r4, #68]	; 0x44
    if(pData != NULL )
90003436:	2f00      	cmp	r7, #0
90003438:	d03a      	beq.n	900034b0 <HAL_QSPI_Receive+0xac>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
9000343a:	2222      	movs	r2, #34	; 0x22
9000343c:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
90003440:	692a      	ldr	r2, [r5, #16]
90003442:	3201      	adds	r2, #1
90003444:	63a2      	str	r2, [r4, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
90003446:	692a      	ldr	r2, [r5, #16]
      hqspi->pRxBuffPtr = pData;
90003448:	6327      	str	r7, [r4, #48]	; 0x30
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
9000344a:	3201      	adds	r2, #1
9000344c:	6362      	str	r2, [r4, #52]	; 0x34
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
9000344e:	6969      	ldr	r1, [r5, #20]
90003450:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
90003454:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
90003458:	6169      	str	r1, [r5, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
9000345a:	f8c5 c018 	str.w	ip, [r5, #24]
      while(hqspi->RxXferCount > 0U)
9000345e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90003460:	b98a      	cbnz	r2, 90003486 <HAL_QSPI_Receive+0x82>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
90003462:	2201      	movs	r2, #1
90003464:	2102      	movs	r1, #2
90003466:	4620      	mov	r0, r4
90003468:	9600      	str	r6, [sp, #0]
9000346a:	f7ff feb9 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
        if  (status == HAL_OK)
9000346e:	b910      	cbnz	r0, 90003476 <HAL_QSPI_Receive+0x72>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
90003470:	6823      	ldr	r3, [r4, #0]
90003472:	2202      	movs	r2, #2
90003474:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
90003476:	2301      	movs	r3, #1
90003478:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
9000347c:	2300      	movs	r3, #0
9000347e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
90003482:	b005      	add	sp, #20
90003484:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
90003486:	2201      	movs	r2, #1
90003488:	2106      	movs	r1, #6
9000348a:	4620      	mov	r0, r4
9000348c:	9600      	str	r6, [sp, #0]
9000348e:	9303      	str	r3, [sp, #12]
90003490:	f7ff fea6 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
        if  (status != HAL_OK)
90003494:	2800      	cmp	r0, #0
90003496:	d1ee      	bne.n	90003476 <HAL_QSPI_Receive+0x72>
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
90003498:	f895 1020 	ldrb.w	r1, [r5, #32]
9000349c:	6b22      	ldr	r2, [r4, #48]	; 0x30
        hqspi->RxXferCount--;
9000349e:	9b03      	ldr	r3, [sp, #12]
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
900034a0:	7011      	strb	r1, [r2, #0]
        hqspi->pRxBuffPtr++;
900034a2:	6b22      	ldr	r2, [r4, #48]	; 0x30
900034a4:	3201      	adds	r2, #1
900034a6:	6322      	str	r2, [r4, #48]	; 0x30
        hqspi->RxXferCount--;
900034a8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
900034aa:	3a01      	subs	r2, #1
900034ac:	63a2      	str	r2, [r4, #56]	; 0x38
900034ae:	e7d6      	b.n	9000345e <HAL_QSPI_Receive+0x5a>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
900034b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
900034b2:	f043 0308 	orr.w	r3, r3, #8
900034b6:	6463      	str	r3, [r4, #68]	; 0x44
      status = HAL_ERROR;
900034b8:	e7e0      	b.n	9000347c <HAL_QSPI_Receive+0x78>
    status = HAL_BUSY;
900034ba:	2002      	movs	r0, #2
900034bc:	e7de      	b.n	9000347c <HAL_QSPI_Receive+0x78>
  __HAL_LOCK(hqspi);
900034be:	2002      	movs	r0, #2
900034c0:	e7df      	b.n	90003482 <HAL_QSPI_Receive+0x7e>

900034c2 <HAL_QSPI_MemoryMapped>:
{
900034c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
900034c4:	4604      	mov	r4, r0
900034c6:	4616      	mov	r6, r2
900034c8:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
900034ca:	f7fe fc1f 	bl	90001d0c <HAL_GetTick>
  __HAL_LOCK(hqspi);
900034ce:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
900034d2:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
900034d4:	2a01      	cmp	r2, #1
900034d6:	d033      	beq.n	90003540 <HAL_QSPI_MemoryMapped+0x7e>
900034d8:	2201      	movs	r2, #1
900034da:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
900034de:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
900034e2:	2a01      	cmp	r2, #1
900034e4:	d12a      	bne.n	9000353c <HAL_QSPI_MemoryMapped+0x7a>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
900034e6:	2200      	movs	r2, #0
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
900034e8:	2182      	movs	r1, #130	; 0x82
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
900034ea:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
900034ec:	6462      	str	r2, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
900034ee:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
900034f2:	6ca1      	ldr	r1, [r4, #72]	; 0x48
900034f4:	9100      	str	r1, [sp, #0]
900034f6:	2120      	movs	r1, #32
900034f8:	f7ff fe72 	bl	900031e0 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
900034fc:	4605      	mov	r5, r0
900034fe:	b9b8      	cbnz	r0, 90003530 <HAL_QSPI_MemoryMapped+0x6e>
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
90003500:	6823      	ldr	r3, [r4, #0]
90003502:	6872      	ldr	r2, [r6, #4]
90003504:	6818      	ldr	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
90003506:	2a08      	cmp	r2, #8
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
90003508:	f020 0008 	bic.w	r0, r0, #8
9000350c:	ea40 0002 	orr.w	r0, r0, r2
90003510:	6018      	str	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
90003512:	d107      	bne.n	90003524 <HAL_QSPI_MemoryMapped+0x62>
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
90003514:	6832      	ldr	r2, [r6, #0]
90003516:	631a      	str	r2, [r3, #48]	; 0x30
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
90003518:	2210      	movs	r2, #16
9000351a:	60da      	str	r2, [r3, #12]
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
9000351c:	681a      	ldr	r2, [r3, #0]
9000351e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
90003522:	601a      	str	r2, [r3, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
90003524:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
90003528:	4639      	mov	r1, r7
9000352a:	4620      	mov	r0, r4
9000352c:	f7ff fda8 	bl	90003080 <QSPI_Config>
  __HAL_UNLOCK(hqspi);
90003530:	2300      	movs	r3, #0
90003532:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
90003536:	4628      	mov	r0, r5
90003538:	b003      	add	sp, #12
9000353a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_BUSY;
9000353c:	2502      	movs	r5, #2
9000353e:	e7f7      	b.n	90003530 <HAL_QSPI_MemoryMapped+0x6e>
  __HAL_LOCK(hqspi);
90003540:	2502      	movs	r5, #2
90003542:	e7f8      	b.n	90003536 <HAL_QSPI_MemoryMapped+0x74>

90003544 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
90003544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
90003546:	4604      	mov	r4, r0
90003548:	b908      	cbnz	r0, 9000354e <HAL_RCC_OscConfig+0xa>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
      {
        return HAL_ERROR;
9000354a:	2001      	movs	r0, #1
9000354c:	e08b      	b.n	90003666 <HAL_RCC_OscConfig+0x122>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
9000354e:	6803      	ldr	r3, [r0, #0]
90003550:	07df      	lsls	r7, r3, #31
90003552:	d45e      	bmi.n	90003612 <HAL_RCC_OscConfig+0xce>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
90003554:	6823      	ldr	r3, [r4, #0]
90003556:	079e      	lsls	r6, r3, #30
90003558:	f100 80af 	bmi.w	900036ba <HAL_RCC_OscConfig+0x176>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
9000355c:	6823      	ldr	r3, [r4, #0]
9000355e:	06da      	lsls	r2, r3, #27
90003560:	d527      	bpl.n	900035b2 <HAL_RCC_OscConfig+0x6e>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
90003562:	4b9e      	ldr	r3, [pc, #632]	; (900037dc <HAL_RCC_OscConfig+0x298>)
90003564:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
90003566:	6a99      	ldr	r1, [r3, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
90003568:	f002 0238 	and.w	r2, r2, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
9000356c:	2a08      	cmp	r2, #8
9000356e:	d007      	beq.n	90003580 <HAL_RCC_OscConfig+0x3c>
90003570:	2a18      	cmp	r2, #24
90003572:	f040 8107 	bne.w	90003784 <HAL_RCC_OscConfig+0x240>
90003576:	f001 0203 	and.w	r2, r1, #3
9000357a:	2a01      	cmp	r2, #1
9000357c:	f040 8102 	bne.w	90003784 <HAL_RCC_OscConfig+0x240>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
90003580:	681b      	ldr	r3, [r3, #0]
90003582:	05db      	lsls	r3, r3, #23
90003584:	d502      	bpl.n	9000358c <HAL_RCC_OscConfig+0x48>
90003586:	69e3      	ldr	r3, [r4, #28]
90003588:	2b80      	cmp	r3, #128	; 0x80
9000358a:	d1de      	bne.n	9000354a <HAL_RCC_OscConfig+0x6>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
9000358c:	f7fe fbd6 	bl	90001d3c <HAL_GetREVID>
90003590:	f241 0303 	movw	r3, #4099	; 0x1003
90003594:	6a21      	ldr	r1, [r4, #32]
90003596:	4298      	cmp	r0, r3
90003598:	4b90      	ldr	r3, [pc, #576]	; (900037dc <HAL_RCC_OscConfig+0x298>)
9000359a:	f200 80ec 	bhi.w	90003776 <HAL_RCC_OscConfig+0x232>
9000359e:	685a      	ldr	r2, [r3, #4]
900035a0:	2920      	cmp	r1, #32
900035a2:	f022 42f8 	bic.w	r2, r2, #2080374784	; 0x7c000000
900035a6:	bf0c      	ite	eq
900035a8:	f042 4280 	orreq.w	r2, r2, #1073741824	; 0x40000000
900035ac:	ea42 6281 	orrne.w	r2, r2, r1, lsl #26
900035b0:	605a      	str	r2, [r3, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
900035b2:	6823      	ldr	r3, [r4, #0]
900035b4:	0719      	lsls	r1, r3, #28
900035b6:	f100 8127 	bmi.w	90003808 <HAL_RCC_OscConfig+0x2c4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
900035ba:	6823      	ldr	r3, [r4, #0]
900035bc:	069a      	lsls	r2, r3, #26
900035be:	f100 8148 	bmi.w	90003852 <HAL_RCC_OscConfig+0x30e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
900035c2:	6823      	ldr	r3, [r4, #0]
900035c4:	075d      	lsls	r5, r3, #29
900035c6:	d51e      	bpl.n	90003606 <HAL_RCC_OscConfig+0xc2>
    PWR->CR1 |= PWR_CR1_DBP;
900035c8:	4d85      	ldr	r5, [pc, #532]	; (900037e0 <HAL_RCC_OscConfig+0x29c>)
900035ca:	682b      	ldr	r3, [r5, #0]
900035cc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900035d0:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
900035d2:	f7fe fb9b 	bl	90001d0c <HAL_GetTick>
900035d6:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
900035d8:	682b      	ldr	r3, [r5, #0]
900035da:	05da      	lsls	r2, r3, #23
900035dc:	f140 815e 	bpl.w	9000389c <HAL_RCC_OscConfig+0x358>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
900035e0:	68a3      	ldr	r3, [r4, #8]
900035e2:	4d7e      	ldr	r5, [pc, #504]	; (900037dc <HAL_RCC_OscConfig+0x298>)
900035e4:	2b01      	cmp	r3, #1
900035e6:	f040 8160 	bne.w	900038aa <HAL_RCC_OscConfig+0x366>
900035ea:	6f2b      	ldr	r3, [r5, #112]	; 0x70
900035ec:	f043 0301 	orr.w	r3, r3, #1
900035f0:	672b      	str	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900035f2:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
900035f6:	f7fe fb89 	bl	90001d0c <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
900035fa:	4e78      	ldr	r6, [pc, #480]	; (900037dc <HAL_RCC_OscConfig+0x298>)
      tickstart = HAL_GetTick();
900035fc:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
900035fe:	6f33      	ldr	r3, [r6, #112]	; 0x70
90003600:	079b      	lsls	r3, r3, #30
90003602:	f140 8178 	bpl.w	900038f6 <HAL_RCC_OscConfig+0x3b2>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
90003606:	6a60      	ldr	r0, [r4, #36]	; 0x24
90003608:	2800      	cmp	r0, #0
9000360a:	f040 817b 	bne.w	90003904 <HAL_RCC_OscConfig+0x3c0>
      }
    }
  }
  return HAL_OK;
9000360e:	2000      	movs	r0, #0
90003610:	e029      	b.n	90003666 <HAL_RCC_OscConfig+0x122>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
90003612:	4b72      	ldr	r3, [pc, #456]	; (900037dc <HAL_RCC_OscConfig+0x298>)
90003614:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
90003616:	6a99      	ldr	r1, [r3, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
90003618:	f002 0238 	and.w	r2, r2, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
9000361c:	2a10      	cmp	r2, #16
9000361e:	d005      	beq.n	9000362c <HAL_RCC_OscConfig+0xe8>
90003620:	2a18      	cmp	r2, #24
90003622:	d10a      	bne.n	9000363a <HAL_RCC_OscConfig+0xf6>
90003624:	f001 0203 	and.w	r2, r1, #3
90003628:	2a02      	cmp	r2, #2
9000362a:	d106      	bne.n	9000363a <HAL_RCC_OscConfig+0xf6>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
9000362c:	681b      	ldr	r3, [r3, #0]
9000362e:	039d      	lsls	r5, r3, #14
90003630:	d590      	bpl.n	90003554 <HAL_RCC_OscConfig+0x10>
90003632:	6863      	ldr	r3, [r4, #4]
90003634:	2b00      	cmp	r3, #0
90003636:	d18d      	bne.n	90003554 <HAL_RCC_OscConfig+0x10>
90003638:	e787      	b.n	9000354a <HAL_RCC_OscConfig+0x6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
9000363a:	6862      	ldr	r2, [r4, #4]
9000363c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
90003640:	d112      	bne.n	90003668 <HAL_RCC_OscConfig+0x124>
90003642:	681a      	ldr	r2, [r3, #0]
90003644:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90003648:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
9000364a:	f7fe fb5f 	bl	90001d0c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
9000364e:	4e63      	ldr	r6, [pc, #396]	; (900037dc <HAL_RCC_OscConfig+0x298>)
        tickstart = HAL_GetTick();
90003650:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90003652:	6833      	ldr	r3, [r6, #0]
90003654:	0398      	lsls	r0, r3, #14
90003656:	f53f af7d 	bmi.w	90003554 <HAL_RCC_OscConfig+0x10>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
9000365a:	f7fe fb57 	bl	90001d0c <HAL_GetTick>
9000365e:	1b40      	subs	r0, r0, r5
90003660:	2864      	cmp	r0, #100	; 0x64
90003662:	d9f6      	bls.n	90003652 <HAL_RCC_OscConfig+0x10e>
            return HAL_TIMEOUT;
90003664:	2003      	movs	r0, #3
}
90003666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90003668:	4d5c      	ldr	r5, [pc, #368]	; (900037dc <HAL_RCC_OscConfig+0x298>)
9000366a:	682b      	ldr	r3, [r5, #0]
9000366c:	b99a      	cbnz	r2, 90003696 <HAL_RCC_OscConfig+0x152>
9000366e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
90003672:	602b      	str	r3, [r5, #0]
90003674:	682b      	ldr	r3, [r5, #0]
90003676:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
9000367a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
9000367c:	f7fe fb46 	bl	90001d0c <HAL_GetTick>
90003680:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
90003682:	682b      	ldr	r3, [r5, #0]
90003684:	0399      	lsls	r1, r3, #14
90003686:	f57f af65 	bpl.w	90003554 <HAL_RCC_OscConfig+0x10>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
9000368a:	f7fe fb3f 	bl	90001d0c <HAL_GetTick>
9000368e:	1b80      	subs	r0, r0, r6
90003690:	2864      	cmp	r0, #100	; 0x64
90003692:	d9f6      	bls.n	90003682 <HAL_RCC_OscConfig+0x13e>
90003694:	e7e6      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90003696:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
9000369a:	d107      	bne.n	900036ac <HAL_RCC_OscConfig+0x168>
9000369c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
900036a0:	602b      	str	r3, [r5, #0]
900036a2:	682b      	ldr	r3, [r5, #0]
900036a4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900036a8:	602b      	str	r3, [r5, #0]
900036aa:	e7ce      	b.n	9000364a <HAL_RCC_OscConfig+0x106>
900036ac:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
900036b0:	602b      	str	r3, [r5, #0]
900036b2:	682b      	ldr	r3, [r5, #0]
900036b4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
900036b8:	e7f6      	b.n	900036a8 <HAL_RCC_OscConfig+0x164>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
900036ba:	4b48      	ldr	r3, [pc, #288]	; (900037dc <HAL_RCC_OscConfig+0x298>)
900036bc:	68e1      	ldr	r1, [r4, #12]
900036be:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
900036c0:	6a98      	ldr	r0, [r3, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
900036c2:	f012 0238 	ands.w	r2, r2, #56	; 0x38
900036c6:	d003      	beq.n	900036d0 <HAL_RCC_OscConfig+0x18c>
900036c8:	2a18      	cmp	r2, #24
900036ca:	d12b      	bne.n	90003724 <HAL_RCC_OscConfig+0x1e0>
900036cc:	0782      	lsls	r2, r0, #30
900036ce:	d129      	bne.n	90003724 <HAL_RCC_OscConfig+0x1e0>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
900036d0:	681b      	ldr	r3, [r3, #0]
900036d2:	075b      	lsls	r3, r3, #29
900036d4:	d502      	bpl.n	900036dc <HAL_RCC_OscConfig+0x198>
900036d6:	2900      	cmp	r1, #0
900036d8:	f43f af37 	beq.w	9000354a <HAL_RCC_OscConfig+0x6>
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
900036dc:	4d3f      	ldr	r5, [pc, #252]	; (900037dc <HAL_RCC_OscConfig+0x298>)
900036de:	682a      	ldr	r2, [r5, #0]
900036e0:	f022 0219 	bic.w	r2, r2, #25
900036e4:	430a      	orrs	r2, r1
900036e6:	602a      	str	r2, [r5, #0]
          tickstart = HAL_GetTick();
900036e8:	f7fe fb10 	bl	90001d0c <HAL_GetTick>
900036ec:	4606      	mov	r6, r0
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
900036ee:	682b      	ldr	r3, [r5, #0]
900036f0:	075f      	lsls	r7, r3, #29
900036f2:	d511      	bpl.n	90003718 <HAL_RCC_OscConfig+0x1d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
900036f4:	f7fe fb22 	bl	90001d3c <HAL_GetREVID>
900036f8:	f241 0303 	movw	r3, #4099	; 0x1003
900036fc:	6922      	ldr	r2, [r4, #16]
900036fe:	4298      	cmp	r0, r3
90003700:	686b      	ldr	r3, [r5, #4]
90003702:	d822      	bhi.n	9000374a <HAL_RCC_OscConfig+0x206>
90003704:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
90003708:	2a40      	cmp	r2, #64	; 0x40
9000370a:	bf0c      	ite	eq
9000370c:	f443 3300 	orreq.w	r3, r3, #131072	; 0x20000
90003710:	ea43 3302 	orrne.w	r3, r3, r2, lsl #12
90003714:	606b      	str	r3, [r5, #4]
90003716:	e721      	b.n	9000355c <HAL_RCC_OscConfig+0x18>
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
90003718:	f7fe faf8 	bl	90001d0c <HAL_GetTick>
9000371c:	1b80      	subs	r0, r0, r6
9000371e:	2802      	cmp	r0, #2
90003720:	d9e5      	bls.n	900036ee <HAL_RCC_OscConfig+0x1aa>
90003722:	e79f      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
90003724:	681a      	ldr	r2, [r3, #0]
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
90003726:	b1a9      	cbz	r1, 90003754 <HAL_RCC_OscConfig+0x210>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
90003728:	f022 0219 	bic.w	r2, r2, #25
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
9000372c:	4d2b      	ldr	r5, [pc, #172]	; (900037dc <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
9000372e:	430a      	orrs	r2, r1
90003730:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
90003732:	f7fe faeb 	bl	90001d0c <HAL_GetTick>
90003736:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90003738:	682b      	ldr	r3, [r5, #0]
9000373a:	0758      	lsls	r0, r3, #29
9000373c:	d4da      	bmi.n	900036f4 <HAL_RCC_OscConfig+0x1b0>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
9000373e:	f7fe fae5 	bl	90001d0c <HAL_GetTick>
90003742:	1b80      	subs	r0, r0, r6
90003744:	2802      	cmp	r0, #2
90003746:	d9f7      	bls.n	90003738 <HAL_RCC_OscConfig+0x1f4>
90003748:	e78c      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
9000374a:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
9000374e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
90003752:	e7df      	b.n	90003714 <HAL_RCC_OscConfig+0x1d0>
        __HAL_RCC_HSI_DISABLE();
90003754:	f022 0201 	bic.w	r2, r2, #1
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
90003758:	4e20      	ldr	r6, [pc, #128]	; (900037dc <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_DISABLE();
9000375a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
9000375c:	f7fe fad6 	bl	90001d0c <HAL_GetTick>
90003760:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
90003762:	6833      	ldr	r3, [r6, #0]
90003764:	0759      	lsls	r1, r3, #29
90003766:	f57f aef9 	bpl.w	9000355c <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
9000376a:	f7fe facf 	bl	90001d0c <HAL_GetTick>
9000376e:	1b40      	subs	r0, r0, r5
90003770:	2802      	cmp	r0, #2
90003772:	d9f6      	bls.n	90003762 <HAL_RCC_OscConfig+0x21e>
90003774:	e776      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
90003776:	68da      	ldr	r2, [r3, #12]
90003778:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
9000377c:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
90003780:	60da      	str	r2, [r3, #12]
90003782:	e716      	b.n	900035b2 <HAL_RCC_OscConfig+0x6e>
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
90003784:	69e2      	ldr	r2, [r4, #28]
90003786:	b36a      	cbz	r2, 900037e4 <HAL_RCC_OscConfig+0x2a0>
        __HAL_RCC_CSI_ENABLE();
90003788:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
9000378a:	4d14      	ldr	r5, [pc, #80]	; (900037dc <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_CSI_ENABLE();
9000378c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
90003790:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
90003792:	f7fe fabb 	bl	90001d0c <HAL_GetTick>
90003796:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
90003798:	682b      	ldr	r3, [r5, #0]
9000379a:	05df      	lsls	r7, r3, #23
9000379c:	d511      	bpl.n	900037c2 <HAL_RCC_OscConfig+0x27e>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
9000379e:	f7fe facd 	bl	90001d3c <HAL_GetREVID>
900037a2:	f241 0303 	movw	r3, #4099	; 0x1003
900037a6:	6a22      	ldr	r2, [r4, #32]
900037a8:	4298      	cmp	r0, r3
900037aa:	d810      	bhi.n	900037ce <HAL_RCC_OscConfig+0x28a>
900037ac:	686b      	ldr	r3, [r5, #4]
900037ae:	2a20      	cmp	r2, #32
900037b0:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
900037b4:	bf0c      	ite	eq
900037b6:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
900037ba:	ea43 6382 	orrne.w	r3, r3, r2, lsl #26
900037be:	606b      	str	r3, [r5, #4]
900037c0:	e6f7      	b.n	900035b2 <HAL_RCC_OscConfig+0x6e>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
900037c2:	f7fe faa3 	bl	90001d0c <HAL_GetTick>
900037c6:	1b80      	subs	r0, r0, r6
900037c8:	2802      	cmp	r0, #2
900037ca:	d9e5      	bls.n	90003798 <HAL_RCC_OscConfig+0x254>
900037cc:	e74a      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
900037ce:	68eb      	ldr	r3, [r5, #12]
900037d0:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
900037d4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
900037d8:	60eb      	str	r3, [r5, #12]
900037da:	e6ea      	b.n	900035b2 <HAL_RCC_OscConfig+0x6e>
900037dc:	58024400 	.word	0x58024400
900037e0:	58024800 	.word	0x58024800
        __HAL_RCC_CSI_DISABLE();
900037e4:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
900037e6:	4e9f      	ldr	r6, [pc, #636]	; (90003a64 <HAL_RCC_OscConfig+0x520>)
        __HAL_RCC_CSI_DISABLE();
900037e8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
900037ec:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
900037ee:	f7fe fa8d 	bl	90001d0c <HAL_GetTick>
900037f2:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
900037f4:	6833      	ldr	r3, [r6, #0]
900037f6:	05d8      	lsls	r0, r3, #23
900037f8:	f57f aedb 	bpl.w	900035b2 <HAL_RCC_OscConfig+0x6e>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
900037fc:	f7fe fa86 	bl	90001d0c <HAL_GetTick>
90003800:	1b40      	subs	r0, r0, r5
90003802:	2802      	cmp	r0, #2
90003804:	d9f6      	bls.n	900037f4 <HAL_RCC_OscConfig+0x2b0>
90003806:	e72d      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
90003808:	6963      	ldr	r3, [r4, #20]
9000380a:	4d96      	ldr	r5, [pc, #600]	; (90003a64 <HAL_RCC_OscConfig+0x520>)
9000380c:	b183      	cbz	r3, 90003830 <HAL_RCC_OscConfig+0x2ec>
      __HAL_RCC_LSI_ENABLE();
9000380e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90003810:	f043 0301 	orr.w	r3, r3, #1
90003814:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
90003816:	f7fe fa79 	bl	90001d0c <HAL_GetTick>
9000381a:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
9000381c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
9000381e:	079b      	lsls	r3, r3, #30
90003820:	f53f aecb 	bmi.w	900035ba <HAL_RCC_OscConfig+0x76>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
90003824:	f7fe fa72 	bl	90001d0c <HAL_GetTick>
90003828:	1b80      	subs	r0, r0, r6
9000382a:	2802      	cmp	r0, #2
9000382c:	d9f6      	bls.n	9000381c <HAL_RCC_OscConfig+0x2d8>
9000382e:	e719      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_LSI_DISABLE();
90003830:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90003832:	f023 0301 	bic.w	r3, r3, #1
90003836:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
90003838:	f7fe fa68 	bl	90001d0c <HAL_GetTick>
9000383c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
9000383e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90003840:	079f      	lsls	r7, r3, #30
90003842:	f57f aeba 	bpl.w	900035ba <HAL_RCC_OscConfig+0x76>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
90003846:	f7fe fa61 	bl	90001d0c <HAL_GetTick>
9000384a:	1b80      	subs	r0, r0, r6
9000384c:	2802      	cmp	r0, #2
9000384e:	d9f6      	bls.n	9000383e <HAL_RCC_OscConfig+0x2fa>
90003850:	e708      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
90003852:	69a3      	ldr	r3, [r4, #24]
90003854:	4d83      	ldr	r5, [pc, #524]	; (90003a64 <HAL_RCC_OscConfig+0x520>)
90003856:	b183      	cbz	r3, 9000387a <HAL_RCC_OscConfig+0x336>
      __HAL_RCC_HSI48_ENABLE();
90003858:	682b      	ldr	r3, [r5, #0]
9000385a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
9000385e:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
90003860:	f7fe fa54 	bl	90001d0c <HAL_GetTick>
90003864:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
90003866:	682b      	ldr	r3, [r5, #0]
90003868:	0498      	lsls	r0, r3, #18
9000386a:	f53f aeaa 	bmi.w	900035c2 <HAL_RCC_OscConfig+0x7e>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
9000386e:	f7fe fa4d 	bl	90001d0c <HAL_GetTick>
90003872:	1b80      	subs	r0, r0, r6
90003874:	2802      	cmp	r0, #2
90003876:	d9f6      	bls.n	90003866 <HAL_RCC_OscConfig+0x322>
90003878:	e6f4      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_HSI48_DISABLE();
9000387a:	682b      	ldr	r3, [r5, #0]
9000387c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
90003880:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
90003882:	f7fe fa43 	bl	90001d0c <HAL_GetTick>
90003886:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
90003888:	682b      	ldr	r3, [r5, #0]
9000388a:	0499      	lsls	r1, r3, #18
9000388c:	f57f ae99 	bpl.w	900035c2 <HAL_RCC_OscConfig+0x7e>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
90003890:	f7fe fa3c 	bl	90001d0c <HAL_GetTick>
90003894:	1b80      	subs	r0, r0, r6
90003896:	2802      	cmp	r0, #2
90003898:	d9f6      	bls.n	90003888 <HAL_RCC_OscConfig+0x344>
9000389a:	e6e3      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
9000389c:	f7fe fa36 	bl	90001d0c <HAL_GetTick>
900038a0:	1b80      	subs	r0, r0, r6
900038a2:	2864      	cmp	r0, #100	; 0x64
900038a4:	f67f ae98 	bls.w	900035d8 <HAL_RCC_OscConfig+0x94>
900038a8:	e6dc      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
900038aa:	b9b3      	cbnz	r3, 900038da <HAL_RCC_OscConfig+0x396>
900038ac:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900038ae:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
900038b2:	f023 0301 	bic.w	r3, r3, #1
900038b6:	672b      	str	r3, [r5, #112]	; 0x70
900038b8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
900038ba:	f023 0304 	bic.w	r3, r3, #4
900038be:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
900038c0:	f7fe fa24 	bl	90001d0c <HAL_GetTick>
900038c4:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
900038c6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
900038c8:	0798      	lsls	r0, r3, #30
900038ca:	f57f ae9c 	bpl.w	90003606 <HAL_RCC_OscConfig+0xc2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900038ce:	f7fe fa1d 	bl	90001d0c <HAL_GetTick>
900038d2:	1b80      	subs	r0, r0, r6
900038d4:	42b8      	cmp	r0, r7
900038d6:	d9f6      	bls.n	900038c6 <HAL_RCC_OscConfig+0x382>
900038d8:	e6c4      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
900038da:	2b05      	cmp	r3, #5
900038dc:	6f2b      	ldr	r3, [r5, #112]	; 0x70
900038de:	d103      	bne.n	900038e8 <HAL_RCC_OscConfig+0x3a4>
900038e0:	f043 0304 	orr.w	r3, r3, #4
900038e4:	672b      	str	r3, [r5, #112]	; 0x70
900038e6:	e680      	b.n	900035ea <HAL_RCC_OscConfig+0xa6>
900038e8:	f023 0301 	bic.w	r3, r3, #1
900038ec:	672b      	str	r3, [r5, #112]	; 0x70
900038ee:	6f2b      	ldr	r3, [r5, #112]	; 0x70
900038f0:	f023 0304 	bic.w	r3, r3, #4
900038f4:	e67c      	b.n	900035f0 <HAL_RCC_OscConfig+0xac>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900038f6:	f7fe fa09 	bl	90001d0c <HAL_GetTick>
900038fa:	1b40      	subs	r0, r0, r5
900038fc:	42b8      	cmp	r0, r7
900038fe:	f67f ae7e 	bls.w	900035fe <HAL_RCC_OscConfig+0xba>
90003902:	e6af      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
90003904:	4d57      	ldr	r5, [pc, #348]	; (90003a64 <HAL_RCC_OscConfig+0x520>)
90003906:	692b      	ldr	r3, [r5, #16]
90003908:	f003 0338 	and.w	r3, r3, #56	; 0x38
9000390c:	2b18      	cmp	r3, #24
9000390e:	d07a      	beq.n	90003a06 <HAL_RCC_OscConfig+0x4c2>
        __HAL_RCC_PLL_DISABLE();
90003910:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
90003912:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
90003914:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
90003918:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
9000391a:	d167      	bne.n	900039ec <HAL_RCC_OscConfig+0x4a8>
        tickstart = HAL_GetTick();
9000391c:	f7fe f9f6 	bl	90001d0c <HAL_GetTick>
90003920:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
90003922:	682b      	ldr	r3, [r5, #0]
90003924:	0199      	lsls	r1, r3, #6
90003926:	d45b      	bmi.n	900039e0 <HAL_RCC_OscConfig+0x49c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
90003928:	6aab      	ldr	r3, [r5, #40]	; 0x28
9000392a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
9000392c:	f423 737c 	bic.w	r3, r3, #1008	; 0x3f0
90003930:	f023 0303 	bic.w	r3, r3, #3
90003934:	4313      	orrs	r3, r2
90003936:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
90003938:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
9000393c:	62ab      	str	r3, [r5, #40]	; 0x28
9000393e:	6b63      	ldr	r3, [r4, #52]	; 0x34
90003940:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90003942:	3b01      	subs	r3, #1
90003944:	3a01      	subs	r2, #1
90003946:	025b      	lsls	r3, r3, #9
90003948:	0412      	lsls	r2, r2, #16
9000394a:	b29b      	uxth	r3, r3
9000394c:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
90003950:	4313      	orrs	r3, r2
90003952:	6b22      	ldr	r2, [r4, #48]	; 0x30
90003954:	3a01      	subs	r2, #1
90003956:	f3c2 0208 	ubfx	r2, r2, #0, #9
9000395a:	4313      	orrs	r3, r2
9000395c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
9000395e:	3a01      	subs	r2, #1
90003960:	0612      	lsls	r2, r2, #24
90003962:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
90003966:	4313      	orrs	r3, r2
90003968:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
9000396a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
9000396c:	f023 0301 	bic.w	r3, r3, #1
90003970:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
90003972:	6b6b      	ldr	r3, [r5, #52]	; 0x34
90003974:	6ca2      	ldr	r2, [r4, #72]	; 0x48
90003976:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
9000397a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
9000397e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
90003982:	636b      	str	r3, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
90003984:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
90003986:	6c22      	ldr	r2, [r4, #64]	; 0x40
90003988:	f023 030c 	bic.w	r3, r3, #12
9000398c:	4313      	orrs	r3, r2
9000398e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
90003990:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
90003992:	6c62      	ldr	r2, [r4, #68]	; 0x44
90003994:	f023 0302 	bic.w	r3, r3, #2
90003998:	4313      	orrs	r3, r2
9000399a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
9000399c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
9000399e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900039a2:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900039a4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
900039a6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900039aa:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
900039ac:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
900039ae:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
900039b2:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
900039b4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
900039b6:	f043 0301 	orr.w	r3, r3, #1
900039ba:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
900039bc:	682b      	ldr	r3, [r5, #0]
900039be:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
900039c2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
900039c4:	f7fe f9a2 	bl	90001d0c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
900039c8:	4d26      	ldr	r5, [pc, #152]	; (90003a64 <HAL_RCC_OscConfig+0x520>)
        tickstart = HAL_GetTick();
900039ca:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
900039cc:	682b      	ldr	r3, [r5, #0]
900039ce:	019a      	lsls	r2, r3, #6
900039d0:	f53f ae1d 	bmi.w	9000360e <HAL_RCC_OscConfig+0xca>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
900039d4:	f7fe f99a 	bl	90001d0c <HAL_GetTick>
900039d8:	1b00      	subs	r0, r0, r4
900039da:	2802      	cmp	r0, #2
900039dc:	d9f6      	bls.n	900039cc <HAL_RCC_OscConfig+0x488>
900039de:	e641      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
900039e0:	f7fe f994 	bl	90001d0c <HAL_GetTick>
900039e4:	1b80      	subs	r0, r0, r6
900039e6:	2802      	cmp	r0, #2
900039e8:	d99b      	bls.n	90003922 <HAL_RCC_OscConfig+0x3de>
900039ea:	e63b      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
        tickstart = HAL_GetTick();
900039ec:	f7fe f98e 	bl	90001d0c <HAL_GetTick>
900039f0:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
900039f2:	682b      	ldr	r3, [r5, #0]
900039f4:	019b      	lsls	r3, r3, #6
900039f6:	f57f ae0a 	bpl.w	9000360e <HAL_RCC_OscConfig+0xca>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
900039fa:	f7fe f987 	bl	90001d0c <HAL_GetTick>
900039fe:	1b00      	subs	r0, r0, r4
90003a00:	2802      	cmp	r0, #2
90003a02:	d9f6      	bls.n	900039f2 <HAL_RCC_OscConfig+0x4ae>
90003a04:	e62e      	b.n	90003664 <HAL_RCC_OscConfig+0x120>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90003a06:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
90003a08:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
90003a0a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90003a0c:	f43f ae2b 	beq.w	90003666 <HAL_RCC_OscConfig+0x122>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
90003a10:	f002 0103 	and.w	r1, r2, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90003a14:	6aa0      	ldr	r0, [r4, #40]	; 0x28
90003a16:	4281      	cmp	r1, r0
90003a18:	f47f ad97 	bne.w	9000354a <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
90003a1c:	f3c2 1205 	ubfx	r2, r2, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
90003a20:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
90003a22:	428a      	cmp	r2, r1
90003a24:	f47f ad91 	bne.w	9000354a <HAL_RCC_OscConfig+0x6>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
90003a28:	6b22      	ldr	r2, [r4, #48]	; 0x30
90003a2a:	f3c3 0108 	ubfx	r1, r3, #0, #9
90003a2e:	3a01      	subs	r2, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
90003a30:	4291      	cmp	r1, r2
90003a32:	f47f ad8a 	bne.w	9000354a <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
90003a36:	6b62      	ldr	r2, [r4, #52]	; 0x34
90003a38:	f3c3 2146 	ubfx	r1, r3, #9, #7
90003a3c:	3a01      	subs	r2, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
90003a3e:	4291      	cmp	r1, r2
90003a40:	f47f ad83 	bne.w	9000354a <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
90003a44:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90003a46:	f3c3 4106 	ubfx	r1, r3, #16, #7
90003a4a:	3a01      	subs	r2, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
90003a4c:	4291      	cmp	r1, r2
90003a4e:	f47f ad7c 	bne.w	9000354a <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
90003a52:	6be0      	ldr	r0, [r4, #60]	; 0x3c
90003a54:	f3c3 6306 	ubfx	r3, r3, #24, #7
90003a58:	3801      	subs	r0, #1
  return HAL_OK;
90003a5a:	1a18      	subs	r0, r3, r0
90003a5c:	bf18      	it	ne
90003a5e:	2001      	movne	r0, #1
90003a60:	e601      	b.n	90003666 <HAL_RCC_OscConfig+0x122>
90003a62:	bf00      	nop
90003a64:	58024400 	.word	0x58024400

90003a68 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
90003a68:	4b48      	ldr	r3, [pc, #288]	; (90003b8c <HAL_RCC_GetSysClockFreq+0x124>)
90003a6a:	691a      	ldr	r2, [r3, #16]
90003a6c:	f002 0238 	and.w	r2, r2, #56	; 0x38
90003a70:	2a10      	cmp	r2, #16
{
90003a72:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
90003a74:	f000 8086 	beq.w	90003b84 <HAL_RCC_GetSysClockFreq+0x11c>
90003a78:	2a18      	cmp	r2, #24
90003a7a:	d00c      	beq.n	90003a96 <HAL_RCC_GetSysClockFreq+0x2e>
90003a7c:	2a00      	cmp	r2, #0
90003a7e:	f040 8083 	bne.w	90003b88 <HAL_RCC_GetSysClockFreq+0x120>
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90003a82:	681a      	ldr	r2, [r3, #0]
90003a84:	4842      	ldr	r0, [pc, #264]	; (90003b90 <HAL_RCC_GetSysClockFreq+0x128>)
90003a86:	f012 0f20 	tst.w	r2, #32
90003a8a:	d003      	beq.n	90003a94 <HAL_RCC_GetSysClockFreq+0x2c>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90003a8c:	681b      	ldr	r3, [r3, #0]
90003a8e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
90003a92:	40d8      	lsrs	r0, r3
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
90003a94:	bd30      	pop	{r4, r5, pc}
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90003a96:	6a99      	ldr	r1, [r3, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
90003a98:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
90003a9a:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    if (pllm != 0U)
90003a9c:	f415 7f7c 	tst.w	r5, #1008	; 0x3f0
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
90003aa0:	f3c5 1005 	ubfx	r0, r5, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90003aa4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    if (pllm != 0U)
90003aa6:	d0f5      	beq.n	90003a94 <HAL_RCC_GetSysClockFreq+0x2c>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90003aa8:	f3c2 02cc 	ubfx	r2, r2, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
90003aac:	f004 0401 	and.w	r4, r4, #1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003ab0:	ee07 0a90 	vmov	s15, r0
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90003ab4:	f001 0103 	and.w	r1, r1, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90003ab8:	4362      	muls	r2, r4
90003aba:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003abe:	eef8 6ae7 	vcvt.f32.s32	s13, s15
90003ac2:	2901      	cmp	r1, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90003ac4:	ee07 2a90 	vmov	s15, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003ac8:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
90003acc:	d04c      	beq.n	90003b68 <HAL_RCC_GetSysClockFreq+0x100>
90003ace:	2902      	cmp	r1, #2
90003ad0:	d03c      	beq.n	90003b4c <HAL_RCC_GetSysClockFreq+0xe4>
90003ad2:	2900      	cmp	r1, #0
90003ad4:	d148      	bne.n	90003b68 <HAL_RCC_GetSysClockFreq+0x100>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90003ad6:	681a      	ldr	r2, [r3, #0]
90003ad8:	0692      	lsls	r2, r2, #26
90003ada:	d527      	bpl.n	90003b2c <HAL_RCC_GetSysClockFreq+0xc4>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90003adc:	6819      	ldr	r1, [r3, #0]
90003ade:	4a2c      	ldr	r2, [pc, #176]	; (90003b90 <HAL_RCC_GetSysClockFreq+0x128>)
90003ae0:	f3c1 01c1 	ubfx	r1, r1, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003ae4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90003ae6:	40ca      	lsrs	r2, r1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003ae8:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003aec:	ee07 2a10 	vmov	s14, r2
90003af0:	eef8 5ac7 	vcvt.f32.s32	s11, s14
90003af4:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90003af8:	ee06 3a90 	vmov	s13, r3
90003afc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
90003b00:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003b04:	ee77 7a86 	vadd.f32	s15, s15, s12
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
90003b08:	4b20      	ldr	r3, [pc, #128]	; (90003b8c <HAL_RCC_GetSysClockFreq+0x124>)
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003b0a:	ee67 7a87 	vmul.f32	s15, s15, s14
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
90003b0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003b10:	f3c3 2346 	ubfx	r3, r3, #9, #7
90003b14:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
90003b16:	ee07 3a10 	vmov	s14, r3
90003b1a:	eef8 6ac7 	vcvt.f32.s32	s13, s14
90003b1e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
90003b22:	eefc 7ac7 	vcvt.u32.f32	s15, s14
90003b26:	ee17 0a90 	vmov	r0, s15
90003b2a:	e7b3      	b.n	90003a94 <HAL_RCC_GetSysClockFreq+0x2c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003b2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003b2e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003b32:	ee07 3a10 	vmov	s14, r3
90003b36:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90003b3a:	ee77 7a27 	vadd.f32	s15, s14, s15
90003b3e:	ee77 7a86 	vadd.f32	s15, s15, s12
90003b42:	ed9f 6a14 	vldr	s12, [pc, #80]	; 90003b94 <HAL_RCC_GetSysClockFreq+0x12c>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003b46:	ee86 7a26 	vdiv.f32	s14, s12, s13
90003b4a:	e7dd      	b.n	90003b08 <HAL_RCC_GetSysClockFreq+0xa0>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003b4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003b4e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003b52:	ee07 3a10 	vmov	s14, r3
90003b56:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90003b5a:	ee77 7a27 	vadd.f32	s15, s14, s15
90003b5e:	ee77 7a86 	vadd.f32	s15, s15, s12
90003b62:	ed9f 6a0d 	vldr	s12, [pc, #52]	; 90003b98 <HAL_RCC_GetSysClockFreq+0x130>
90003b66:	e7ee      	b.n	90003b46 <HAL_RCC_GetSysClockFreq+0xde>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90003b68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003b6a:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003b6e:	ee07 3a10 	vmov	s14, r3
90003b72:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90003b76:	ee77 7a27 	vadd.f32	s15, s14, s15
90003b7a:	ee77 7a86 	vadd.f32	s15, s15, s12
90003b7e:	ed9f 6a07 	vldr	s12, [pc, #28]	; 90003b9c <HAL_RCC_GetSysClockFreq+0x134>
90003b82:	e7e0      	b.n	90003b46 <HAL_RCC_GetSysClockFreq+0xde>
  switch (RCC->CFGR & RCC_CFGR_SWS)
90003b84:	4806      	ldr	r0, [pc, #24]	; (90003ba0 <HAL_RCC_GetSysClockFreq+0x138>)
90003b86:	e785      	b.n	90003a94 <HAL_RCC_GetSysClockFreq+0x2c>
    sysclockfreq = CSI_VALUE;
90003b88:	4806      	ldr	r0, [pc, #24]	; (90003ba4 <HAL_RCC_GetSysClockFreq+0x13c>)
90003b8a:	e783      	b.n	90003a94 <HAL_RCC_GetSysClockFreq+0x2c>
90003b8c:	58024400 	.word	0x58024400
90003b90:	03d09000 	.word	0x03d09000
90003b94:	4c742400 	.word	0x4c742400
90003b98:	4bbebc20 	.word	0x4bbebc20
90003b9c:	4a742400 	.word	0x4a742400
90003ba0:	017d7840 	.word	0x017d7840
90003ba4:	003d0900 	.word	0x003d0900

90003ba8 <HAL_RCC_ClockConfig>:
{
90003ba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90003bac:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
90003bae:	4604      	mov	r4, r0
90003bb0:	b910      	cbnz	r0, 90003bb8 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
90003bb2:	2001      	movs	r0, #1
}
90003bb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
90003bb8:	4a88      	ldr	r2, [pc, #544]	; (90003ddc <HAL_RCC_ClockConfig+0x234>)
90003bba:	6813      	ldr	r3, [r2, #0]
90003bbc:	f003 030f 	and.w	r3, r3, #15
90003bc0:	428b      	cmp	r3, r1
90003bc2:	f0c0 8093 	bcc.w	90003cec <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
90003bc6:	6823      	ldr	r3, [r4, #0]
90003bc8:	075f      	lsls	r7, r3, #29
90003bca:	f100 809b 	bmi.w	90003d04 <HAL_RCC_ClockConfig+0x15c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
90003bce:	071e      	lsls	r6, r3, #28
90003bd0:	d50b      	bpl.n	90003bea <HAL_RCC_ClockConfig+0x42>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
90003bd2:	4983      	ldr	r1, [pc, #524]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003bd4:	6966      	ldr	r6, [r4, #20]
90003bd6:	69c8      	ldr	r0, [r1, #28]
90003bd8:	f000 0070 	and.w	r0, r0, #112	; 0x70
90003bdc:	4286      	cmp	r6, r0
90003bde:	d904      	bls.n	90003bea <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
90003be0:	69ca      	ldr	r2, [r1, #28]
90003be2:	f022 0270 	bic.w	r2, r2, #112	; 0x70
90003be6:	4332      	orrs	r2, r6
90003be8:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
90003bea:	06d8      	lsls	r0, r3, #27
90003bec:	d50b      	bpl.n	90003c06 <HAL_RCC_ClockConfig+0x5e>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
90003bee:	497c      	ldr	r1, [pc, #496]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003bf0:	69a6      	ldr	r6, [r4, #24]
90003bf2:	69c8      	ldr	r0, [r1, #28]
90003bf4:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
90003bf8:	4286      	cmp	r6, r0
90003bfa:	d904      	bls.n	90003c06 <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
90003bfc:	69ca      	ldr	r2, [r1, #28]
90003bfe:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
90003c02:	4332      	orrs	r2, r6
90003c04:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
90003c06:	0699      	lsls	r1, r3, #26
90003c08:	d50b      	bpl.n	90003c22 <HAL_RCC_ClockConfig+0x7a>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
90003c0a:	4975      	ldr	r1, [pc, #468]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003c0c:	69e6      	ldr	r6, [r4, #28]
90003c0e:	6a08      	ldr	r0, [r1, #32]
90003c10:	f000 0070 	and.w	r0, r0, #112	; 0x70
90003c14:	4286      	cmp	r6, r0
90003c16:	d904      	bls.n	90003c22 <HAL_RCC_ClockConfig+0x7a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
90003c18:	6a0a      	ldr	r2, [r1, #32]
90003c1a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
90003c1e:	4332      	orrs	r2, r6
90003c20:	620a      	str	r2, [r1, #32]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
90003c22:	079a      	lsls	r2, r3, #30
90003c24:	d50b      	bpl.n	90003c3e <HAL_RCC_ClockConfig+0x96>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
90003c26:	496e      	ldr	r1, [pc, #440]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003c28:	68e6      	ldr	r6, [r4, #12]
90003c2a:	6988      	ldr	r0, [r1, #24]
90003c2c:	f000 000f 	and.w	r0, r0, #15
90003c30:	4286      	cmp	r6, r0
90003c32:	d904      	bls.n	90003c3e <HAL_RCC_ClockConfig+0x96>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
90003c34:	698a      	ldr	r2, [r1, #24]
90003c36:	f022 020f 	bic.w	r2, r2, #15
90003c3a:	4332      	orrs	r2, r6
90003c3c:	618a      	str	r2, [r1, #24]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
90003c3e:	07df      	lsls	r7, r3, #31
90003c40:	d46e      	bmi.n	90003d20 <HAL_RCC_ClockConfig+0x178>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
90003c42:	6823      	ldr	r3, [r4, #0]
90003c44:	079e      	lsls	r6, r3, #30
90003c46:	f100 80a1 	bmi.w	90003d8c <HAL_RCC_ClockConfig+0x1e4>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
90003c4a:	4964      	ldr	r1, [pc, #400]	; (90003ddc <HAL_RCC_ClockConfig+0x234>)
90003c4c:	680a      	ldr	r2, [r1, #0]
90003c4e:	f002 020f 	and.w	r2, r2, #15
90003c52:	42aa      	cmp	r2, r5
90003c54:	f200 80a8 	bhi.w	90003da8 <HAL_RCC_ClockConfig+0x200>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
90003c58:	0758      	lsls	r0, r3, #29
90003c5a:	f100 80b1 	bmi.w	90003dc0 <HAL_RCC_ClockConfig+0x218>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
90003c5e:	0719      	lsls	r1, r3, #28
90003c60:	d50b      	bpl.n	90003c7a <HAL_RCC_ClockConfig+0xd2>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
90003c62:	495f      	ldr	r1, [pc, #380]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003c64:	6965      	ldr	r5, [r4, #20]
90003c66:	69c8      	ldr	r0, [r1, #28]
90003c68:	f000 0070 	and.w	r0, r0, #112	; 0x70
90003c6c:	4285      	cmp	r5, r0
90003c6e:	d204      	bcs.n	90003c7a <HAL_RCC_ClockConfig+0xd2>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
90003c70:	69ca      	ldr	r2, [r1, #28]
90003c72:	f022 0270 	bic.w	r2, r2, #112	; 0x70
90003c76:	432a      	orrs	r2, r5
90003c78:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
90003c7a:	06da      	lsls	r2, r3, #27
90003c7c:	d50b      	bpl.n	90003c96 <HAL_RCC_ClockConfig+0xee>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
90003c7e:	4958      	ldr	r1, [pc, #352]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003c80:	69a5      	ldr	r5, [r4, #24]
90003c82:	69c8      	ldr	r0, [r1, #28]
90003c84:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
90003c88:	4285      	cmp	r5, r0
90003c8a:	d204      	bcs.n	90003c96 <HAL_RCC_ClockConfig+0xee>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
90003c8c:	69ca      	ldr	r2, [r1, #28]
90003c8e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
90003c92:	432a      	orrs	r2, r5
90003c94:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
90003c96:	069b      	lsls	r3, r3, #26
90003c98:	d50b      	bpl.n	90003cb2 <HAL_RCC_ClockConfig+0x10a>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
90003c9a:	4a51      	ldr	r2, [pc, #324]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003c9c:	69e0      	ldr	r0, [r4, #28]
90003c9e:	6a11      	ldr	r1, [r2, #32]
90003ca0:	f001 0170 	and.w	r1, r1, #112	; 0x70
90003ca4:	4288      	cmp	r0, r1
90003ca6:	d204      	bcs.n	90003cb2 <HAL_RCC_ClockConfig+0x10a>
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
90003ca8:	6a13      	ldr	r3, [r2, #32]
90003caa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
90003cae:	4303      	orrs	r3, r0
90003cb0:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
90003cb2:	f7ff fed9 	bl	90003a68 <HAL_RCC_GetSysClockFreq>
90003cb6:	494a      	ldr	r1, [pc, #296]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003cb8:	4a4a      	ldr	r2, [pc, #296]	; (90003de4 <HAL_RCC_ClockConfig+0x23c>)
90003cba:	698b      	ldr	r3, [r1, #24]
90003cbc:	f3c3 2303 	ubfx	r3, r3, #8, #4
90003cc0:	5cd3      	ldrb	r3, [r2, r3]
90003cc2:	f003 031f 	and.w	r3, r3, #31
90003cc6:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90003cc8:	698b      	ldr	r3, [r1, #24]
90003cca:	f003 030f 	and.w	r3, r3, #15
90003cce:	5cd3      	ldrb	r3, [r2, r3]
90003cd0:	4a45      	ldr	r2, [pc, #276]	; (90003de8 <HAL_RCC_ClockConfig+0x240>)
90003cd2:	f003 031f 	and.w	r3, r3, #31
90003cd6:	fa20 f303 	lsr.w	r3, r0, r3
90003cda:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
90003cdc:	4b43      	ldr	r3, [pc, #268]	; (90003dec <HAL_RCC_ClockConfig+0x244>)
90003cde:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick (uwTickPrio);
90003ce0:	4b43      	ldr	r3, [pc, #268]	; (90003df0 <HAL_RCC_ClockConfig+0x248>)
}
90003ce2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
90003ce6:	6818      	ldr	r0, [r3, #0]
90003ce8:	f7fd bfb0 	b.w	90001c4c <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
90003cec:	6813      	ldr	r3, [r2, #0]
90003cee:	f023 030f 	bic.w	r3, r3, #15
90003cf2:	430b      	orrs	r3, r1
90003cf4:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
90003cf6:	6813      	ldr	r3, [r2, #0]
90003cf8:	f003 030f 	and.w	r3, r3, #15
90003cfc:	428b      	cmp	r3, r1
90003cfe:	f47f af58 	bne.w	90003bb2 <HAL_RCC_ClockConfig+0xa>
90003d02:	e760      	b.n	90003bc6 <HAL_RCC_ClockConfig+0x1e>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
90003d04:	4936      	ldr	r1, [pc, #216]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003d06:	6926      	ldr	r6, [r4, #16]
90003d08:	6988      	ldr	r0, [r1, #24]
90003d0a:	f000 0070 	and.w	r0, r0, #112	; 0x70
90003d0e:	4286      	cmp	r6, r0
90003d10:	f67f af5d 	bls.w	90003bce <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
90003d14:	698a      	ldr	r2, [r1, #24]
90003d16:	f022 0270 	bic.w	r2, r2, #112	; 0x70
90003d1a:	4332      	orrs	r2, r6
90003d1c:	618a      	str	r2, [r1, #24]
90003d1e:	e756      	b.n	90003bce <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
90003d20:	4b2f      	ldr	r3, [pc, #188]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003d22:	68a1      	ldr	r1, [r4, #8]
90003d24:	699a      	ldr	r2, [r3, #24]
90003d26:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
90003d2a:	430a      	orrs	r2, r1
90003d2c:	619a      	str	r2, [r3, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
90003d2e:	6862      	ldr	r2, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90003d30:	681b      	ldr	r3, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
90003d32:	2a02      	cmp	r2, #2
90003d34:	d11d      	bne.n	90003d72 <HAL_RCC_ClockConfig+0x1ca>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90003d36:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90003d3a:	f43f af3a 	beq.w	90003bb2 <HAL_RCC_ClockConfig+0xa>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
90003d3e:	4e28      	ldr	r6, [pc, #160]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
90003d40:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
90003d44:	6933      	ldr	r3, [r6, #16]
90003d46:	f023 0307 	bic.w	r3, r3, #7
90003d4a:	4313      	orrs	r3, r2
90003d4c:	6133      	str	r3, [r6, #16]
      tickstart = HAL_GetTick();
90003d4e:	f7fd ffdd 	bl	90001d0c <HAL_GetTick>
90003d52:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
90003d54:	6933      	ldr	r3, [r6, #16]
90003d56:	6862      	ldr	r2, [r4, #4]
90003d58:	f003 0338 	and.w	r3, r3, #56	; 0x38
90003d5c:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
90003d60:	f43f af6f 	beq.w	90003c42 <HAL_RCC_ClockConfig+0x9a>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
90003d64:	f7fd ffd2 	bl	90001d0c <HAL_GetTick>
90003d68:	1bc0      	subs	r0, r0, r7
90003d6a:	4540      	cmp	r0, r8
90003d6c:	d9f2      	bls.n	90003d54 <HAL_RCC_ClockConfig+0x1ac>
            return HAL_TIMEOUT;
90003d6e:	2003      	movs	r0, #3
90003d70:	e720      	b.n	90003bb4 <HAL_RCC_ClockConfig+0xc>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
90003d72:	2a03      	cmp	r2, #3
90003d74:	d102      	bne.n	90003d7c <HAL_RCC_ClockConfig+0x1d4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
90003d76:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
90003d7a:	e7de      	b.n	90003d3a <HAL_RCC_ClockConfig+0x192>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
90003d7c:	2a01      	cmp	r2, #1
90003d7e:	d102      	bne.n	90003d86 <HAL_RCC_ClockConfig+0x1de>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
90003d80:	f413 7f80 	tst.w	r3, #256	; 0x100
90003d84:	e7d9      	b.n	90003d3a <HAL_RCC_ClockConfig+0x192>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90003d86:	f013 0f04 	tst.w	r3, #4
90003d8a:	e7d6      	b.n	90003d3a <HAL_RCC_ClockConfig+0x192>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
90003d8c:	4914      	ldr	r1, [pc, #80]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003d8e:	68e6      	ldr	r6, [r4, #12]
90003d90:	6988      	ldr	r0, [r1, #24]
90003d92:	f000 000f 	and.w	r0, r0, #15
90003d96:	4286      	cmp	r6, r0
90003d98:	f4bf af57 	bcs.w	90003c4a <HAL_RCC_ClockConfig+0xa2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
90003d9c:	698a      	ldr	r2, [r1, #24]
90003d9e:	f022 020f 	bic.w	r2, r2, #15
90003da2:	4332      	orrs	r2, r6
90003da4:	618a      	str	r2, [r1, #24]
90003da6:	e750      	b.n	90003c4a <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
90003da8:	680a      	ldr	r2, [r1, #0]
90003daa:	f022 020f 	bic.w	r2, r2, #15
90003dae:	432a      	orrs	r2, r5
90003db0:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
90003db2:	680a      	ldr	r2, [r1, #0]
90003db4:	f002 020f 	and.w	r2, r2, #15
90003db8:	42aa      	cmp	r2, r5
90003dba:	f47f aefa 	bne.w	90003bb2 <HAL_RCC_ClockConfig+0xa>
90003dbe:	e74b      	b.n	90003c58 <HAL_RCC_ClockConfig+0xb0>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
90003dc0:	4907      	ldr	r1, [pc, #28]	; (90003de0 <HAL_RCC_ClockConfig+0x238>)
90003dc2:	6925      	ldr	r5, [r4, #16]
90003dc4:	6988      	ldr	r0, [r1, #24]
90003dc6:	f000 0070 	and.w	r0, r0, #112	; 0x70
90003dca:	4285      	cmp	r5, r0
90003dcc:	f4bf af47 	bcs.w	90003c5e <HAL_RCC_ClockConfig+0xb6>
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
90003dd0:	698a      	ldr	r2, [r1, #24]
90003dd2:	f022 0270 	bic.w	r2, r2, #112	; 0x70
90003dd6:	432a      	orrs	r2, r5
90003dd8:	618a      	str	r2, [r1, #24]
90003dda:	e740      	b.n	90003c5e <HAL_RCC_ClockConfig+0xb6>
90003ddc:	52002000 	.word	0x52002000
90003de0:	58024400 	.word	0x58024400
90003de4:	90012b61 	.word	0x90012b61
90003de8:	24000020 	.word	0x24000020
90003dec:	2400001c 	.word	0x2400001c
90003df0:	24000028 	.word	0x24000028

90003df4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
90003df4:	b510      	push	{r4, lr}
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
90003df6:	4c0c      	ldr	r4, [pc, #48]	; (90003e28 <HAL_RCC_GetHCLKFreq+0x34>)
90003df8:	f7ff fe36 	bl	90003a68 <HAL_RCC_GetSysClockFreq>
90003dfc:	490b      	ldr	r1, [pc, #44]	; (90003e2c <HAL_RCC_GetHCLKFreq+0x38>)
90003dfe:	69a3      	ldr	r3, [r4, #24]
90003e00:	f3c3 2303 	ubfx	r3, r3, #8, #4
90003e04:	5cca      	ldrb	r2, [r1, r3]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90003e06:	69a3      	ldr	r3, [r4, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
90003e08:	f002 021f 	and.w	r2, r2, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90003e0c:	f003 030f 	and.w	r3, r3, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
90003e10:	fa20 f202 	lsr.w	r2, r0, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90003e14:	5ccb      	ldrb	r3, [r1, r3]
90003e16:	f003 031f 	and.w	r3, r3, #31
90003e1a:	fa22 f003 	lsr.w	r0, r2, r3
90003e1e:	4b04      	ldr	r3, [pc, #16]	; (90003e30 <HAL_RCC_GetHCLKFreq+0x3c>)
90003e20:	6018      	str	r0, [r3, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
90003e22:	4b04      	ldr	r3, [pc, #16]	; (90003e34 <HAL_RCC_GetHCLKFreq+0x40>)
90003e24:	601a      	str	r2, [r3, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
90003e26:	bd10      	pop	{r4, pc}
90003e28:	58024400 	.word	0x58024400
90003e2c:	90012b61 	.word	0x90012b61
90003e30:	24000020 	.word	0x24000020
90003e34:	2400001c 	.word	0x2400001c

90003e38 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
90003e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
90003e3a:	4c3a      	ldr	r4, [pc, #232]	; (90003f24 <RCCEx_PLL2_Config+0xec>)
{
90003e3c:	4606      	mov	r6, r0
90003e3e:	460d      	mov	r5, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
90003e40:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90003e42:	f003 0303 	and.w	r3, r3, #3
90003e46:	2b03      	cmp	r3, #3
90003e48:	d069      	beq.n	90003f1e <RCCEx_PLL2_Config+0xe6>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
90003e4a:	6823      	ldr	r3, [r4, #0]
90003e4c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
90003e50:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90003e52:	f7fd ff5b 	bl	90001d0c <HAL_GetTick>
90003e56:	4607      	mov	r7, r0

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
90003e58:	6823      	ldr	r3, [r4, #0]
90003e5a:	011a      	lsls	r2, r3, #4
90003e5c:	d44b      	bmi.n	90003ef6 <RCCEx_PLL2_Config+0xbe>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
90003e5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90003e60:	6832      	ldr	r2, [r6, #0]
90003e62:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
90003e66:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
90003e6a:	62a3      	str	r3, [r4, #40]	; 0x28
90003e6c:	68b3      	ldr	r3, [r6, #8]
90003e6e:	68f2      	ldr	r2, [r6, #12]
90003e70:	3b01      	subs	r3, #1
90003e72:	3a01      	subs	r2, #1
90003e74:	025b      	lsls	r3, r3, #9
90003e76:	0412      	lsls	r2, r2, #16
90003e78:	b29b      	uxth	r3, r3
90003e7a:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
90003e7e:	4313      	orrs	r3, r2
90003e80:	6872      	ldr	r2, [r6, #4]
90003e82:	3a01      	subs	r2, #1
90003e84:	f3c2 0208 	ubfx	r2, r2, #0, #9
90003e88:	4313      	orrs	r3, r2
90003e8a:	6932      	ldr	r2, [r6, #16]
90003e8c:	3a01      	subs	r2, #1
90003e8e:	0612      	lsls	r2, r2, #24
90003e90:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
90003e94:	4313      	orrs	r3, r2
90003e96:	63a3      	str	r3, [r4, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
90003e98:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003e9a:	6972      	ldr	r2, [r6, #20]
90003e9c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
90003ea0:	4313      	orrs	r3, r2
90003ea2:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
90003ea4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003ea6:	69b2      	ldr	r2, [r6, #24]
90003ea8:	f023 0320 	bic.w	r3, r3, #32
90003eac:	4313      	orrs	r3, r2
90003eae:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
90003eb0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003eb2:	f023 0310 	bic.w	r3, r3, #16
90003eb6:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
90003eb8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90003eba:	69f2      	ldr	r2, [r6, #28]
90003ebc:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
90003ec0:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
90003ec4:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
90003ec8:	63e3      	str	r3, [r4, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
90003eca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003ecc:	f043 0310 	orr.w	r3, r3, #16
90003ed0:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
90003ed2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
90003ed4:	b9b5      	cbnz	r5, 90003f04 <RCCEx_PLL2_Config+0xcc>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
90003ed6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
90003eda:	62e3      	str	r3, [r4, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
90003edc:	4c11      	ldr	r4, [pc, #68]	; (90003f24 <RCCEx_PLL2_Config+0xec>)
90003ede:	6823      	ldr	r3, [r4, #0]
90003ee0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
90003ee4:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90003ee6:	f7fd ff11 	bl	90001d0c <HAL_GetTick>
90003eea:	4605      	mov	r5, r0

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
90003eec:	6823      	ldr	r3, [r4, #0]
90003eee:	011b      	lsls	r3, r3, #4
90003ef0:	d50f      	bpl.n	90003f12 <RCCEx_PLL2_Config+0xda>
    }

  }


  return status;
90003ef2:	2000      	movs	r0, #0
90003ef4:	e005      	b.n	90003f02 <RCCEx_PLL2_Config+0xca>
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
90003ef6:	f7fd ff09 	bl	90001d0c <HAL_GetTick>
90003efa:	1bc0      	subs	r0, r0, r7
90003efc:	2802      	cmp	r0, #2
90003efe:	d9ab      	bls.n	90003e58 <RCCEx_PLL2_Config+0x20>
        return HAL_TIMEOUT;
90003f00:	2003      	movs	r0, #3
}
90003f02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if(Divider == DIVIDER_Q_UPDATE)
90003f04:	2d01      	cmp	r5, #1
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
90003f06:	bf0c      	ite	eq
90003f08:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
90003f0c:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
90003f10:	e7e3      	b.n	90003eda <RCCEx_PLL2_Config+0xa2>
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
90003f12:	f7fd fefb 	bl	90001d0c <HAL_GetTick>
90003f16:	1b40      	subs	r0, r0, r5
90003f18:	2802      	cmp	r0, #2
90003f1a:	d9e7      	bls.n	90003eec <RCCEx_PLL2_Config+0xb4>
90003f1c:	e7f0      	b.n	90003f00 <RCCEx_PLL2_Config+0xc8>
    return HAL_ERROR;
90003f1e:	2001      	movs	r0, #1
90003f20:	e7ef      	b.n	90003f02 <RCCEx_PLL2_Config+0xca>
90003f22:	bf00      	nop
90003f24:	58024400 	.word	0x58024400

90003f28 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
90003f28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
90003f2a:	4c3a      	ldr	r4, [pc, #232]	; (90004014 <RCCEx_PLL3_Config+0xec>)
{
90003f2c:	4606      	mov	r6, r0
90003f2e:	460d      	mov	r5, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
90003f30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90003f32:	f003 0303 	and.w	r3, r3, #3
90003f36:	2b03      	cmp	r3, #3
90003f38:	d069      	beq.n	9000400e <RCCEx_PLL3_Config+0xe6>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
90003f3a:	6823      	ldr	r3, [r4, #0]
90003f3c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
90003f40:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90003f42:	f7fd fee3 	bl	90001d0c <HAL_GetTick>
90003f46:	4607      	mov	r7, r0
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
90003f48:	6823      	ldr	r3, [r4, #0]
90003f4a:	009a      	lsls	r2, r3, #2
90003f4c:	d44b      	bmi.n	90003fe6 <RCCEx_PLL3_Config+0xbe>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
90003f4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90003f50:	6832      	ldr	r2, [r6, #0]
90003f52:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
90003f56:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
90003f5a:	62a3      	str	r3, [r4, #40]	; 0x28
90003f5c:	68b3      	ldr	r3, [r6, #8]
90003f5e:	68f2      	ldr	r2, [r6, #12]
90003f60:	3b01      	subs	r3, #1
90003f62:	3a01      	subs	r2, #1
90003f64:	025b      	lsls	r3, r3, #9
90003f66:	0412      	lsls	r2, r2, #16
90003f68:	b29b      	uxth	r3, r3
90003f6a:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
90003f6e:	4313      	orrs	r3, r2
90003f70:	6872      	ldr	r2, [r6, #4]
90003f72:	3a01      	subs	r2, #1
90003f74:	f3c2 0208 	ubfx	r2, r2, #0, #9
90003f78:	4313      	orrs	r3, r2
90003f7a:	6932      	ldr	r2, [r6, #16]
90003f7c:	3a01      	subs	r2, #1
90003f7e:	0612      	lsls	r2, r2, #24
90003f80:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
90003f84:	4313      	orrs	r3, r2
90003f86:	6423      	str	r3, [r4, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
90003f88:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003f8a:	6972      	ldr	r2, [r6, #20]
90003f8c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
90003f90:	4313      	orrs	r3, r2
90003f92:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
90003f94:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003f96:	69b2      	ldr	r2, [r6, #24]
90003f98:	f423 7300 	bic.w	r3, r3, #512	; 0x200
90003f9c:	4313      	orrs	r3, r2
90003f9e:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
90003fa0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003fa2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
90003fa6:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
90003fa8:	6c63      	ldr	r3, [r4, #68]	; 0x44
90003faa:	69f2      	ldr	r2, [r6, #28]
90003fac:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
90003fb0:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
90003fb4:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
90003fb8:	6463      	str	r3, [r4, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
90003fba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90003fbc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90003fc0:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
90003fc2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
90003fc4:	b9b5      	cbnz	r5, 90003ff4 <RCCEx_PLL3_Config+0xcc>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
90003fc6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
90003fca:	62e3      	str	r3, [r4, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
90003fcc:	4c11      	ldr	r4, [pc, #68]	; (90004014 <RCCEx_PLL3_Config+0xec>)
90003fce:	6823      	ldr	r3, [r4, #0]
90003fd0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90003fd4:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90003fd6:	f7fd fe99 	bl	90001d0c <HAL_GetTick>
90003fda:	4605      	mov	r5, r0

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
90003fdc:	6823      	ldr	r3, [r4, #0]
90003fde:	009b      	lsls	r3, r3, #2
90003fe0:	d50f      	bpl.n	90004002 <RCCEx_PLL3_Config+0xda>
    }

  }


  return status;
90003fe2:	2000      	movs	r0, #0
90003fe4:	e005      	b.n	90003ff2 <RCCEx_PLL3_Config+0xca>
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
90003fe6:	f7fd fe91 	bl	90001d0c <HAL_GetTick>
90003fea:	1bc0      	subs	r0, r0, r7
90003fec:	2802      	cmp	r0, #2
90003fee:	d9ab      	bls.n	90003f48 <RCCEx_PLL3_Config+0x20>
        return HAL_TIMEOUT;
90003ff0:	2003      	movs	r0, #3
}
90003ff2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if(Divider == DIVIDER_Q_UPDATE)
90003ff4:	2d01      	cmp	r5, #1
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
90003ff6:	bf0c      	ite	eq
90003ff8:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
90003ffc:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
90004000:	e7e3      	b.n	90003fca <RCCEx_PLL3_Config+0xa2>
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
90004002:	f7fd fe83 	bl	90001d0c <HAL_GetTick>
90004006:	1b40      	subs	r0, r0, r5
90004008:	2802      	cmp	r0, #2
9000400a:	d9e7      	bls.n	90003fdc <RCCEx_PLL3_Config+0xb4>
9000400c:	e7f0      	b.n	90003ff0 <RCCEx_PLL3_Config+0xc8>
    return HAL_ERROR;
9000400e:	2001      	movs	r0, #1
90004010:	e7ef      	b.n	90003ff2 <RCCEx_PLL3_Config+0xca>
90004012:	bf00      	nop
90004014:	58024400 	.word	0x58024400

90004018 <HAL_RCCEx_PeriphCLKConfig>:
{
90004018:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
9000401c:	6806      	ldr	r6, [r0, #0]
{
9000401e:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
90004020:	f016 6600 	ands.w	r6, r6, #134217728	; 0x8000000
90004024:	d009      	beq.n	9000403a <HAL_RCCEx_PeriphCLKConfig+0x22>
    switch(PeriphClkInit->SpdifrxClockSelection)
90004026:	6e43      	ldr	r3, [r0, #100]	; 0x64
90004028:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
9000402c:	d02e      	beq.n	9000408c <HAL_RCCEx_PeriphCLKConfig+0x74>
9000402e:	d813      	bhi.n	90004058 <HAL_RCCEx_PeriphCLKConfig+0x40>
90004030:	b1f3      	cbz	r3, 90004070 <HAL_RCCEx_PeriphCLKConfig+0x58>
90004032:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
90004036:	d021      	beq.n	9000407c <HAL_RCCEx_PeriphCLKConfig+0x64>
90004038:	2601      	movs	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
9000403a:	682b      	ldr	r3, [r5, #0]
9000403c:	05dc      	lsls	r4, r3, #23
9000403e:	f140 80ea 	bpl.w	90004216 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    switch(PeriphClkInit->Sai1ClockSelection)
90004042:	6d6b      	ldr	r3, [r5, #84]	; 0x54
90004044:	2b04      	cmp	r3, #4
90004046:	f200 80e5 	bhi.w	90004214 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
9000404a:	e8df f013 	tbh	[pc, r3, lsl #1]
9000404e:	0024      	.short	0x0024
90004050:	00dd002b 	.word	0x00dd002b
90004054:	00290029 	.word	0x00290029
    switch(PeriphClkInit->SpdifrxClockSelection)
90004058:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
9000405c:	d1ec      	bne.n	90004038 <HAL_RCCEx_PeriphCLKConfig+0x20>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
9000405e:	4aa6      	ldr	r2, [pc, #664]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
90004060:	2600      	movs	r6, #0
90004062:	6e69      	ldr	r1, [r5, #100]	; 0x64
90004064:	6d13      	ldr	r3, [r2, #80]	; 0x50
90004066:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
9000406a:	430b      	orrs	r3, r1
9000406c:	6513      	str	r3, [r2, #80]	; 0x50
9000406e:	e7e4      	b.n	9000403a <HAL_RCCEx_PeriphCLKConfig+0x22>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004070:	4aa1      	ldr	r2, [pc, #644]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
90004072:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
90004074:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004078:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
9000407a:	e7f0      	b.n	9000405e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
9000407c:	2102      	movs	r1, #2
9000407e:	3004      	adds	r0, #4
90004080:	f7ff feda 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90004084:	4606      	mov	r6, r0
    if(ret == HAL_OK)
90004086:	2800      	cmp	r0, #0
90004088:	d1d7      	bne.n	9000403a <HAL_RCCEx_PeriphCLKConfig+0x22>
9000408a:	e7e8      	b.n	9000405e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
9000408c:	2102      	movs	r1, #2
9000408e:	3024      	adds	r0, #36	; 0x24
90004090:	f7ff ff4a 	bl	90003f28 <RCCEx_PLL3_Config>
90004094:	e7f6      	b.n	90004084 <HAL_RCCEx_PeriphCLKConfig+0x6c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004096:	4a98      	ldr	r2, [pc, #608]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
90004098:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
9000409a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9000409e:	62d3      	str	r3, [r2, #44]	; 0x2c
    switch(PeriphClkInit->Sai1ClockSelection)
900040a0:	4634      	mov	r4, r6
900040a2:	e004      	b.n	900040ae <HAL_RCCEx_PeriphCLKConfig+0x96>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
900040a4:	2100      	movs	r1, #0
900040a6:	1d28      	adds	r0, r5, #4
900040a8:	f7ff fec6 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
900040ac:	4604      	mov	r4, r0
    if(ret == HAL_OK)
900040ae:	2c00      	cmp	r4, #0
900040b0:	f040 80b3 	bne.w	9000421a <HAL_RCCEx_PeriphCLKConfig+0x202>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
900040b4:	4a90      	ldr	r2, [pc, #576]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
900040b6:	6d69      	ldr	r1, [r5, #84]	; 0x54
900040b8:	6d13      	ldr	r3, [r2, #80]	; 0x50
900040ba:	f023 0307 	bic.w	r3, r3, #7
900040be:	430b      	orrs	r3, r1
900040c0:	6513      	str	r3, [r2, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
900040c2:	682b      	ldr	r3, [r5, #0]
900040c4:	0598      	lsls	r0, r3, #22
900040c6:	d50d      	bpl.n	900040e4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
    switch(PeriphClkInit->Sai23ClockSelection)
900040c8:	6dab      	ldr	r3, [r5, #88]	; 0x58
900040ca:	2b80      	cmp	r3, #128	; 0x80
900040cc:	f000 80c2 	beq.w	90004254 <HAL_RCCEx_PeriphCLKConfig+0x23c>
900040d0:	f200 80a5 	bhi.w	9000421e <HAL_RCCEx_PeriphCLKConfig+0x206>
900040d4:	2b00      	cmp	r3, #0
900040d6:	f000 80b1 	beq.w	9000423c <HAL_RCCEx_PeriphCLKConfig+0x224>
900040da:	2b40      	cmp	r3, #64	; 0x40
900040dc:	f000 80b4 	beq.w	90004248 <HAL_RCCEx_PeriphCLKConfig+0x230>
900040e0:	2601      	movs	r6, #1
900040e2:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
900040e4:	682b      	ldr	r3, [r5, #0]
900040e6:	0559      	lsls	r1, r3, #21
900040e8:	d510      	bpl.n	9000410c <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->Sai4AClockSelection)
900040ea:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
900040ee:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
900040f2:	f000 80d4 	beq.w	9000429e <HAL_RCCEx_PeriphCLKConfig+0x286>
900040f6:	f200 80b5 	bhi.w	90004264 <HAL_RCCEx_PeriphCLKConfig+0x24c>
900040fa:	2b00      	cmp	r3, #0
900040fc:	f000 80c3 	beq.w	90004286 <HAL_RCCEx_PeriphCLKConfig+0x26e>
90004100:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90004104:	f000 80c5 	beq.w	90004292 <HAL_RCCEx_PeriphCLKConfig+0x27a>
90004108:	2601      	movs	r6, #1
9000410a:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
9000410c:	682b      	ldr	r3, [r5, #0]
9000410e:	051a      	lsls	r2, r3, #20
90004110:	d510      	bpl.n	90004134 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    switch(PeriphClkInit->Sai4BClockSelection)
90004112:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
90004116:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
9000411a:	f000 80e5 	beq.w	900042e8 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
9000411e:	f200 80c6 	bhi.w	900042ae <HAL_RCCEx_PeriphCLKConfig+0x296>
90004122:	2b00      	cmp	r3, #0
90004124:	f000 80d4 	beq.w	900042d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
90004128:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
9000412c:	f000 80d6 	beq.w	900042dc <HAL_RCCEx_PeriphCLKConfig+0x2c4>
90004130:	2601      	movs	r6, #1
90004132:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
90004134:	682b      	ldr	r3, [r5, #0]
90004136:	019b      	lsls	r3, r3, #6
90004138:	d50d      	bpl.n	90004156 <HAL_RCCEx_PeriphCLKConfig+0x13e>
    switch(PeriphClkInit->QspiClockSelection)
9000413a:	6cab      	ldr	r3, [r5, #72]	; 0x48
9000413c:	2b20      	cmp	r3, #32
9000413e:	f000 80ef 	beq.w	90004320 <HAL_RCCEx_PeriphCLKConfig+0x308>
90004142:	f200 80db 	bhi.w	900042fc <HAL_RCCEx_PeriphCLKConfig+0x2e4>
90004146:	2b00      	cmp	r3, #0
90004148:	f000 80db 	beq.w	90004302 <HAL_RCCEx_PeriphCLKConfig+0x2ea>
9000414c:	2b10      	cmp	r3, #16
9000414e:	f000 80e1 	beq.w	90004314 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
90004152:	2601      	movs	r6, #1
90004154:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
90004156:	682b      	ldr	r3, [r5, #0]
90004158:	04df      	lsls	r7, r3, #19
9000415a:	d50f      	bpl.n	9000417c <HAL_RCCEx_PeriphCLKConfig+0x164>
    switch(PeriphClkInit->Spi123ClockSelection)
9000415c:	6deb      	ldr	r3, [r5, #92]	; 0x5c
9000415e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90004162:	f000 8101 	beq.w	90004368 <HAL_RCCEx_PeriphCLKConfig+0x350>
90004166:	f200 80e3 	bhi.w	90004330 <HAL_RCCEx_PeriphCLKConfig+0x318>
9000416a:	2b00      	cmp	r3, #0
9000416c:	f000 80f0 	beq.w	90004350 <HAL_RCCEx_PeriphCLKConfig+0x338>
90004170:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90004174:	f000 80f2 	beq.w	9000435c <HAL_RCCEx_PeriphCLKConfig+0x344>
90004178:	2601      	movs	r6, #1
9000417a:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
9000417c:	682b      	ldr	r3, [r5, #0]
9000417e:	0498      	lsls	r0, r3, #18
90004180:	d50f      	bpl.n	900041a2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
    switch(PeriphClkInit->Spi45ClockSelection)
90004182:	6e2b      	ldr	r3, [r5, #96]	; 0x60
90004184:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90004188:	f000 810e 	beq.w	900043a8 <HAL_RCCEx_PeriphCLKConfig+0x390>
9000418c:	f200 80f4 	bhi.w	90004378 <HAL_RCCEx_PeriphCLKConfig+0x360>
90004190:	2b00      	cmp	r3, #0
90004192:	f000 80fa 	beq.w	9000438a <HAL_RCCEx_PeriphCLKConfig+0x372>
90004196:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
9000419a:	f000 80ff 	beq.w	9000439c <HAL_RCCEx_PeriphCLKConfig+0x384>
9000419e:	2601      	movs	r6, #1
900041a0:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
900041a2:	682b      	ldr	r3, [r5, #0]
900041a4:	0459      	lsls	r1, r3, #17
900041a6:	d510      	bpl.n	900041ca <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    switch(PeriphClkInit->Spi6ClockSelection)
900041a8:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
900041ac:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900041b0:	f000 811b 	beq.w	900043ea <HAL_RCCEx_PeriphCLKConfig+0x3d2>
900041b4:	f200 8100 	bhi.w	900043b8 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
900041b8:	2b00      	cmp	r3, #0
900041ba:	f000 8106 	beq.w	900043ca <HAL_RCCEx_PeriphCLKConfig+0x3b2>
900041be:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900041c2:	f000 810c 	beq.w	900043de <HAL_RCCEx_PeriphCLKConfig+0x3c6>
900041c6:	2601      	movs	r6, #1
900041c8:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
900041ca:	682b      	ldr	r3, [r5, #0]
900041cc:	041a      	lsls	r2, r3, #16
900041ce:	d50d      	bpl.n	900041ec <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    switch(PeriphClkInit->FdcanClockSelection)
900041d0:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
900041d2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900041d6:	f000 8110 	beq.w	900043fa <HAL_RCCEx_PeriphCLKConfig+0x3e2>
900041da:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900041de:	f000 811a 	beq.w	90004416 <HAL_RCCEx_PeriphCLKConfig+0x3fe>
900041e2:	2b00      	cmp	r3, #0
900041e4:	f000 810e 	beq.w	90004404 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
900041e8:	2601      	movs	r6, #1
900041ea:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
900041ec:	682b      	ldr	r3, [r5, #0]
900041ee:	01db      	lsls	r3, r3, #7
900041f0:	f140 8127 	bpl.w	90004442 <HAL_RCCEx_PeriphCLKConfig+0x42a>
    switch(PeriphClkInit->FmcClockSelection)
900041f4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
900041f6:	2b03      	cmp	r3, #3
900041f8:	f200 8167 	bhi.w	900044ca <HAL_RCCEx_PeriphCLKConfig+0x4b2>
900041fc:	e8df f013 	tbh	[pc, r3, lsl #1]
90004200:	01130118 	.word	0x01130118
90004204:	0118015f 	.word	0x0118015f
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90004208:	2100      	movs	r1, #0
9000420a:	f105 0024 	add.w	r0, r5, #36	; 0x24
9000420e:	f7ff fe8b 	bl	90003f28 <RCCEx_PLL3_Config>
90004212:	e74b      	b.n	900040ac <HAL_RCCEx_PeriphCLKConfig+0x94>
    switch(PeriphClkInit->Sai1ClockSelection)
90004214:	2601      	movs	r6, #1
90004216:	4634      	mov	r4, r6
90004218:	e753      	b.n	900040c2 <HAL_RCCEx_PeriphCLKConfig+0xaa>
9000421a:	4626      	mov	r6, r4
9000421c:	e751      	b.n	900040c2 <HAL_RCCEx_PeriphCLKConfig+0xaa>
    switch(PeriphClkInit->Sai23ClockSelection)
9000421e:	2bc0      	cmp	r3, #192	; 0xc0
90004220:	d003      	beq.n	9000422a <HAL_RCCEx_PeriphCLKConfig+0x212>
90004222:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90004226:	f47f af5b 	bne.w	900040e0 <HAL_RCCEx_PeriphCLKConfig+0xc8>
    if(ret == HAL_OK)
9000422a:	b9cc      	cbnz	r4, 90004260 <HAL_RCCEx_PeriphCLKConfig+0x248>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
9000422c:	4a32      	ldr	r2, [pc, #200]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
9000422e:	6da9      	ldr	r1, [r5, #88]	; 0x58
90004230:	6d13      	ldr	r3, [r2, #80]	; 0x50
90004232:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
90004236:	430b      	orrs	r3, r1
90004238:	6513      	str	r3, [r2, #80]	; 0x50
9000423a:	e753      	b.n	900040e4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
9000423c:	4a2e      	ldr	r2, [pc, #184]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
9000423e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
90004240:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004244:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
90004246:	e7f0      	b.n	9000422a <HAL_RCCEx_PeriphCLKConfig+0x212>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90004248:	2100      	movs	r1, #0
9000424a:	1d28      	adds	r0, r5, #4
9000424c:	f7ff fdf4 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90004250:	4604      	mov	r4, r0
      break;
90004252:	e7ea      	b.n	9000422a <HAL_RCCEx_PeriphCLKConfig+0x212>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90004254:	2100      	movs	r1, #0
90004256:	f105 0024 	add.w	r0, r5, #36	; 0x24
9000425a:	f7ff fe65 	bl	90003f28 <RCCEx_PLL3_Config>
9000425e:	e7f7      	b.n	90004250 <HAL_RCCEx_PeriphCLKConfig+0x238>
90004260:	4626      	mov	r6, r4
90004262:	e73f      	b.n	900040e4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
    switch(PeriphClkInit->Sai4AClockSelection)
90004264:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
90004268:	d003      	beq.n	90004272 <HAL_RCCEx_PeriphCLKConfig+0x25a>
9000426a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
9000426e:	f47f af4b 	bne.w	90004108 <HAL_RCCEx_PeriphCLKConfig+0xf0>
    if(ret == HAL_OK)
90004272:	b9d4      	cbnz	r4, 900042aa <HAL_RCCEx_PeriphCLKConfig+0x292>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
90004274:	4a20      	ldr	r2, [pc, #128]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
90004276:	f8d5 10a4 	ldr.w	r1, [r5, #164]	; 0xa4
9000427a:	6d93      	ldr	r3, [r2, #88]	; 0x58
9000427c:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
90004280:	430b      	orrs	r3, r1
90004282:	6593      	str	r3, [r2, #88]	; 0x58
90004284:	e742      	b.n	9000410c <HAL_RCCEx_PeriphCLKConfig+0xf4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004286:	4a1c      	ldr	r2, [pc, #112]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
90004288:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
9000428a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9000428e:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
90004290:	e7ef      	b.n	90004272 <HAL_RCCEx_PeriphCLKConfig+0x25a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90004292:	2100      	movs	r1, #0
90004294:	1d28      	adds	r0, r5, #4
90004296:	f7ff fdcf 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
9000429a:	4604      	mov	r4, r0
      break;
9000429c:	e7e9      	b.n	90004272 <HAL_RCCEx_PeriphCLKConfig+0x25a>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
9000429e:	2100      	movs	r1, #0
900042a0:	f105 0024 	add.w	r0, r5, #36	; 0x24
900042a4:	f7ff fe40 	bl	90003f28 <RCCEx_PLL3_Config>
900042a8:	e7f7      	b.n	9000429a <HAL_RCCEx_PeriphCLKConfig+0x282>
900042aa:	4626      	mov	r6, r4
900042ac:	e72e      	b.n	9000410c <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->Sai4BClockSelection)
900042ae:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
900042b2:	d003      	beq.n	900042bc <HAL_RCCEx_PeriphCLKConfig+0x2a4>
900042b4:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
900042b8:	f47f af3a 	bne.w	90004130 <HAL_RCCEx_PeriphCLKConfig+0x118>
    if(ret == HAL_OK)
900042bc:	b9d4      	cbnz	r4, 900042f4 <HAL_RCCEx_PeriphCLKConfig+0x2dc>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
900042be:	4a0e      	ldr	r2, [pc, #56]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
900042c0:	f8d5 10a8 	ldr.w	r1, [r5, #168]	; 0xa8
900042c4:	6d93      	ldr	r3, [r2, #88]	; 0x58
900042c6:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
900042ca:	430b      	orrs	r3, r1
900042cc:	6593      	str	r3, [r2, #88]	; 0x58
900042ce:	e731      	b.n	90004134 <HAL_RCCEx_PeriphCLKConfig+0x11c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900042d0:	4a09      	ldr	r2, [pc, #36]	; (900042f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
900042d2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
900042d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900042d8:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
900042da:	e7ef      	b.n	900042bc <HAL_RCCEx_PeriphCLKConfig+0x2a4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
900042dc:	2100      	movs	r1, #0
900042de:	1d28      	adds	r0, r5, #4
900042e0:	f7ff fdaa 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
900042e4:	4604      	mov	r4, r0
      break;
900042e6:	e7e9      	b.n	900042bc <HAL_RCCEx_PeriphCLKConfig+0x2a4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
900042e8:	2100      	movs	r1, #0
900042ea:	f105 0024 	add.w	r0, r5, #36	; 0x24
900042ee:	f7ff fe1b 	bl	90003f28 <RCCEx_PLL3_Config>
900042f2:	e7f7      	b.n	900042e4 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
900042f4:	4626      	mov	r6, r4
900042f6:	e71d      	b.n	90004134 <HAL_RCCEx_PeriphCLKConfig+0x11c>
900042f8:	58024400 	.word	0x58024400
    switch(PeriphClkInit->QspiClockSelection)
900042fc:	2b30      	cmp	r3, #48	; 0x30
900042fe:	f47f af28 	bne.w	90004152 <HAL_RCCEx_PeriphCLKConfig+0x13a>
    if(ret == HAL_OK)
90004302:	b99c      	cbnz	r4, 9000432c <HAL_RCCEx_PeriphCLKConfig+0x314>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
90004304:	4a9d      	ldr	r2, [pc, #628]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004306:	6ca9      	ldr	r1, [r5, #72]	; 0x48
90004308:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
9000430a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
9000430e:	430b      	orrs	r3, r1
90004310:	64d3      	str	r3, [r2, #76]	; 0x4c
90004312:	e720      	b.n	90004156 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004314:	4a99      	ldr	r2, [pc, #612]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004316:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
90004318:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9000431c:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
9000431e:	e7f0      	b.n	90004302 <HAL_RCCEx_PeriphCLKConfig+0x2ea>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
90004320:	2102      	movs	r1, #2
90004322:	1d28      	adds	r0, r5, #4
90004324:	f7ff fd88 	bl	90003e38 <RCCEx_PLL2_Config>
90004328:	4604      	mov	r4, r0
      break;
9000432a:	e7ea      	b.n	90004302 <HAL_RCCEx_PeriphCLKConfig+0x2ea>
9000432c:	4626      	mov	r6, r4
9000432e:	e712      	b.n	90004156 <HAL_RCCEx_PeriphCLKConfig+0x13e>
    switch(PeriphClkInit->Spi123ClockSelection)
90004330:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
90004334:	d003      	beq.n	9000433e <HAL_RCCEx_PeriphCLKConfig+0x326>
90004336:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
9000433a:	f47f af1d 	bne.w	90004178 <HAL_RCCEx_PeriphCLKConfig+0x160>
    if(ret == HAL_OK)
9000433e:	b9cc      	cbnz	r4, 90004374 <HAL_RCCEx_PeriphCLKConfig+0x35c>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
90004340:	4a8e      	ldr	r2, [pc, #568]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004342:	6de9      	ldr	r1, [r5, #92]	; 0x5c
90004344:	6d13      	ldr	r3, [r2, #80]	; 0x50
90004346:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
9000434a:	430b      	orrs	r3, r1
9000434c:	6513      	str	r3, [r2, #80]	; 0x50
9000434e:	e715      	b.n	9000417c <HAL_RCCEx_PeriphCLKConfig+0x164>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004350:	4a8a      	ldr	r2, [pc, #552]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004352:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
90004354:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004358:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
9000435a:	e7f0      	b.n	9000433e <HAL_RCCEx_PeriphCLKConfig+0x326>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
9000435c:	2100      	movs	r1, #0
9000435e:	1d28      	adds	r0, r5, #4
90004360:	f7ff fd6a 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90004364:	4604      	mov	r4, r0
      break;
90004366:	e7ea      	b.n	9000433e <HAL_RCCEx_PeriphCLKConfig+0x326>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90004368:	2100      	movs	r1, #0
9000436a:	f105 0024 	add.w	r0, r5, #36	; 0x24
9000436e:	f7ff fddb 	bl	90003f28 <RCCEx_PLL3_Config>
90004372:	e7f7      	b.n	90004364 <HAL_RCCEx_PeriphCLKConfig+0x34c>
90004374:	4626      	mov	r6, r4
90004376:	e701      	b.n	9000417c <HAL_RCCEx_PeriphCLKConfig+0x164>
    switch(PeriphClkInit->Spi45ClockSelection)
90004378:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
9000437c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
90004380:	d003      	beq.n	9000438a <HAL_RCCEx_PeriphCLKConfig+0x372>
90004382:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
90004386:	f47f af0a 	bne.w	9000419e <HAL_RCCEx_PeriphCLKConfig+0x186>
    if(ret == HAL_OK)
9000438a:	b99c      	cbnz	r4, 900043b4 <HAL_RCCEx_PeriphCLKConfig+0x39c>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
9000438c:	4a7b      	ldr	r2, [pc, #492]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
9000438e:	6e29      	ldr	r1, [r5, #96]	; 0x60
90004390:	6d13      	ldr	r3, [r2, #80]	; 0x50
90004392:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
90004396:	430b      	orrs	r3, r1
90004398:	6513      	str	r3, [r2, #80]	; 0x50
9000439a:	e702      	b.n	900041a2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
9000439c:	2101      	movs	r1, #1
9000439e:	1d28      	adds	r0, r5, #4
900043a0:	f7ff fd4a 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900043a4:	4604      	mov	r4, r0
      break;
900043a6:	e7f0      	b.n	9000438a <HAL_RCCEx_PeriphCLKConfig+0x372>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900043a8:	2101      	movs	r1, #1
900043aa:	f105 0024 	add.w	r0, r5, #36	; 0x24
900043ae:	f7ff fdbb 	bl	90003f28 <RCCEx_PLL3_Config>
900043b2:	e7f7      	b.n	900043a4 <HAL_RCCEx_PeriphCLKConfig+0x38c>
900043b4:	4626      	mov	r6, r4
900043b6:	e6f4      	b.n	900041a2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
    switch(PeriphClkInit->Spi6ClockSelection)
900043b8:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
900043bc:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
900043c0:	d003      	beq.n	900043ca <HAL_RCCEx_PeriphCLKConfig+0x3b2>
900043c2:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
900043c6:	f47f aefe 	bne.w	900041c6 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
    if(ret == HAL_OK)
900043ca:	b9a4      	cbnz	r4, 900043f6 <HAL_RCCEx_PeriphCLKConfig+0x3de>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
900043cc:	4a6b      	ldr	r2, [pc, #428]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
900043ce:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
900043d2:	6d93      	ldr	r3, [r2, #88]	; 0x58
900043d4:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
900043d8:	430b      	orrs	r3, r1
900043da:	6593      	str	r3, [r2, #88]	; 0x58
900043dc:	e6f5      	b.n	900041ca <HAL_RCCEx_PeriphCLKConfig+0x1b2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
900043de:	2101      	movs	r1, #1
900043e0:	1d28      	adds	r0, r5, #4
900043e2:	f7ff fd29 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900043e6:	4604      	mov	r4, r0
      break;
900043e8:	e7ef      	b.n	900043ca <HAL_RCCEx_PeriphCLKConfig+0x3b2>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900043ea:	2101      	movs	r1, #1
900043ec:	f105 0024 	add.w	r0, r5, #36	; 0x24
900043f0:	f7ff fd9a 	bl	90003f28 <RCCEx_PLL3_Config>
900043f4:	e7f7      	b.n	900043e6 <HAL_RCCEx_PeriphCLKConfig+0x3ce>
900043f6:	4626      	mov	r6, r4
900043f8:	e6e7      	b.n	900041ca <HAL_RCCEx_PeriphCLKConfig+0x1b2>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900043fa:	4a60      	ldr	r2, [pc, #384]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
900043fc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
900043fe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004402:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
90004404:	b96c      	cbnz	r4, 90004422 <HAL_RCCEx_PeriphCLKConfig+0x40a>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
90004406:	4a5d      	ldr	r2, [pc, #372]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004408:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
9000440a:	6d13      	ldr	r3, [r2, #80]	; 0x50
9000440c:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
90004410:	430b      	orrs	r3, r1
90004412:	6513      	str	r3, [r2, #80]	; 0x50
90004414:	e6ea      	b.n	900041ec <HAL_RCCEx_PeriphCLKConfig+0x1d4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90004416:	2101      	movs	r1, #1
90004418:	1d28      	adds	r0, r5, #4
9000441a:	f7ff fd0d 	bl	90003e38 <RCCEx_PLL2_Config>
9000441e:	4604      	mov	r4, r0
      break;
90004420:	e7f0      	b.n	90004404 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
90004422:	4626      	mov	r6, r4
90004424:	e6e2      	b.n	900041ec <HAL_RCCEx_PeriphCLKConfig+0x1d4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004426:	4a55      	ldr	r2, [pc, #340]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004428:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
9000442a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9000442e:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
90004430:	2c00      	cmp	r4, #0
90004432:	d14d      	bne.n	900044d0 <HAL_RCCEx_PeriphCLKConfig+0x4b8>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
90004434:	4a51      	ldr	r2, [pc, #324]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004436:	6c69      	ldr	r1, [r5, #68]	; 0x44
90004438:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
9000443a:	f023 0303 	bic.w	r3, r3, #3
9000443e:	430b      	orrs	r3, r1
90004440:	64d3      	str	r3, [r2, #76]	; 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
90004442:	682b      	ldr	r3, [r5, #0]
90004444:	025f      	lsls	r7, r3, #9
90004446:	d54d      	bpl.n	900044e4 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
90004448:	4f4d      	ldr	r7, [pc, #308]	; (90004580 <HAL_RCCEx_PeriphCLKConfig+0x568>)
9000444a:	683b      	ldr	r3, [r7, #0]
9000444c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90004450:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
90004452:	f7fd fc5b 	bl	90001d0c <HAL_GetTick>
90004456:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
90004458:	683b      	ldr	r3, [r7, #0]
9000445a:	05d8      	lsls	r0, r3, #23
9000445c:	d53a      	bpl.n	900044d4 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    if(ret == HAL_OK)
9000445e:	2c00      	cmp	r4, #0
90004460:	d16c      	bne.n	9000453c <HAL_RCCEx_PeriphCLKConfig+0x524>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
90004462:	4b46      	ldr	r3, [pc, #280]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004464:	f8d5 00b0 	ldr.w	r0, [r5, #176]	; 0xb0
90004468:	6f1a      	ldr	r2, [r3, #112]	; 0x70
9000446a:	4042      	eors	r2, r0
9000446c:	f412 7f40 	tst.w	r2, #768	; 0x300
90004470:	d00b      	beq.n	9000448a <HAL_RCCEx_PeriphCLKConfig+0x472>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
90004472:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
90004474:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
90004476:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
9000447a:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
9000447e:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
90004480:	6f19      	ldr	r1, [r3, #112]	; 0x70
90004482:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
90004486:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
90004488:	671a      	str	r2, [r3, #112]	; 0x70
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
9000448a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
9000448e:	d040      	beq.n	90004512 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
90004490:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
90004494:	4939      	ldr	r1, [pc, #228]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004496:	f403 7240 	and.w	r2, r3, #768	; 0x300
9000449a:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
9000449e:	d149      	bne.n	90004534 <HAL_RCCEx_PeriphCLKConfig+0x51c>
900044a0:	6908      	ldr	r0, [r1, #16]
900044a2:	4a38      	ldr	r2, [pc, #224]	; (90004584 <HAL_RCCEx_PeriphCLKConfig+0x56c>)
900044a4:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
900044a8:	ea02 1213 	and.w	r2, r2, r3, lsr #4
900044ac:	4302      	orrs	r2, r0
900044ae:	610a      	str	r2, [r1, #16]
900044b0:	f3c3 030b 	ubfx	r3, r3, #0, #12
900044b4:	4a31      	ldr	r2, [pc, #196]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
900044b6:	6f11      	ldr	r1, [r2, #112]	; 0x70
900044b8:	430b      	orrs	r3, r1
900044ba:	6713      	str	r3, [r2, #112]	; 0x70
900044bc:	e012      	b.n	900044e4 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
900044be:	2102      	movs	r1, #2
900044c0:	1d28      	adds	r0, r5, #4
900044c2:	f7ff fcb9 	bl	90003e38 <RCCEx_PLL2_Config>
900044c6:	4604      	mov	r4, r0
      break;
900044c8:	e7b2      	b.n	90004430 <HAL_RCCEx_PeriphCLKConfig+0x418>
    switch(PeriphClkInit->FmcClockSelection)
900044ca:	2601      	movs	r6, #1
900044cc:	4634      	mov	r4, r6
900044ce:	e7b8      	b.n	90004442 <HAL_RCCEx_PeriphCLKConfig+0x42a>
900044d0:	4626      	mov	r6, r4
900044d2:	e7b6      	b.n	90004442 <HAL_RCCEx_PeriphCLKConfig+0x42a>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
900044d4:	f7fd fc1a 	bl	90001d0c <HAL_GetTick>
900044d8:	eba0 0008 	sub.w	r0, r0, r8
900044dc:	2864      	cmp	r0, #100	; 0x64
900044de:	d9bb      	bls.n	90004458 <HAL_RCCEx_PeriphCLKConfig+0x440>
        ret = HAL_TIMEOUT;
900044e0:	2603      	movs	r6, #3
900044e2:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
900044e4:	682b      	ldr	r3, [r5, #0]
900044e6:	07da      	lsls	r2, r3, #31
900044e8:	d508      	bpl.n	900044fc <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    switch(PeriphClkInit->Usart16ClockSelection)
900044ea:	6fab      	ldr	r3, [r5, #120]	; 0x78
900044ec:	2b10      	cmp	r3, #16
900044ee:	d03c      	beq.n	9000456a <HAL_RCCEx_PeriphCLKConfig+0x552>
900044f0:	d826      	bhi.n	90004540 <HAL_RCCEx_PeriphCLKConfig+0x528>
900044f2:	b35b      	cbz	r3, 9000454c <HAL_RCCEx_PeriphCLKConfig+0x534>
900044f4:	2b08      	cmp	r3, #8
900044f6:	d032      	beq.n	9000455e <HAL_RCCEx_PeriphCLKConfig+0x546>
900044f8:	2601      	movs	r6, #1
900044fa:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
900044fc:	682b      	ldr	r3, [r5, #0]
900044fe:	079b      	lsls	r3, r3, #30
90004500:	d54f      	bpl.n	900045a2 <HAL_RCCEx_PeriphCLKConfig+0x58a>
    switch(PeriphClkInit->Usart234578ClockSelection)
90004502:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90004504:	2b05      	cmp	r3, #5
90004506:	d862      	bhi.n	900045ce <HAL_RCCEx_PeriphCLKConfig+0x5b6>
90004508:	e8df f003 	tbb	[pc, r3]
9000450c:	435b3e43 	.word	0x435b3e43
90004510:	4343      	.short	0x4343
        tickstart = HAL_GetTick();
90004512:	f7fd fbfb 	bl	90001d0c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
90004516:	f8df 8064 	ldr.w	r8, [pc, #100]	; 9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>
        tickstart = HAL_GetTick();
9000451a:	4607      	mov	r7, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
9000451c:	f241 3988 	movw	r9, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
90004520:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
90004524:	0799      	lsls	r1, r3, #30
90004526:	d4b3      	bmi.n	90004490 <HAL_RCCEx_PeriphCLKConfig+0x478>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90004528:	f7fd fbf0 	bl	90001d0c <HAL_GetTick>
9000452c:	1bc0      	subs	r0, r0, r7
9000452e:	4548      	cmp	r0, r9
90004530:	d9f6      	bls.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x508>
90004532:	e7d5      	b.n	900044e0 <HAL_RCCEx_PeriphCLKConfig+0x4c8>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
90004534:	690a      	ldr	r2, [r1, #16]
90004536:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
9000453a:	e7b8      	b.n	900044ae <HAL_RCCEx_PeriphCLKConfig+0x496>
9000453c:	4626      	mov	r6, r4
9000453e:	e7d1      	b.n	900044e4 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
    switch(PeriphClkInit->Usart16ClockSelection)
90004540:	f023 0208 	bic.w	r2, r3, #8
90004544:	2a20      	cmp	r2, #32
90004546:	d001      	beq.n	9000454c <HAL_RCCEx_PeriphCLKConfig+0x534>
90004548:	2b18      	cmp	r3, #24
9000454a:	d1d5      	bne.n	900044f8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
    if(ret == HAL_OK)
9000454c:	b99c      	cbnz	r4, 90004576 <HAL_RCCEx_PeriphCLKConfig+0x55e>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
9000454e:	4a0b      	ldr	r2, [pc, #44]	; (9000457c <HAL_RCCEx_PeriphCLKConfig+0x564>)
90004550:	6fa9      	ldr	r1, [r5, #120]	; 0x78
90004552:	6d53      	ldr	r3, [r2, #84]	; 0x54
90004554:	f023 0338 	bic.w	r3, r3, #56	; 0x38
90004558:	430b      	orrs	r3, r1
9000455a:	6553      	str	r3, [r2, #84]	; 0x54
9000455c:	e7ce      	b.n	900044fc <HAL_RCCEx_PeriphCLKConfig+0x4e4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
9000455e:	2101      	movs	r1, #1
90004560:	1d28      	adds	r0, r5, #4
90004562:	f7ff fc69 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90004566:	4604      	mov	r4, r0
      break;
90004568:	e7f0      	b.n	9000454c <HAL_RCCEx_PeriphCLKConfig+0x534>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
9000456a:	2101      	movs	r1, #1
9000456c:	f105 0024 	add.w	r0, r5, #36	; 0x24
90004570:	f7ff fcda 	bl	90003f28 <RCCEx_PLL3_Config>
90004574:	e7f7      	b.n	90004566 <HAL_RCCEx_PeriphCLKConfig+0x54e>
90004576:	4626      	mov	r6, r4
90004578:	e7c0      	b.n	900044fc <HAL_RCCEx_PeriphCLKConfig+0x4e4>
9000457a:	bf00      	nop
9000457c:	58024400 	.word	0x58024400
90004580:	58024800 	.word	0x58024800
90004584:	00ffffcf 	.word	0x00ffffcf
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90004588:	2101      	movs	r1, #1
9000458a:	1d28      	adds	r0, r5, #4
9000458c:	f7ff fc54 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90004590:	4604      	mov	r4, r0
    if(ret == HAL_OK)
90004592:	b9fc      	cbnz	r4, 900045d4 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
90004594:	4aa6      	ldr	r2, [pc, #664]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
90004596:	6f69      	ldr	r1, [r5, #116]	; 0x74
90004598:	6d53      	ldr	r3, [r2, #84]	; 0x54
9000459a:	f023 0307 	bic.w	r3, r3, #7
9000459e:	430b      	orrs	r3, r1
900045a0:	6553      	str	r3, [r2, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
900045a2:	682b      	ldr	r3, [r5, #0]
900045a4:	075f      	lsls	r7, r3, #29
900045a6:	d527      	bpl.n	900045f8 <HAL_RCCEx_PeriphCLKConfig+0x5e0>
    switch(PeriphClkInit->Lpuart1ClockSelection)
900045a8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
900045ac:	2b05      	cmp	r3, #5
900045ae:	f200 8139 	bhi.w	90004824 <HAL_RCCEx_PeriphCLKConfig+0x80c>
900045b2:	e8df f013 	tbh	[pc, r3, lsl #1]
900045b6:	0016      	.short	0x0016
900045b8:	01310011 	.word	0x01310011
900045bc:	00160016 	.word	0x00160016
900045c0:	0016      	.short	0x0016
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900045c2:	2101      	movs	r1, #1
900045c4:	f105 0024 	add.w	r0, r5, #36	; 0x24
900045c8:	f7ff fcae 	bl	90003f28 <RCCEx_PLL3_Config>
900045cc:	e7e0      	b.n	90004590 <HAL_RCCEx_PeriphCLKConfig+0x578>
    switch(PeriphClkInit->Usart234578ClockSelection)
900045ce:	2601      	movs	r6, #1
900045d0:	4634      	mov	r4, r6
900045d2:	e7e6      	b.n	900045a2 <HAL_RCCEx_PeriphCLKConfig+0x58a>
900045d4:	4626      	mov	r6, r4
900045d6:	e7e4      	b.n	900045a2 <HAL_RCCEx_PeriphCLKConfig+0x58a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
900045d8:	2101      	movs	r1, #1
900045da:	1d28      	adds	r0, r5, #4
900045dc:	f7ff fc2c 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900045e0:	4604      	mov	r4, r0
    if(ret == HAL_OK)
900045e2:	2c00      	cmp	r4, #0
900045e4:	f040 8121 	bne.w	9000482a <HAL_RCCEx_PeriphCLKConfig+0x812>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
900045e8:	4a91      	ldr	r2, [pc, #580]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900045ea:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
900045ee:	6d93      	ldr	r3, [r2, #88]	; 0x58
900045f0:	f023 0307 	bic.w	r3, r3, #7
900045f4:	430b      	orrs	r3, r1
900045f6:	6593      	str	r3, [r2, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
900045f8:	682b      	ldr	r3, [r5, #0]
900045fa:	0698      	lsls	r0, r3, #26
900045fc:	d510      	bpl.n	90004620 <HAL_RCCEx_PeriphCLKConfig+0x608>
    switch(PeriphClkInit->Lptim1ClockSelection)
900045fe:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
90004602:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90004606:	f000 812e 	beq.w	90004866 <HAL_RCCEx_PeriphCLKConfig+0x84e>
9000460a:	f200 8113 	bhi.w	90004834 <HAL_RCCEx_PeriphCLKConfig+0x81c>
9000460e:	2b00      	cmp	r3, #0
90004610:	f000 8119 	beq.w	90004846 <HAL_RCCEx_PeriphCLKConfig+0x82e>
90004614:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90004618:	f000 811f 	beq.w	9000485a <HAL_RCCEx_PeriphCLKConfig+0x842>
9000461c:	2601      	movs	r6, #1
9000461e:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
90004620:	682b      	ldr	r3, [r5, #0]
90004622:	0659      	lsls	r1, r3, #25
90004624:	d510      	bpl.n	90004648 <HAL_RCCEx_PeriphCLKConfig+0x630>
    switch(PeriphClkInit->Lptim2ClockSelection)
90004626:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
9000462a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
9000462e:	f000 813b 	beq.w	900048a8 <HAL_RCCEx_PeriphCLKConfig+0x890>
90004632:	f200 8120 	bhi.w	90004876 <HAL_RCCEx_PeriphCLKConfig+0x85e>
90004636:	2b00      	cmp	r3, #0
90004638:	f000 8126 	beq.w	90004888 <HAL_RCCEx_PeriphCLKConfig+0x870>
9000463c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
90004640:	f000 812c 	beq.w	9000489c <HAL_RCCEx_PeriphCLKConfig+0x884>
90004644:	2601      	movs	r6, #1
90004646:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
90004648:	682b      	ldr	r3, [r5, #0]
9000464a:	061a      	lsls	r2, r3, #24
9000464c:	d510      	bpl.n	90004670 <HAL_RCCEx_PeriphCLKConfig+0x658>
    switch(PeriphClkInit->Lptim345ClockSelection)
9000464e:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
90004652:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
90004656:	f000 8148 	beq.w	900048ea <HAL_RCCEx_PeriphCLKConfig+0x8d2>
9000465a:	f200 812d 	bhi.w	900048b8 <HAL_RCCEx_PeriphCLKConfig+0x8a0>
9000465e:	2b00      	cmp	r3, #0
90004660:	f000 8133 	beq.w	900048ca <HAL_RCCEx_PeriphCLKConfig+0x8b2>
90004664:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90004668:	f000 8139 	beq.w	900048de <HAL_RCCEx_PeriphCLKConfig+0x8c6>
9000466c:	2601      	movs	r6, #1
9000466e:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
90004670:	682b      	ldr	r3, [r5, #0]
90004672:	071b      	lsls	r3, r3, #28
90004674:	d514      	bpl.n	900046a0 <HAL_RCCEx_PeriphCLKConfig+0x688>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
90004676:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
9000467a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
9000467e:	d107      	bne.n	90004690 <HAL_RCCEx_PeriphCLKConfig+0x678>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
90004680:	2102      	movs	r1, #2
90004682:	f105 0024 	add.w	r0, r5, #36	; 0x24
90004686:	f7ff fc4f 	bl	90003f28 <RCCEx_PLL3_Config>
          status = HAL_ERROR;
9000468a:	2800      	cmp	r0, #0
9000468c:	bf18      	it	ne
9000468e:	2601      	movne	r6, #1
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
90004690:	4a67      	ldr	r2, [pc, #412]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
90004692:	f8d5 1080 	ldr.w	r1, [r5, #128]	; 0x80
90004696:	6d53      	ldr	r3, [r2, #84]	; 0x54
90004698:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
9000469c:	430b      	orrs	r3, r1
9000469e:	6553      	str	r3, [r2, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
900046a0:	682b      	ldr	r3, [r5, #0]
900046a2:	06df      	lsls	r7, r3, #27
900046a4:	d514      	bpl.n	900046d0 <HAL_RCCEx_PeriphCLKConfig+0x6b8>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
900046a6:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
900046aa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900046ae:	d107      	bne.n	900046c0 <HAL_RCCEx_PeriphCLKConfig+0x6a8>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
900046b0:	2102      	movs	r1, #2
900046b2:	f105 0024 	add.w	r0, r5, #36	; 0x24
900046b6:	f7ff fc37 	bl	90003f28 <RCCEx_PLL3_Config>
        status = HAL_ERROR;
900046ba:	2800      	cmp	r0, #0
900046bc:	bf18      	it	ne
900046be:	2601      	movne	r6, #1
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
900046c0:	4a5b      	ldr	r2, [pc, #364]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900046c2:	f8d5 1094 	ldr.w	r1, [r5, #148]	; 0x94
900046c6:	6d93      	ldr	r3, [r2, #88]	; 0x58
900046c8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
900046cc:	430b      	orrs	r3, r1
900046ce:	6593      	str	r3, [r2, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
900046d0:	682b      	ldr	r3, [r5, #0]
900046d2:	0318      	lsls	r0, r3, #12
900046d4:	d51a      	bpl.n	9000470c <HAL_RCCEx_PeriphCLKConfig+0x6f4>
    switch(PeriphClkInit->AdcClockSelection)
900046d6:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
900046da:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
900046de:	f000 810c 	beq.w	900048fa <HAL_RCCEx_PeriphCLKConfig+0x8e2>
900046e2:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
900046e6:	d006      	beq.n	900046f6 <HAL_RCCEx_PeriphCLKConfig+0x6de>
900046e8:	2900      	cmp	r1, #0
900046ea:	f040 810c 	bne.w	90004906 <HAL_RCCEx_PeriphCLKConfig+0x8ee>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
900046ee:	1d28      	adds	r0, r5, #4
900046f0:	f7ff fba2 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900046f4:	4604      	mov	r4, r0
    if(ret == HAL_OK)
900046f6:	2c00      	cmp	r4, #0
900046f8:	f040 8108 	bne.w	9000490c <HAL_RCCEx_PeriphCLKConfig+0x8f4>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
900046fc:	4a4c      	ldr	r2, [pc, #304]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900046fe:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
90004702:	6d93      	ldr	r3, [r2, #88]	; 0x58
90004704:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
90004708:	430b      	orrs	r3, r1
9000470a:	6593      	str	r3, [r2, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
9000470c:	682b      	ldr	r3, [r5, #0]
9000470e:	0359      	lsls	r1, r3, #13
90004710:	d51c      	bpl.n	9000474c <HAL_RCCEx_PeriphCLKConfig+0x734>
    switch(PeriphClkInit->UsbClockSelection)
90004712:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
90004716:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
9000471a:	f000 80f9 	beq.w	90004910 <HAL_RCCEx_PeriphCLKConfig+0x8f8>
9000471e:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
90004722:	d008      	beq.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0x71e>
90004724:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
90004728:	f040 80f9 	bne.w	9000491e <HAL_RCCEx_PeriphCLKConfig+0x906>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
9000472c:	4a40      	ldr	r2, [pc, #256]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
9000472e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
90004730:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004734:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
90004736:	2c00      	cmp	r4, #0
90004738:	f040 80f4 	bne.w	90004924 <HAL_RCCEx_PeriphCLKConfig+0x90c>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
9000473c:	4a3c      	ldr	r2, [pc, #240]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
9000473e:	f8d5 1084 	ldr.w	r1, [r5, #132]	; 0x84
90004742:	6d53      	ldr	r3, [r2, #84]	; 0x54
90004744:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
90004748:	430b      	orrs	r3, r1
9000474a:	6553      	str	r3, [r2, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
9000474c:	682b      	ldr	r3, [r5, #0]
9000474e:	03da      	lsls	r2, r3, #15
90004750:	d509      	bpl.n	90004766 <HAL_RCCEx_PeriphCLKConfig+0x74e>
    switch(PeriphClkInit->SdmmcClockSelection)
90004752:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
90004754:	2b00      	cmp	r3, #0
90004756:	f000 80e7 	beq.w	90004928 <HAL_RCCEx_PeriphCLKConfig+0x910>
9000475a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
9000475e:	f000 80f1 	beq.w	90004944 <HAL_RCCEx_PeriphCLKConfig+0x92c>
90004762:	2601      	movs	r6, #1
90004764:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
90004766:	682b      	ldr	r3, [r5, #0]
90004768:	009b      	lsls	r3, r3, #2
9000476a:	d507      	bpl.n	9000477c <HAL_RCCEx_PeriphCLKConfig+0x764>
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
9000476c:	2102      	movs	r1, #2
9000476e:	f105 0024 	add.w	r0, r5, #36	; 0x24
90004772:	f7ff fbd9 	bl	90003f28 <RCCEx_PLL3_Config>
      status=HAL_ERROR;
90004776:	2800      	cmp	r0, #0
90004778:	bf18      	it	ne
9000477a:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
9000477c:	682b      	ldr	r3, [r5, #0]
9000477e:	039f      	lsls	r7, r3, #14
90004780:	d50a      	bpl.n	90004798 <HAL_RCCEx_PeriphCLKConfig+0x780>
    switch(PeriphClkInit->RngClockSelection)
90004782:	6fe9      	ldr	r1, [r5, #124]	; 0x7c
90004784:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
90004788:	f000 80f2 	beq.w	90004970 <HAL_RCCEx_PeriphCLKConfig+0x958>
9000478c:	f200 80e2 	bhi.w	90004954 <HAL_RCCEx_PeriphCLKConfig+0x93c>
90004790:	2900      	cmp	r1, #0
90004792:	f000 80e5 	beq.w	90004960 <HAL_RCCEx_PeriphCLKConfig+0x948>
90004796:	2601      	movs	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
90004798:	02dc      	lsls	r4, r3, #11
9000479a:	d506      	bpl.n	900047aa <HAL_RCCEx_PeriphCLKConfig+0x792>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
9000479c:	4924      	ldr	r1, [pc, #144]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
9000479e:	6f28      	ldr	r0, [r5, #112]	; 0x70
900047a0:	6d0a      	ldr	r2, [r1, #80]	; 0x50
900047a2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
900047a6:	4302      	orrs	r2, r0
900047a8:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
900047aa:	00d8      	lsls	r0, r3, #3
900047ac:	d507      	bpl.n	900047be <HAL_RCCEx_PeriphCLKConfig+0x7a6>
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
900047ae:	4920      	ldr	r1, [pc, #128]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900047b0:	f8d5 00b4 	ldr.w	r0, [r5, #180]	; 0xb4
900047b4:	690a      	ldr	r2, [r1, #16]
900047b6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
900047ba:	4302      	orrs	r2, r0
900047bc:	610a      	str	r2, [r1, #16]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
900047be:	0299      	lsls	r1, r3, #10
900047c0:	d506      	bpl.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
900047c2:	491b      	ldr	r1, [pc, #108]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900047c4:	6ea8      	ldr	r0, [r5, #104]	; 0x68
900047c6:	6d0a      	ldr	r2, [r1, #80]	; 0x50
900047c8:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
900047cc:	4302      	orrs	r2, r0
900047ce:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
900047d0:	005a      	lsls	r2, r3, #1
900047d2:	d509      	bpl.n	900047e8 <HAL_RCCEx_PeriphCLKConfig+0x7d0>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
900047d4:	4a16      	ldr	r2, [pc, #88]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900047d6:	6911      	ldr	r1, [r2, #16]
900047d8:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
900047dc:	6111      	str	r1, [r2, #16]
900047de:	6911      	ldr	r1, [r2, #16]
900047e0:	f8d5 00b8 	ldr.w	r0, [r5, #184]	; 0xb8
900047e4:	4301      	orrs	r1, r0
900047e6:	6111      	str	r1, [r2, #16]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
900047e8:	2b00      	cmp	r3, #0
900047ea:	da06      	bge.n	900047fa <HAL_RCCEx_PeriphCLKConfig+0x7e2>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
900047ec:	4910      	ldr	r1, [pc, #64]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
900047ee:	6d28      	ldr	r0, [r5, #80]	; 0x50
900047f0:	6cca      	ldr	r2, [r1, #76]	; 0x4c
900047f2:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
900047f6:	4302      	orrs	r2, r0
900047f8:	64ca      	str	r2, [r1, #76]	; 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
900047fa:	021b      	lsls	r3, r3, #8
900047fc:	d507      	bpl.n	9000480e <HAL_RCCEx_PeriphCLKConfig+0x7f6>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
900047fe:	4a0c      	ldr	r2, [pc, #48]	; (90004830 <HAL_RCCEx_PeriphCLKConfig+0x818>)
90004800:	f8d5 1088 	ldr.w	r1, [r5, #136]	; 0x88
90004804:	6d53      	ldr	r3, [r2, #84]	; 0x54
90004806:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
9000480a:	430b      	orrs	r3, r1
9000480c:	6553      	str	r3, [r2, #84]	; 0x54
}
9000480e:	1e30      	subs	r0, r6, #0
90004810:	bf18      	it	ne
90004812:	2001      	movne	r0, #1
90004814:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90004818:	2101      	movs	r1, #1
9000481a:	f105 0024 	add.w	r0, r5, #36	; 0x24
9000481e:	f7ff fb83 	bl	90003f28 <RCCEx_PLL3_Config>
90004822:	e6dd      	b.n	900045e0 <HAL_RCCEx_PeriphCLKConfig+0x5c8>
    switch(PeriphClkInit->Lpuart1ClockSelection)
90004824:	2601      	movs	r6, #1
90004826:	4634      	mov	r4, r6
90004828:	e6e6      	b.n	900045f8 <HAL_RCCEx_PeriphCLKConfig+0x5e0>
9000482a:	4626      	mov	r6, r4
9000482c:	e6e4      	b.n	900045f8 <HAL_RCCEx_PeriphCLKConfig+0x5e0>
9000482e:	bf00      	nop
90004830:	58024400 	.word	0x58024400
    switch(PeriphClkInit->Lptim1ClockSelection)
90004834:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
90004838:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
9000483c:	d003      	beq.n	90004846 <HAL_RCCEx_PeriphCLKConfig+0x82e>
9000483e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90004842:	f47f aeeb 	bne.w	9000461c <HAL_RCCEx_PeriphCLKConfig+0x604>
    if(ret == HAL_OK)
90004846:	b9a4      	cbnz	r4, 90004872 <HAL_RCCEx_PeriphCLKConfig+0x85a>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
90004848:	4a4d      	ldr	r2, [pc, #308]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
9000484a:	f8d5 108c 	ldr.w	r1, [r5, #140]	; 0x8c
9000484e:	6d53      	ldr	r3, [r2, #84]	; 0x54
90004850:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
90004854:	430b      	orrs	r3, r1
90004856:	6553      	str	r3, [r2, #84]	; 0x54
90004858:	e6e2      	b.n	90004620 <HAL_RCCEx_PeriphCLKConfig+0x608>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
9000485a:	2100      	movs	r1, #0
9000485c:	1d28      	adds	r0, r5, #4
9000485e:	f7ff faeb 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90004862:	4604      	mov	r4, r0
      break;
90004864:	e7ef      	b.n	90004846 <HAL_RCCEx_PeriphCLKConfig+0x82e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90004866:	2102      	movs	r1, #2
90004868:	f105 0024 	add.w	r0, r5, #36	; 0x24
9000486c:	f7ff fb5c 	bl	90003f28 <RCCEx_PLL3_Config>
90004870:	e7f7      	b.n	90004862 <HAL_RCCEx_PeriphCLKConfig+0x84a>
90004872:	4626      	mov	r6, r4
90004874:	e6d4      	b.n	90004620 <HAL_RCCEx_PeriphCLKConfig+0x608>
    switch(PeriphClkInit->Lptim2ClockSelection)
90004876:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
9000487a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
9000487e:	d003      	beq.n	90004888 <HAL_RCCEx_PeriphCLKConfig+0x870>
90004880:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
90004884:	f47f aede 	bne.w	90004644 <HAL_RCCEx_PeriphCLKConfig+0x62c>
    if(ret == HAL_OK)
90004888:	b9a4      	cbnz	r4, 900048b4 <HAL_RCCEx_PeriphCLKConfig+0x89c>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
9000488a:	4a3d      	ldr	r2, [pc, #244]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
9000488c:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
90004890:	6d93      	ldr	r3, [r2, #88]	; 0x58
90004892:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
90004896:	430b      	orrs	r3, r1
90004898:	6593      	str	r3, [r2, #88]	; 0x58
9000489a:	e6d5      	b.n	90004648 <HAL_RCCEx_PeriphCLKConfig+0x630>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
9000489c:	2100      	movs	r1, #0
9000489e:	1d28      	adds	r0, r5, #4
900048a0:	f7ff faca 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900048a4:	4604      	mov	r4, r0
      break;
900048a6:	e7ef      	b.n	90004888 <HAL_RCCEx_PeriphCLKConfig+0x870>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900048a8:	2102      	movs	r1, #2
900048aa:	f105 0024 	add.w	r0, r5, #36	; 0x24
900048ae:	f7ff fb3b 	bl	90003f28 <RCCEx_PLL3_Config>
900048b2:	e7f7      	b.n	900048a4 <HAL_RCCEx_PeriphCLKConfig+0x88c>
900048b4:	4626      	mov	r6, r4
900048b6:	e6c7      	b.n	90004648 <HAL_RCCEx_PeriphCLKConfig+0x630>
    switch(PeriphClkInit->Lptim345ClockSelection)
900048b8:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
900048bc:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
900048c0:	d003      	beq.n	900048ca <HAL_RCCEx_PeriphCLKConfig+0x8b2>
900048c2:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
900048c6:	f47f aed1 	bne.w	9000466c <HAL_RCCEx_PeriphCLKConfig+0x654>
    if(ret == HAL_OK)
900048ca:	b9a4      	cbnz	r4, 900048f6 <HAL_RCCEx_PeriphCLKConfig+0x8de>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
900048cc:	4a2c      	ldr	r2, [pc, #176]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
900048ce:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
900048d2:	6d93      	ldr	r3, [r2, #88]	; 0x58
900048d4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
900048d8:	430b      	orrs	r3, r1
900048da:	6593      	str	r3, [r2, #88]	; 0x58
900048dc:	e6c8      	b.n	90004670 <HAL_RCCEx_PeriphCLKConfig+0x658>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
900048de:	2100      	movs	r1, #0
900048e0:	1d28      	adds	r0, r5, #4
900048e2:	f7ff faa9 	bl	90003e38 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900048e6:	4604      	mov	r4, r0
      break;
900048e8:	e7ef      	b.n	900048ca <HAL_RCCEx_PeriphCLKConfig+0x8b2>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900048ea:	2102      	movs	r1, #2
900048ec:	f105 0024 	add.w	r0, r5, #36	; 0x24
900048f0:	f7ff fb1a 	bl	90003f28 <RCCEx_PLL3_Config>
900048f4:	e7f7      	b.n	900048e6 <HAL_RCCEx_PeriphCLKConfig+0x8ce>
900048f6:	4626      	mov	r6, r4
900048f8:	e6ba      	b.n	90004670 <HAL_RCCEx_PeriphCLKConfig+0x658>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900048fa:	2102      	movs	r1, #2
900048fc:	f105 0024 	add.w	r0, r5, #36	; 0x24
90004900:	f7ff fb12 	bl	90003f28 <RCCEx_PLL3_Config>
90004904:	e6f6      	b.n	900046f4 <HAL_RCCEx_PeriphCLKConfig+0x6dc>
    switch(PeriphClkInit->AdcClockSelection)
90004906:	2601      	movs	r6, #1
90004908:	4634      	mov	r4, r6
9000490a:	e6ff      	b.n	9000470c <HAL_RCCEx_PeriphCLKConfig+0x6f4>
9000490c:	4626      	mov	r6, r4
9000490e:	e6fd      	b.n	9000470c <HAL_RCCEx_PeriphCLKConfig+0x6f4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90004910:	2101      	movs	r1, #1
90004912:	f105 0024 	add.w	r0, r5, #36	; 0x24
90004916:	f7ff fb07 	bl	90003f28 <RCCEx_PLL3_Config>
9000491a:	4604      	mov	r4, r0
      break;
9000491c:	e70b      	b.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0x71e>
    switch(PeriphClkInit->UsbClockSelection)
9000491e:	2601      	movs	r6, #1
90004920:	4634      	mov	r4, r6
90004922:	e713      	b.n	9000474c <HAL_RCCEx_PeriphCLKConfig+0x734>
90004924:	4626      	mov	r6, r4
90004926:	e711      	b.n	9000474c <HAL_RCCEx_PeriphCLKConfig+0x734>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004928:	4a15      	ldr	r2, [pc, #84]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
9000492a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
9000492c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004930:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
90004932:	b96c      	cbnz	r4, 90004950 <HAL_RCCEx_PeriphCLKConfig+0x938>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
90004934:	4a12      	ldr	r2, [pc, #72]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
90004936:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
90004938:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
9000493a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
9000493e:	430b      	orrs	r3, r1
90004940:	64d3      	str	r3, [r2, #76]	; 0x4c
90004942:	e710      	b.n	90004766 <HAL_RCCEx_PeriphCLKConfig+0x74e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
90004944:	2102      	movs	r1, #2
90004946:	1d28      	adds	r0, r5, #4
90004948:	f7ff fa76 	bl	90003e38 <RCCEx_PLL2_Config>
9000494c:	4604      	mov	r4, r0
      break;
9000494e:	e7f0      	b.n	90004932 <HAL_RCCEx_PeriphCLKConfig+0x91a>
90004950:	4626      	mov	r6, r4
90004952:	e708      	b.n	90004766 <HAL_RCCEx_PeriphCLKConfig+0x74e>
    switch(PeriphClkInit->RngClockSelection)
90004954:	f421 7280 	bic.w	r2, r1, #256	; 0x100
90004958:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
9000495c:	f47f af1b 	bne.w	90004796 <HAL_RCCEx_PeriphCLKConfig+0x77e>
    if(ret == HAL_OK)
90004960:	b964      	cbnz	r4, 9000497c <HAL_RCCEx_PeriphCLKConfig+0x964>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
90004962:	4807      	ldr	r0, [pc, #28]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
90004964:	6d42      	ldr	r2, [r0, #84]	; 0x54
90004966:	f422 7240 	bic.w	r2, r2, #768	; 0x300
9000496a:	430a      	orrs	r2, r1
9000496c:	6542      	str	r2, [r0, #84]	; 0x54
9000496e:	e713      	b.n	90004798 <HAL_RCCEx_PeriphCLKConfig+0x780>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90004970:	4803      	ldr	r0, [pc, #12]	; (90004980 <HAL_RCCEx_PeriphCLKConfig+0x968>)
90004972:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
90004974:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
90004978:	62c2      	str	r2, [r0, #44]	; 0x2c
      break;
9000497a:	e7f1      	b.n	90004960 <HAL_RCCEx_PeriphCLKConfig+0x948>
9000497c:	4626      	mov	r6, r4
9000497e:	e70b      	b.n	90004798 <HAL_RCCEx_PeriphCLKConfig+0x780>
90004980:	58024400 	.word	0x58024400

90004984 <HAL_RCCEx_GetD3PCLK1Freq>:
{
90004984:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
90004986:	f7ff fa35 	bl	90003df4 <HAL_RCC_GetHCLKFreq>
9000498a:	4b05      	ldr	r3, [pc, #20]	; (900049a0 <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
9000498c:	4a05      	ldr	r2, [pc, #20]	; (900049a4 <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
9000498e:	6a1b      	ldr	r3, [r3, #32]
90004990:	f3c3 1302 	ubfx	r3, r3, #4, #3
90004994:	5cd3      	ldrb	r3, [r2, r3]
90004996:	f003 031f 	and.w	r3, r3, #31
}
9000499a:	40d8      	lsrs	r0, r3
9000499c:	bd08      	pop	{r3, pc}
9000499e:	bf00      	nop
900049a0:	58024400 	.word	0x58024400
900049a4:	90012b61 	.word	0x90012b61

900049a8 <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
900049a8:	4a4e      	ldr	r2, [pc, #312]	; (90004ae4 <HAL_RCCEx_GetPLL2ClockFreq+0x13c>)
{
900049aa:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
900049ac:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
900049ae:	6a96      	ldr	r6, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
900049b0:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  if (pll2m != 0U)
900049b2:	f416 3f7c 	tst.w	r6, #258048	; 0x3f000
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
900049b6:	f3c6 3105 	ubfx	r1, r6, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
900049ba:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
  if (pll2m != 0U)
900049bc:	f000 808d 	beq.w	90004ada <HAL_RCCEx_GetPLL2ClockFreq+0x132>
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
900049c0:	ee07 1a90 	vmov	s15, r1
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
900049c4:	f3c3 03cc 	ubfx	r3, r3, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
900049c8:	f3c5 1100 	ubfx	r1, r5, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
900049cc:	f004 0403 	and.w	r4, r4, #3
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
900049d0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
900049d4:	434b      	muls	r3, r1
    switch (pllsource)
900049d6:	2c01      	cmp	r4, #1
900049d8:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
900049dc:	ee07 3a90 	vmov	s15, r3
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
900049e0:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
    switch (pllsource)
900049e4:	d06b      	beq.n	90004abe <HAL_RCCEx_GetPLL2ClockFreq+0x116>
900049e6:	2c02      	cmp	r4, #2
900049e8:	d05b      	beq.n	90004aa2 <HAL_RCCEx_GetPLL2ClockFreq+0xfa>
900049ea:	2c00      	cmp	r4, #0
900049ec:	d167      	bne.n	90004abe <HAL_RCCEx_GetPLL2ClockFreq+0x116>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
900049ee:	6813      	ldr	r3, [r2, #0]
900049f0:	069b      	lsls	r3, r3, #26
900049f2:	d546      	bpl.n	90004a82 <HAL_RCCEx_GetPLL2ClockFreq+0xda>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
900049f4:	6811      	ldr	r1, [r2, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
900049f6:	6b93      	ldr	r3, [r2, #56]	; 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
900049f8:	f3c1 01c1 	ubfx	r1, r1, #3, #2
900049fc:	4a3a      	ldr	r2, [pc, #232]	; (90004ae8 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
900049fe:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004a02:	40ca      	lsrs	r2, r1
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004a04:	ee07 2a10 	vmov	s14, r2
90004a08:	eef8 5ac7 	vcvt.f32.s32	s11, s14
90004a0c:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004a10:	ee06 3a90 	vmov	s13, r3
90004a14:	eef8 6ae6 	vcvt.f32.s32	s13, s13
90004a18:	ee76 7aa7 	vadd.f32	s15, s13, s15
90004a1c:	ee77 7a86 	vadd.f32	s15, s15, s12
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
90004a20:	4a30      	ldr	r2, [pc, #192]	; (90004ae4 <HAL_RCCEx_GetPLL2ClockFreq+0x13c>)
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004a22:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
90004a26:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004a28:	f3c3 2346 	ubfx	r3, r3, #9, #7
90004a2c:	ee07 3a10 	vmov	s14, r3
90004a30:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004a34:	ee37 7a06 	vadd.f32	s14, s14, s12
90004a38:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004a3c:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004a40:	edc0 6a00 	vstr	s13, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
90004a44:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004a46:	f3c3 4306 	ubfx	r3, r3, #16, #7
90004a4a:	ee07 3a10 	vmov	s14, r3
90004a4e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004a52:	ee37 7a06 	vadd.f32	s14, s14, s12
90004a56:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004a5a:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004a5e:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
90004a62:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004a64:	f3c3 6306 	ubfx	r3, r3, #24, #7
90004a68:	ee07 3a10 	vmov	s14, r3
90004a6c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004a70:	ee37 6a06 	vadd.f32	s12, s14, s12
90004a74:	ee87 7a86 	vdiv.f32	s14, s15, s12
90004a78:	eebc 7ac7 	vcvt.u32.f32	s14, s14
90004a7c:	ed80 7a02 	vstr	s14, [r0, #8]
}
90004a80:	bd70      	pop	{r4, r5, r6, pc}
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004a82:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004a84:	eddf 5a19 	vldr	s11, [pc, #100]	; 90004aec <HAL_RCCEx_GetPLL2ClockFreq+0x144>
90004a88:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004a8c:	ee07 3a10 	vmov	s14, r3
90004a90:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004a94:	ee77 7a27 	vadd.f32	s15, s14, s15
90004a98:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004a9c:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004aa0:	e7be      	b.n	90004a20 <HAL_RCCEx_GetPLL2ClockFreq+0x78>
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004aa2:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004aa4:	eddf 5a12 	vldr	s11, [pc, #72]	; 90004af0 <HAL_RCCEx_GetPLL2ClockFreq+0x148>
90004aa8:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004aac:	ee07 3a10 	vmov	s14, r3
90004ab0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004ab4:	ee77 7a27 	vadd.f32	s15, s14, s15
90004ab8:	ee77 7a86 	vadd.f32	s15, s15, s12
90004abc:	e7ee      	b.n	90004a9c <HAL_RCCEx_GetPLL2ClockFreq+0xf4>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90004abe:	6b93      	ldr	r3, [r2, #56]	; 0x38
90004ac0:	eddf 5a0c 	vldr	s11, [pc, #48]	; 90004af4 <HAL_RCCEx_GetPLL2ClockFreq+0x14c>
90004ac4:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004ac8:	ee07 3a10 	vmov	s14, r3
90004acc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004ad0:	ee77 7a27 	vadd.f32	s15, s14, s15
90004ad4:	ee77 7a86 	vadd.f32	s15, s15, s12
90004ad8:	e7e0      	b.n	90004a9c <HAL_RCCEx_GetPLL2ClockFreq+0xf4>
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
90004ada:	e9c0 1100 	strd	r1, r1, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
90004ade:	6081      	str	r1, [r0, #8]
}
90004ae0:	e7ce      	b.n	90004a80 <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
90004ae2:	bf00      	nop
90004ae4:	58024400 	.word	0x58024400
90004ae8:	03d09000 	.word	0x03d09000
90004aec:	4c742400 	.word	0x4c742400
90004af0:	4bbebc20 	.word	0x4bbebc20
90004af4:	4a742400 	.word	0x4a742400

90004af8 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004af8:	4a4e      	ldr	r2, [pc, #312]	; (90004c34 <HAL_RCCEx_GetPLL3ClockFreq+0x13c>)
{
90004afa:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004afc:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
90004afe:	6a96      	ldr	r6, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
90004b00:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  if (pll3m != 0U)
90004b02:	f016 7f7c 	tst.w	r6, #66060288	; 0x3f00000
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
90004b06:	f3c6 5105 	ubfx	r1, r6, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
90004b0a:	6c53      	ldr	r3, [r2, #68]	; 0x44
  if (pll3m != 0U)
90004b0c:	f000 808d 	beq.w	90004c2a <HAL_RCCEx_GetPLL3ClockFreq+0x132>
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b10:	ee07 1a90 	vmov	s15, r1
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
90004b14:	f3c3 03cc 	ubfx	r3, r3, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
90004b18:	f3c5 2100 	ubfx	r1, r5, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004b1c:	f004 0403 	and.w	r4, r4, #3
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b20:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
90004b24:	434b      	muls	r3, r1
    switch (pllsource)
90004b26:	2c01      	cmp	r4, #1
90004b28:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
90004b2c:	ee07 3a90 	vmov	s15, r3
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b30:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
    switch (pllsource)
90004b34:	d06b      	beq.n	90004c0e <HAL_RCCEx_GetPLL3ClockFreq+0x116>
90004b36:	2c02      	cmp	r4, #2
90004b38:	d05b      	beq.n	90004bf2 <HAL_RCCEx_GetPLL3ClockFreq+0xfa>
90004b3a:	2c00      	cmp	r4, #0
90004b3c:	d167      	bne.n	90004c0e <HAL_RCCEx_GetPLL3ClockFreq+0x116>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90004b3e:	6813      	ldr	r3, [r2, #0]
90004b40:	069b      	lsls	r3, r3, #26
90004b42:	d546      	bpl.n	90004bd2 <HAL_RCCEx_GetPLL3ClockFreq+0xda>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004b44:	6811      	ldr	r1, [r2, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b46:	6c13      	ldr	r3, [r2, #64]	; 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004b48:	f3c1 01c1 	ubfx	r1, r1, #3, #2
90004b4c:	4a3a      	ldr	r2, [pc, #232]	; (90004c38 <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b4e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004b52:	40ca      	lsrs	r2, r1
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b54:	ee07 2a10 	vmov	s14, r2
90004b58:	eef8 5ac7 	vcvt.f32.s32	s11, s14
90004b5c:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004b60:	ee06 3a90 	vmov	s13, r3
90004b64:	eef8 6ae6 	vcvt.f32.s32	s13, s13
90004b68:	ee76 7aa7 	vadd.f32	s15, s13, s15
90004b6c:	ee77 7a86 	vadd.f32	s15, s15, s12
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
90004b70:	4a30      	ldr	r2, [pc, #192]	; (90004c34 <HAL_RCCEx_GetPLL3ClockFreq+0x13c>)
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004b72:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
90004b76:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004b78:	f3c3 2346 	ubfx	r3, r3, #9, #7
90004b7c:	ee07 3a10 	vmov	s14, r3
90004b80:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004b84:	ee37 7a06 	vadd.f32	s14, s14, s12
90004b88:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004b8c:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004b90:	edc0 6a00 	vstr	s13, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
90004b94:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004b96:	f3c3 4306 	ubfx	r3, r3, #16, #7
90004b9a:	ee07 3a10 	vmov	s14, r3
90004b9e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004ba2:	ee37 7a06 	vadd.f32	s14, s14, s12
90004ba6:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004baa:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004bae:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
90004bb2:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004bb4:	f3c3 6306 	ubfx	r3, r3, #24, #7
90004bb8:	ee07 3a10 	vmov	s14, r3
90004bbc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004bc0:	ee37 6a06 	vadd.f32	s12, s14, s12
90004bc4:	ee87 7a86 	vdiv.f32	s14, s15, s12
90004bc8:	eebc 7ac7 	vcvt.u32.f32	s14, s14
90004bcc:	ed80 7a02 	vstr	s14, [r0, #8]
}
90004bd0:	bd70      	pop	{r4, r5, r6, pc}
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004bd2:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004bd4:	eddf 5a19 	vldr	s11, [pc, #100]	; 90004c3c <HAL_RCCEx_GetPLL3ClockFreq+0x144>
90004bd8:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004bdc:	ee07 3a10 	vmov	s14, r3
90004be0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004be4:	ee77 7a27 	vadd.f32	s15, s14, s15
90004be8:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004bec:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004bf0:	e7be      	b.n	90004b70 <HAL_RCCEx_GetPLL3ClockFreq+0x78>
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004bf2:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004bf4:	eddf 5a12 	vldr	s11, [pc, #72]	; 90004c40 <HAL_RCCEx_GetPLL3ClockFreq+0x148>
90004bf8:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004bfc:	ee07 3a10 	vmov	s14, r3
90004c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004c04:	ee77 7a27 	vadd.f32	s15, s14, s15
90004c08:	ee77 7a86 	vadd.f32	s15, s15, s12
90004c0c:	e7ee      	b.n	90004bec <HAL_RCCEx_GetPLL3ClockFreq+0xf4>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90004c0e:	6c13      	ldr	r3, [r2, #64]	; 0x40
90004c10:	eddf 5a0c 	vldr	s11, [pc, #48]	; 90004c44 <HAL_RCCEx_GetPLL3ClockFreq+0x14c>
90004c14:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004c18:	ee07 3a10 	vmov	s14, r3
90004c1c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004c20:	ee77 7a27 	vadd.f32	s15, s14, s15
90004c24:	ee77 7a86 	vadd.f32	s15, s15, s12
90004c28:	e7e0      	b.n	90004bec <HAL_RCCEx_GetPLL3ClockFreq+0xf4>
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
90004c2a:	e9c0 1100 	strd	r1, r1, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
90004c2e:	6081      	str	r1, [r0, #8]
}
90004c30:	e7ce      	b.n	90004bd0 <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
90004c32:	bf00      	nop
90004c34:	58024400 	.word	0x58024400
90004c38:	03d09000 	.word	0x03d09000
90004c3c:	4c742400 	.word	0x4c742400
90004c40:	4bbebc20 	.word	0x4bbebc20
90004c44:	4a742400 	.word	0x4a742400

90004c48 <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004c48:	4a4e      	ldr	r2, [pc, #312]	; (90004d84 <HAL_RCCEx_GetPLL1ClockFreq+0x13c>)
{
90004c4a:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004c4c:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
90004c4e:	6a96      	ldr	r6, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
90004c50:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  if (pll1m != 0U)
90004c52:	f416 7f7c 	tst.w	r6, #1008	; 0x3f0
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
90004c56:	f3c6 1105 	ubfx	r1, r6, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90004c5a:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (pll1m != 0U)
90004c5c:	f000 808d 	beq.w	90004d7a <HAL_RCCEx_GetPLL1ClockFreq+0x132>
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004c60:	ee07 1a90 	vmov	s15, r1
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90004c64:	f3c3 03cc 	ubfx	r3, r3, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
90004c68:	f005 0101 	and.w	r1, r5, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90004c6c:	f004 0403 	and.w	r4, r4, #3
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004c70:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90004c74:	434b      	muls	r3, r1
    switch (pllsource)
90004c76:	2c01      	cmp	r4, #1
90004c78:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90004c7c:	ee07 3a90 	vmov	s15, r3
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004c80:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
    switch (pllsource)
90004c84:	d04d      	beq.n	90004d22 <HAL_RCCEx_GetPLL1ClockFreq+0xda>
90004c86:	2c02      	cmp	r4, #2
90004c88:	d05b      	beq.n	90004d42 <HAL_RCCEx_GetPLL1ClockFreq+0xfa>
90004c8a:	2c00      	cmp	r4, #0
90004c8c:	d167      	bne.n	90004d5e <HAL_RCCEx_GetPLL1ClockFreq+0x116>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90004c8e:	6813      	ldr	r3, [r2, #0]
90004c90:	069b      	lsls	r3, r3, #26
90004c92:	d564      	bpl.n	90004d5e <HAL_RCCEx_GetPLL1ClockFreq+0x116>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004c94:	6811      	ldr	r1, [r2, #0]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004c96:	6b13      	ldr	r3, [r2, #48]	; 0x30
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004c98:	f3c1 01c1 	ubfx	r1, r1, #3, #2
90004c9c:	4a3a      	ldr	r2, [pc, #232]	; (90004d88 <HAL_RCCEx_GetPLL1ClockFreq+0x140>)
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004c9e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004ca2:	40ca      	lsrs	r2, r1
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004ca4:	ee07 2a10 	vmov	s14, r2
90004ca8:	eef8 5ac7 	vcvt.f32.s32	s11, s14
90004cac:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004cb0:	ee06 3a90 	vmov	s13, r3
90004cb4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
90004cb8:	ee76 7aa7 	vadd.f32	s15, s13, s15
90004cbc:	ee77 7a86 	vadd.f32	s15, s15, s12
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
90004cc0:	4a30      	ldr	r2, [pc, #192]	; (90004d84 <HAL_RCCEx_GetPLL1ClockFreq+0x13c>)
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004cc2:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
90004cc6:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004cc8:	f3c3 2346 	ubfx	r3, r3, #9, #7
90004ccc:	ee07 3a10 	vmov	s14, r3
90004cd0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004cd4:	ee37 7a06 	vadd.f32	s14, s14, s12
90004cd8:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004cdc:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004ce0:	edc0 6a00 	vstr	s13, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
90004ce4:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004ce6:	f3c3 4306 	ubfx	r3, r3, #16, #7
90004cea:	ee07 3a10 	vmov	s14, r3
90004cee:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004cf2:	ee37 7a06 	vadd.f32	s14, s14, s12
90004cf6:	eec7 6a87 	vdiv.f32	s13, s15, s14
90004cfa:	eefc 6ae6 	vcvt.u32.f32	s13, s13
90004cfe:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
90004d02:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004d04:	f3c3 6306 	ubfx	r3, r3, #24, #7
90004d08:	ee07 3a10 	vmov	s14, r3
90004d0c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004d10:	ee37 6a06 	vadd.f32	s12, s14, s12
90004d14:	ee87 7a86 	vdiv.f32	s14, s15, s12
90004d18:	eebc 7ac7 	vcvt.u32.f32	s14, s14
90004d1c:	ed80 7a02 	vstr	s14, [r0, #8]
}
90004d20:	bd70      	pop	{r4, r5, r6, pc}
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004d22:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004d24:	eddf 5a19 	vldr	s11, [pc, #100]	; 90004d8c <HAL_RCCEx_GetPLL1ClockFreq+0x144>
90004d28:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004d2c:	ee07 3a10 	vmov	s14, r3
90004d30:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004d34:	ee77 7a27 	vadd.f32	s15, s14, s15
90004d38:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004d3c:	ee85 7aa6 	vdiv.f32	s14, s11, s13
90004d40:	e7be      	b.n	90004cc0 <HAL_RCCEx_GetPLL1ClockFreq+0x78>
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004d42:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004d44:	eddf 5a12 	vldr	s11, [pc, #72]	; 90004d90 <HAL_RCCEx_GetPLL1ClockFreq+0x148>
90004d48:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004d4c:	ee07 3a10 	vmov	s14, r3
90004d50:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004d54:	ee77 7a27 	vadd.f32	s15, s14, s15
90004d58:	ee77 7a86 	vadd.f32	s15, s15, s12
90004d5c:	e7ee      	b.n	90004d3c <HAL_RCCEx_GetPLL1ClockFreq+0xf4>
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90004d5e:	6b13      	ldr	r3, [r2, #48]	; 0x30
90004d60:	eddf 5a0c 	vldr	s11, [pc, #48]	; 90004d94 <HAL_RCCEx_GetPLL1ClockFreq+0x14c>
90004d64:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004d68:	ee07 3a10 	vmov	s14, r3
90004d6c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
90004d70:	ee77 7a27 	vadd.f32	s15, s14, s15
90004d74:	ee77 7a86 	vadd.f32	s15, s15, s12
90004d78:	e7e0      	b.n	90004d3c <HAL_RCCEx_GetPLL1ClockFreq+0xf4>
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
90004d7a:	e9c0 1100 	strd	r1, r1, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
90004d7e:	6081      	str	r1, [r0, #8]
}
90004d80:	e7ce      	b.n	90004d20 <HAL_RCCEx_GetPLL1ClockFreq+0xd8>
90004d82:	bf00      	nop
90004d84:	58024400 	.word	0x58024400
90004d88:	03d09000 	.word	0x03d09000
90004d8c:	4a742400 	.word	0x4a742400
90004d90:	4bbebc20 	.word	0x4bbebc20
90004d94:	4c742400 	.word	0x4c742400

90004d98 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
90004d98:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
90004d9c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
90004d9e:	d131      	bne.n	90004e04 <HAL_RCCEx_GetPeriphCLKFreq+0x6c>
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
90004da0:	4b95      	ldr	r3, [pc, #596]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004da2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
90004da4:	f002 0207 	and.w	r2, r2, #7
      switch (saiclocksource)
90004da8:	2a04      	cmp	r2, #4
90004daa:	d84b      	bhi.n	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
90004dac:	e8df f012 	tbh	[pc, r2, lsl #1]
90004db0:	003900cc 	.word	0x003900cc
90004db4:	01400005 	.word	0x01400005
90004db8:	000d      	.short	0x000d
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90004dba:	6818      	ldr	r0, [r3, #0]
90004dbc:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
90004dc0:	d037      	beq.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90004dc2:	a801      	add	r0, sp, #4
90004dc4:	f7ff fe98 	bl	90004af8 <HAL_RCCEx_GetPLL3ClockFreq>
90004dc8:	e032      	b.n	90004e30 <HAL_RCCEx_GetPeriphCLKFreq+0x98>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004dca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004dcc:	6819      	ldr	r1, [r3, #0]
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004dce:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004dd2:	681b      	ldr	r3, [r3, #0]
          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004dd4:	0749      	lsls	r1, r1, #29
90004dd6:	d505      	bpl.n	90004de4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
90004dd8:	b922      	cbnz	r2, 90004de4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004dda:	f3c3 03c1 	ubfx	r3, r3, #3, #2
90004dde:	4887      	ldr	r0, [pc, #540]	; (90004ffc <HAL_RCCEx_GetPeriphCLKFreq+0x264>)
90004de0:	40d8      	lsrs	r0, r3
90004de2:	e026      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90004de4:	05d8      	lsls	r0, r3, #23
90004de6:	d502      	bpl.n	90004dee <HAL_RCCEx_GetPeriphCLKFreq+0x56>
90004de8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
90004dec:	d053      	beq.n	90004e96 <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
90004dee:	4b82      	ldr	r3, [pc, #520]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
90004df0:	6818      	ldr	r0, [r3, #0]
90004df2:	f410 3000 	ands.w	r0, r0, #131072	; 0x20000
90004df6:	d01c      	beq.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
            frequency = HSE_VALUE;
90004df8:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
90004dfc:	4880      	ldr	r0, [pc, #512]	; (90005000 <HAL_RCCEx_GetPeriphCLKFreq+0x268>)
90004dfe:	bf18      	it	ne
90004e00:	2000      	movne	r0, #0
90004e02:	e016      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
90004e04:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
90004e08:	d127      	bne.n	90004e5a <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
90004e0a:	4b7b      	ldr	r3, [pc, #492]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004e0c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
90004e0e:	f402 72e0 	and.w	r2, r2, #448	; 0x1c0
      switch (saiclocksource)
90004e12:	2a80      	cmp	r2, #128	; 0x80
90004e14:	d0d1      	beq.n	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x22>
90004e16:	d80f      	bhi.n	90004e38 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
90004e18:	2a00      	cmp	r2, #0
90004e1a:	f000 8095 	beq.w	90004f48 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
90004e1e:	2a40      	cmp	r2, #64	; 0x40
      switch (srcclk)
90004e20:	d110      	bne.n	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90004e22:	6818      	ldr	r0, [r3, #0]
90004e24:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
90004e28:	d003      	beq.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90004e2a:	a801      	add	r0, sp, #4
90004e2c:	f7ff fdbc 	bl	900049a8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
90004e30:	9801      	ldr	r0, [sp, #4]
}
90004e32:	b005      	add	sp, #20
90004e34:	f85d fb04 	ldr.w	pc, [sp], #4
      switch (saiclocksource)
90004e38:	2ac0      	cmp	r2, #192	; 0xc0
90004e3a:	f000 80f9 	beq.w	90005030 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
90004e3e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
      switch (saiclocksource)
90004e42:	d001      	beq.n	90004e48 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>
      switch (srcclk)
90004e44:	2000      	movs	r0, #0
  return frequency;
90004e46:	e7f4      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004e48:	6cda      	ldr	r2, [r3, #76]	; 0x4c
          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004e4a:	6819      	ldr	r1, [r3, #0]
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004e4c:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004e50:	0749      	lsls	r1, r1, #29
90004e52:	d519      	bpl.n	90004e88 <HAL_RCCEx_GetPeriphCLKFreq+0xf0>
90004e54:	b9c2      	cbnz	r2, 90004e88 <HAL_RCCEx_GetPeriphCLKFreq+0xf0>
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004e56:	681b      	ldr	r3, [r3, #0]
90004e58:	e7bf      	b.n	90004dda <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
90004e5a:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
90004e5e:	d11c      	bne.n	90004e9a <HAL_RCCEx_GetPeriphCLKFreq+0x102>
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
90004e60:	4b65      	ldr	r3, [pc, #404]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004e62:	6d9a      	ldr	r2, [r3, #88]	; 0x58
90004e64:	f402 0260 	and.w	r2, r2, #14680064	; 0xe00000
      switch (saiclocksource)
90004e68:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
90004e6c:	d0a5      	beq.n	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x22>
90004e6e:	d804      	bhi.n	90004e7a <HAL_RCCEx_GetPeriphCLKFreq+0xe2>
90004e70:	2a00      	cmp	r2, #0
90004e72:	d069      	beq.n	90004f48 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
90004e74:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
90004e78:	e7d2      	b.n	90004e20 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
90004e7a:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
90004e7e:	f000 80d7 	beq.w	90005030 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
90004e82:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
90004e86:	e7dc      	b.n	90004e42 <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90004e88:	4b5b      	ldr	r3, [pc, #364]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90004e8a:	6819      	ldr	r1, [r3, #0]
90004e8c:	05c9      	lsls	r1, r1, #23
90004e8e:	d5af      	bpl.n	90004df0 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
90004e90:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
90004e94:	d1ac      	bne.n	90004df0 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
            frequency = CSI_VALUE;
90004e96:	485b      	ldr	r0, [pc, #364]	; (90005004 <HAL_RCCEx_GetPeriphCLKFreq+0x26c>)
90004e98:	e7cb      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
90004e9a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
90004e9e:	d11c      	bne.n	90004eda <HAL_RCCEx_GetPeriphCLKFreq+0x142>
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
90004ea0:	4b55      	ldr	r3, [pc, #340]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004ea2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
90004ea4:	f002 62e0 	and.w	r2, r2, #117440512	; 0x7000000
      switch (saiclocksource)
90004ea8:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
90004eac:	d085      	beq.n	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x22>
90004eae:	d804      	bhi.n	90004eba <HAL_RCCEx_GetPeriphCLKFreq+0x122>
90004eb0:	2a00      	cmp	r2, #0
90004eb2:	d049      	beq.n	90004f48 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
90004eb4:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
90004eb8:	e7b2      	b.n	90004e20 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
90004eba:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
90004ebe:	f000 80b7 	beq.w	90005030 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
90004ec2:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
      switch (srcclk)
90004ec6:	d1bd      	bne.n	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004ec8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004eca:	6819      	ldr	r1, [r3, #0]
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90004ecc:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90004ed0:	0748      	lsls	r0, r1, #29
90004ed2:	d5da      	bpl.n	90004e8a <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
90004ed4:	2a00      	cmp	r2, #0
90004ed6:	d1d8      	bne.n	90004e8a <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
90004ed8:	e7bd      	b.n	90004e56 <HAL_RCCEx_GetPeriphCLKFreq+0xbe>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
90004eda:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
90004ede:	d113      	bne.n	90004f08 <HAL_RCCEx_GetPeriphCLKFreq+0x170>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
90004ee0:	4b45      	ldr	r3, [pc, #276]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004ee2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
90004ee4:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
      switch (srcclk)
90004ee8:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
90004eec:	f43f af65 	beq.w	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x22>
90004ef0:	d803      	bhi.n	90004efa <HAL_RCCEx_GetPeriphCLKFreq+0x162>
90004ef2:	b34a      	cbz	r2, 90004f48 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
90004ef4:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
90004ef8:	e792      	b.n	90004e20 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
90004efa:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
90004efe:	f000 8097 	beq.w	90005030 <HAL_RCCEx_GetPeriphCLKFreq+0x298>
90004f02:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
90004f06:	e7de      	b.n	90004ec6 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
90004f08:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
90004f0c:	d115      	bne.n	90004f3a <HAL_RCCEx_GetPeriphCLKFreq+0x1a2>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
90004f0e:	4b3a      	ldr	r3, [pc, #232]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004f10:	6d9a      	ldr	r2, [r3, #88]	; 0x58
90004f12:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      switch (srcclk)
90004f16:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
90004f1a:	d005      	beq.n	90004f28 <HAL_RCCEx_GetPeriphCLKFreq+0x190>
90004f1c:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
90004f20:	d0d2      	beq.n	90004ec8 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
90004f22:	2a00      	cmp	r2, #0
90004f24:	d18e      	bne.n	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
90004f26:	e77c      	b.n	90004e22 <HAL_RCCEx_GetPeriphCLKFreq+0x8a>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90004f28:	6818      	ldr	r0, [r3, #0]
90004f2a:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
90004f2e:	d080      	beq.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90004f30:	a801      	add	r0, sp, #4
90004f32:	f7ff fde1 	bl	90004af8 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
90004f36:	9803      	ldr	r0, [sp, #12]
90004f38:	e77b      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
90004f3a:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
90004f3e:	d116      	bne.n	90004f6e <HAL_RCCEx_GetPeriphCLKFreq+0x1d6>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
90004f40:	4b2d      	ldr	r3, [pc, #180]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004f42:	6cda      	ldr	r2, [r3, #76]	; 0x4c
      switch (srcclk)
90004f44:	03d2      	lsls	r2, r2, #15
90004f46:	d409      	bmi.n	90004f5c <HAL_RCCEx_GetPeriphCLKFreq+0x1c4>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
90004f48:	6818      	ldr	r0, [r3, #0]
90004f4a:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
90004f4e:	f43f af70 	beq.w	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
           HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
90004f52:	a801      	add	r0, sp, #4
90004f54:	f7ff fe78 	bl	90004c48 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
90004f58:	9802      	ldr	r0, [sp, #8]
90004f5a:	e76a      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90004f5c:	6818      	ldr	r0, [r3, #0]
90004f5e:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
90004f62:	f43f af66 	beq.w	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90004f66:	a801      	add	r0, sp, #4
90004f68:	f7ff fd1e 	bl	900049a8 <HAL_RCCEx_GetPLL2ClockFreq>
90004f6c:	e7e3      	b.n	90004f36 <HAL_RCCEx_GetPeriphCLKFreq+0x19e>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
90004f6e:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
90004f72:	d149      	bne.n	90005008 <HAL_RCCEx_GetPeriphCLKFreq+0x270>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
90004f74:	4a20      	ldr	r2, [pc, #128]	; (90004ff8 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
90004f76:	6d93      	ldr	r3, [r2, #88]	; 0x58
90004f78:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
90004f7c:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90004f80:	d02c      	beq.n	90004fdc <HAL_RCCEx_GetPeriphCLKFreq+0x244>
90004f82:	d80d      	bhi.n	90004fa0 <HAL_RCCEx_GetPeriphCLKFreq+0x208>
90004f84:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90004f88:	d016      	beq.n	90004fb8 <HAL_RCCEx_GetPeriphCLKFreq+0x220>
90004f8a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90004f8e:	d01c      	beq.n	90004fca <HAL_RCCEx_GetPeriphCLKFreq+0x232>
90004f90:	2b00      	cmp	r3, #0
90004f92:	f47f af57 	bne.w	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
}
90004f96:	b005      	add	sp, #20
90004f98:	f85d eb04 	ldr.w	lr, [sp], #4
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
90004f9c:	f7ff bcf2 	b.w	90004984 <HAL_RCCEx_GetD3PCLK1Freq>
      switch (srcclk)
90004fa0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90004fa4:	d021      	beq.n	90004fea <HAL_RCCEx_GetPeriphCLKFreq+0x252>
90004fa6:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90004faa:	f47f af4b 	bne.w	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
90004fae:	6810      	ldr	r0, [r2, #0]
            frequency = HSE_VALUE;
90004fb0:	4b13      	ldr	r3, [pc, #76]	; (90005000 <HAL_RCCEx_GetPeriphCLKFreq+0x268>)
90004fb2:	f410 3000 	ands.w	r0, r0, #131072	; 0x20000
90004fb6:	e01c      	b.n	90004ff2 <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90004fb8:	6810      	ldr	r0, [r2, #0]
90004fba:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
90004fbe:	f43f af38 	beq.w	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90004fc2:	a801      	add	r0, sp, #4
90004fc4:	f7ff fcf0 	bl	900049a8 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
90004fc8:	e7c6      	b.n	90004f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90004fca:	6810      	ldr	r0, [r2, #0]
90004fcc:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
90004fd0:	f43f af2f 	beq.w	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90004fd4:	a801      	add	r0, sp, #4
90004fd6:	f7ff fd8f 	bl	90004af8 <HAL_RCCEx_GetPLL3ClockFreq>
90004fda:	e7bd      	b.n	90004f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
90004fdc:	6810      	ldr	r0, [r2, #0]
90004fde:	f010 0004 	ands.w	r0, r0, #4
90004fe2:	f43f af26 	beq.w	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90004fe6:	6813      	ldr	r3, [r2, #0]
90004fe8:	e6f7      	b.n	90004dda <HAL_RCCEx_GetPeriphCLKFreq+0x42>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
90004fea:	6810      	ldr	r0, [r2, #0]
            frequency = CSI_VALUE;
90004fec:	4b05      	ldr	r3, [pc, #20]	; (90005004 <HAL_RCCEx_GetPeriphCLKFreq+0x26c>)
90004fee:	f410 7080 	ands.w	r0, r0, #256	; 0x100
            frequency = HSE_VALUE;
90004ff2:	bf18      	it	ne
90004ff4:	4618      	movne	r0, r3
90004ff6:	e71c      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
90004ff8:	58024400 	.word	0x58024400
90004ffc:	03d09000 	.word	0x03d09000
90005000:	017d7840 	.word	0x017d7840
90005004:	003d0900 	.word	0x003d0900
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
90005008:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
9000500c:	f47f af1a 	bne.w	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
      srcclk= __HAL_RCC_GET_FDCAN_SOURCE();
90005010:	4a08      	ldr	r2, [pc, #32]	; (90005034 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
90005012:	6d13      	ldr	r3, [r2, #80]	; 0x50
90005014:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
      switch (srcclk)
90005018:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
9000501c:	d006      	beq.n	9000502c <HAL_RCCEx_GetPeriphCLKFreq+0x294>
9000501e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90005022:	d0c9      	beq.n	90004fb8 <HAL_RCCEx_GetPeriphCLKFreq+0x220>
90005024:	2b00      	cmp	r3, #0
90005026:	f47f af0d 	bne.w	90004e44 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
9000502a:	e7c0      	b.n	90004fae <HAL_RCCEx_GetPeriphCLKFreq+0x216>
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
9000502c:	6810      	ldr	r0, [r2, #0]
9000502e:	e78c      	b.n	90004f4a <HAL_RCCEx_GetPeriphCLKFreq+0x1b2>
          frequency = EXTERNAL_CLOCK_VALUE;
90005030:	4801      	ldr	r0, [pc, #4]	; (90005038 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
90005032:	e6fe      	b.n	90004e32 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
90005034:	58024400 	.word	0x58024400
90005038:	00bb8000 	.word	0x00bb8000

9000503c <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
9000503c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
90005040:	4605      	mov	r5, r0
90005042:	b086      	sub	sp, #24
90005044:	4688      	mov	r8, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90005046:	f7fc fe61 	bl	90001d0c <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
9000504a:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
9000504c:	4681      	mov	r9, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
9000504e:	6828      	ldr	r0, [r5, #0]
90005050:	f001 f83e 	bl	900060d0 <SDMMC_CmdBlockLength>
  if (errorstate != HAL_SD_ERROR_NONE)
90005054:	4604      	mov	r4, r0
90005056:	bb48      	cbnz	r0, 900050ac <SD_FindSCR+0x70>
  {
    return errorstate;
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
90005058:	6c69      	ldr	r1, [r5, #68]	; 0x44
9000505a:	6828      	ldr	r0, [r5, #0]
9000505c:	0409      	lsls	r1, r1, #16
9000505e:	f001 f8f8 	bl	90006252 <SDMMC_CmdAppCommand>
  if (errorstate != HAL_SD_ERROR_NONE)
90005062:	4604      	mov	r4, r0
90005064:	bb10      	cbnz	r0, 900050ac <SD_FindSCR+0x70>
  {
    return errorstate;
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
90005066:	f04f 30ff 	mov.w	r0, #4294967295
9000506a:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000506c:	2630      	movs	r6, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  config.DPSM          = SDMMC_DPSM_ENABLE;
  (void)SDMMC_ConfigData(hsd->Instance, &config);
9000506e:	4669      	mov	r1, sp
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90005070:	9404      	str	r4, [sp, #16]
  config.DataLength    = 8U;
90005072:	e9cd 0300 	strd	r0, r3, [sp]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90005076:	2302      	movs	r3, #2
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90005078:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000507a:	e9cd 6302 	strd	r6, r3, [sp, #8]
  config.DPSM          = SDMMC_DPSM_ENABLE;
9000507e:	2301      	movs	r3, #1
90005080:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90005082:	f000 ff56 	bl	90005f32 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
90005086:	6828      	ldr	r0, [r5, #0]
90005088:	f001 f915 	bl	900062b6 <SDMMC_CmdSendSCR>
  if (errorstate != HAL_SD_ERROR_NONE)
9000508c:	4604      	mov	r4, r0
9000508e:	b968      	cbnz	r0, 900050ac <SD_FindSCR+0x70>
  uint32_t tempscr[2U] = {0UL, 0UL};
90005090:	4607      	mov	r7, r0
90005092:	4606      	mov	r6, r0
  {
    return errorstate;
  }

  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
90005094:	f240 5a2a 	movw	sl, #1322	; 0x52a
90005098:	6828      	ldr	r0, [r5, #0]
9000509a:	6b42      	ldr	r2, [r0, #52]	; 0x34
9000509c:	ea12 0f0a 	tst.w	r2, sl
                            SDMMC_FLAG_DATAEND))
  {
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
900050a0:	6b42      	ldr	r2, [r0, #52]	; 0x34
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
900050a2:	d007      	beq.n	900050b4 <SD_FindSCR+0x78>
    {
      return HAL_SD_ERROR_TIMEOUT;
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
900050a4:	0712      	lsls	r2, r2, #28
900050a6:	d519      	bpl.n	900050dc <SD_FindSCR+0xa0>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
900050a8:	2408      	movs	r4, #8

    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
900050aa:	6384      	str	r4, [r0, #56]	; 0x38
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
900050ac:	4620      	mov	r0, r4
900050ae:	b006      	add	sp, #24
900050b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
900050b4:	0311      	lsls	r1, r2, #12
900050b6:	d408      	bmi.n	900050ca <SD_FindSCR+0x8e>
900050b8:	b93c      	cbnz	r4, 900050ca <SD_FindSCR+0x8e>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
900050ba:	f000 ff11 	bl	90005ee0 <SDMMC_ReadFIFO>
900050be:	4606      	mov	r6, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
900050c0:	6828      	ldr	r0, [r5, #0]
      index++;
900050c2:	2401      	movs	r4, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
900050c4:	f000 ff0c 	bl	90005ee0 <SDMMC_ReadFIFO>
900050c8:	4607      	mov	r7, r0
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
900050ca:	f7fc fe1f 	bl	90001d0c <HAL_GetTick>
900050ce:	eba0 0009 	sub.w	r0, r0, r9
900050d2:	3001      	adds	r0, #1
900050d4:	d1e0      	bne.n	90005098 <SD_FindSCR+0x5c>
      return HAL_SD_ERROR_TIMEOUT;
900050d6:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
900050da:	e7e7      	b.n	900050ac <SD_FindSCR+0x70>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
900050dc:	6b42      	ldr	r2, [r0, #52]	; 0x34
900050de:	0793      	lsls	r3, r2, #30
900050e0:	d501      	bpl.n	900050e6 <SD_FindSCR+0xaa>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
900050e2:	2402      	movs	r4, #2
900050e4:	e7e1      	b.n	900050aa <SD_FindSCR+0x6e>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
900050e6:	6b44      	ldr	r4, [r0, #52]	; 0x34
900050e8:	f014 0420 	ands.w	r4, r4, #32
900050ec:	d001      	beq.n	900050f2 <SD_FindSCR+0xb6>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
900050ee:	2420      	movs	r4, #32
900050f0:	e7db      	b.n	900050aa <SD_FindSCR+0x6e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
900050f2:	4a04      	ldr	r2, [pc, #16]	; (90005104 <SD_FindSCR+0xc8>)
900050f4:	ba3f      	rev	r7, r7
900050f6:	ba36      	rev	r6, r6
900050f8:	6382      	str	r2, [r0, #56]	; 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) | \
900050fa:	f8c8 7000 	str.w	r7, [r8]
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) | \
900050fe:	f8c8 6004 	str.w	r6, [r8, #4]
  return HAL_SD_ERROR_NONE;
90005102:	e7d3      	b.n	900050ac <SD_FindSCR+0x70>
90005104:	18000f3a 	.word	0x18000f3a

90005108 <HAL_SD_ReadBlocks_DMA>:
{
90005108:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9000510c:	4604      	mov	r4, r0
9000510e:	b086      	sub	sp, #24
90005110:	4615      	mov	r5, r2
90005112:	461e      	mov	r6, r3
  if (NULL == pData)
90005114:	4688      	mov	r8, r1
90005116:	b941      	cbnz	r1, 9000512a <HAL_SD_ReadBlocks_DMA+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
90005118:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
9000511a:	2701      	movs	r7, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
9000511c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
90005120:	6343      	str	r3, [r0, #52]	; 0x34
}
90005122:	4638      	mov	r0, r7
90005124:	b006      	add	sp, #24
90005126:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (hsd->State == HAL_SD_STATE_READY)
9000512a:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
9000512e:	2b01      	cmp	r3, #1
90005130:	b2df      	uxtb	r7, r3
90005132:	d14e      	bne.n	900051d2 <HAL_SD_ReadBlocks_DMA+0xca>
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90005134:	1993      	adds	r3, r2, r6
90005136:	6d02      	ldr	r2, [r0, #80]	; 0x50
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90005138:	2100      	movs	r1, #0
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
9000513a:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
9000513c:	6341      	str	r1, [r0, #52]	; 0x34
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
9000513e:	d904      	bls.n	9000514a <HAL_SD_ReadBlocks_DMA+0x42>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90005140:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005142:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
90005146:	6343      	str	r3, [r0, #52]	; 0x34
      return HAL_ERROR;
90005148:	e7eb      	b.n	90005122 <HAL_SD_ReadBlocks_DMA+0x1a>
    hsd->State = HAL_SD_STATE_BUSY;
9000514a:	2303      	movs	r3, #3
9000514c:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
90005150:	0273      	lsls	r3, r6, #9
    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
90005152:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    hsd->Instance->DCTRL = 0U;
90005154:	6800      	ldr	r0, [r0, #0]
    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
90005156:	2a01      	cmp	r2, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
90005158:	f04f 32ff 	mov.w	r2, #4294967295
    hsd->Instance->DCTRL = 0U;
9000515c:	62c1      	str	r1, [r0, #44]	; 0x2c
    (void)SDMMC_ConfigData(hsd->Instance, &config);
9000515e:	4669      	mov	r1, sp
    hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
90005160:	62a3      	str	r3, [r4, #40]	; 0x28
      add *= 512U;
90005162:	bf18      	it	ne
90005164:	026d      	lslne	r5, r5, #9
    hsd->pRxBuffPtr = pData;
90005166:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
9000516a:	e9cd 2300 	strd	r2, r3, [sp]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000516e:	2290      	movs	r2, #144	; 0x90
90005170:	2302      	movs	r3, #2
90005172:	e9cd 2302 	strd	r2, r3, [sp, #8]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90005176:	2300      	movs	r3, #0
    config.DPSM          = SDMMC_DPSM_DISABLE;
90005178:	e9cd 3304 	strd	r3, r3, [sp, #16]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
9000517c:	f000 fed9 	bl	90005f32 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
90005180:	6820      	ldr	r0, [r4, #0]
90005182:	68c3      	ldr	r3, [r0, #12]
90005184:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90005188:	60c3      	str	r3, [r0, #12]
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
9000518a:	2301      	movs	r3, #1
    hsd->Instance->IDMABASE0 = (uint32_t) pData ;
9000518c:	f8c0 8058 	str.w	r8, [r0, #88]	; 0x58
    if (NumberOfBlocks > 1U)
90005190:	429e      	cmp	r6, r3
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
90005192:	6503      	str	r3, [r0, #80]	; 0x50
    if (NumberOfBlocks > 1U)
90005194:	d911      	bls.n	900051ba <HAL_SD_ReadBlocks_DMA+0xb2>
      hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
90005196:	2382      	movs	r3, #130	; 0x82
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
90005198:	4629      	mov	r1, r5
      hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
9000519a:	62e3      	str	r3, [r4, #44]	; 0x2c
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
9000519c:	f000 ffca 	bl	90006134 <SDMMC_CmdReadMultiBlock>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900051a0:	6823      	ldr	r3, [r4, #0]
    if (errorstate != HAL_SD_ERROR_NONE)
900051a2:	b180      	cbz	r0, 900051c6 <HAL_SD_ReadBlocks_DMA+0xbe>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900051a4:	4a0c      	ldr	r2, [pc, #48]	; (900051d8 <HAL_SD_ReadBlocks_DMA+0xd0>)
900051a6:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
900051a8:	6b63      	ldr	r3, [r4, #52]	; 0x34
900051aa:	4318      	orrs	r0, r3
      hsd->State = HAL_SD_STATE_READY;
900051ac:	2301      	movs	r3, #1
      hsd->ErrorCode |= errorstate;
900051ae:	6360      	str	r0, [r4, #52]	; 0x34
      hsd->State = HAL_SD_STATE_READY;
900051b0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      hsd->Context = SD_CONTEXT_NONE;
900051b4:	2300      	movs	r3, #0
900051b6:	62e3      	str	r3, [r4, #44]	; 0x2c
      return HAL_ERROR;
900051b8:	e7b3      	b.n	90005122 <HAL_SD_ReadBlocks_DMA+0x1a>
      hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
900051ba:	2381      	movs	r3, #129	; 0x81
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
900051bc:	4629      	mov	r1, r5
      hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
900051be:	62e3      	str	r3, [r4, #44]	; 0x2c
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
900051c0:	f000 ff9f 	bl	90006102 <SDMMC_CmdReadSingleBlock>
900051c4:	e7ec      	b.n	900051a0 <HAL_SD_ReadBlocks_DMA+0x98>
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
900051c6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    return HAL_OK;
900051c8:	4607      	mov	r7, r0
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
900051ca:	f442 7295 	orr.w	r2, r2, #298	; 0x12a
900051ce:	63da      	str	r2, [r3, #60]	; 0x3c
    return HAL_OK;
900051d0:	e7a7      	b.n	90005122 <HAL_SD_ReadBlocks_DMA+0x1a>
    return HAL_BUSY;
900051d2:	2702      	movs	r7, #2
900051d4:	e7a5      	b.n	90005122 <HAL_SD_ReadBlocks_DMA+0x1a>
900051d6:	bf00      	nop
900051d8:	1fe00fff 	.word	0x1fe00fff

900051dc <HAL_SD_WriteBlocks_DMA>:
{
900051dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
900051e0:	4604      	mov	r4, r0
900051e2:	b087      	sub	sp, #28
900051e4:	4615      	mov	r5, r2
900051e6:	461e      	mov	r6, r3
  if (NULL == pData)
900051e8:	4688      	mov	r8, r1
900051ea:	b941      	cbnz	r1, 900051fe <HAL_SD_WriteBlocks_DMA+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
900051ec:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
900051ee:	2701      	movs	r7, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
900051f0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
900051f4:	6343      	str	r3, [r0, #52]	; 0x34
}
900051f6:	4638      	mov	r0, r7
900051f8:	b007      	add	sp, #28
900051fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (hsd->State == HAL_SD_STATE_READY)
900051fe:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
90005202:	2b01      	cmp	r3, #1
90005204:	b2df      	uxtb	r7, r3
90005206:	d14e      	bne.n	900052a6 <HAL_SD_WriteBlocks_DMA+0xca>
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90005208:	1993      	adds	r3, r2, r6
9000520a:	6d02      	ldr	r2, [r0, #80]	; 0x50
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
9000520c:	2100      	movs	r1, #0
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
9000520e:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90005210:	6341      	str	r1, [r0, #52]	; 0x34
    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90005212:	d904      	bls.n	9000521e <HAL_SD_WriteBlocks_DMA+0x42>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90005214:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005216:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
9000521a:	6343      	str	r3, [r0, #52]	; 0x34
      return HAL_ERROR;
9000521c:	e7eb      	b.n	900051f6 <HAL_SD_WriteBlocks_DMA+0x1a>
    hsd->State = HAL_SD_STATE_BUSY;
9000521e:	2303      	movs	r3, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
90005220:	f04f 0990 	mov.w	r9, #144	; 0x90
    hsd->State = HAL_SD_STATE_BUSY;
90005224:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
90005228:	0273      	lsls	r3, r6, #9
    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
9000522a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    hsd->Instance->DCTRL = 0U;
9000522c:	6800      	ldr	r0, [r0, #0]
    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
9000522e:	2a01      	cmp	r2, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
90005230:	f04f 32ff 	mov.w	r2, #4294967295
    hsd->Instance->DCTRL = 0U;
90005234:	62c1      	str	r1, [r0, #44]	; 0x2c
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90005236:	4669      	mov	r1, sp
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
90005238:	6223      	str	r3, [r4, #32]
      add *= 512U;
9000523a:	bf18      	it	ne
9000523c:	026d      	lslne	r5, r5, #9
    hsd->pTxBuffPtr = pData;
9000523e:	f8c4 801c 	str.w	r8, [r4, #28]
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
90005242:	e9cd 2300 	strd	r2, r3, [sp]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
90005246:	2300      	movs	r3, #0
90005248:	e9cd 9302 	strd	r9, r3, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
9000524c:	e9cd 3304 	strd	r3, r3, [sp, #16]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90005250:	f000 fe6f 	bl	90005f32 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
90005254:	6820      	ldr	r0, [r4, #0]
90005256:	68c3      	ldr	r3, [r0, #12]
90005258:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9000525c:	60c3      	str	r3, [r0, #12]
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
9000525e:	2301      	movs	r3, #1
    hsd->Instance->IDMABASE0 = (uint32_t) pData ;
90005260:	f8c0 8058 	str.w	r8, [r0, #88]	; 0x58
    if (NumberOfBlocks > 1U)
90005264:	429e      	cmp	r6, r3
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
90005266:	6503      	str	r3, [r0, #80]	; 0x50
    if (NumberOfBlocks > 1U)
90005268:	d911      	bls.n	9000528e <HAL_SD_WriteBlocks_DMA+0xb2>
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
9000526a:	23a0      	movs	r3, #160	; 0xa0
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
9000526c:	4629      	mov	r1, r5
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
9000526e:	62e3      	str	r3, [r4, #44]	; 0x2c
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
90005270:	f000 ff92 	bl	90006198 <SDMMC_CmdWriteMultiBlock>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005274:	6823      	ldr	r3, [r4, #0]
    if (errorstate != HAL_SD_ERROR_NONE)
90005276:	b180      	cbz	r0, 9000529a <HAL_SD_WriteBlocks_DMA+0xbe>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005278:	4a0c      	ldr	r2, [pc, #48]	; (900052ac <HAL_SD_WriteBlocks_DMA+0xd0>)
9000527a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
9000527c:	6b63      	ldr	r3, [r4, #52]	; 0x34
9000527e:	4318      	orrs	r0, r3
      hsd->State = HAL_SD_STATE_READY;
90005280:	2301      	movs	r3, #1
      hsd->ErrorCode |= errorstate;
90005282:	6360      	str	r0, [r4, #52]	; 0x34
      hsd->State = HAL_SD_STATE_READY;
90005284:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      hsd->Context = SD_CONTEXT_NONE;
90005288:	2300      	movs	r3, #0
9000528a:	62e3      	str	r3, [r4, #44]	; 0x2c
      return HAL_ERROR;
9000528c:	e7b3      	b.n	900051f6 <HAL_SD_WriteBlocks_DMA+0x1a>
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
9000528e:	4629      	mov	r1, r5
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
90005290:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
90005294:	f000 ff67 	bl	90006166 <SDMMC_CmdWriteSingleBlock>
90005298:	e7ec      	b.n	90005274 <HAL_SD_WriteBlocks_DMA+0x98>
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
9000529a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    return HAL_OK;
9000529c:	4607      	mov	r7, r0
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
9000529e:	f442 728d 	orr.w	r2, r2, #282	; 0x11a
900052a2:	63da      	str	r2, [r3, #60]	; 0x3c
    return HAL_OK;
900052a4:	e7a7      	b.n	900051f6 <HAL_SD_WriteBlocks_DMA+0x1a>
    return HAL_BUSY;
900052a6:	2702      	movs	r7, #2
900052a8:	e7a5      	b.n	900051f6 <HAL_SD_WriteBlocks_DMA+0x1a>
900052aa:	bf00      	nop
900052ac:	1fe00fff 	.word	0x1fe00fff

900052b0 <HAL_SD_ErrorCallback>:
900052b0:	4770      	bx	lr
	...

900052b4 <HAL_SD_GetCardCSD>:
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
900052b4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
900052b6:	0f9a      	lsrs	r2, r3, #30
900052b8:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
900052ba:	f3c3 6283 	ubfx	r2, r3, #26, #4
900052be:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
900052c0:	f3c3 6201 	ubfx	r2, r3, #24, #2
900052c4:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
900052c6:	f3c3 4207 	ubfx	r2, r3, #16, #8
900052ca:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
900052cc:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
900052d0:	b2db      	uxtb	r3, r3
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
900052d2:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
900052d4:	714b      	strb	r3, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
900052d6:	6e03      	ldr	r3, [r0, #96]	; 0x60
900052d8:	0d1a      	lsrs	r2, r3, #20
900052da:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
900052dc:	f3c3 4203 	ubfx	r2, r3, #16, #4
900052e0:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
900052e2:	f3c3 32c0 	ubfx	r2, r3, #15, #1
900052e6:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
900052e8:	f3c3 3280 	ubfx	r2, r3, #14, #1
900052ec:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
900052ee:	f3c3 3240 	ubfx	r2, r3, #13, #1
900052f2:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
900052f4:	f3c3 3200 	ubfx	r2, r3, #12, #1
900052f8:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
900052fa:	2200      	movs	r2, #0
900052fc:	734a      	strb	r2, [r1, #13]
  if (hsd->SdCard.CardType == CARD_SDSC)
900052fe:	6b82      	ldr	r2, [r0, #56]	; 0x38
{
90005300:	b510      	push	{r4, lr}
  if (hsd->SdCard.CardType == CARD_SDSC)
90005302:	2a00      	cmp	r2, #0
90005304:	d16c      	bne.n	900053e0 <HAL_SD_GetCardCSD+0x12c>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
90005306:	f640 74fc 	movw	r4, #4092	; 0xffc
9000530a:	6e42      	ldr	r2, [r0, #100]	; 0x64
9000530c:	ea04 0383 	and.w	r3, r4, r3, lsl #2
90005310:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
90005314:	610b      	str	r3, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
90005316:	f3c2 63c2 	ubfx	r3, r2, #27, #3
9000531a:	750b      	strb	r3, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
9000531c:	f3c2 6302 	ubfx	r3, r2, #24, #3
90005320:	754b      	strb	r3, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
90005322:	f3c2 5342 	ubfx	r3, r2, #21, #3
90005326:	758b      	strb	r3, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
90005328:	f3c2 4382 	ubfx	r3, r2, #18, #3
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
9000532c:	f3c2 32c2 	ubfx	r2, r2, #15, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
90005330:	75cb      	strb	r3, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
90005332:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
90005334:	690b      	ldr	r3, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
90005336:	7e0a      	ldrb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
90005338:	3301      	adds	r3, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
9000533a:	f002 0207 	and.w	r2, r2, #7
9000533e:	3202      	adds	r2, #2
90005340:	fa03 f202 	lsl.w	r2, r3, r2
90005344:	6482      	str	r2, [r0, #72]	; 0x48
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
90005346:	7a0b      	ldrb	r3, [r1, #8]
90005348:	f003 040f 	and.w	r4, r3, #15
9000534c:	2301      	movs	r3, #1
9000534e:	40a3      	lsls	r3, r4
90005350:	64c3      	str	r3, [r0, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
90005352:	0a5b      	lsrs	r3, r3, #9
90005354:	4353      	muls	r3, r2
90005356:	6503      	str	r3, [r0, #80]	; 0x50
    hsd->SdCard.LogBlockSize = 512U;
90005358:	f44f 7300 	mov.w	r3, #512	; 0x200
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
9000535c:	6543      	str	r3, [r0, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
9000535e:	6e43      	ldr	r3, [r0, #100]	; 0x64
90005360:	f3c3 3280 	ubfx	r2, r3, #14, #1
90005364:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
90005366:	f3c3 12c6 	ubfx	r2, r3, #7, #7
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
9000536a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
9000536e:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
90005370:	76cb      	strb	r3, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
90005372:	6e83      	ldr	r3, [r0, #104]	; 0x68
  pCSD->Reserved3 = 0;
90005374:	2000      	movs	r0, #0
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
90005376:	0fda      	lsrs	r2, r3, #31
90005378:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
9000537a:	f3c3 7241 	ubfx	r2, r3, #29, #2
9000537e:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
90005380:	f3c3 6282 	ubfx	r2, r3, #26, #3
90005384:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen = (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
90005386:	f3c3 5283 	ubfx	r2, r3, #22, #4
9000538a:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
9000538c:	f3c3 5240 	ubfx	r2, r3, #21, #1
90005390:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
90005394:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->Reserved3 = 0;
90005398:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
9000539c:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
900053a0:	f3c3 32c0 	ubfx	r2, r3, #15, #1
900053a4:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
900053a8:	f3c3 3280 	ubfx	r2, r3, #14, #1
900053ac:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
900053b0:	f3c3 3240 	ubfx	r2, r3, #13, #1
900053b4:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
900053b8:	f3c3 3200 	ubfx	r2, r3, #12, #1
900053bc:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
900053c0:	f3c3 2281 	ubfx	r2, r3, #10, #2
900053c4:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC = (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
900053c8:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
900053cc:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC = (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
900053d0:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
900053d4:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
900053d8:	2301      	movs	r3, #1
900053da:	f881 302a 	strb.w	r3, [r1, #42]	; 0x2a
}
900053de:	bd10      	pop	{r4, pc}
  else if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
900053e0:	2a01      	cmp	r2, #1
900053e2:	d10f      	bne.n	90005404 <HAL_SD_GetCardCSD+0x150>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
900053e4:	041b      	lsls	r3, r3, #16
900053e6:	f8b0 2066 	ldrh.w	r2, [r0, #102]	; 0x66
900053ea:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
900053ee:	4313      	orrs	r3, r2
900053f0:	610b      	str	r3, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
900053f2:	690b      	ldr	r3, [r1, #16]
900053f4:	3301      	adds	r3, #1
900053f6:	029b      	lsls	r3, r3, #10
900053f8:	6483      	str	r3, [r0, #72]	; 0x48
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
900053fa:	6503      	str	r3, [r0, #80]	; 0x50
    hsd->SdCard.BlockSize = 512U;
900053fc:	f44f 7300 	mov.w	r3, #512	; 0x200
90005400:	64c3      	str	r3, [r0, #76]	; 0x4c
90005402:	e7ab      	b.n	9000535c <HAL_SD_GetCardCSD+0xa8>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005404:	6803      	ldr	r3, [r0, #0]
90005406:	4a05      	ldr	r2, [pc, #20]	; (9000541c <HAL_SD_GetCardCSD+0x168>)
90005408:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
9000540a:	6b43      	ldr	r3, [r0, #52]	; 0x34
9000540c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90005410:	6343      	str	r3, [r0, #52]	; 0x34
    hsd->State = HAL_SD_STATE_READY;
90005412:	2301      	movs	r3, #1
90005414:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    return HAL_ERROR;
90005418:	4618      	mov	r0, r3
9000541a:	e7e0      	b.n	900053de <HAL_SD_GetCardCSD+0x12a>
9000541c:	1fe00fff 	.word	0x1fe00fff

90005420 <HAL_SD_InitCard>:
{
90005420:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
90005424:	2700      	movs	r7, #0
{
90005426:	b094      	sub	sp, #80	; 0x50
90005428:	4604      	mov	r4, r0
  sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
9000542a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
9000542e:	e9cd 7704 	strd	r7, r7, [sp, #16]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
90005432:	e9cd 7706 	strd	r7, r7, [sp, #24]
  sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
90005436:	f7ff fcaf 	bl	90004d98 <HAL_RCCEx_GetPeriphCLKFreq>
  if (sdmmc_clk == 0U)
9000543a:	4605      	mov	r5, r0
9000543c:	b948      	cbnz	r0, 90005452 <HAL_SD_InitCard+0x32>
    hsd->State = HAL_SD_STATE_READY;
9000543e:	2501      	movs	r5, #1
    hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
90005440:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    hsd->State = HAL_SD_STATE_READY;
90005444:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
    hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
90005448:	6363      	str	r3, [r4, #52]	; 0x34
}
9000544a:	4628      	mov	r0, r5
9000544c:	b014      	add	sp, #80	; 0x50
9000544e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
90005452:	4e78      	ldr	r6, [pc, #480]	; (90005634 <HAL_SD_InitCard+0x214>)
  (void)SDMMC_Init(hsd->Instance, Init);
90005454:	ab04      	add	r3, sp, #16
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
90005456:	fbb0 f6f6 	udiv	r6, r0, r6
  (void)SDMMC_Init(hsd->Instance, Init);
9000545a:	9807      	ldr	r0, [sp, #28]
9000545c:	4631      	mov	r1, r6
9000545e:	9608      	str	r6, [sp, #32]
  sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
90005460:	0076      	lsls	r6, r6, #1
  (void)SDMMC_Init(hsd->Instance, Init);
90005462:	e88d 0003 	stmia.w	sp, {r0, r1}
90005466:	6820      	ldr	r0, [r4, #0]
90005468:	cb0e      	ldmia	r3, {r1, r2, r3}
9000546a:	f000 fd1f 	bl	90005eac <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
9000546e:	6820      	ldr	r0, [r4, #0]
90005470:	f000 fd3e 	bl	90005ef0 <SDMMC_PowerState_ON>
  HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
90005474:	4870      	ldr	r0, [pc, #448]	; (90005638 <HAL_SD_InitCard+0x218>)
  sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
90005476:	fbb5 f5f6 	udiv	r5, r5, r6
  HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
9000547a:	fbb0 f0f5 	udiv	r0, r0, r5
9000547e:	3001      	adds	r0, #1
90005480:	f7fc fc4a 	bl	90001d18 <HAL_Delay>
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90005484:	6820      	ldr	r0, [r4, #0]
  __IO uint32_t count = 0U;
90005486:	9703      	str	r7, [sp, #12]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90005488:	f000 fd66 	bl	90005f58 <SDMMC_CmdGoIdleState>
  if (errorstate != HAL_SD_ERROR_NONE)
9000548c:	4605      	mov	r5, r0
9000548e:	b950      	cbnz	r0, 900054a6 <HAL_SD_InitCard+0x86>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
90005490:	6820      	ldr	r0, [r4, #0]
90005492:	f001 f871 	bl	90006578 <SDMMC_CmdOperCond>
  if (errorstate == SDMMC_ERROR_TIMEOUT) /* No response to CMD8 */
90005496:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
9000549a:	d10b      	bne.n	900054b4 <HAL_SD_InitCard+0x94>
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
9000549c:	6820      	ldr	r0, [r4, #0]
    hsd->SdCard.CardVersion = CARD_V1_X;
9000549e:	63e5      	str	r5, [r4, #60]	; 0x3c
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
900054a0:	f000 fd5a 	bl	90005f58 <SDMMC_CmdGoIdleState>
    if (errorstate != HAL_SD_ERROR_NONE)
900054a4:	b180      	cbz	r0, 900054c8 <HAL_SD_InitCard+0xa8>
    hsd->State = HAL_SD_STATE_READY;
900054a6:	2501      	movs	r5, #1
900054a8:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
    hsd->ErrorCode |= errorstate;
900054ac:	6b63      	ldr	r3, [r4, #52]	; 0x34
900054ae:	4318      	orrs	r0, r3
900054b0:	6360      	str	r0, [r4, #52]	; 0x34
    return HAL_ERROR;
900054b2:	e7ca      	b.n	9000544a <HAL_SD_InitCard+0x2a>
    hsd->SdCard.CardVersion = CARD_V2_X;
900054b4:	2301      	movs	r3, #1
900054b6:	63e3      	str	r3, [r4, #60]	; 0x3c
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
900054b8:	2100      	movs	r1, #0
900054ba:	6820      	ldr	r0, [r4, #0]
900054bc:	f000 fec9 	bl	90006252 <SDMMC_CmdAppCommand>
    if (errorstate != HAL_SD_ERROR_NONE)
900054c0:	b128      	cbz	r0, 900054ce <HAL_SD_InitCard+0xae>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
900054c2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
900054c6:	e7ee      	b.n	900054a6 <HAL_SD_InitCard+0x86>
  if (hsd->SdCard.CardVersion == CARD_V2_X)
900054c8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
900054ca:	2b01      	cmp	r3, #1
900054cc:	d0f4      	beq.n	900054b8 <HAL_SD_InitCard+0x98>
{
900054ce:	2600      	movs	r6, #0
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
900054d0:	f64f 77fe 	movw	r7, #65534	; 0xfffe
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY |
900054d4:	f8df 8168 	ldr.w	r8, [pc, #360]	; 90005640 <HAL_SD_InitCard+0x220>
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
900054d8:	9b03      	ldr	r3, [sp, #12]
900054da:	42bb      	cmp	r3, r7
900054dc:	d800      	bhi.n	900054e0 <HAL_SD_InitCard+0xc0>
900054de:	b1a6      	cbz	r6, 9000550a <HAL_SD_InitCard+0xea>
  if (count >= SDMMC_MAX_VOLT_TRIAL)
900054e0:	9b03      	ldr	r3, [sp, #12]
900054e2:	42bb      	cmp	r3, r7
900054e4:	d827      	bhi.n	90005536 <HAL_SD_InitCard+0x116>
  if ((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY)
900054e6:	f015 4580 	ands.w	r5, r5, #1073741824	; 0x40000000
900054ea:	d027      	beq.n	9000553c <HAL_SD_InitCard+0x11c>
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
900054ec:	2301      	movs	r3, #1
900054ee:	63a3      	str	r3, [r4, #56]	; 0x38
  uint16_t sd_rca = 0U;
900054f0:	2300      	movs	r3, #0
900054f2:	f8ad 300a 	strh.w	r3, [sp, #10]
  uint32_t tickstart = HAL_GetTick();
900054f6:	f7fc fc09 	bl	90001d0c <HAL_GetTick>
900054fa:	4605      	mov	r5, r0
  if (SDMMC_GetPowerState(hsd->Instance) == 0U)
900054fc:	6820      	ldr	r0, [r4, #0]
900054fe:	f000 fcfd 	bl	90005efc <SDMMC_GetPowerState>
90005502:	b9e8      	cbnz	r0, 90005540 <HAL_SD_InitCard+0x120>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
90005504:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
90005508:	e7cd      	b.n	900054a6 <HAL_SD_InitCard+0x86>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
9000550a:	4631      	mov	r1, r6
9000550c:	6820      	ldr	r0, [r4, #0]
9000550e:	f000 fea0 	bl	90006252 <SDMMC_CmdAppCommand>
    if (errorstate != HAL_SD_ERROR_NONE)
90005512:	2800      	cmp	r0, #0
90005514:	d1c7      	bne.n	900054a6 <HAL_SD_InitCard+0x86>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY |
90005516:	4641      	mov	r1, r8
90005518:	6820      	ldr	r0, [r4, #0]
9000551a:	f000 ff8f 	bl	9000643c <SDMMC_CmdAppOperCommand>
    if (errorstate != HAL_SD_ERROR_NONE)
9000551e:	2800      	cmp	r0, #0
90005520:	d1cf      	bne.n	900054c2 <HAL_SD_InitCard+0xa2>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90005522:	4631      	mov	r1, r6
90005524:	6820      	ldr	r0, [r4, #0]
90005526:	f000 fd01 	bl	90005f2c <SDMMC_GetResponse>
    count++;
9000552a:	9b03      	ldr	r3, [sp, #12]
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
9000552c:	4605      	mov	r5, r0
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
9000552e:	0fc6      	lsrs	r6, r0, #31
    count++;
90005530:	3301      	adds	r3, #1
90005532:	9303      	str	r3, [sp, #12]
90005534:	e7d0      	b.n	900054d8 <HAL_SD_InitCard+0xb8>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
90005536:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
    hsd->State = HAL_SD_STATE_READY;
9000553a:	e7b4      	b.n	900054a6 <HAL_SD_InitCard+0x86>
  hsd->SdCard.CardType = CARD_SDSC;
9000553c:	63a5      	str	r5, [r4, #56]	; 0x38
9000553e:	e7d7      	b.n	900054f0 <HAL_SD_InitCard+0xd0>
  if (hsd->SdCard.CardType != CARD_SECURED)
90005540:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90005542:	2b03      	cmp	r3, #3
90005544:	d03f      	beq.n	900055c6 <HAL_SD_InitCard+0x1a6>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
90005546:	6820      	ldr	r0, [r4, #0]
90005548:	f000 ff28 	bl	9000639c <SDMMC_CmdSendCID>
    if (errorstate != HAL_SD_ERROR_NONE)
9000554c:	2800      	cmp	r0, #0
9000554e:	d1aa      	bne.n	900054a6 <HAL_SD_InitCard+0x86>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90005550:	4601      	mov	r1, r0
90005552:	6820      	ldr	r0, [r4, #0]
90005554:	f000 fcea 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90005558:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
9000555a:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
9000555c:	6820      	ldr	r0, [r4, #0]
9000555e:	f000 fce5 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90005562:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90005564:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90005566:	6820      	ldr	r0, [r4, #0]
90005568:	f000 fce0 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
9000556c:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
9000556e:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90005570:	6820      	ldr	r0, [r4, #0]
90005572:	f000 fcdb 	bl	90005f2c <SDMMC_GetResponse>
  if (hsd->SdCard.CardType != CARD_SECURED)
90005576:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90005578:	67a0      	str	r0, [r4, #120]	; 0x78
  if (hsd->SdCard.CardType != CARD_SECURED)
9000557a:	2b03      	cmp	r3, #3
9000557c:	d023      	beq.n	900055c6 <HAL_SD_InitCard+0x1a6>
      if ((HAL_GetTick() - tickstart) >=  SDMMC_CMDTIMEOUT)
9000557e:	f241 3687 	movw	r6, #4999	; 0x1387
    while (sd_rca == 0U)
90005582:	f8bd 100a 	ldrh.w	r1, [sp, #10]
      errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
90005586:	6820      	ldr	r0, [r4, #0]
    while (sd_rca == 0U)
90005588:	2900      	cmp	r1, #0
9000558a:	d044      	beq.n	90005616 <HAL_SD_InitCard+0x1f6>
  if (hsd->SdCard.CardType != CARD_SECURED)
9000558c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
9000558e:	2b03      	cmp	r3, #3
90005590:	d019      	beq.n	900055c6 <HAL_SD_InitCard+0x1a6>
    hsd->SdCard.RelCardAdd = sd_rca;
90005592:	6461      	str	r1, [r4, #68]	; 0x44
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90005594:	0409      	lsls	r1, r1, #16
90005596:	f000 ff17 	bl	900063c8 <SDMMC_CmdSendCSD>
    if (errorstate != HAL_SD_ERROR_NONE)
9000559a:	2800      	cmp	r0, #0
9000559c:	d183      	bne.n	900054a6 <HAL_SD_InitCard+0x86>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
9000559e:	4601      	mov	r1, r0
900055a0:	6820      	ldr	r0, [r4, #0]
900055a2:	f000 fcc3 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
900055a6:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
900055a8:	65e0      	str	r0, [r4, #92]	; 0x5c
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
900055aa:	6820      	ldr	r0, [r4, #0]
900055ac:	f000 fcbe 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
900055b0:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
900055b2:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
900055b4:	6820      	ldr	r0, [r4, #0]
900055b6:	f000 fcb9 	bl	90005f2c <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
900055ba:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
900055bc:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
900055be:	6820      	ldr	r0, [r4, #0]
900055c0:	f000 fcb4 	bl	90005f2c <SDMMC_GetResponse>
900055c4:	66a0      	str	r0, [r4, #104]	; 0x68
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
900055c6:	2104      	movs	r1, #4
900055c8:	6820      	ldr	r0, [r4, #0]
900055ca:	f000 fcaf 	bl	90005f2c <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
900055ce:	a909      	add	r1, sp, #36	; 0x24
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
900055d0:	0d00      	lsrs	r0, r0, #20
900055d2:	6420      	str	r0, [r4, #64]	; 0x40
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
900055d4:	4620      	mov	r0, r4
900055d6:	f7ff fe6d 	bl	900052b4 <HAL_SD_GetCardCSD>
900055da:	4605      	mov	r5, r0
900055dc:	2800      	cmp	r0, #0
900055de:	f47f af70 	bne.w	900054c2 <HAL_SD_InitCard+0xa2>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
900055e2:	6c61      	ldr	r1, [r4, #68]	; 0x44
900055e4:	6820      	ldr	r0, [r4, #0]
900055e6:	0409      	lsls	r1, r1, #16
900055e8:	f000 fe1a 	bl	90006220 <SDMMC_CmdSelDesel>
  if (errorstate != HAL_SD_ERROR_NONE)
900055ec:	2800      	cmp	r0, #0
900055ee:	f47f af5a 	bne.w	900054a6 <HAL_SD_InitCard+0x86>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
900055f2:	f44f 7100 	mov.w	r1, #512	; 0x200
900055f6:	6820      	ldr	r0, [r4, #0]
900055f8:	f000 fd6a 	bl	900060d0 <SDMMC_CmdBlockLength>
  if (errorstate != HAL_SD_ERROR_NONE)
900055fc:	2800      	cmp	r0, #0
900055fe:	f43f af24 	beq.w	9000544a <HAL_SD_InitCard+0x2a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005602:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
90005604:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005606:	4a0d      	ldr	r2, [pc, #52]	; (9000563c <HAL_SD_InitCard+0x21c>)
90005608:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
9000560a:	6b63      	ldr	r3, [r4, #52]	; 0x34
9000560c:	4318      	orrs	r0, r3
9000560e:	6360      	str	r0, [r4, #52]	; 0x34
    hsd->State = HAL_SD_STATE_READY;
90005610:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
    return HAL_ERROR;
90005614:	e719      	b.n	9000544a <HAL_SD_InitCard+0x2a>
      errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
90005616:	f10d 010a 	add.w	r1, sp, #10
9000561a:	f000 ff69 	bl	900064f0 <SDMMC_CmdSetRelAdd>
      if (errorstate != HAL_SD_ERROR_NONE)
9000561e:	2800      	cmp	r0, #0
90005620:	f47f af41 	bne.w	900054a6 <HAL_SD_InitCard+0x86>
      if ((HAL_GetTick() - tickstart) >=  SDMMC_CMDTIMEOUT)
90005624:	f7fc fb72 	bl	90001d0c <HAL_GetTick>
90005628:	1b40      	subs	r0, r0, r5
9000562a:	42b0      	cmp	r0, r6
9000562c:	d9a9      	bls.n	90005582 <HAL_SD_InitCard+0x162>
        return HAL_SD_ERROR_TIMEOUT;
9000562e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  if (errorstate != HAL_SD_ERROR_NONE)
90005632:	e738      	b.n	900054a6 <HAL_SD_InitCard+0x86>
90005634:	000c3500 	.word	0x000c3500
90005638:	00012110 	.word	0x00012110
9000563c:	1fe00fff 	.word	0x1fe00fff
90005640:	c1100000 	.word	0xc1100000

90005644 <HAL_SD_GetCardStatus>:
{
90005644:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->State == HAL_SD_STATE_BUSY)
90005648:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
{
9000564c:	b096      	sub	sp, #88	; 0x58
9000564e:	4604      	mov	r4, r0
90005650:	460e      	mov	r6, r1
  if (hsd->State == HAL_SD_STATE_BUSY)
90005652:	2b03      	cmp	r3, #3
90005654:	f000 80b5 	beq.w	900057c2 <HAL_SD_GetCardStatus+0x17e>
  uint32_t tickstart = HAL_GetTick();
90005658:	f7fc fb58 	bl	90001d0c <HAL_GetTick>
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
9000565c:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
9000565e:	4607      	mov	r7, r0
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90005660:	6820      	ldr	r0, [r4, #0]
90005662:	f000 fc63 	bl	90005f2c <SDMMC_GetResponse>
90005666:	0183      	lsls	r3, r0, #6
90005668:	d50b      	bpl.n	90005682 <HAL_SD_GetCardStatus+0x3e>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
9000566a:	f44f 6000 	mov.w	r0, #2048	; 0x800
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000566e:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
90005670:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005672:	4a55      	ldr	r2, [pc, #340]	; (900057c8 <HAL_SD_GetCardStatus+0x184>)
90005674:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
90005676:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005678:	4318      	orrs	r0, r3
9000567a:	6360      	str	r0, [r4, #52]	; 0x34
    hsd->State = HAL_SD_STATE_READY;
9000567c:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
    status = HAL_ERROR;
90005680:	e08a      	b.n	90005798 <HAL_SD_GetCardStatus+0x154>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
90005682:	2140      	movs	r1, #64	; 0x40
90005684:	6820      	ldr	r0, [r4, #0]
90005686:	f000 fd23 	bl	900060d0 <SDMMC_CmdBlockLength>
  if (errorstate != HAL_SD_ERROR_NONE)
9000568a:	b110      	cbz	r0, 90005692 <HAL_SD_GetCardStatus+0x4e>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
9000568c:	6b63      	ldr	r3, [r4, #52]	; 0x34
9000568e:	6363      	str	r3, [r4, #52]	; 0x34
    return errorstate;
90005690:	e7ed      	b.n	9000566e <HAL_SD_GetCardStatus+0x2a>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90005692:	6c61      	ldr	r1, [r4, #68]	; 0x44
90005694:	6820      	ldr	r0, [r4, #0]
90005696:	0409      	lsls	r1, r1, #16
90005698:	f000 fddb 	bl	90006252 <SDMMC_CmdAppCommand>
  if (errorstate != HAL_SD_ERROR_NONE)
9000569c:	2800      	cmp	r0, #0
9000569e:	d1f5      	bne.n	9000568c <HAL_SD_GetCardStatus+0x48>
  config.DataLength    = 64U;
900056a0:	2340      	movs	r3, #64	; 0x40
900056a2:	f04f 35ff 	mov.w	r5, #4294967295
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
900056a6:	f04f 0c60 	mov.w	ip, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
900056aa:	9004      	str	r0, [sp, #16]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
900056ac:	4669      	mov	r1, sp
900056ae:	6820      	ldr	r0, [r4, #0]
  config.DataLength    = 64U;
900056b0:	e9cd 5300 	strd	r5, r3, [sp]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
900056b4:	2302      	movs	r3, #2
900056b6:	e9cd c302 	strd	ip, r3, [sp, #8]
  config.DPSM          = SDMMC_DPSM_ENABLE;
900056ba:	2301      	movs	r3, #1
900056bc:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
900056be:	f000 fc38 	bl	90005f32 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
900056c2:	6820      	ldr	r0, [r4, #0]
900056c4:	f000 fe29 	bl	9000631a <SDMMC_CmdStatusRegister>
  if (errorstate != HAL_SD_ERROR_NONE)
900056c8:	2800      	cmp	r0, #0
900056ca:	d1df      	bne.n	9000568c <HAL_SD_GetCardStatus+0x48>
  uint32_t *pData = pSDstatus;
900056cc:	f10d 0818 	add.w	r8, sp, #24
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
900056d0:	6823      	ldr	r3, [r4, #0]
900056d2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
900056d4:	f412 7f95 	tst.w	r2, #298	; 0x12a
900056d8:	d00a      	beq.n	900056f0 <HAL_SD_GetCardStatus+0xac>
  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
900056da:	6b5a      	ldr	r2, [r3, #52]	; 0x34
900056dc:	0711      	lsls	r1, r2, #28
900056de:	d46e      	bmi.n	900057be <HAL_SD_GetCardStatus+0x17a>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
900056e0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
900056e2:	0792      	lsls	r2, r2, #30
900056e4:	d469      	bmi.n	900057ba <HAL_SD_GetCardStatus+0x176>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
900056e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900056e8:	069b      	lsls	r3, r3, #26
900056ea:	d51e      	bpl.n	9000572a <HAL_SD_GetCardStatus+0xe6>
    return HAL_SD_ERROR_RX_OVERRUN;
900056ec:	2020      	movs	r0, #32
900056ee:	e7be      	b.n	9000566e <HAL_SD_GetCardStatus+0x2a>
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
900056f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900056f2:	0418      	lsls	r0, r3, #16
900056f4:	d508      	bpl.n	90005708 <HAL_SD_GetCardStatus+0xc4>
900056f6:	f108 0520 	add.w	r5, r8, #32
        *pData = SDMMC_ReadFIFO(hsd->Instance);
900056fa:	6820      	ldr	r0, [r4, #0]
900056fc:	f000 fbf0 	bl	90005ee0 <SDMMC_ReadFIFO>
90005700:	f848 0b04 	str.w	r0, [r8], #4
      for (count = 0U; count < 8U; count++)
90005704:	45a8      	cmp	r8, r5
90005706:	d1f8      	bne.n	900056fa <HAL_SD_GetCardStatus+0xb6>
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
90005708:	f7fc fb00 	bl	90001d0c <HAL_GetTick>
9000570c:	1bc0      	subs	r0, r0, r7
9000570e:	3001      	adds	r0, #1
90005710:	d1de      	bne.n	900056d0 <HAL_SD_GetCardStatus+0x8c>
      return HAL_SD_ERROR_TIMEOUT;
90005712:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  if (errorstate != HAL_SD_ERROR_NONE)
90005716:	e7aa      	b.n	9000566e <HAL_SD_GetCardStatus+0x2a>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
90005718:	f000 fbe2 	bl	90005ee0 <SDMMC_ReadFIFO>
9000571c:	f848 0b04 	str.w	r0, [r8], #4
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
90005720:	f7fc faf4 	bl	90001d0c <HAL_GetTick>
90005724:	1bc0      	subs	r0, r0, r7
90005726:	3001      	adds	r0, #1
90005728:	d0f3      	beq.n	90005712 <HAL_SD_GetCardStatus+0xce>
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
9000572a:	6820      	ldr	r0, [r4, #0]
9000572c:	6b45      	ldr	r5, [r0, #52]	; 0x34
9000572e:	f415 5580 	ands.w	r5, r5, #4096	; 0x1000
90005732:	d1f1      	bne.n	90005718 <HAL_SD_GetCardStatus+0xd4>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
90005734:	9a06      	ldr	r2, [sp, #24]
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90005736:	4b25      	ldr	r3, [pc, #148]	; (900057cc <HAL_SD_GetCardStatus+0x188>)
90005738:	6383      	str	r3, [r0, #56]	; 0x38
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
9000573a:	f3c2 1381 	ubfx	r3, r2, #6, #2
9000573e:	7033      	strb	r3, [r6, #0]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
90005740:	f3c2 1340 	ubfx	r3, r2, #5, #1
90005744:	7073      	strb	r3, [r6, #1]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
90005746:	0a13      	lsrs	r3, r2, #8
90005748:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
9000574c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
90005750:	b29b      	uxth	r3, r3
90005752:	8073      	strh	r3, [r6, #2]
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
90005754:	9b07      	ldr	r3, [sp, #28]
90005756:	ba1b      	rev	r3, r3
90005758:	6073      	str	r3, [r6, #4]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
9000575a:	9b08      	ldr	r3, [sp, #32]
9000575c:	b2da      	uxtb	r2, r3
9000575e:	7232      	strb	r2, [r6, #8]
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
90005760:	f3c3 2207 	ubfx	r2, r3, #8, #8
90005764:	7272      	strb	r2, [r6, #9]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
90005766:	f3c3 5203 	ubfx	r2, r3, #20, #4
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
9000576a:	0c1b      	lsrs	r3, r3, #16
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
9000576c:	72b2      	strb	r2, [r6, #10]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
9000576e:	9a09      	ldr	r2, [sp, #36]	; 0x24
90005770:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
90005774:	b2d1      	uxtb	r1, r2
90005776:	430b      	orrs	r3, r1
90005778:	81b3      	strh	r3, [r6, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
9000577a:	f3c2 2385 	ubfx	r3, r2, #10, #6
9000577e:	73b3      	strb	r3, [r6, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
90005780:	f3c2 2301 	ubfx	r3, r2, #8, #2
90005784:	73f3      	strb	r3, [r6, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
90005786:	f3c2 1303 	ubfx	r3, r2, #4, #4
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
9000578a:	f002 020f 	and.w	r2, r2, #15
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
9000578e:	7433      	strb	r3, [r6, #16]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
90005790:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
90005794:	7472      	strb	r2, [r6, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
90005796:	74b3      	strb	r3, [r6, #18]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
90005798:	f44f 7100 	mov.w	r1, #512	; 0x200
9000579c:	6820      	ldr	r0, [r4, #0]
9000579e:	f000 fc97 	bl	900060d0 <SDMMC_CmdBlockLength>
  if (errorstate != HAL_SD_ERROR_NONE)
900057a2:	b130      	cbz	r0, 900057b2 <HAL_SD_GetCardStatus+0x16e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900057a4:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
900057a6:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900057a8:	4a07      	ldr	r2, [pc, #28]	; (900057c8 <HAL_SD_GetCardStatus+0x184>)
900057aa:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode = errorstate;
900057ac:	6360      	str	r0, [r4, #52]	; 0x34
    hsd->State = HAL_SD_STATE_READY;
900057ae:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
}
900057b2:	4628      	mov	r0, r5
900057b4:	b016      	add	sp, #88	; 0x58
900057b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_SD_ERROR_DATA_CRC_FAIL;
900057ba:	2002      	movs	r0, #2
900057bc:	e757      	b.n	9000566e <HAL_SD_GetCardStatus+0x2a>
    return HAL_SD_ERROR_DATA_TIMEOUT;
900057be:	2008      	movs	r0, #8
900057c0:	e755      	b.n	9000566e <HAL_SD_GetCardStatus+0x2a>
    return HAL_ERROR;
900057c2:	2501      	movs	r5, #1
900057c4:	e7f5      	b.n	900057b2 <HAL_SD_GetCardStatus+0x16e>
900057c6:	bf00      	nop
900057c8:	1fe00fff 	.word	0x1fe00fff
900057cc:	18000f3a 	.word	0x18000f3a

900057d0 <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
900057d0:	6b83      	ldr	r3, [r0, #56]	; 0x38
900057d2:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
900057d4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
900057d6:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
900057d8:	6c03      	ldr	r3, [r0, #64]	; 0x40
900057da:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
900057dc:	6c43      	ldr	r3, [r0, #68]	; 0x44
900057de:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
900057e0:	6c83      	ldr	r3, [r0, #72]	; 0x48
900057e2:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
900057e4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
900057e6:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
900057e8:	6d03      	ldr	r3, [r0, #80]	; 0x50
900057ea:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
900057ec:	6d43      	ldr	r3, [r0, #84]	; 0x54
}
900057ee:	2000      	movs	r0, #0
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
900057f0:	61cb      	str	r3, [r1, #28]
}
900057f2:	4770      	bx	lr

900057f4 <HAL_SD_ConfigWideBusOperation>:
  hsd->State = HAL_SD_STATE_BUSY;
900057f4:	2303      	movs	r3, #3
{
900057f6:	b530      	push	{r4, r5, lr}
  hsd->State = HAL_SD_STATE_BUSY;
900057f8:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
{
900057fc:	b089      	sub	sp, #36	; 0x24
  if (hsd->SdCard.CardType != CARD_SECURED)
900057fe:	6b83      	ldr	r3, [r0, #56]	; 0x38
{
90005800:	4604      	mov	r4, r0
90005802:	460d      	mov	r5, r1
  if (hsd->SdCard.CardType != CARD_SECURED)
90005804:	2b03      	cmp	r3, #3
90005806:	d002      	beq.n	9000580e <HAL_SD_ConfigWideBusOperation+0x1a>
    if (WideMode == SDMMC_BUS_WIDE_8B)
90005808:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
9000580c:	d103      	bne.n	90005816 <HAL_SD_ConfigWideBusOperation+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
9000580e:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005810:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90005814:	e049      	b.n	900058aa <HAL_SD_ConfigWideBusOperation+0xb6>
    else if (WideMode == SDMMC_BUS_WIDE_4B)
90005816:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
9000581a:	d123      	bne.n	90005864 <HAL_SD_ConfigWideBusOperation+0x70>
  uint32_t scr[2U] = {0UL, 0UL};
9000581c:	2100      	movs	r1, #0
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
9000581e:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0UL, 0UL};
90005820:	e9cd 1103 	strd	r1, r1, [sp, #12]
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90005824:	f000 fb82 	bl	90005f2c <SDMMC_GetResponse>
90005828:	0180      	lsls	r0, r0, #6
9000582a:	d435      	bmi.n	90005898 <HAL_SD_ConfigWideBusOperation+0xa4>
  errorstate = SD_FindSCR(hsd, scr);
9000582c:	a903      	add	r1, sp, #12
9000582e:	4620      	mov	r0, r4
90005830:	f7ff fc04 	bl	9000503c <SD_FindSCR>
  if (errorstate != HAL_SD_ERROR_NONE)
90005834:	b960      	cbnz	r0, 90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
  if ((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
90005836:	9b04      	ldr	r3, [sp, #16]
90005838:	0359      	lsls	r1, r3, #13
9000583a:	d530      	bpl.n	9000589e <HAL_SD_ConfigWideBusOperation+0xaa>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
9000583c:	6c61      	ldr	r1, [r4, #68]	; 0x44
9000583e:	6820      	ldr	r0, [r4, #0]
90005840:	0409      	lsls	r1, r1, #16
90005842:	f000 fd06 	bl	90006252 <SDMMC_CmdAppCommand>
    if (errorstate != HAL_SD_ERROR_NONE)
90005846:	b918      	cbnz	r0, 90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
90005848:	2102      	movs	r1, #2
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
9000584a:	6820      	ldr	r0, [r4, #0]
9000584c:	f000 fd1a 	bl	90006284 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
90005850:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005852:	4318      	orrs	r0, r3
90005854:	6360      	str	r0, [r4, #52]	; 0x34
  if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
90005856:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005858:	b34b      	cbz	r3, 900058ae <HAL_SD_ConfigWideBusOperation+0xba>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000585a:	6823      	ldr	r3, [r4, #0]
9000585c:	4a41      	ldr	r2, [pc, #260]	; (90005964 <HAL_SD_ConfigWideBusOperation+0x170>)
9000585e:	639a      	str	r2, [r3, #56]	; 0x38
      status = HAL_ERROR;
90005860:	2501      	movs	r5, #1
90005862:	e052      	b.n	9000590a <HAL_SD_ConfigWideBusOperation+0x116>
    else if (WideMode == SDMMC_BUS_WIDE_1B)
90005864:	b9f1      	cbnz	r1, 900058a4 <HAL_SD_ConfigWideBusOperation+0xb0>
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90005866:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0UL, 0UL};
90005868:	e9cd 1103 	strd	r1, r1, [sp, #12]
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
9000586c:	f000 fb5e 	bl	90005f2c <SDMMC_GetResponse>
90005870:	0182      	lsls	r2, r0, #6
90005872:	d411      	bmi.n	90005898 <HAL_SD_ConfigWideBusOperation+0xa4>
  errorstate = SD_FindSCR(hsd, scr);
90005874:	a903      	add	r1, sp, #12
90005876:	4620      	mov	r0, r4
90005878:	f7ff fbe0 	bl	9000503c <SD_FindSCR>
  if (errorstate != HAL_SD_ERROR_NONE)
9000587c:	2800      	cmp	r0, #0
9000587e:	d1e7      	bne.n	90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
  if ((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
90005880:	9b04      	ldr	r3, [sp, #16]
90005882:	03db      	lsls	r3, r3, #15
90005884:	d50b      	bpl.n	9000589e <HAL_SD_ConfigWideBusOperation+0xaa>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90005886:	6c61      	ldr	r1, [r4, #68]	; 0x44
90005888:	6820      	ldr	r0, [r4, #0]
9000588a:	0409      	lsls	r1, r1, #16
9000588c:	f000 fce1 	bl	90006252 <SDMMC_CmdAppCommand>
    if (errorstate != HAL_SD_ERROR_NONE)
90005890:	2800      	cmp	r0, #0
90005892:	d1dd      	bne.n	90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
90005894:	4601      	mov	r1, r0
90005896:	e7d8      	b.n	9000584a <HAL_SD_ConfigWideBusOperation+0x56>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
90005898:	f44f 6000 	mov.w	r0, #2048	; 0x800
9000589c:	e7d8      	b.n	90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
9000589e:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
900058a2:	e7d5      	b.n	90005850 <HAL_SD_ConfigWideBusOperation+0x5c>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
900058a4:	6b43      	ldr	r3, [r0, #52]	; 0x34
900058a6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
900058aa:	6363      	str	r3, [r4, #52]	; 0x34
900058ac:	e7d3      	b.n	90005856 <HAL_SD_ConfigWideBusOperation+0x62>
    sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
900058ae:	f44f 3080 	mov.w	r0, #65536	; 0x10000
900058b2:	f7ff fa71 	bl	90004d98 <HAL_RCCEx_GetPeriphCLKFreq>
    if (sdmmc_clk != 0U)
900058b6:	2800      	cmp	r0, #0
900058b8:	d04f      	beq.n	9000595a <HAL_SD_ConfigWideBusOperation+0x166>
      Init.ClockEdge           = hsd->Init.ClockEdge;
900058ba:	6863      	ldr	r3, [r4, #4]
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
900058bc:	492a      	ldr	r1, [pc, #168]	; (90005968 <HAL_SD_ConfigWideBusOperation+0x174>)
      Init.ClockEdge           = hsd->Init.ClockEdge;
900058be:	9303      	str	r3, [sp, #12]
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
900058c0:	68a3      	ldr	r3, [r4, #8]
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
900058c2:	fbb0 f2f1 	udiv	r2, r0, r1
      Init.BusWide             = WideMode;
900058c6:	e9cd 3504 	strd	r3, r5, [sp, #16]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
900058ca:	6923      	ldr	r3, [r4, #16]
900058cc:	9306      	str	r3, [sp, #24]
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
900058ce:	6963      	ldr	r3, [r4, #20]
900058d0:	4293      	cmp	r3, r2
900058d2:	d301      	bcc.n	900058d8 <HAL_SD_ConfigWideBusOperation+0xe4>
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
900058d4:	9307      	str	r3, [sp, #28]
900058d6:	e00d      	b.n	900058f4 <HAL_SD_ConfigWideBusOperation+0x100>
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
900058d8:	6da5      	ldr	r5, [r4, #88]	; 0x58
900058da:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
900058de:	d0f9      	beq.n	900058d4 <HAL_SD_ConfigWideBusOperation+0xe0>
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
900058e0:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
900058e4:	d12c      	bne.n	90005940 <HAL_SD_ConfigWideBusOperation+0x14c>
        if (hsd->Init.ClockDiv == 0U)
900058e6:	bb2b      	cbnz	r3, 90005934 <HAL_SD_ConfigWideBusOperation+0x140>
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
900058e8:	4288      	cmp	r0, r1
900058ea:	d921      	bls.n	90005930 <HAL_SD_ConfigWideBusOperation+0x13c>
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
900058ec:	4b1f      	ldr	r3, [pc, #124]	; (9000596c <HAL_SD_ConfigWideBusOperation+0x178>)
900058ee:	fbb0 f0f3 	udiv	r0, r0, r3
900058f2:	9007      	str	r0, [sp, #28]
      (void)SDMMC_Init(hsd->Instance, Init);
900058f4:	ab08      	add	r3, sp, #32
  HAL_StatusTypeDef status = HAL_OK;
900058f6:	2500      	movs	r5, #0
      (void)SDMMC_Init(hsd->Instance, Init);
900058f8:	e913 0003 	ldmdb	r3, {r0, r1}
900058fc:	ab03      	add	r3, sp, #12
900058fe:	e88d 0003 	stmia.w	sp, {r0, r1}
90005902:	6820      	ldr	r0, [r4, #0]
90005904:	cb0e      	ldmia	r3, {r1, r2, r3}
90005906:	f000 fad1 	bl	90005eac <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
9000590a:	f44f 7100 	mov.w	r1, #512	; 0x200
9000590e:	6820      	ldr	r0, [r4, #0]
90005910:	f000 fbde 	bl	900060d0 <SDMMC_CmdBlockLength>
  if (errorstate != HAL_SD_ERROR_NONE)
90005914:	b130      	cbz	r0, 90005924 <HAL_SD_ConfigWideBusOperation+0x130>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90005916:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
90005918:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000591a:	4a12      	ldr	r2, [pc, #72]	; (90005964 <HAL_SD_ConfigWideBusOperation+0x170>)
9000591c:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
9000591e:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005920:	4318      	orrs	r0, r3
90005922:	6360      	str	r0, [r4, #52]	; 0x34
  hsd->State = HAL_SD_STATE_READY;
90005924:	2301      	movs	r3, #1
}
90005926:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
90005928:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
9000592c:	b009      	add	sp, #36	; 0x24
9000592e:	bd30      	pop	{r4, r5, pc}
            Init.ClockDiv = hsd->Init.ClockDiv;
90005930:	2300      	movs	r3, #0
90005932:	e7cf      	b.n	900058d4 <HAL_SD_ConfigWideBusOperation+0xe0>
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
90005934:	005a      	lsls	r2, r3, #1
90005936:	fbb0 f2f2 	udiv	r2, r0, r2
9000593a:	428a      	cmp	r2, r1
9000593c:	d9ca      	bls.n	900058d4 <HAL_SD_ConfigWideBusOperation+0xe0>
9000593e:	e7d5      	b.n	900058ec <HAL_SD_ConfigWideBusOperation+0xf8>
        if (hsd->Init.ClockDiv == 0U)
90005940:	490b      	ldr	r1, [pc, #44]	; (90005970 <HAL_SD_ConfigWideBusOperation+0x17c>)
90005942:	b91b      	cbnz	r3, 9000594c <HAL_SD_ConfigWideBusOperation+0x158>
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
90005944:	4288      	cmp	r0, r1
90005946:	d9f3      	bls.n	90005930 <HAL_SD_ConfigWideBusOperation+0x13c>
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
90005948:	9207      	str	r2, [sp, #28]
9000594a:	e7d3      	b.n	900058f4 <HAL_SD_ConfigWideBusOperation+0x100>
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
9000594c:	005d      	lsls	r5, r3, #1
9000594e:	fbb0 f0f5 	udiv	r0, r0, r5
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
90005952:	4288      	cmp	r0, r1
90005954:	bf88      	it	hi
90005956:	4613      	movhi	r3, r2
90005958:	e7bc      	b.n	900058d4 <HAL_SD_ConfigWideBusOperation+0xe0>
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
9000595a:	6b63      	ldr	r3, [r4, #52]	; 0x34
9000595c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
90005960:	6363      	str	r3, [r4, #52]	; 0x34
90005962:	e77d      	b.n	90005860 <HAL_SD_ConfigWideBusOperation+0x6c>
90005964:	1fe00fff 	.word	0x1fe00fff
90005968:	02faf080 	.word	0x02faf080
9000596c:	05f5e100 	.word	0x05f5e100
90005970:	017d7840 	.word	0x017d7840

90005974 <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90005974:	6c41      	ldr	r1, [r0, #68]	; 0x44
{
90005976:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90005978:	0409      	lsls	r1, r1, #16
{
9000597a:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
9000597c:	6800      	ldr	r0, [r0, #0]
9000597e:	f000 fcb3 	bl	900062e8 <SDMMC_CmdSendStatus>
  if (errorstate != HAL_SD_ERROR_NONE)
90005982:	4601      	mov	r1, r0
90005984:	b928      	cbnz	r0, 90005992 <HAL_SD_GetCardState+0x1e>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90005986:	6820      	ldr	r0, [r4, #0]
90005988:	f000 fad0 	bl	90005f2c <SDMMC_GetResponse>
}
9000598c:	f3c0 2043 	ubfx	r0, r0, #9, #4
90005990:	bd10      	pop	{r4, pc}
    hsd->ErrorCode |= errorstate;
90005992:	6b60      	ldr	r0, [r4, #52]	; 0x34
90005994:	4308      	orrs	r0, r1
90005996:	6360      	str	r0, [r4, #52]	; 0x34
  uint32_t resp1 = 0;
90005998:	2000      	movs	r0, #0
9000599a:	e7f7      	b.n	9000598c <HAL_SD_GetCardState+0x18>

9000599c <HAL_SD_Init>:
{
9000599c:	b570      	push	{r4, r5, r6, lr}
  if (hsd == NULL)
9000599e:	4604      	mov	r4, r0
{
900059a0:	b086      	sub	sp, #24
  if (hsd == NULL)
900059a2:	b918      	cbnz	r0, 900059ac <HAL_SD_Init+0x10>
    return HAL_ERROR;
900059a4:	2501      	movs	r5, #1
}
900059a6:	4628      	mov	r0, r5
900059a8:	b006      	add	sp, #24
900059aa:	bd70      	pop	{r4, r5, r6, pc}
  if (hsd->State == HAL_SD_STATE_RESET)
900059ac:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
900059b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
900059b4:	b913      	cbnz	r3, 900059bc <HAL_SD_Init+0x20>
    hsd->Lock = HAL_UNLOCKED;
900059b6:	7602      	strb	r2, [r0, #24]
    HAL_SD_MspInit(hsd);
900059b8:	f7fa fff2 	bl	900009a0 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_PROGRAMMING;
900059bc:	2304      	movs	r3, #4
  if (HAL_SD_InitCard(hsd) != HAL_OK)
900059be:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_PROGRAMMING;
900059c0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  if (HAL_SD_InitCard(hsd) != HAL_OK)
900059c4:	f7ff fd2c 	bl	90005420 <HAL_SD_InitCard>
900059c8:	2800      	cmp	r0, #0
900059ca:	d1eb      	bne.n	900059a4 <HAL_SD_Init+0x8>
  if (HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
900059cc:	a901      	add	r1, sp, #4
900059ce:	4620      	mov	r0, r4
900059d0:	f7ff fe38 	bl	90005644 <HAL_SD_GetCardStatus>
900059d4:	2800      	cmp	r0, #0
900059d6:	d1e5      	bne.n	900059a4 <HAL_SD_Init+0x8>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
900059d8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  speedgrade = CardStatus.UhsSpeedGrade;
900059da:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
900059de:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
900059e0:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
900059e4:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
900059e6:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
900059e8:	d11c      	bne.n	90005a24 <HAL_SD_Init+0x88>
900059ea:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
900059ec:	bf14      	ite	ne
900059ee:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
900059f2:	f44f 7380 	moveq.w	r3, #256	; 0x100
900059f6:	65a3      	str	r3, [r4, #88]	; 0x58
  if (HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
900059f8:	68e1      	ldr	r1, [r4, #12]
900059fa:	4620      	mov	r0, r4
900059fc:	f7ff fefa 	bl	900057f4 <HAL_SD_ConfigWideBusOperation>
90005a00:	4605      	mov	r5, r0
90005a02:	2800      	cmp	r0, #0
90005a04:	d1ce      	bne.n	900059a4 <HAL_SD_Init+0x8>
  tickstart = HAL_GetTick();
90005a06:	f7fc f981 	bl	90001d0c <HAL_GetTick>
90005a0a:	4606      	mov	r6, r0
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
90005a0c:	4620      	mov	r0, r4
90005a0e:	f7ff ffb1 	bl	90005974 <HAL_SD_GetCardState>
90005a12:	2804      	cmp	r0, #4
90005a14:	d108      	bne.n	90005a28 <HAL_SD_Init+0x8c>
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
90005a16:	2300      	movs	r3, #0
90005a18:	6363      	str	r3, [r4, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
90005a1a:	62e3      	str	r3, [r4, #44]	; 0x2c
  hsd->State = HAL_SD_STATE_READY;
90005a1c:	2301      	movs	r3, #1
90005a1e:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  return HAL_OK;
90005a22:	e7c0      	b.n	900059a6 <HAL_SD_Init+0xa>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
90005a24:	65a0      	str	r0, [r4, #88]	; 0x58
90005a26:	e7e7      	b.n	900059f8 <HAL_SD_Init+0x5c>
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
90005a28:	f7fc f970 	bl	90001d0c <HAL_GetTick>
90005a2c:	1b80      	subs	r0, r0, r6
90005a2e:	3001      	adds	r0, #1
90005a30:	d1ec      	bne.n	90005a0c <HAL_SD_Init+0x70>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
90005a32:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
      return HAL_TIMEOUT;
90005a36:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
90005a38:	6363      	str	r3, [r4, #52]	; 0x34
      hsd->State = HAL_SD_STATE_READY;
90005a3a:	2301      	movs	r3, #1
90005a3c:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      return HAL_TIMEOUT;
90005a40:	e7b1      	b.n	900059a6 <HAL_SD_Init+0xa>

90005a42 <HAL_SDEx_Read_DMADoubleBuf0CpltCallback>:
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Read_DMADoubleBuf0CpltCallback can be implemented in the user file
   */
}
90005a42:	4770      	bx	lr

90005a44 <HAL_SDEx_Read_DMADoubleBuf1CpltCallback>:
90005a44:	4770      	bx	lr

90005a46 <HAL_SDEx_Write_DMADoubleBuf0CpltCallback>:
90005a46:	4770      	bx	lr

90005a48 <HAL_SDEx_Write_DMADoubleBuf1CpltCallback>:
90005a48:	4770      	bx	lr
	...

90005a4c <HAL_SD_IRQHandler>:
{
90005a4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t context = hsd->Context;
90005a4e:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
{
90005a50:	4604      	mov	r4, r0
  if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
90005a52:	6800      	ldr	r0, [r0, #0]
90005a54:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005a56:	041b      	lsls	r3, r3, #16
90005a58:	d520      	bpl.n	90005a9c <HAL_SD_IRQHandler+0x50>
90005a5a:	072f      	lsls	r7, r5, #28
90005a5c:	d51e      	bpl.n	90005a9c <HAL_SD_IRQHandler+0x50>
  if (hsd->RxXferSize >= 32U)
90005a5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90005a60:	2b1f      	cmp	r3, #31
90005a62:	d919      	bls.n	90005a98 <HAL_SD_IRQHandler+0x4c>
  tmp = hsd->pRxBuffPtr;
90005a64:	6a66      	ldr	r6, [r4, #36]	; 0x24
90005a66:	1d35      	adds	r5, r6, #4
90005a68:	f106 0724 	add.w	r7, r6, #36	; 0x24
      data = SDMMC_ReadFIFO(hsd->Instance);
90005a6c:	6820      	ldr	r0, [r4, #0]
    for (count = 0U; count < 8U; count++)
90005a6e:	3504      	adds	r5, #4
      data = SDMMC_ReadFIFO(hsd->Instance);
90005a70:	f000 fa36 	bl	90005ee0 <SDMMC_ReadFIFO>
      *tmp = (uint8_t)(data & 0xFFU);
90005a74:	f805 0c08 	strb.w	r0, [r5, #-8]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
90005a78:	0a03      	lsrs	r3, r0, #8
90005a7a:	f805 3c07 	strb.w	r3, [r5, #-7]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
90005a7e:	0c03      	lsrs	r3, r0, #16
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
90005a80:	0e00      	lsrs	r0, r0, #24
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
90005a82:	f805 3c06 	strb.w	r3, [r5, #-6]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
90005a86:	f805 0c05 	strb.w	r0, [r5, #-5]
    for (count = 0U; count < 8U; count++)
90005a8a:	42bd      	cmp	r5, r7
90005a8c:	d1ee      	bne.n	90005a6c <HAL_SD_IRQHandler+0x20>
    hsd->RxXferSize -= 32U;
90005a8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      tmp++;
90005a90:	3620      	adds	r6, #32
    hsd->RxXferSize -= 32U;
90005a92:	3b20      	subs	r3, #32
    hsd->pRxBuffPtr = tmp;
90005a94:	6266      	str	r6, [r4, #36]	; 0x24
    hsd->RxXferSize -= 32U;
90005a96:	62a3      	str	r3, [r4, #40]	; 0x28
}
90005a98:	b003      	add	sp, #12
90005a9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
90005a9c:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005a9e:	05de      	lsls	r6, r3, #23
90005aa0:	d553      	bpl.n	90005b4a <HAL_SD_IRQHandler+0xfe>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
90005aa2:	f44f 7380 	mov.w	r3, #256	; 0x100
90005aa6:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
90005aa8:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
90005aaa:	f423 4341 	bic.w	r3, r3, #49408	; 0xc100
90005aae:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
90005ab2:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
90005ab4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
90005ab6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
90005aba:	63c3      	str	r3, [r0, #60]	; 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
90005abc:	68c3      	ldr	r3, [r0, #12]
90005abe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
90005ac2:	60c3      	str	r3, [r0, #12]
    if ((context & SD_CONTEXT_IT) != 0U)
90005ac4:	f015 0308 	ands.w	r3, r5, #8
90005ac8:	d01f      	beq.n	90005b0a <HAL_SD_IRQHandler+0xbe>
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
90005aca:	f015 0f22 	tst.w	r5, #34	; 0x22
90005ace:	d008      	beq.n	90005ae2 <HAL_SD_IRQHandler+0x96>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
90005ad0:	f000 fb7c 	bl	900061cc <SDMMC_CmdStopTransfer>
        if (errorstate != HAL_SD_ERROR_NONE)
90005ad4:	b128      	cbz	r0, 90005ae2 <HAL_SD_IRQHandler+0x96>
          hsd->ErrorCode |= errorstate;
90005ad6:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005ad8:	4318      	orrs	r0, r3
90005ada:	6360      	str	r0, [r4, #52]	; 0x34
          HAL_SD_ErrorCallback(hsd);
90005adc:	4620      	mov	r0, r4
90005ade:	f7ff fbe7 	bl	900052b0 <HAL_SD_ErrorCallback>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90005ae2:	6823      	ldr	r3, [r4, #0]
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
90005ae4:	07a9      	lsls	r1, r5, #30
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90005ae6:	4a69      	ldr	r2, [pc, #420]	; (90005c8c <HAL_SD_IRQHandler+0x240>)
90005ae8:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90005aea:	f04f 0301 	mov.w	r3, #1
90005aee:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      hsd->Context = SD_CONTEXT_NONE;
90005af2:	f04f 0300 	mov.w	r3, #0
90005af6:	62e3      	str	r3, [r4, #44]	; 0x2c
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
90005af8:	d003      	beq.n	90005b02 <HAL_SD_IRQHandler+0xb6>
        HAL_SD_RxCpltCallback(hsd);
90005afa:	4620      	mov	r0, r4
90005afc:	f7fb f886 	bl	90000c0c <HAL_SD_RxCpltCallback>
90005b00:	e7ca      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
        HAL_SD_TxCpltCallback(hsd);
90005b02:	4620      	mov	r0, r4
90005b04:	f7fb f87e 	bl	90000c04 <HAL_SD_TxCpltCallback>
90005b08:	e7c6      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
90005b0a:	062a      	lsls	r2, r5, #24
90005b0c:	d5c4      	bpl.n	90005a98 <HAL_SD_IRQHandler+0x4c>
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
90005b0e:	f015 0f22 	tst.w	r5, #34	; 0x22
      hsd->Instance->DLEN = 0;
90005b12:	6283      	str	r3, [r0, #40]	; 0x28
      hsd->Instance->DCTRL = 0;
90005b14:	62c3      	str	r3, [r0, #44]	; 0x2c
      hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
90005b16:	6503      	str	r3, [r0, #80]	; 0x50
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
90005b18:	d008      	beq.n	90005b2c <HAL_SD_IRQHandler+0xe0>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
90005b1a:	f000 fb57 	bl	900061cc <SDMMC_CmdStopTransfer>
        if (errorstate != HAL_SD_ERROR_NONE)
90005b1e:	b128      	cbz	r0, 90005b2c <HAL_SD_IRQHandler+0xe0>
          hsd->ErrorCode |= errorstate;
90005b20:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005b22:	4318      	orrs	r0, r3
90005b24:	6360      	str	r0, [r4, #52]	; 0x34
          HAL_SD_ErrorCallback(hsd);
90005b26:	4620      	mov	r0, r4
90005b28:	f7ff fbc2 	bl	900052b0 <HAL_SD_ErrorCallback>
      hsd->State = HAL_SD_STATE_READY;
90005b2c:	2301      	movs	r3, #1
      if (((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
90005b2e:	f015 0f30 	tst.w	r5, #48	; 0x30
      hsd->State = HAL_SD_STATE_READY;
90005b32:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      hsd->Context = SD_CONTEXT_NONE;
90005b36:	f04f 0300 	mov.w	r3, #0
90005b3a:	62e3      	str	r3, [r4, #44]	; 0x2c
      if (((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
90005b3c:	d002      	beq.n	90005b44 <HAL_SD_IRQHandler+0xf8>
        HAL_SD_TxCpltCallback(hsd);
90005b3e:	4620      	mov	r0, r4
90005b40:	f7fb f860 	bl	90000c04 <HAL_SD_TxCpltCallback>
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
90005b44:	07af      	lsls	r7, r5, #30
90005b46:	d0a7      	beq.n	90005a98 <HAL_SD_IRQHandler+0x4c>
90005b48:	e7d7      	b.n	90005afa <HAL_SD_IRQHandler+0xae>
  else if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
90005b4a:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005b4c:	045e      	lsls	r6, r3, #17
90005b4e:	d527      	bpl.n	90005ba0 <HAL_SD_IRQHandler+0x154>
90005b50:	0729      	lsls	r1, r5, #28
90005b52:	d525      	bpl.n	90005ba0 <HAL_SD_IRQHandler+0x154>
  if (hsd->TxXferSize >= 32U)
90005b54:	6a23      	ldr	r3, [r4, #32]
90005b56:	2b1f      	cmp	r3, #31
90005b58:	d99e      	bls.n	90005a98 <HAL_SD_IRQHandler+0x4c>
  tmp = hsd->pTxBuffPtr;
90005b5a:	69e6      	ldr	r6, [r4, #28]
90005b5c:	1d35      	adds	r5, r6, #4
90005b5e:	f106 0724 	add.w	r7, r6, #36	; 0x24
      data = (uint32_t)(*tmp);
90005b62:	f815 3c04 	ldrb.w	r3, [r5, #-4]
    for (count = 0U; count < 8U; count++)
90005b66:	3504      	adds	r5, #4
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
90005b68:	a901      	add	r1, sp, #4
90005b6a:	6820      	ldr	r0, [r4, #0]
      data = (uint32_t)(*tmp);
90005b6c:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 8U);
90005b6e:	f815 2c07 	ldrb.w	r2, [r5, #-7]
90005b72:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
90005b76:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 16U);
90005b78:	f815 2c06 	ldrb.w	r2, [r5, #-6]
90005b7c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
90005b80:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 24U);
90005b82:	f815 2c05 	ldrb.w	r2, [r5, #-5]
90005b86:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
90005b8a:	9301      	str	r3, [sp, #4]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
90005b8c:	f000 f9ab 	bl	90005ee6 <SDMMC_WriteFIFO>
    for (count = 0U; count < 8U; count++)
90005b90:	42af      	cmp	r7, r5
90005b92:	d1e6      	bne.n	90005b62 <HAL_SD_IRQHandler+0x116>
    hsd->TxXferSize -= 32U;
90005b94:	6a23      	ldr	r3, [r4, #32]
      tmp++;
90005b96:	3620      	adds	r6, #32
    hsd->TxXferSize -= 32U;
90005b98:	3b20      	subs	r3, #32
    hsd->pTxBuffPtr = tmp;
90005b9a:	61e6      	str	r6, [r4, #28]
    hsd->TxXferSize -= 32U;
90005b9c:	6223      	str	r3, [r4, #32]
}
90005b9e:	e77b      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR |
90005ba0:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005ba2:	f013 0f3a 	tst.w	r3, #58	; 0x3a
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
90005ba6:	6b43      	ldr	r3, [r0, #52]	; 0x34
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR |
90005ba8:	d056      	beq.n	90005c58 <HAL_SD_IRQHandler+0x20c>
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
90005baa:	079a      	lsls	r2, r3, #30
90005bac:	d503      	bpl.n	90005bb6 <HAL_SD_IRQHandler+0x16a>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
90005bae:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005bb0:	f043 0302 	orr.w	r3, r3, #2
90005bb4:	6363      	str	r3, [r4, #52]	; 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DTIMEOUT) != RESET)
90005bb6:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005bb8:	071b      	lsls	r3, r3, #28
90005bba:	d503      	bpl.n	90005bc4 <HAL_SD_IRQHandler+0x178>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
90005bbc:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005bbe:	f043 0308 	orr.w	r3, r3, #8
90005bc2:	6363      	str	r3, [r4, #52]	; 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_RXOVERR) != RESET)
90005bc4:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005bc6:	069f      	lsls	r7, r3, #26
90005bc8:	d503      	bpl.n	90005bd2 <HAL_SD_IRQHandler+0x186>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
90005bca:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005bcc:	f043 0320 	orr.w	r3, r3, #32
90005bd0:	6363      	str	r3, [r4, #52]	; 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_TXUNDERR) != RESET)
90005bd2:	6b43      	ldr	r3, [r0, #52]	; 0x34
90005bd4:	06de      	lsls	r6, r3, #27
90005bd6:	d503      	bpl.n	90005be0 <HAL_SD_IRQHandler+0x194>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
90005bd8:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005bda:	f043 0310 	orr.w	r3, r3, #16
90005bde:	6363      	str	r3, [r4, #52]	; 0x34
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90005be0:	4b2a      	ldr	r3, [pc, #168]	; (90005c8c <HAL_SD_IRQHandler+0x240>)
90005be2:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
90005be4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
90005be6:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
90005bea:	63c3      	str	r3, [r0, #60]	; 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
90005bec:	68c3      	ldr	r3, [r0, #12]
90005bee:	f023 0340 	bic.w	r3, r3, #64	; 0x40
90005bf2:	60c3      	str	r3, [r0, #12]
    hsd->Instance->DCTRL |= SDMMC_DCTRL_FIFORST;
90005bf4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
90005bf6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
90005bfa:	62c3      	str	r3, [r0, #44]	; 0x2c
    hsd->Instance->CMD |= SDMMC_CMD_CMDSTOP;
90005bfc:	68c3      	ldr	r3, [r0, #12]
90005bfe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90005c02:	60c3      	str	r3, [r0, #12]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
90005c04:	f000 fae2 	bl	900061cc <SDMMC_CmdStopTransfer>
90005c08:	6b63      	ldr	r3, [r4, #52]	; 0x34
    if ((context & SD_CONTEXT_IT) != 0U)
90005c0a:	f015 0108 	ands.w	r1, r5, #8
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
90005c0e:	ea40 0003 	orr.w	r0, r0, r3
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
90005c12:	6823      	ldr	r3, [r4, #0]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
90005c14:	6360      	str	r0, [r4, #52]	; 0x34
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
90005c16:	68da      	ldr	r2, [r3, #12]
90005c18:	f022 0280 	bic.w	r2, r2, #128	; 0x80
90005c1c:	60da      	str	r2, [r3, #12]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DABORT);
90005c1e:	f44f 6200 	mov.w	r2, #2048	; 0x800
90005c22:	639a      	str	r2, [r3, #56]	; 0x38
    if ((context & SD_CONTEXT_IT) != 0U)
90005c24:	d008      	beq.n	90005c38 <HAL_SD_IRQHandler+0x1ec>
      hsd->State = HAL_SD_STATE_READY;
90005c26:	2301      	movs	r3, #1
90005c28:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      hsd->Context = SD_CONTEXT_NONE;
90005c2c:	2300      	movs	r3, #0
90005c2e:	62e3      	str	r3, [r4, #44]	; 0x2c
        HAL_SD_ErrorCallback(hsd);
90005c30:	4620      	mov	r0, r4
90005c32:	f7ff fb3d 	bl	900052b0 <HAL_SD_ErrorCallback>
90005c36:	e72f      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
90005c38:	0628      	lsls	r0, r5, #24
90005c3a:	f57f af2d 	bpl.w	90005a98 <HAL_SD_IRQHandler+0x4c>
      if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
90005c3e:	6b62      	ldr	r2, [r4, #52]	; 0x34
90005c40:	2a00      	cmp	r2, #0
90005c42:	f43f af29 	beq.w	90005a98 <HAL_SD_IRQHandler+0x4c>
        __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
90005c46:	6bda      	ldr	r2, [r3, #60]	; 0x3c
90005c48:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
90005c4c:	63da      	str	r2, [r3, #60]	; 0x3c
        hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
90005c4e:	6519      	str	r1, [r3, #80]	; 0x50
        hsd->State = HAL_SD_STATE_READY;
90005c50:	2301      	movs	r3, #1
90005c52:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
90005c56:	e7eb      	b.n	90005c30 <HAL_SD_IRQHandler+0x1e4>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_IDMABTC) != RESET)
90005c58:	00da      	lsls	r2, r3, #3
90005c5a:	f57f af1d 	bpl.w	90005a98 <HAL_SD_IRQHandler+0x4c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
90005c5e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
      if ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
90005c62:	f005 0520 	and.w	r5, r5, #32
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
90005c66:	6383      	str	r3, [r0, #56]	; 0x38
    if (READ_BIT(hsd->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
90005c68:	6d03      	ldr	r3, [r0, #80]	; 0x50
        HAL_SDEx_Write_DMADoubleBuf1CpltCallback(hsd);
90005c6a:	4620      	mov	r0, r4
    if (READ_BIT(hsd->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
90005c6c:	075b      	lsls	r3, r3, #29
90005c6e:	d406      	bmi.n	90005c7e <HAL_SD_IRQHandler+0x232>
      if ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
90005c70:	b115      	cbz	r5, 90005c78 <HAL_SD_IRQHandler+0x22c>
        HAL_SDEx_Write_DMADoubleBuf1CpltCallback(hsd);
90005c72:	f7ff fee9 	bl	90005a48 <HAL_SDEx_Write_DMADoubleBuf1CpltCallback>
90005c76:	e70f      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
        HAL_SDEx_Read_DMADoubleBuf1CpltCallback(hsd);
90005c78:	f7ff fee4 	bl	90005a44 <HAL_SDEx_Read_DMADoubleBuf1CpltCallback>
90005c7c:	e70c      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
      if ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
90005c7e:	b115      	cbz	r5, 90005c86 <HAL_SD_IRQHandler+0x23a>
        HAL_SDEx_Write_DMADoubleBuf0CpltCallback(hsd);
90005c80:	f7ff fee1 	bl	90005a46 <HAL_SDEx_Write_DMADoubleBuf0CpltCallback>
90005c84:	e708      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
        HAL_SDEx_Read_DMADoubleBuf0CpltCallback(hsd);
90005c86:	f7ff fedc 	bl	90005a42 <HAL_SDEx_Read_DMADoubleBuf0CpltCallback>
}
90005c8a:	e705      	b.n	90005a98 <HAL_SD_IRQHandler+0x4c>
90005c8c:	18000f3a 	.word	0x18000f3a

90005c90 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
90005c90:	b538      	push	{r3, r4, r5, lr}
90005c92:	460d      	mov	r5, r1
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
90005c94:	4604      	mov	r4, r0
90005c96:	b1f0      	cbz	r0, 90005cd6 <HAL_SDRAM_Init+0x46>
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
90005c98:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
90005c9c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
90005ca0:	b91b      	cbnz	r3, 90005caa <HAL_SDRAM_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
90005ca2:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
90005ca6:	f7fa fbcb 	bl	90000440 <HAL_SDRAM_MspInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90005caa:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
90005cac:	1d21      	adds	r1, r4, #4
90005cae:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90005cb0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
90005cb4:	f000 f863 	bl	90005d7e <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
90005cb8:	6862      	ldr	r2, [r4, #4]
90005cba:	4629      	mov	r1, r5
90005cbc:	6820      	ldr	r0, [r4, #0]
90005cbe:	f000 f899 	bl	90005df4 <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
90005cc2:	4a06      	ldr	r2, [pc, #24]	; (90005cdc <HAL_SDRAM_Init+0x4c>)
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;

  return HAL_OK;
90005cc4:	2000      	movs	r0, #0
  __FMC_ENABLE();
90005cc6:	6813      	ldr	r3, [r2, #0]
90005cc8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
90005ccc:	6013      	str	r3, [r2, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
90005cce:	2301      	movs	r3, #1
90005cd0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
90005cd4:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
90005cd6:	2001      	movs	r0, #1
90005cd8:	e7fc      	b.n	90005cd4 <HAL_SDRAM_Init+0x44>
90005cda:	bf00      	nop
90005cdc:	52004000 	.word	0x52004000

90005ce0 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command,
                                        uint32_t Timeout)
{
90005ce0:	b570      	push	{r4, r5, r6, lr}
  HAL_SDRAM_StateTypeDef state = hsdram->State;
90005ce2:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
90005ce6:	4605      	mov	r5, r0
90005ce8:	460e      	mov	r6, r1

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
90005cea:	2b02      	cmp	r3, #2
  HAL_SDRAM_StateTypeDef state = hsdram->State;
90005cec:	b2d8      	uxtb	r0, r3
  if (state == HAL_SDRAM_STATE_BUSY)
90005cee:	d010      	beq.n	90005d12 <HAL_SDRAM_SendCommand+0x32>
  {
    return HAL_BUSY;
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
90005cf0:	f000 04fb 	and.w	r4, r0, #251	; 0xfb
90005cf4:	2c01      	cmp	r4, #1
90005cf6:	d110      	bne.n	90005d1a <HAL_SDRAM_SendCommand+0x3a>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005cf8:	2302      	movs	r3, #2

    /* Send SDRAM command */
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
90005cfa:	6828      	ldr	r0, [r5, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005cfc:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
90005d00:	f000 f8ae 	bl	90005e60 <FMC_SDRAM_SendCommand>

    /* Update the SDRAM controller state state */
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
90005d04:	6833      	ldr	r3, [r6, #0]
90005d06:	2b02      	cmp	r3, #2
90005d08:	d104      	bne.n	90005d14 <HAL_SDRAM_SendCommand+0x34>
    {
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
90005d0a:	2305      	movs	r3, #5
90005d0c:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
90005d10:	2000      	movs	r0, #0
}
90005d12:	bd70      	pop	{r4, r5, r6, pc}
      hsdram->State = HAL_SDRAM_STATE_READY;
90005d14:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
90005d18:	e7fa      	b.n	90005d10 <HAL_SDRAM_SendCommand+0x30>
    return HAL_ERROR;
90005d1a:	2001      	movs	r0, #1
90005d1c:	e7f9      	b.n	90005d12 <HAL_SDRAM_SendCommand+0x32>

90005d1e <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
90005d1e:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
90005d20:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
90005d24:	4604      	mov	r4, r0
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
90005d26:	2b02      	cmp	r3, #2
90005d28:	b2d8      	uxtb	r0, r3
90005d2a:	d00d      	beq.n	90005d48 <HAL_SDRAM_ProgramRefreshRate+0x2a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
90005d2c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
90005d30:	2b01      	cmp	r3, #1
90005d32:	b2dd      	uxtb	r5, r3
90005d34:	d109      	bne.n	90005d4a <HAL_SDRAM_ProgramRefreshRate+0x2c>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005d36:	2302      	movs	r3, #2

    /* Program the refresh rate */
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
90005d38:	6820      	ldr	r0, [r4, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005d3a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
90005d3e:	f000 f8a1 	bl	90005e84 <FMC_SDRAM_ProgramRefreshRate>
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
90005d42:	2000      	movs	r0, #0
    hsdram->State = HAL_SDRAM_STATE_READY;
90005d44:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
}
90005d48:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
90005d4a:	2001      	movs	r0, #1
90005d4c:	e7fc      	b.n	90005d48 <HAL_SDRAM_ProgramRefreshRate+0x2a>

90005d4e <HAL_SDRAM_SetAutoRefreshNumber>:
  *                the configuration information for SDRAM module.
  * @param  AutoRefreshNumber The SDRAM auto Refresh number
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
{
90005d4e:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
90005d50:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
90005d54:	4604      	mov	r4, r0
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
90005d56:	2b02      	cmp	r3, #2
90005d58:	b2d8      	uxtb	r0, r3
90005d5a:	d00d      	beq.n	90005d78 <HAL_SDRAM_SetAutoRefreshNumber+0x2a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
90005d5c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
90005d60:	2b01      	cmp	r3, #1
90005d62:	b2dd      	uxtb	r5, r3
90005d64:	d109      	bne.n	90005d7a <HAL_SDRAM_SetAutoRefreshNumber+0x2c>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005d66:	2302      	movs	r3, #2

    /* Set the Auto-Refresh number */
    (void)FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance, AutoRefreshNumber);
90005d68:	6820      	ldr	r0, [r4, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90005d6a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance, AutoRefreshNumber);
90005d6e:	f000 f893 	bl	90005e98 <FMC_SDRAM_SetAutoRefreshNumber>
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
90005d72:	2000      	movs	r0, #0
    hsdram->State = HAL_SDRAM_STATE_READY;
90005d74:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
}
90005d78:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
90005d7a:	2001      	movs	r0, #1
90005d7c:	e7fc      	b.n	90005d78 <HAL_SDRAM_SetAutoRefreshNumber+0x2a>

90005d7e <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
90005d7e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
90005d82:	680a      	ldr	r2, [r1, #0]
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
90005d84:	f8d1 9024 	ldr.w	r9, [r1, #36]	; 0x24
90005d88:	e9d1 4307 	ldrd	r4, r3, [r1, #28]
90005d8c:	e9d1 5801 	ldrd	r5, r8, [r1, #4]
90005d90:	e9d1 ec03 	ldrd	lr, ip, [r1, #12]
90005d94:	e9d1 7605 	ldrd	r7, r6, [r1, #20]
90005d98:	4323      	orrs	r3, r4
  if (Init->SDBank == FMC_SDRAM_BANK1)
90005d9a:	b9a2      	cbnz	r2, 90005dc6 <FMC_SDRAM_Init+0x48>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
90005d9c:	ea43 0209 	orr.w	r2, r3, r9
90005da0:	6801      	ldr	r1, [r0, #0]
90005da2:	432a      	orrs	r2, r5
90005da4:	f421 41ff 	bic.w	r1, r1, #32640	; 0x7f80
90005da8:	ea42 0308 	orr.w	r3, r2, r8
90005dac:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
90005db0:	ea43 030e 	orr.w	r3, r3, lr
90005db4:	ea43 030c 	orr.w	r3, r3, ip
90005db8:	433b      	orrs	r3, r7
90005dba:	4333      	orrs	r3, r6
90005dbc:	430b      	orrs	r3, r1
90005dbe:	6003      	str	r3, [r0, #0]
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
90005dc0:	2000      	movs	r0, #0
90005dc2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
90005dc6:	6802      	ldr	r2, [r0, #0]
90005dc8:	ea43 0309 	orr.w	r3, r3, r9
90005dcc:	f422 42f8 	bic.w	r2, r2, #31744	; 0x7c00
90005dd0:	4313      	orrs	r3, r2
90005dd2:	6003      	str	r3, [r0, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
90005dd4:	ea45 0308 	orr.w	r3, r5, r8
90005dd8:	6842      	ldr	r2, [r0, #4]
90005dda:	ea43 030e 	orr.w	r3, r3, lr
90005dde:	f422 42ff 	bic.w	r2, r2, #32640	; 0x7f80
90005de2:	ea43 030c 	orr.w	r3, r3, ip
90005de6:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
90005dea:	433b      	orrs	r3, r7
90005dec:	4333      	orrs	r3, r6
90005dee:	4313      	orrs	r3, r2
90005df0:	6043      	str	r3, [r0, #4]
90005df2:	e7e5      	b.n	90005dc0 <FMC_SDRAM_Init+0x42>

90005df4 <FMC_SDRAM_Timing_Init>:
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90005df4:	68cb      	ldr	r3, [r1, #12]
90005df6:	f103 3cff 	add.w	ip, r3, #4294967295
90005dfa:	694b      	ldr	r3, [r1, #20]
{
90005dfc:	b5f0      	push	{r4, r5, r6, r7, lr}
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90005dfe:	3b01      	subs	r3, #1
90005e00:	680f      	ldr	r7, [r1, #0]
90005e02:	684c      	ldr	r4, [r1, #4]
90005e04:	688e      	ldr	r6, [r1, #8]
90005e06:	051b      	lsls	r3, r3, #20
90005e08:	690d      	ldr	r5, [r1, #16]
90005e0a:	3c01      	subs	r4, #1
90005e0c:	6989      	ldr	r1, [r1, #24]
90005e0e:	3e01      	subs	r6, #1
90005e10:	3d01      	subs	r5, #1
90005e12:	3f01      	subs	r7, #1
90005e14:	3901      	subs	r1, #1
90005e16:	0124      	lsls	r4, r4, #4
90005e18:	0236      	lsls	r6, r6, #8
90005e1a:	042d      	lsls	r5, r5, #16
90005e1c:	0609      	lsls	r1, r1, #24
90005e1e:	ea43 330c 	orr.w	r3, r3, ip, lsl #12
  if (Bank == FMC_SDRAM_BANK1)
90005e22:	b95a      	cbnz	r2, 90005e3c <FMC_SDRAM_Timing_Init+0x48>
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90005e24:	433b      	orrs	r3, r7
90005e26:	6882      	ldr	r2, [r0, #8]
90005e28:	4323      	orrs	r3, r4
90005e2a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
90005e2e:	4333      	orrs	r3, r6
90005e30:	432b      	orrs	r3, r5
90005e32:	430b      	orrs	r3, r1
90005e34:	4313      	orrs	r3, r2
90005e36:	6083      	str	r3, [r0, #8]
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
90005e38:	2000      	movs	r0, #0
90005e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90005e3c:	6882      	ldr	r2, [r0, #8]
90005e3e:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
90005e42:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
90005e46:	431a      	orrs	r2, r3
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
90005e48:	ea44 0306 	orr.w	r3, r4, r6
90005e4c:	433b      	orrs	r3, r7
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90005e4e:	6082      	str	r2, [r0, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
90005e50:	68c2      	ldr	r2, [r0, #12]
90005e52:	432b      	orrs	r3, r5
90005e54:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
90005e58:	430b      	orrs	r3, r1
90005e5a:	4313      	orrs	r3, r2
90005e5c:	60c3      	str	r3, [r0, #12]
90005e5e:	e7eb      	b.n	90005e38 <FMC_SDRAM_Timing_Init+0x44>

90005e60 <FMC_SDRAM_SendCommand>:
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
90005e60:	6902      	ldr	r2, [r0, #16]
{
90005e62:	b510      	push	{r4, lr}
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
90005e64:	e9d1 3400 	ldrd	r3, r4, [r1]
90005e68:	0d92      	lsrs	r2, r2, #22
90005e6a:	4323      	orrs	r3, r4
90005e6c:	68cc      	ldr	r4, [r1, #12]
90005e6e:	0592      	lsls	r2, r2, #22
90005e70:	ea43 2344 	orr.w	r3, r3, r4, lsl #9
90005e74:	4313      	orrs	r3, r2
90005e76:	688a      	ldr	r2, [r1, #8]
90005e78:	3a01      	subs	r2, #1
90005e7a:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
90005e7e:	6103      	str	r3, [r0, #16]
              (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
              ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
90005e80:	2000      	movs	r0, #0
90005e82:	bd10      	pop	{r4, pc}

90005e84 <FMC_SDRAM_ProgramRefreshRate>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
90005e84:	6943      	ldr	r3, [r0, #20]
90005e86:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
90005e8a:	f023 033e 	bic.w	r3, r3, #62	; 0x3e
90005e8e:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
90005e92:	6141      	str	r1, [r0, #20]

  return HAL_OK;
}
90005e94:	2000      	movs	r0, #0
90005e96:	4770      	bx	lr

90005e98 <FMC_SDRAM_SetAutoRefreshNumber>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(AutoRefreshNumber));

  /* Set the Auto-refresh number in command register */
  MODIFY_REG(Device->SDCMR, FMC_SDCMR_NRFS, ((AutoRefreshNumber - 1U) << FMC_SDCMR_NRFS_Pos));
90005e98:	6903      	ldr	r3, [r0, #16]
90005e9a:	3901      	subs	r1, #1
90005e9c:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
90005ea0:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
90005ea4:	6103      	str	r3, [r0, #16]

  return HAL_OK;
}
90005ea6:	2000      	movs	r0, #0
90005ea8:	4770      	bx	lr
	...

90005eac <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
90005eac:	b084      	sub	sp, #16
90005eae:	b510      	push	{r4, lr}
90005eb0:	ac03      	add	r4, sp, #12
90005eb2:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
90005eb6:	9b03      	ldr	r3, [sp, #12]
             Init.HardwareFlowControl | \
             Init.ClockDiv
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90005eb8:	6841      	ldr	r1, [r0, #4]
  tmpreg |= (Init.ClockEdge           | \
90005eba:	4313      	orrs	r3, r2
             Init.ClockPowerSave      | \
90005ebc:	9a05      	ldr	r2, [sp, #20]
90005ebe:	4313      	orrs	r3, r2
             Init.BusWide             | \
90005ec0:	9a06      	ldr	r2, [sp, #24]
90005ec2:	4313      	orrs	r3, r2
             Init.HardwareFlowControl | \
90005ec4:	9a07      	ldr	r2, [sp, #28]
90005ec6:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90005ec8:	4a04      	ldr	r2, [pc, #16]	; (90005edc <SDMMC_Init+0x30>)
90005eca:	400a      	ands	r2, r1

  return HAL_OK;
}
90005ecc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90005ed0:	4313      	orrs	r3, r2
}
90005ed2:	b004      	add	sp, #16
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90005ed4:	6043      	str	r3, [r0, #4]
}
90005ed6:	2000      	movs	r0, #0
90005ed8:	4770      	bx	lr
90005eda:	bf00      	nop
90005edc:	ffc02c00 	.word	0xffc02c00

90005ee0 <SDMMC_ReadFIFO>:
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
90005ee0:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
90005ee4:	4770      	bx	lr

90005ee6 <SDMMC_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
90005ee6:	680b      	ldr	r3, [r1, #0]
90005ee8:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
90005eec:	2000      	movs	r0, #0
90005eee:	4770      	bx	lr

90005ef0 <SDMMC_PowerState_ON>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
90005ef0:	6803      	ldr	r3, [r0, #0]
90005ef2:	f043 0303 	orr.w	r3, r3, #3
90005ef6:	6003      	str	r3, [r0, #0]

  return HAL_OK;
}
90005ef8:	2000      	movs	r0, #0
90005efa:	4770      	bx	lr

90005efc <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
90005efc:	6800      	ldr	r0, [r0, #0]
}
90005efe:	f000 0003 	and.w	r0, r0, #3
90005f02:	4770      	bx	lr

90005f04 <SDMMC_SendCommand>:
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
90005f04:	680b      	ldr	r3, [r1, #0]
{
90005f06:	b510      	push	{r4, lr}
  SDMMCx->ARG = Command->Argument;
90005f08:	6083      	str	r3, [r0, #8]
                       Command->Response         | \
                       Command->WaitForInterrupt | \
                       Command->CPSM);

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
90005f0a:	68c4      	ldr	r4, [r0, #12]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90005f0c:	e9d1 3201 	ldrd	r3, r2, [r1, #4]
90005f10:	4313      	orrs	r3, r2
                       Command->Response         | \
90005f12:	68ca      	ldr	r2, [r1, #12]
90005f14:	4313      	orrs	r3, r2
                       Command->WaitForInterrupt | \
90005f16:	690a      	ldr	r2, [r1, #16]
90005f18:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
90005f1a:	4a03      	ldr	r2, [pc, #12]	; (90005f28 <SDMMC_SendCommand+0x24>)
90005f1c:	4022      	ands	r2, r4
90005f1e:	4313      	orrs	r3, r2
90005f20:	60c3      	str	r3, [r0, #12]

  return HAL_OK;
}
90005f22:	2000      	movs	r0, #0
90005f24:	bd10      	pop	{r4, pc}
90005f26:	bf00      	nop
90005f28:	fffee0c0 	.word	0xfffee0c0

90005f2c <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
90005f2c:	3014      	adds	r0, #20

  return (*(__IO uint32_t *) tmp);
90005f2e:	5840      	ldr	r0, [r0, r1]
}
90005f30:	4770      	bx	lr

90005f32 <SDMMC_ConfigData>:
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
90005f32:	680b      	ldr	r3, [r1, #0]
{
90005f34:	b510      	push	{r4, lr}
  SDMMCx->DTIMER = Data->DataTimeOut;
90005f36:	6243      	str	r3, [r0, #36]	; 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
90005f38:	684b      	ldr	r3, [r1, #4]
90005f3a:	6283      	str	r3, [r0, #40]	; 0x28
                       Data->TransferDir   | \
                       Data->TransferMode  | \
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
90005f3c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
90005f3e:	e9d1 3402 	ldrd	r3, r4, [r1, #8]
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
90005f42:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
90005f46:	4323      	orrs	r3, r4
                       Data->TransferDir   | \
90005f48:	690c      	ldr	r4, [r1, #16]
                       Data->TransferMode  | \
90005f4a:	6949      	ldr	r1, [r1, #20]
                       Data->TransferDir   | \
90005f4c:	4323      	orrs	r3, r4
                       Data->TransferMode  | \
90005f4e:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
90005f50:	4313      	orrs	r3, r2
90005f52:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
90005f54:	2000      	movs	r0, #0
90005f56:	bd10      	pop	{r4, pc}

90005f58 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
90005f58:	b510      	push	{r4, lr}
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
90005f5a:	2300      	movs	r3, #0
{
90005f5c:	b086      	sub	sp, #24
90005f5e:	4604      	mov	r4, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90005f60:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
90005f62:	e9cd 3301 	strd	r3, r3, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90005f66:	e9cd 3303 	strd	r3, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90005f6a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90005f6e:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90005f70:	f7ff ffc8 	bl	90005f04 <SDMMC_SendCommand>
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90005f74:	4b0a      	ldr	r3, [pc, #40]	; (90005fa0 <SDMMC_CmdGoIdleState+0x48>)
90005f76:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
90005f7a:	681b      	ldr	r3, [r3, #0]
90005f7c:	fbb3 f3f2 	udiv	r3, r3, r2
90005f80:	f241 3288 	movw	r2, #5000	; 0x1388
90005f84:	4353      	muls	r3, r2

  do
  {
    if (count-- == 0U)
90005f86:	3b01      	subs	r3, #1
90005f88:	d307      	bcc.n	90005f9a <SDMMC_CmdGoIdleState+0x42>
    {
      return SDMMC_ERROR_TIMEOUT;
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
90005f8a:	6b62      	ldr	r2, [r4, #52]	; 0x34
90005f8c:	0612      	lsls	r2, r2, #24
90005f8e:	d5fa      	bpl.n	90005f86 <SDMMC_CmdGoIdleState+0x2e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90005f90:	4b04      	ldr	r3, [pc, #16]	; (90005fa4 <SDMMC_CmdGoIdleState+0x4c>)

  return SDMMC_ERROR_NONE;
90005f92:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90005f94:	63a3      	str	r3, [r4, #56]	; 0x38
}
90005f96:	b006      	add	sp, #24
90005f98:	bd10      	pop	{r4, pc}
      return SDMMC_ERROR_TIMEOUT;
90005f9a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  return errorstate;
90005f9e:	e7fa      	b.n	90005f96 <SDMMC_CmdGoIdleState+0x3e>
90005fa0:	2400001c 	.word	0x2400001c
90005fa4:	002000c5 	.word	0x002000c5

90005fa8 <SDMMC_GetCmdResp1>:
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
90005fa8:	4b45      	ldr	r3, [pc, #276]	; (900060c0 <SDMMC_GetCmdResp1+0x118>)
{
90005faa:	b510      	push	{r4, lr}
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
90005fac:	681b      	ldr	r3, [r3, #0]
{
90005fae:	4604      	mov	r4, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
90005fb0:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
90005fb4:	fbb3 f3f0 	udiv	r3, r3, r0
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
90005fb8:	4842      	ldr	r0, [pc, #264]	; (900060c4 <SDMMC_GetCmdResp1+0x11c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
90005fba:	435a      	muls	r2, r3
    if (count-- == 0U)
90005fbc:	2a00      	cmp	r2, #0
90005fbe:	d048      	beq.n	90006052 <SDMMC_GetCmdResp1+0xaa>
    sta_reg = SDMMCx->STA;
90005fc0:	6b63      	ldr	r3, [r4, #52]	; 0x34
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90005fc2:	4203      	tst	r3, r0
90005fc4:	d007      	beq.n	90005fd6 <SDMMC_GetCmdResp1+0x2e>
90005fc6:	049b      	lsls	r3, r3, #18
90005fc8:	d405      	bmi.n	90005fd6 <SDMMC_GetCmdResp1+0x2e>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90005fca:	6b63      	ldr	r3, [r4, #52]	; 0x34
90005fcc:	0758      	lsls	r0, r3, #29
90005fce:	d504      	bpl.n	90005fda <SDMMC_GetCmdResp1+0x32>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90005fd0:	2004      	movs	r0, #4
90005fd2:	63a0      	str	r0, [r4, #56]	; 0x38
}
90005fd4:	bd10      	pop	{r4, pc}
90005fd6:	3a01      	subs	r2, #1
90005fd8:	e7f0      	b.n	90005fbc <SDMMC_GetCmdResp1+0x14>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90005fda:	6b60      	ldr	r0, [r4, #52]	; 0x34
90005fdc:	f010 0001 	ands.w	r0, r0, #1
90005fe0:	d002      	beq.n	90005fe8 <SDMMC_GetCmdResp1+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90005fe2:	2301      	movs	r3, #1
90005fe4:	63a3      	str	r3, [r4, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
90005fe6:	e7f5      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90005fe8:	4b37      	ldr	r3, [pc, #220]	; (900060c8 <SDMMC_GetCmdResp1+0x120>)
90005fea:	63a3      	str	r3, [r4, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
90005fec:	6923      	ldr	r3, [r4, #16]
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
90005fee:	b2db      	uxtb	r3, r3
90005ff0:	4299      	cmp	r1, r3
90005ff2:	d131      	bne.n	90006058 <SDMMC_GetCmdResp1+0xb0>
  return (*(__IO uint32_t *) tmp);
90005ff4:	6963      	ldr	r3, [r4, #20]
  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
90005ff6:	4835      	ldr	r0, [pc, #212]	; (900060cc <SDMMC_GetCmdResp1+0x124>)
90005ff8:	4018      	ands	r0, r3
90005ffa:	2800      	cmp	r0, #0
90005ffc:	d0ea      	beq.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
90005ffe:	2b00      	cmp	r3, #0
90006000:	db2c      	blt.n	9000605c <SDMMC_GetCmdResp1+0xb4>
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
90006002:	005a      	lsls	r2, r3, #1
90006004:	d42d      	bmi.n	90006062 <SDMMC_GetCmdResp1+0xba>
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
90006006:	009c      	lsls	r4, r3, #2
90006008:	d42d      	bmi.n	90006066 <SDMMC_GetCmdResp1+0xbe>
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
9000600a:	00d9      	lsls	r1, r3, #3
9000600c:	d42d      	bmi.n	9000606a <SDMMC_GetCmdResp1+0xc2>
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
9000600e:	011a      	lsls	r2, r3, #4
90006010:	d42e      	bmi.n	90006070 <SDMMC_GetCmdResp1+0xc8>
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
90006012:	015c      	lsls	r4, r3, #5
90006014:	d42f      	bmi.n	90006076 <SDMMC_GetCmdResp1+0xce>
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
90006016:	01d9      	lsls	r1, r3, #7
90006018:	d430      	bmi.n	9000607c <SDMMC_GetCmdResp1+0xd4>
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
9000601a:	021a      	lsls	r2, r3, #8
9000601c:	d431      	bmi.n	90006082 <SDMMC_GetCmdResp1+0xda>
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
9000601e:	025c      	lsls	r4, r3, #9
90006020:	d432      	bmi.n	90006088 <SDMMC_GetCmdResp1+0xe0>
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
90006022:	0299      	lsls	r1, r3, #10
90006024:	d433      	bmi.n	9000608e <SDMMC_GetCmdResp1+0xe6>
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
90006026:	02da      	lsls	r2, r3, #11
90006028:	d434      	bmi.n	90006094 <SDMMC_GetCmdResp1+0xec>
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
9000602a:	035c      	lsls	r4, r3, #13
9000602c:	d435      	bmi.n	9000609a <SDMMC_GetCmdResp1+0xf2>
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
9000602e:	0399      	lsls	r1, r3, #14
90006030:	d436      	bmi.n	900060a0 <SDMMC_GetCmdResp1+0xf8>
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
90006032:	03da      	lsls	r2, r3, #15
90006034:	d437      	bmi.n	900060a6 <SDMMC_GetCmdResp1+0xfe>
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
90006036:	041c      	lsls	r4, r3, #16
90006038:	d438      	bmi.n	900060ac <SDMMC_GetCmdResp1+0x104>
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
9000603a:	0459      	lsls	r1, r3, #17
9000603c:	d439      	bmi.n	900060b2 <SDMMC_GetCmdResp1+0x10a>
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
9000603e:	049a      	lsls	r2, r3, #18
90006040:	d43a      	bmi.n	900060b8 <SDMMC_GetCmdResp1+0x110>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
90006042:	f013 0f08 	tst.w	r3, #8
90006046:	bf14      	ite	ne
90006048:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
9000604c:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
90006050:	e7c0      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
      return SDMMC_ERROR_TIMEOUT;
90006052:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
90006056:	e7bd      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
90006058:	2001      	movs	r0, #1
9000605a:	e7bb      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
9000605c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
90006060:	e7b8      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ADDR_MISALIGNED;
90006062:	2040      	movs	r0, #64	; 0x40
90006064:	e7b6      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
90006066:	2080      	movs	r0, #128	; 0x80
90006068:	e7b4      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
9000606a:	f44f 7080 	mov.w	r0, #256	; 0x100
9000606e:	e7b1      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
90006070:	f44f 7000 	mov.w	r0, #512	; 0x200
90006074:	e7ae      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
90006076:	f44f 6080 	mov.w	r0, #1024	; 0x400
9000607a:	e7ab      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
9000607c:	f44f 6000 	mov.w	r0, #2048	; 0x800
90006080:	e7a8      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_COM_CRC_FAILED;
90006082:	f44f 5080 	mov.w	r0, #4096	; 0x1000
90006086:	e7a5      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ILLEGAL_CMD;
90006088:	f44f 5000 	mov.w	r0, #8192	; 0x2000
9000608c:	e7a2      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CARD_ECC_FAILED;
9000608e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
90006092:	e79f      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CC_ERR;
90006094:	f44f 4000 	mov.w	r0, #32768	; 0x8000
90006098:	e79c      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
9000609a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
9000609e:	e799      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
900060a0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
900060a4:	e796      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
900060a6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
900060aa:	e793      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_WP_ERASE_SKIP;
900060ac:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
900060b0:	e790      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
900060b2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
900060b6:	e78d      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ERASE_RESET;
900060b8:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
900060bc:	e78a      	b.n	90005fd4 <SDMMC_GetCmdResp1+0x2c>
900060be:	bf00      	nop
900060c0:	2400001c 	.word	0x2400001c
900060c4:	00200045 	.word	0x00200045
900060c8:	002000c5 	.word	0x002000c5
900060cc:	fdffe008 	.word	0xfdffe008

900060d0 <SDMMC_CmdBlockLength>:
{
900060d0:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900060d2:	f44f 7380 	mov.w	r3, #256	; 0x100
{
900060d6:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900060d8:	2510      	movs	r5, #16
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900060da:	2200      	movs	r2, #0
{
900060dc:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
900060de:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900060e0:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900060e2:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900060e6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900060ea:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900060ee:	f7ff ff09 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
900060f2:	f241 3288 	movw	r2, #5000	; 0x1388
900060f6:	4629      	mov	r1, r5
900060f8:	4620      	mov	r0, r4
900060fa:	f7ff ff55 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
900060fe:	b007      	add	sp, #28
90006100:	bd30      	pop	{r4, r5, pc}

90006102 <SDMMC_CmdReadSingleBlock>:
{
90006102:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006104:	f44f 7380 	mov.w	r3, #256	; 0x100
{
90006108:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000610a:	2511      	movs	r5, #17
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000610c:	2200      	movs	r2, #0
{
9000610e:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
90006110:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006112:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006114:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006118:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000611c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006120:	f7ff fef0 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
90006124:	f241 3288 	movw	r2, #5000	; 0x1388
90006128:	4629      	mov	r1, r5
9000612a:	4620      	mov	r0, r4
9000612c:	f7ff ff3c 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006130:	b007      	add	sp, #28
90006132:	bd30      	pop	{r4, r5, pc}

90006134 <SDMMC_CmdReadMultiBlock>:
{
90006134:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006136:	f44f 7380 	mov.w	r3, #256	; 0x100
{
9000613a:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000613c:	2512      	movs	r5, #18
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000613e:	2200      	movs	r2, #0
{
90006140:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
90006142:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006144:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006146:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000614a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000614e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006152:	f7ff fed7 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
90006156:	f241 3288 	movw	r2, #5000	; 0x1388
9000615a:	4629      	mov	r1, r5
9000615c:	4620      	mov	r0, r4
9000615e:	f7ff ff23 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006162:	b007      	add	sp, #28
90006164:	bd30      	pop	{r4, r5, pc}

90006166 <SDMMC_CmdWriteSingleBlock>:
{
90006166:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006168:	f44f 7380 	mov.w	r3, #256	; 0x100
{
9000616c:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000616e:	2518      	movs	r5, #24
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006170:	2200      	movs	r2, #0
{
90006172:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
90006174:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006176:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006178:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000617c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90006180:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006184:	f7ff febe 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
90006188:	f241 3288 	movw	r2, #5000	; 0x1388
9000618c:	4629      	mov	r1, r5
9000618e:	4620      	mov	r0, r4
90006190:	f7ff ff0a 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006194:	b007      	add	sp, #28
90006196:	bd30      	pop	{r4, r5, pc}

90006198 <SDMMC_CmdWriteMultiBlock>:
{
90006198:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000619a:	f44f 7380 	mov.w	r3, #256	; 0x100
{
9000619e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900061a0:	2519      	movs	r5, #25
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900061a2:	2200      	movs	r2, #0
{
900061a4:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
900061a6:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900061a8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900061aa:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900061ae:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900061b2:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900061b6:	f7ff fea5 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
900061ba:	f241 3288 	movw	r2, #5000	; 0x1388
900061be:	4629      	mov	r1, r5
900061c0:	4620      	mov	r0, r4
900061c2:	f7ff fef1 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
900061c6:	b007      	add	sp, #28
900061c8:	bd30      	pop	{r4, r5, pc}
	...

900061cc <SDMMC_CmdStopTransfer>:
{
900061cc:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
900061ce:	2300      	movs	r3, #0
{
900061d0:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
900061d2:	250c      	movs	r5, #12
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900061d4:	f44f 7280 	mov.w	r2, #256	; 0x100
{
900061d8:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900061da:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900061dc:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
900061e0:	e9cd 3501 	strd	r3, r5, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900061e4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900061e8:	9305      	str	r3, [sp, #20]
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
900061ea:	68c3      	ldr	r3, [r0, #12]
900061ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
900061f0:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
900061f2:	68c3      	ldr	r3, [r0, #12]
900061f4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
900061f8:	60c3      	str	r3, [r0, #12]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900061fa:	f7ff fe83 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
900061fe:	4a07      	ldr	r2, [pc, #28]	; (9000621c <SDMMC_CmdStopTransfer+0x50>)
90006200:	4629      	mov	r1, r5
90006202:	4620      	mov	r0, r4
90006204:	f7ff fed0 	bl	90005fa8 <SDMMC_GetCmdResp1>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
90006208:	68e3      	ldr	r3, [r4, #12]
    errorstate = SDMMC_ERROR_NONE;
9000620a:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
9000620e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
}
90006212:	bf08      	it	eq
90006214:	2000      	moveq	r0, #0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
90006216:	60e3      	str	r3, [r4, #12]
}
90006218:	b007      	add	sp, #28
9000621a:	bd30      	pop	{r4, r5, pc}
9000621c:	05f5e100 	.word	0x05f5e100

90006220 <SDMMC_CmdSelDesel>:
{
90006220:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006222:	f44f 7380 	mov.w	r3, #256	; 0x100
{
90006226:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006228:	2507      	movs	r5, #7
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000622a:	2200      	movs	r2, #0
{
9000622c:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
9000622e:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006230:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006232:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006236:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000623a:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000623e:	f7ff fe61 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
90006242:	f241 3288 	movw	r2, #5000	; 0x1388
90006246:	4629      	mov	r1, r5
90006248:	4620      	mov	r0, r4
9000624a:	f7ff fead 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
9000624e:	b007      	add	sp, #28
90006250:	bd30      	pop	{r4, r5, pc}

90006252 <SDMMC_CmdAppCommand>:
{
90006252:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006254:	f44f 7380 	mov.w	r3, #256	; 0x100
{
90006258:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000625a:	2537      	movs	r5, #55	; 0x37
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000625c:	2200      	movs	r2, #0
{
9000625e:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
90006260:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006262:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006264:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006268:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000626c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006270:	f7ff fe48 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
90006274:	f241 3288 	movw	r2, #5000	; 0x1388
90006278:	4629      	mov	r1, r5
9000627a:	4620      	mov	r0, r4
9000627c:	f7ff fe94 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006280:	b007      	add	sp, #28
90006282:	bd30      	pop	{r4, r5, pc}

90006284 <SDMMC_CmdBusWidth>:
{
90006284:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006286:	f44f 7380 	mov.w	r3, #256	; 0x100
{
9000628a:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000628c:	2506      	movs	r5, #6
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000628e:	2200      	movs	r2, #0
{
90006290:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
90006292:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006294:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006296:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000629a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000629e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900062a2:	f7ff fe2f 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
900062a6:	f241 3288 	movw	r2, #5000	; 0x1388
900062aa:	4629      	mov	r1, r5
900062ac:	4620      	mov	r0, r4
900062ae:	f7ff fe7b 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
900062b2:	b007      	add	sp, #28
900062b4:	bd30      	pop	{r4, r5, pc}

900062b6 <SDMMC_CmdSendSCR>:
{
900062b6:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
900062b8:	2300      	movs	r3, #0
{
900062ba:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
900062bc:	2533      	movs	r5, #51	; 0x33
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900062be:	f44f 7280 	mov.w	r2, #256	; 0x100
{
900062c2:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900062c4:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900062c6:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
900062ca:	e9cd 3501 	strd	r3, r5, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900062ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900062d2:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900062d4:	f7ff fe16 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
900062d8:	f241 3288 	movw	r2, #5000	; 0x1388
900062dc:	4629      	mov	r1, r5
900062de:	4620      	mov	r0, r4
900062e0:	f7ff fe62 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
900062e4:	b007      	add	sp, #28
900062e6:	bd30      	pop	{r4, r5, pc}

900062e8 <SDMMC_CmdSendStatus>:
{
900062e8:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900062ea:	f44f 7380 	mov.w	r3, #256	; 0x100
{
900062ee:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900062f0:	250d      	movs	r5, #13
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900062f2:	2200      	movs	r2, #0
{
900062f4:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
900062f6:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900062f8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900062fa:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900062fe:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90006302:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006306:	f7ff fdfd 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
9000630a:	f241 3288 	movw	r2, #5000	; 0x1388
9000630e:	4629      	mov	r1, r5
90006310:	4620      	mov	r0, r4
90006312:	f7ff fe49 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006316:	b007      	add	sp, #28
90006318:	bd30      	pop	{r4, r5, pc}

9000631a <SDMMC_CmdStatusRegister>:
{
9000631a:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
9000631c:	2300      	movs	r3, #0
{
9000631e:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
90006320:	250d      	movs	r5, #13
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006322:	f44f 7280 	mov.w	r2, #256	; 0x100
{
90006326:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006328:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000632a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
9000632e:	e9cd 3501 	strd	r3, r5, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006332:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90006336:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006338:	f7ff fde4 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
9000633c:	f241 3288 	movw	r2, #5000	; 0x1388
90006340:	4629      	mov	r1, r5
90006342:	4620      	mov	r0, r4
90006344:	f7ff fe30 	bl	90005fa8 <SDMMC_GetCmdResp1>
}
90006348:	b007      	add	sp, #28
9000634a:	bd30      	pop	{r4, r5, pc}

9000634c <SDMMC_GetCmdResp2>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
9000634c:	4b11      	ldr	r3, [pc, #68]	; (90006394 <SDMMC_GetCmdResp2+0x48>)
9000634e:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
{
90006352:	4602      	mov	r2, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90006354:	681b      	ldr	r3, [r3, #0]
90006356:	fbb3 f3f1 	udiv	r3, r3, r1
9000635a:	f241 3188 	movw	r1, #5000	; 0x1388
9000635e:	434b      	muls	r3, r1
    if (count-- == 0U)
90006360:	3b01      	subs	r3, #1
90006362:	d313      	bcc.n	9000638c <SDMMC_GetCmdResp2+0x40>
    sta_reg = SDMMCx->STA;
90006364:	6b51      	ldr	r1, [r2, #52]	; 0x34
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90006366:	f011 0f45 	tst.w	r1, #69	; 0x45
9000636a:	d0f9      	beq.n	90006360 <SDMMC_GetCmdResp2+0x14>
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
9000636c:	0489      	lsls	r1, r1, #18
9000636e:	d4f7      	bmi.n	90006360 <SDMMC_GetCmdResp2+0x14>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90006370:	6b53      	ldr	r3, [r2, #52]	; 0x34
90006372:	075b      	lsls	r3, r3, #29
90006374:	d502      	bpl.n	9000637c <SDMMC_GetCmdResp2+0x30>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90006376:	2004      	movs	r0, #4
90006378:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
9000637a:	4770      	bx	lr
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
9000637c:	6b50      	ldr	r0, [r2, #52]	; 0x34
9000637e:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90006382:	bf14      	ite	ne
90006384:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90006386:	4b04      	ldreq	r3, [pc, #16]	; (90006398 <SDMMC_GetCmdResp2+0x4c>)
90006388:	6393      	str	r3, [r2, #56]	; 0x38
  return SDMMC_ERROR_NONE;
9000638a:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
9000638c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
90006390:	4770      	bx	lr
90006392:	bf00      	nop
90006394:	2400001c 	.word	0x2400001c
90006398:	002000c5 	.word	0x002000c5

9000639c <SDMMC_CmdSendCID>:
{
9000639c:	b510      	push	{r4, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
9000639e:	2300      	movs	r3, #0
{
900063a0:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
900063a2:	2202      	movs	r2, #2
{
900063a4:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900063a6:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
900063a8:	e9cd 3201 	strd	r3, r2, [sp, #4]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900063ac:	f44f 7240 	mov.w	r2, #768	; 0x300
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900063b0:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900063b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900063b8:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900063ba:	f7ff fda3 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900063be:	4620      	mov	r0, r4
900063c0:	f7ff ffc4 	bl	9000634c <SDMMC_GetCmdResp2>
}
900063c4:	b006      	add	sp, #24
900063c6:	bd10      	pop	{r4, pc}

900063c8 <SDMMC_CmdSendCSD>:
{
900063c8:	b510      	push	{r4, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900063ca:	2209      	movs	r2, #9
{
900063cc:	b086      	sub	sp, #24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900063ce:	f44f 7340 	mov.w	r3, #768	; 0x300
{
900063d2:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
900063d4:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900063d6:	2100      	movs	r1, #0
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900063d8:	e9cd 2302 	strd	r2, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900063dc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900063e0:	e9cd 1304 	strd	r1, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900063e4:	a901      	add	r1, sp, #4
900063e6:	f7ff fd8d 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900063ea:	4620      	mov	r0, r4
900063ec:	f7ff ffae 	bl	9000634c <SDMMC_GetCmdResp2>
}
900063f0:	b006      	add	sp, #24
900063f2:	bd10      	pop	{r4, pc}

900063f4 <SDMMC_GetCmdResp3>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900063f4:	4b0f      	ldr	r3, [pc, #60]	; (90006434 <SDMMC_GetCmdResp3+0x40>)
900063f6:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
{
900063fa:	4602      	mov	r2, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900063fc:	681b      	ldr	r3, [r3, #0]
900063fe:	fbb3 f3f1 	udiv	r3, r3, r1
90006402:	f241 3188 	movw	r1, #5000	; 0x1388
90006406:	434b      	muls	r3, r1
    if (count-- == 0U)
90006408:	3b01      	subs	r3, #1
9000640a:	d30f      	bcc.n	9000642c <SDMMC_GetCmdResp3+0x38>
    sta_reg = SDMMCx->STA;
9000640c:	6b51      	ldr	r1, [r2, #52]	; 0x34
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9000640e:	f011 0f45 	tst.w	r1, #69	; 0x45
90006412:	d0f9      	beq.n	90006408 <SDMMC_GetCmdResp3+0x14>
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90006414:	0489      	lsls	r1, r1, #18
90006416:	d4f7      	bmi.n	90006408 <SDMMC_GetCmdResp3+0x14>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90006418:	6b50      	ldr	r0, [r2, #52]	; 0x34
9000641a:	f010 0004 	ands.w	r0, r0, #4
9000641e:	d002      	beq.n	90006426 <SDMMC_GetCmdResp3+0x32>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90006420:	2004      	movs	r0, #4
90006422:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
90006424:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90006426:	4b04      	ldr	r3, [pc, #16]	; (90006438 <SDMMC_GetCmdResp3+0x44>)
90006428:	6393      	str	r3, [r2, #56]	; 0x38
  return SDMMC_ERROR_NONE;
9000642a:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
9000642c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
90006430:	4770      	bx	lr
90006432:	bf00      	nop
90006434:	2400001c 	.word	0x2400001c
90006438:	002000c5 	.word	0x002000c5

9000643c <SDMMC_CmdAppOperCommand>:
{
9000643c:	b510      	push	{r4, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000643e:	2229      	movs	r2, #41	; 0x29
{
90006440:	b086      	sub	sp, #24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90006442:	f44f 7380 	mov.w	r3, #256	; 0x100
{
90006446:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
90006448:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000644a:	2100      	movs	r1, #0
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000644c:	e9cd 2302 	strd	r2, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006450:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90006454:	e9cd 1304 	strd	r1, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006458:	a901      	add	r1, sp, #4
9000645a:	f7ff fd53 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
9000645e:	4620      	mov	r0, r4
90006460:	f7ff ffc8 	bl	900063f4 <SDMMC_GetCmdResp3>
}
90006464:	b006      	add	sp, #24
90006466:	bd10      	pop	{r4, pc}

90006468 <SDMMC_GetCmdResp6>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90006468:	4b1f      	ldr	r3, [pc, #124]	; (900064e8 <SDMMC_GetCmdResp6+0x80>)
{
9000646a:	b510      	push	{r4, lr}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
9000646c:	681b      	ldr	r3, [r3, #0]
{
9000646e:	4604      	mov	r4, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90006470:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
90006474:	fbb3 f3f0 	udiv	r3, r3, r0
90006478:	f241 3088 	movw	r0, #5000	; 0x1388
9000647c:	4343      	muls	r3, r0
    if (count-- == 0U)
9000647e:	3b01      	subs	r3, #1
90006480:	d329      	bcc.n	900064d6 <SDMMC_GetCmdResp6+0x6e>
    sta_reg = SDMMCx->STA;
90006482:	6b60      	ldr	r0, [r4, #52]	; 0x34
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90006484:	f010 0f45 	tst.w	r0, #69	; 0x45
90006488:	d0f9      	beq.n	9000647e <SDMMC_GetCmdResp6+0x16>
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
9000648a:	0480      	lsls	r0, r0, #18
9000648c:	d4f7      	bmi.n	9000647e <SDMMC_GetCmdResp6+0x16>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
9000648e:	6b63      	ldr	r3, [r4, #52]	; 0x34
90006490:	0758      	lsls	r0, r3, #29
90006492:	d502      	bpl.n	9000649a <SDMMC_GetCmdResp6+0x32>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90006494:	2004      	movs	r0, #4
90006496:	63a0      	str	r0, [r4, #56]	; 0x38
}
90006498:	bd10      	pop	{r4, pc}
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
9000649a:	6b60      	ldr	r0, [r4, #52]	; 0x34
9000649c:	f010 0001 	ands.w	r0, r0, #1
900064a0:	d002      	beq.n	900064a8 <SDMMC_GetCmdResp6+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
900064a2:	2301      	movs	r3, #1
900064a4:	63a3      	str	r3, [r4, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
900064a6:	e7f7      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
  return (uint8_t)(SDMMCx->RESPCMD);
900064a8:	6923      	ldr	r3, [r4, #16]
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
900064aa:	b2db      	uxtb	r3, r3
900064ac:	4299      	cmp	r1, r3
900064ae:	d115      	bne.n	900064dc <SDMMC_GetCmdResp6+0x74>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900064b0:	4b0e      	ldr	r3, [pc, #56]	; (900064ec <SDMMC_GetCmdResp6+0x84>)
900064b2:	63a3      	str	r3, [r4, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
900064b4:	6963      	ldr	r3, [r4, #20]
  if ((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD |
900064b6:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
900064ba:	d102      	bne.n	900064c2 <SDMMC_GetCmdResp6+0x5a>
    *pRCA = (uint16_t)(response_r1 >> 16);
900064bc:	0c1b      	lsrs	r3, r3, #16
900064be:	8013      	strh	r3, [r2, #0]
    return SDMMC_ERROR_NONE;
900064c0:	e7ea      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
  else if ((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
900064c2:	045a      	lsls	r2, r3, #17
900064c4:	d40c      	bmi.n	900064e0 <SDMMC_GetCmdResp6+0x78>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
900064c6:	f413 4f00 	tst.w	r3, #32768	; 0x8000
900064ca:	bf14      	ite	ne
900064cc:	f44f 5080 	movne.w	r0, #4096	; 0x1000
900064d0:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
900064d4:	e7e0      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
      return SDMMC_ERROR_TIMEOUT;
900064d6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
900064da:	e7dd      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
    return SDMMC_ERROR_CMD_CRC_FAIL;
900064dc:	2001      	movs	r0, #1
900064de:	e7db      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
    return SDMMC_ERROR_ILLEGAL_CMD;
900064e0:	f44f 5000 	mov.w	r0, #8192	; 0x2000
900064e4:	e7d8      	b.n	90006498 <SDMMC_GetCmdResp6+0x30>
900064e6:	bf00      	nop
900064e8:	2400001c 	.word	0x2400001c
900064ec:	002000c5 	.word	0x002000c5

900064f0 <SDMMC_CmdSetRelAdd>:
{
900064f0:	b530      	push	{r4, r5, lr}
900064f2:	b089      	sub	sp, #36	; 0x24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
900064f4:	2300      	movs	r3, #0
900064f6:	2503      	movs	r5, #3
{
900064f8:	4604      	mov	r4, r0
900064fa:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900064fc:	f44f 7180 	mov.w	r1, #256	; 0x100
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
90006500:	e9cd 3503 	strd	r3, r5, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90006504:	e9cd 1305 	strd	r1, r3, [sp, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006508:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000650c:	a903      	add	r1, sp, #12
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000650e:	9307      	str	r3, [sp, #28]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006510:	f7ff fcf8 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
90006514:	9a01      	ldr	r2, [sp, #4]
90006516:	4629      	mov	r1, r5
90006518:	4620      	mov	r0, r4
9000651a:	f7ff ffa5 	bl	90006468 <SDMMC_GetCmdResp6>
}
9000651e:	b009      	add	sp, #36	; 0x24
90006520:	bd30      	pop	{r4, r5, pc}
	...

90006524 <SDMMC_GetCmdResp7>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90006524:	4b13      	ldr	r3, [pc, #76]	; (90006574 <SDMMC_GetCmdResp7+0x50>)
90006526:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
{
9000652a:	4602      	mov	r2, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
9000652c:	681b      	ldr	r3, [r3, #0]
9000652e:	fbb3 f3f1 	udiv	r3, r3, r1
90006532:	f241 3188 	movw	r1, #5000	; 0x1388
90006536:	434b      	muls	r3, r1
    if (count-- == 0U)
90006538:	3b01      	subs	r3, #1
9000653a:	d317      	bcc.n	9000656c <SDMMC_GetCmdResp7+0x48>
    sta_reg = SDMMCx->STA;
9000653c:	6b51      	ldr	r1, [r2, #52]	; 0x34
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9000653e:	f011 0f45 	tst.w	r1, #69	; 0x45
90006542:	d0f9      	beq.n	90006538 <SDMMC_GetCmdResp7+0x14>
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90006544:	0488      	lsls	r0, r1, #18
90006546:	d4f7      	bmi.n	90006538 <SDMMC_GetCmdResp7+0x14>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90006548:	6b53      	ldr	r3, [r2, #52]	; 0x34
9000654a:	0759      	lsls	r1, r3, #29
9000654c:	d502      	bpl.n	90006554 <SDMMC_GetCmdResp7+0x30>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
9000654e:	2004      	movs	r0, #4
90006550:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
90006552:	4770      	bx	lr
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90006554:	6b50      	ldr	r0, [r2, #52]	; 0x34
90006556:	f010 0001 	ands.w	r0, r0, #1
9000655a:	d002      	beq.n	90006562 <SDMMC_GetCmdResp7+0x3e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
9000655c:	2301      	movs	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
9000655e:	6393      	str	r3, [r2, #56]	; 0x38
90006560:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
90006562:	6b53      	ldr	r3, [r2, #52]	; 0x34
90006564:	065b      	lsls	r3, r3, #25
90006566:	d503      	bpl.n	90006570 <SDMMC_GetCmdResp7+0x4c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
90006568:	2340      	movs	r3, #64	; 0x40
9000656a:	e7f8      	b.n	9000655e <SDMMC_GetCmdResp7+0x3a>
      return SDMMC_ERROR_TIMEOUT;
9000656c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
90006570:	4770      	bx	lr
90006572:	bf00      	nop
90006574:	2400001c 	.word	0x2400001c

90006578 <SDMMC_CmdOperCond>:
{
90006578:	b510      	push	{r4, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
9000657a:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
{
9000657e:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
90006580:	2308      	movs	r3, #8
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90006582:	f44f 7180 	mov.w	r1, #256	; 0x100
{
90006586:	4604      	mov	r4, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
90006588:	e9cd 2301 	strd	r2, r3, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000658c:	2300      	movs	r3, #0
9000658e:	e9cd 1303 	strd	r1, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006592:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90006596:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90006598:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000659a:	f7ff fcb3 	bl	90005f04 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
9000659e:	4620      	mov	r0, r4
900065a0:	f7ff ffc0 	bl	90006524 <SDMMC_GetCmdResp7>
}
900065a4:	b006      	add	sp, #24
900065a6:	bd10      	pop	{r4, pc}

900065a8 <lwiperf_tcp_close>:
}

/** Close an iperf tcp session */
static void
lwiperf_tcp_close(lwiperf_state_tcp_t *conn, enum lwiperf_report_type report_type)
{
900065a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
900065ac:	4604      	mov	r4, r0
  for (iter = lwiperf_all_connections; iter != NULL; prev = iter, iter = iter->next) {
900065ae:	4837      	ldr	r0, [pc, #220]	; (9000668c <lwiperf_tcp_close+0xe4>)
{
900065b0:	b087      	sub	sp, #28
900065b2:	460e      	mov	r6, r1
  for (iter = lwiperf_all_connections; iter != NULL; prev = iter, iter = iter->next) {
900065b4:	6803      	ldr	r3, [r0, #0]
  lwiperf_state_base_t *prev = NULL;
900065b6:	2200      	movs	r2, #0
  for (iter = lwiperf_all_connections; iter != NULL; prev = iter, iter = iter->next) {
900065b8:	b15b      	cbz	r3, 900065d2 <lwiperf_tcp_close+0x2a>
    if (iter == item) {
900065ba:	429c      	cmp	r4, r3
        lwiperf_all_connections = iter->next;
900065bc:	6819      	ldr	r1, [r3, #0]
    if (iter == item) {
900065be:	d139      	bne.n	90006634 <lwiperf_tcp_close+0x8c>
      if (prev == NULL) {
900065c0:	bb62      	cbnz	r2, 9000661c <lwiperf_tcp_close+0x74>
        lwiperf_all_connections = iter->next;
900065c2:	6001      	str	r1, [r0, #0]
      for (iter = iter->next; iter != NULL; iter = iter->next) {
900065c4:	681d      	ldr	r5, [r3, #0]
        LWIP_ASSERT("duplicate entry", iter != item);
900065c6:	4f32      	ldr	r7, [pc, #200]	; (90006690 <lwiperf_tcp_close+0xe8>)
900065c8:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 9000669c <lwiperf_tcp_close+0xf4>
900065cc:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 90006698 <lwiperf_tcp_close+0xf0>
      for (iter = iter->next; iter != NULL; iter = iter->next) {
900065d0:	bb35      	cbnz	r5, 90006620 <lwiperf_tcp_close+0x78>
  if ((conn != NULL) && (conn->report_fn != NULL)) {
900065d2:	bb94      	cbnz	r4, 9000663a <lwiperf_tcp_close+0x92>
  err_t err;

  lwiperf_list_remove(&conn->base);
  lwip_tcp_conn_report(conn, report_type);
  if (conn->conn_pcb != NULL) {
900065d4:	6920      	ldr	r0, [r4, #16]
900065d6:	2800      	cmp	r0, #0
900065d8:	d04a      	beq.n	90006670 <lwiperf_tcp_close+0xc8>
    tcp_arg(conn->conn_pcb, NULL);
900065da:	2100      	movs	r1, #0
900065dc:	f007 f962 	bl	9000d8a4 <tcp_arg>
    tcp_poll(conn->conn_pcb, NULL, 0);
900065e0:	2200      	movs	r2, #0
900065e2:	6920      	ldr	r0, [r4, #16]
900065e4:	4611      	mov	r1, r2
900065e6:	f007 f9af 	bl	9000d948 <tcp_poll>
    tcp_sent(conn->conn_pcb, NULL);
900065ea:	2100      	movs	r1, #0
900065ec:	6920      	ldr	r0, [r4, #16]
900065ee:	f007 f975 	bl	9000d8dc <tcp_sent>
    tcp_recv(conn->conn_pcb, NULL);
900065f2:	2100      	movs	r1, #0
900065f4:	6920      	ldr	r0, [r4, #16]
900065f6:	f007 f959 	bl	9000d8ac <tcp_recv>
    tcp_err(conn->conn_pcb, NULL);
900065fa:	6920      	ldr	r0, [r4, #16]
900065fc:	2100      	movs	r1, #0
900065fe:	f007 f985 	bl	9000d90c <tcp_err>
    err = tcp_close(conn->conn_pcb);
90006602:	6920      	ldr	r0, [r4, #16]
90006604:	f007 fd82 	bl	9000e10c <tcp_close>
    if (err != ERR_OK) {
90006608:	b110      	cbz	r0, 90006610 <lwiperf_tcp_close+0x68>
      /* don't want to wait for free memory here... */
      tcp_abort(conn->conn_pcb);
9000660a:	6920      	ldr	r0, [r4, #16]
9000660c:	f007 fbb4 	bl	9000dd78 <tcp_abort>
  } else {
    /* no conn pcb, this is the listener pcb */
    err = tcp_close(conn->server_pcb);
    LWIP_ASSERT("error", err == ERR_OK);
  }
  LWIPERF_FREE(lwiperf_state_tcp_t, conn);
90006610:	4620      	mov	r0, r4
}
90006612:	b007      	add	sp, #28
90006614:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIPERF_FREE(lwiperf_state_tcp_t, conn);
90006618:	f005 bc44 	b.w	9000bea4 <mem_free>
        prev->next = iter->next;
9000661c:	6011      	str	r1, [r2, #0]
9000661e:	e7d1      	b.n	900065c4 <lwiperf_tcp_close+0x1c>
        LWIP_ASSERT("duplicate entry", iter != item);
90006620:	42ac      	cmp	r4, r5
90006622:	d105      	bne.n	90006630 <lwiperf_tcp_close+0x88>
90006624:	463b      	mov	r3, r7
90006626:	22d0      	movs	r2, #208	; 0xd0
90006628:	4641      	mov	r1, r8
9000662a:	4648      	mov	r0, r9
9000662c:	f00b fabe 	bl	90011bac <iprintf>
      for (iter = iter->next; iter != NULL; iter = iter->next) {
90006630:	682d      	ldr	r5, [r5, #0]
90006632:	e7cd      	b.n	900065d0 <lwiperf_tcp_close+0x28>
90006634:	461a      	mov	r2, r3
        lwiperf_all_connections = iter->next;
90006636:	460b      	mov	r3, r1
90006638:	e7be      	b.n	900065b8 <lwiperf_tcp_close+0x10>
  if ((conn != NULL) && (conn->report_fn != NULL)) {
9000663a:	69a3      	ldr	r3, [r4, #24]
9000663c:	2b00      	cmp	r3, #0
9000663e:	d0c9      	beq.n	900065d4 <lwiperf_tcp_close+0x2c>
    now = sys_now();
90006640:	f7fa fe16 	bl	90001270 <sys_now>
    duration_ms = now - conn->time_started;
90006644:	6963      	ldr	r3, [r4, #20]
    if (duration_ms == 0) {
90006646:	6a61      	ldr	r1, [r4, #36]	; 0x24
90006648:	1ac0      	subs	r0, r0, r3
                    &conn->conn_pcb->local_ip, conn->conn_pcb->local_port,
9000664a:	6922      	ldr	r2, [r4, #16]
      bandwidth_kbitpsec = (conn->bytes_transferred / duration_ms) * 8U;
9000664c:	bf16      	itet	ne
9000664e:	fbb1 f5f0 	udivne	r5, r1, r0
      bandwidth_kbitpsec = 0;
90006652:	4605      	moveq	r5, r0
      bandwidth_kbitpsec = (conn->bytes_transferred / duration_ms) * 8U;
90006654:	00ed      	lslne	r5, r5, #3
    conn->report_fn(conn->report_arg, report_type,
90006656:	8ad3      	ldrh	r3, [r2, #22]
90006658:	9102      	str	r1, [sp, #8]
9000665a:	e9cd 0503 	strd	r0, r5, [sp, #12]
9000665e:	8b11      	ldrh	r1, [r2, #24]
90006660:	69a5      	ldr	r5, [r4, #24]
90006662:	9101      	str	r1, [sp, #4]
                    &conn->conn_pcb->remote_ip, conn->conn_pcb->remote_port,
90006664:	1d11      	adds	r1, r2, #4
    conn->report_fn(conn->report_arg, report_type,
90006666:	69e0      	ldr	r0, [r4, #28]
90006668:	9100      	str	r1, [sp, #0]
9000666a:	4631      	mov	r1, r6
9000666c:	47a8      	blx	r5
9000666e:	e7b1      	b.n	900065d4 <lwiperf_tcp_close+0x2c>
    err = tcp_close(conn->server_pcb);
90006670:	68e0      	ldr	r0, [r4, #12]
90006672:	f007 fd4b 	bl	9000e10c <tcp_close>
    LWIP_ASSERT("error", err == ERR_OK);
90006676:	2800      	cmp	r0, #0
90006678:	d0ca      	beq.n	90006610 <lwiperf_tcp_close+0x68>
9000667a:	4b05      	ldr	r3, [pc, #20]	; (90006690 <lwiperf_tcp_close+0xe8>)
9000667c:	f240 120d 	movw	r2, #269	; 0x10d
90006680:	4904      	ldr	r1, [pc, #16]	; (90006694 <lwiperf_tcp_close+0xec>)
90006682:	4805      	ldr	r0, [pc, #20]	; (90006698 <lwiperf_tcp_close+0xf0>)
90006684:	f00b fa92 	bl	90011bac <iprintf>
90006688:	e7c2      	b.n	90006610 <lwiperf_tcp_close+0x68>
9000668a:	bf00      	nop
9000668c:	24004dd4 	.word	0x24004dd4
90006690:	90012b71 	.word	0x90012b71
90006694:	9001357a 	.word	0x9001357a
90006698:	90012aff 	.word	0x90012aff
9000669c:	90012bb3 	.word	0x90012bb3

900066a0 <lwiperf_tcp_accept>:
}

/** This is called when a new client connects for an iperf tcp session */
static err_t
lwiperf_tcp_accept(void *arg, struct tcp_pcb *newpcb, err_t err)
{
900066a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900066a2:	4604      	mov	r4, r0
900066a4:	460e      	mov	r6, r1
  lwiperf_state_tcp_t *s, *conn;
  if ((err != ERR_OK) || (newpcb == NULL) || (arg == NULL)) {
900066a6:	4617      	mov	r7, r2
900066a8:	b11a      	cbz	r2, 900066b2 <lwiperf_tcp_accept+0x12>
    return ERR_VAL;
900066aa:	f06f 0705 	mvn.w	r7, #5
      lwiperf_tcp_close(s, LWIPERF_TCP_ABORTED_LOCAL);
    }
  }
  lwiperf_list_add(&conn->base);
  return ERR_OK;
}
900066ae:	4638      	mov	r0, r7
900066b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((err != ERR_OK) || (newpcb == NULL) || (arg == NULL)) {
900066b2:	2900      	cmp	r1, #0
900066b4:	d0f9      	beq.n	900066aa <lwiperf_tcp_accept+0xa>
900066b6:	2800      	cmp	r0, #0
900066b8:	d0f7      	beq.n	900066aa <lwiperf_tcp_accept+0xa>
  LWIP_ASSERT("invalid session", s->base.server);
900066ba:	7943      	ldrb	r3, [r0, #5]
900066bc:	b933      	cbnz	r3, 900066cc <lwiperf_tcp_accept+0x2c>
900066be:	4b3b      	ldr	r3, [pc, #236]	; (900067ac <lwiperf_tcp_accept+0x10c>)
900066c0:	f44f 7216 	mov.w	r2, #600	; 0x258
900066c4:	493a      	ldr	r1, [pc, #232]	; (900067b0 <lwiperf_tcp_accept+0x110>)
900066c6:	483b      	ldr	r0, [pc, #236]	; (900067b4 <lwiperf_tcp_accept+0x114>)
900066c8:	f00b fa70 	bl	90011bac <iprintf>
  LWIP_ASSERT("invalid listen pcb", s->server_pcb != NULL);
900066cc:	68e3      	ldr	r3, [r4, #12]
900066ce:	b933      	cbnz	r3, 900066de <lwiperf_tcp_accept+0x3e>
900066d0:	4b36      	ldr	r3, [pc, #216]	; (900067ac <lwiperf_tcp_accept+0x10c>)
900066d2:	f240 2259 	movw	r2, #601	; 0x259
900066d6:	4938      	ldr	r1, [pc, #224]	; (900067b8 <lwiperf_tcp_accept+0x118>)
900066d8:	4836      	ldr	r0, [pc, #216]	; (900067b4 <lwiperf_tcp_accept+0x114>)
900066da:	f00b fa67 	bl	90011bac <iprintf>
  LWIP_ASSERT("invalid conn pcb", s->conn_pcb == NULL);
900066de:	6923      	ldr	r3, [r4, #16]
900066e0:	b133      	cbz	r3, 900066f0 <lwiperf_tcp_accept+0x50>
900066e2:	4b32      	ldr	r3, [pc, #200]	; (900067ac <lwiperf_tcp_accept+0x10c>)
900066e4:	f240 225a 	movw	r2, #602	; 0x25a
900066e8:	4934      	ldr	r1, [pc, #208]	; (900067bc <lwiperf_tcp_accept+0x11c>)
900066ea:	4832      	ldr	r0, [pc, #200]	; (900067b4 <lwiperf_tcp_accept+0x114>)
900066ec:	f00b fa5e 	bl	90011bac <iprintf>
  if (s->specific_remote) {
900066f0:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    LWIP_ASSERT("s->base.related_master_state != NULL", s->base.related_master_state != NULL);
900066f4:	68a3      	ldr	r3, [r4, #8]
  if (s->specific_remote) {
900066f6:	2a00      	cmp	r2, #0
900066f8:	d047      	beq.n	9000678a <lwiperf_tcp_accept+0xea>
    LWIP_ASSERT("s->base.related_master_state != NULL", s->base.related_master_state != NULL);
900066fa:	b933      	cbnz	r3, 9000670a <lwiperf_tcp_accept+0x6a>
900066fc:	4b2b      	ldr	r3, [pc, #172]	; (900067ac <lwiperf_tcp_accept+0x10c>)
900066fe:	f44f 7217 	mov.w	r2, #604	; 0x25c
90006702:	492f      	ldr	r1, [pc, #188]	; (900067c0 <lwiperf_tcp_accept+0x120>)
90006704:	482b      	ldr	r0, [pc, #172]	; (900067b4 <lwiperf_tcp_accept+0x114>)
90006706:	f00b fa51 	bl	90011bac <iprintf>
    if (!ip_addr_cmp(&newpcb->remote_ip, &s->remote_addr)) {
9000670a:	6872      	ldr	r2, [r6, #4]
9000670c:	6c63      	ldr	r3, [r4, #68]	; 0x44
9000670e:	429a      	cmp	r2, r3
90006710:	d1cb      	bne.n	900066aa <lwiperf_tcp_accept+0xa>
  conn = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
90006712:	2048      	movs	r0, #72	; 0x48
90006714:	f005 fd58 	bl	9000c1c8 <mem_malloc>
  if (conn == NULL) {
90006718:	4605      	mov	r5, r0
9000671a:	2800      	cmp	r0, #0
9000671c:	d043      	beq.n	900067a6 <lwiperf_tcp_accept+0x106>
  memset(conn, 0, sizeof(lwiperf_state_tcp_t));
9000671e:	2248      	movs	r2, #72	; 0x48
90006720:	2100      	movs	r1, #0
90006722:	f00b f95b 	bl	900119dc <memset>
  conn->base.tcp = 1;
90006726:	f240 1301 	movw	r3, #257	; 0x101
  conn->conn_pcb = newpcb;
9000672a:	612e      	str	r6, [r5, #16]
  conn->base.tcp = 1;
9000672c:	80ab      	strh	r3, [r5, #4]
  conn->base.related_master_state = &s->base;
9000672e:	60ac      	str	r4, [r5, #8]
  conn->time_started = sys_now();
90006730:	f7fa fd9e 	bl	90001270 <sys_now>
  conn->report_fn = s->report_fn;
90006734:	69a3      	ldr	r3, [r4, #24]
  tcp_arg(newpcb, conn);
90006736:	4629      	mov	r1, r5
  conn->time_started = sys_now();
90006738:	6168      	str	r0, [r5, #20]
  conn->report_fn = s->report_fn;
9000673a:	61ab      	str	r3, [r5, #24]
  tcp_arg(newpcb, conn);
9000673c:	4630      	mov	r0, r6
  conn->report_arg = s->report_arg;
9000673e:	69e3      	ldr	r3, [r4, #28]
90006740:	61eb      	str	r3, [r5, #28]
  tcp_arg(newpcb, conn);
90006742:	f007 f8af 	bl	9000d8a4 <tcp_arg>
  tcp_recv(newpcb, lwiperf_tcp_recv);
90006746:	4630      	mov	r0, r6
90006748:	491e      	ldr	r1, [pc, #120]	; (900067c4 <lwiperf_tcp_accept+0x124>)
9000674a:	f007 f8af 	bl	9000d8ac <tcp_recv>
  tcp_poll(newpcb, lwiperf_tcp_poll, 2U);
9000674e:	4630      	mov	r0, r6
90006750:	2202      	movs	r2, #2
90006752:	491d      	ldr	r1, [pc, #116]	; (900067c8 <lwiperf_tcp_accept+0x128>)
90006754:	f007 f8f8 	bl	9000d948 <tcp_poll>
  tcp_err(conn->conn_pcb, lwiperf_tcp_err);
90006758:	491c      	ldr	r1, [pc, #112]	; (900067cc <lwiperf_tcp_accept+0x12c>)
9000675a:	6928      	ldr	r0, [r5, #16]
9000675c:	f007 f8d6 	bl	9000d90c <tcp_err>
  if (s->specific_remote) {
90006760:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
90006764:	4e1a      	ldr	r6, [pc, #104]	; (900067d0 <lwiperf_tcp_accept+0x130>)
90006766:	b163      	cbz	r3, 90006782 <lwiperf_tcp_accept+0xe2>
    conn->base.related_master_state = s->base.related_master_state;
90006768:	68a2      	ldr	r2, [r4, #8]
9000676a:	60aa      	str	r2, [r5, #8]
    if (!s->client_tradeoff_mode || !lwiperf_list_find(s->base.related_master_state)) {
9000676c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
90006770:	b10b      	cbz	r3, 90006776 <lwiperf_tcp_accept+0xd6>
  for (iter = lwiperf_all_connections; iter != NULL; iter = iter->next) {
90006772:	6833      	ldr	r3, [r6, #0]
90006774:	b99b      	cbnz	r3, 9000679e <lwiperf_tcp_accept+0xfe>
      s->report_fn = NULL;
90006776:	2300      	movs	r3, #0
      lwiperf_tcp_close(s, LWIPERF_TCP_ABORTED_LOCAL);
90006778:	2102      	movs	r1, #2
9000677a:	4620      	mov	r0, r4
      s->report_fn = NULL;
9000677c:	61a3      	str	r3, [r4, #24]
      lwiperf_tcp_close(s, LWIPERF_TCP_ABORTED_LOCAL);
9000677e:	f7ff ff13 	bl	900065a8 <lwiperf_tcp_close>
  item->next = lwiperf_all_connections;
90006782:	6833      	ldr	r3, [r6, #0]
  lwiperf_all_connections = item;
90006784:	6035      	str	r5, [r6, #0]
  item->next = lwiperf_all_connections;
90006786:	602b      	str	r3, [r5, #0]
}
90006788:	e791      	b.n	900066ae <lwiperf_tcp_accept+0xe>
    LWIP_ASSERT("s->base.related_master_state == NULL", s->base.related_master_state == NULL);
9000678a:	2b00      	cmp	r3, #0
9000678c:	d0c1      	beq.n	90006712 <lwiperf_tcp_accept+0x72>
9000678e:	4b07      	ldr	r3, [pc, #28]	; (900067ac <lwiperf_tcp_accept+0x10c>)
90006790:	f240 2262 	movw	r2, #610	; 0x262
90006794:	490f      	ldr	r1, [pc, #60]	; (900067d4 <lwiperf_tcp_accept+0x134>)
90006796:	4807      	ldr	r0, [pc, #28]	; (900067b4 <lwiperf_tcp_accept+0x114>)
90006798:	f00b fa08 	bl	90011bac <iprintf>
9000679c:	e7b9      	b.n	90006712 <lwiperf_tcp_accept+0x72>
    if (iter == item) {
9000679e:	429a      	cmp	r2, r3
900067a0:	d0ef      	beq.n	90006782 <lwiperf_tcp_accept+0xe2>
  for (iter = lwiperf_all_connections; iter != NULL; iter = iter->next) {
900067a2:	681b      	ldr	r3, [r3, #0]
900067a4:	e7e6      	b.n	90006774 <lwiperf_tcp_accept+0xd4>
    return ERR_MEM;
900067a6:	f04f 37ff 	mov.w	r7, #4294967295
900067aa:	e780      	b.n	900066ae <lwiperf_tcp_accept+0xe>
900067ac:	90012b71 	.word	0x90012b71
900067b0:	90012bc3 	.word	0x90012bc3
900067b4:	90012aff 	.word	0x90012aff
900067b8:	90012bd3 	.word	0x90012bd3
900067bc:	90012be6 	.word	0x90012be6
900067c0:	90012bf7 	.word	0x90012bf7
900067c4:	90006b91 	.word	0x90006b91
900067c8:	90006905 	.word	0x90006905
900067cc:	900067d9 	.word	0x900067d9
900067d0:	24004dd4 	.word	0x24004dd4
900067d4:	90012c1c 	.word	0x90012c1c

900067d8 <lwiperf_tcp_err>:
  lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_REMOTE);
900067d8:	2105      	movs	r1, #5
900067da:	f7ff bee5 	b.w	900065a8 <lwiperf_tcp_close>
	...

900067e0 <lwiperf_tcp_client_send_more>:
{
900067e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("conn invalid", (conn != NULL) && conn->base.tcp && (conn->base.server == 0));
900067e4:	4605      	mov	r5, r0
900067e6:	b118      	cbz	r0, 900067f0 <lwiperf_tcp_client_send_more+0x10>
900067e8:	7903      	ldrb	r3, [r0, #4]
900067ea:	b10b      	cbz	r3, 900067f0 <lwiperf_tcp_client_send_more+0x10>
900067ec:	7943      	ldrb	r3, [r0, #5]
900067ee:	b133      	cbz	r3, 900067fe <lwiperf_tcp_client_send_more+0x1e>
900067f0:	4b33      	ldr	r3, [pc, #204]	; (900068c0 <lwiperf_tcp_client_send_more+0xe0>)
900067f2:	f240 121d 	movw	r2, #285	; 0x11d
900067f6:	4933      	ldr	r1, [pc, #204]	; (900068c4 <lwiperf_tcp_client_send_more+0xe4>)
900067f8:	4833      	ldr	r0, [pc, #204]	; (900068c8 <lwiperf_tcp_client_send_more+0xe8>)
900067fa:	f00b f9d7 	bl	90011bac <iprintf>
      u32_t time_ms = time * 10;
900067fe:	f06f 0709 	mvn.w	r7, #9
      txptr = LWIP_CONST_CAST(void *, &lwiperf_txbuf_const[conn->bytes_transferred % 10]);
90006802:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 900068cc <lwiperf_tcp_client_send_more+0xec>
90006806:	260a      	movs	r6, #10
    if (conn->settings.amount & PP_HTONL(0x80000000)) {
90006808:	6be8      	ldr	r0, [r5, #60]	; 0x3c
9000680a:	0602      	lsls	r2, r0, #24
9000680c:	d510      	bpl.n	90006830 <lwiperf_tcp_client_send_more+0x50>
      u32_t now = sys_now();
9000680e:	f7fa fd2f 	bl	90001270 <sys_now>
      u32_t diff_ms = now - conn->time_started;
90006812:	696c      	ldr	r4, [r5, #20]
90006814:	1b04      	subs	r4, r0, r4
      u32_t time = (u32_t) - (s32_t)lwip_htonl(conn->settings.amount);
90006816:	6be8      	ldr	r0, [r5, #60]	; 0x3c
90006818:	f002 fcb5 	bl	90009186 <lwip_htonl>
      u32_t time_ms = time * 10;
9000681c:	4378      	muls	r0, r7
      if (diff_ms >= time_ms) {
9000681e:	4284      	cmp	r4, r0
90006820:	d30b      	bcc.n	9000683a <lwiperf_tcp_client_send_more+0x5a>
        lwiperf_tcp_close(conn, LWIPERF_TCP_DONE_CLIENT);
90006822:	2101      	movs	r1, #1
90006824:	4628      	mov	r0, r5
90006826:	f7ff febf 	bl	900065a8 <lwiperf_tcp_close>
}
9000682a:	2000      	movs	r0, #0
9000682c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      u32_t amount_bytes = lwip_htonl(conn->settings.amount);
90006830:	f002 fca9 	bl	90009186 <lwip_htonl>
      if (amount_bytes >= conn->bytes_transferred) {
90006834:	6a6b      	ldr	r3, [r5, #36]	; 0x24
90006836:	4283      	cmp	r3, r0
90006838:	d9f3      	bls.n	90006822 <lwiperf_tcp_client_send_more+0x42>
    if (conn->bytes_transferred < 24) {
9000683a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
9000683c:	2a17      	cmp	r2, #23
9000683e:	d819      	bhi.n	90006874 <lwiperf_tcp_client_send_more+0x94>
      txptr = &((u8_t *)&conn->settings)[conn->bytes_transferred];
90006840:	f105 0928 	add.w	r9, r5, #40	; 0x28
      apiflags = TCP_WRITE_FLAG_COPY;
90006844:	f04f 0b01 	mov.w	fp, #1
    send_more = 0;
90006848:	f04f 0a00 	mov.w	sl, #0
      txptr = &((u8_t *)&conn->settings)[conn->bytes_transferred];
9000684c:	4491      	add	r9, r2
      txlen_max = (u16_t)(24 - conn->bytes_transferred);
9000684e:	f1c2 0218 	rsb	r2, r2, #24
90006852:	b294      	uxth	r4, r2
      err = tcp_write(conn->conn_pcb, txptr, txlen, apiflags);
90006854:	465b      	mov	r3, fp
90006856:	4622      	mov	r2, r4
90006858:	4649      	mov	r1, r9
9000685a:	6928      	ldr	r0, [r5, #16]
9000685c:	f009 fbc0 	bl	9000ffe0 <tcp_write>
      if (err ==  ERR_MEM) {
90006860:	1c43      	adds	r3, r0, #1
90006862:	d123      	bne.n	900068ac <lwiperf_tcp_client_send_more+0xcc>
        txlen /= 2;
90006864:	0864      	lsrs	r4, r4, #1
    } while ((err == ERR_MEM) && (txlen >= (TCP_MSS / 2)));
90006866:	f5b4 7f86 	cmp.w	r4, #268	; 0x10c
9000686a:	d0f3      	beq.n	90006854 <lwiperf_tcp_client_send_more+0x74>
  tcp_output(conn->conn_pcb);
9000686c:	6928      	ldr	r0, [r5, #16]
9000686e:	f00a f915 	bl	90010a9c <tcp_output>
  return ERR_OK;
90006872:	e7da      	b.n	9000682a <lwiperf_tcp_client_send_more+0x4a>
    } else if (conn->bytes_transferred < 48) {
90006874:	2a2f      	cmp	r2, #47	; 0x2f
90006876:	d80b      	bhi.n	90006890 <lwiperf_tcp_client_send_more+0xb0>
      txptr = &((u8_t *)&conn->settings)[conn->bytes_transferred - 24];
90006878:	eb05 0902 	add.w	r9, r5, r2
      txlen_max = (u16_t)(48 - conn->bytes_transferred);
9000687c:	f1c2 0230 	rsb	r2, r2, #48	; 0x30
      apiflags = TCP_WRITE_FLAG_COPY | TCP_WRITE_FLAG_MORE;
90006880:	f04f 0b03 	mov.w	fp, #3
      txptr = &((u8_t *)&conn->settings)[conn->bytes_transferred - 24];
90006884:	f109 0910 	add.w	r9, r9, #16
      txlen_max = (u16_t)(48 - conn->bytes_transferred);
90006888:	b294      	uxth	r4, r2
      apiflags = 0; /* no copying needed */
9000688a:	f04f 0a01 	mov.w	sl, #1
    txlen = txlen_max;
9000688e:	e7e1      	b.n	90006854 <lwiperf_tcp_client_send_more+0x74>
      txptr = LWIP_CONST_CAST(void *, &lwiperf_txbuf_const[conn->bytes_transferred % 10]);
90006890:	fbb2 f9f6 	udiv	r9, r2, r6
      apiflags = 0; /* no copying needed */
90006894:	2a30      	cmp	r2, #48	; 0x30
      txptr = LWIP_CONST_CAST(void *, &lwiperf_txbuf_const[conn->bytes_transferred % 10]);
90006896:	fb06 2919 	mls	r9, r6, r9, r2
      apiflags = 0; /* no copying needed */
9000689a:	f04f 0b00 	mov.w	fp, #0
      txptr = LWIP_CONST_CAST(void *, &lwiperf_txbuf_const[conn->bytes_transferred % 10]);
9000689e:	44c1      	add	r9, r8
      apiflags = 0; /* no copying needed */
900068a0:	bf14      	ite	ne
900068a2:	f44f 7406 	movne.w	r4, #536	; 0x218
900068a6:	f44f 7400 	moveq.w	r4, #512	; 0x200
900068aa:	e7ee      	b.n	9000688a <lwiperf_tcp_client_send_more+0xaa>
    if (err == ERR_OK) {
900068ac:	2800      	cmp	r0, #0
900068ae:	d1dd      	bne.n	9000686c <lwiperf_tcp_client_send_more+0x8c>
      conn->bytes_transferred += txlen;
900068b0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
900068b2:	4422      	add	r2, r4
900068b4:	626a      	str	r2, [r5, #36]	; 0x24
  } while (send_more);
900068b6:	f1ba 0f00 	cmp.w	sl, #0
900068ba:	d1a5      	bne.n	90006808 <lwiperf_tcp_client_send_more+0x28>
900068bc:	e7d6      	b.n	9000686c <lwiperf_tcp_client_send_more+0x8c>
900068be:	bf00      	nop
900068c0:	90012b71 	.word	0x90012b71
900068c4:	90012c41 	.word	0x90012c41
900068c8:	90012aff 	.word	0x90012aff
900068cc:	90012cb4 	.word	0x90012cb4

900068d0 <lwiperf_tcp_client_sent>:
  LWIP_ASSERT("invalid conn", conn->conn_pcb == tpcb);
900068d0:	6903      	ldr	r3, [r0, #16]
900068d2:	428b      	cmp	r3, r1
{
900068d4:	b510      	push	{r4, lr}
900068d6:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid conn", conn->conn_pcb == tpcb);
900068d8:	d006      	beq.n	900068e8 <lwiperf_tcp_client_sent+0x18>
900068da:	4b07      	ldr	r3, [pc, #28]	; (900068f8 <lwiperf_tcp_client_sent+0x28>)
900068dc:	f44f 72b3 	mov.w	r2, #358	; 0x166
900068e0:	4906      	ldr	r1, [pc, #24]	; (900068fc <lwiperf_tcp_client_sent+0x2c>)
900068e2:	4807      	ldr	r0, [pc, #28]	; (90006900 <lwiperf_tcp_client_sent+0x30>)
900068e4:	f00b f962 	bl	90011bac <iprintf>
  conn->poll_count = 0;
900068e8:	2300      	movs	r3, #0
  return lwiperf_tcp_client_send_more(conn);
900068ea:	4620      	mov	r0, r4
  conn->poll_count = 0;
900068ec:	f884 3020 	strb.w	r3, [r4, #32]
}
900068f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return lwiperf_tcp_client_send_more(conn);
900068f4:	f7ff bf74 	b.w	900067e0 <lwiperf_tcp_client_send_more>
900068f8:	90012b71 	.word	0x90012b71
900068fc:	90012c4e 	.word	0x90012c4e
90006900:	90012aff 	.word	0x90012aff

90006904 <lwiperf_tcp_poll>:
  LWIP_ASSERT("pcb mismatch", conn->conn_pcb == tpcb);
90006904:	6903      	ldr	r3, [r0, #16]
90006906:	428b      	cmp	r3, r1
{
90006908:	b510      	push	{r4, lr}
9000690a:	4604      	mov	r4, r0
  LWIP_ASSERT("pcb mismatch", conn->conn_pcb == tpcb);
9000690c:	d006      	beq.n	9000691c <lwiperf_tcp_poll+0x18>
9000690e:	4b0e      	ldr	r3, [pc, #56]	; (90006948 <lwiperf_tcp_poll+0x44>)
90006910:	f44f 7210 	mov.w	r2, #576	; 0x240
90006914:	490d      	ldr	r1, [pc, #52]	; (9000694c <lwiperf_tcp_poll+0x48>)
90006916:	480e      	ldr	r0, [pc, #56]	; (90006950 <lwiperf_tcp_poll+0x4c>)
90006918:	f00b f948 	bl	90011bac <iprintf>
  if (++conn->poll_count >= LWIPERF_TCP_MAX_IDLE_SEC) {
9000691c:	f894 3020 	ldrb.w	r3, [r4, #32]
90006920:	3301      	adds	r3, #1
90006922:	b2db      	uxtb	r3, r3
90006924:	2b09      	cmp	r3, #9
90006926:	f884 3020 	strb.w	r3, [r4, #32]
9000692a:	d905      	bls.n	90006938 <lwiperf_tcp_poll+0x34>
    lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL);
9000692c:	2102      	movs	r1, #2
9000692e:	4620      	mov	r0, r4
90006930:	f7ff fe3a 	bl	900065a8 <lwiperf_tcp_close>
}
90006934:	2000      	movs	r0, #0
90006936:	bd10      	pop	{r4, pc}
  if (!conn->base.server) {
90006938:	7963      	ldrb	r3, [r4, #5]
9000693a:	2b00      	cmp	r3, #0
9000693c:	d1fa      	bne.n	90006934 <lwiperf_tcp_poll+0x30>
    lwiperf_tcp_client_send_more(conn);
9000693e:	4620      	mov	r0, r4
90006940:	f7ff ff4e 	bl	900067e0 <lwiperf_tcp_client_send_more>
90006944:	e7f6      	b.n	90006934 <lwiperf_tcp_poll+0x30>
90006946:	bf00      	nop
90006948:	90012b71 	.word	0x90012b71
9000694c:	90012c5b 	.word	0x90012c5b
90006950:	90012aff 	.word	0x90012aff

90006954 <lwiperf_tcp_client_connected>:
{
90006954:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("invalid conn", conn->conn_pcb == tpcb);
90006956:	6903      	ldr	r3, [r0, #16]
{
90006958:	4604      	mov	r4, r0
9000695a:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid conn", conn->conn_pcb == tpcb);
9000695c:	428b      	cmp	r3, r1
9000695e:	d006      	beq.n	9000696e <lwiperf_tcp_client_connected+0x1a>
90006960:	4b0b      	ldr	r3, [pc, #44]	; (90006990 <lwiperf_tcp_client_connected+0x3c>)
90006962:	f44f 72ba 	mov.w	r2, #372	; 0x174
90006966:	490b      	ldr	r1, [pc, #44]	; (90006994 <lwiperf_tcp_client_connected+0x40>)
90006968:	480b      	ldr	r0, [pc, #44]	; (90006998 <lwiperf_tcp_client_connected+0x44>)
9000696a:	f00b f91f 	bl	90011bac <iprintf>
  if (err != ERR_OK) {
9000696e:	b94d      	cbnz	r5, 90006984 <lwiperf_tcp_client_connected+0x30>
  conn->poll_count = 0;
90006970:	f884 5020 	strb.w	r5, [r4, #32]
  conn->time_started = sys_now();
90006974:	f7fa fc7c 	bl	90001270 <sys_now>
90006978:	6160      	str	r0, [r4, #20]
  return lwiperf_tcp_client_send_more(conn);
9000697a:	4620      	mov	r0, r4
}
9000697c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return lwiperf_tcp_client_send_more(conn);
90006980:	f7ff bf2e 	b.w	900067e0 <lwiperf_tcp_client_send_more>
    lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_REMOTE);
90006984:	4620      	mov	r0, r4
90006986:	2105      	movs	r1, #5
90006988:	f7ff fe0e 	bl	900065a8 <lwiperf_tcp_close>
}
9000698c:	2000      	movs	r0, #0
9000698e:	bd38      	pop	{r3, r4, r5, pc}
90006990:	90012b71 	.word	0x90012b71
90006994:	90012c4e 	.word	0x90012c4e
90006998:	90012aff 	.word	0x90012aff

9000699c <lwiperf_start_tcp_server_impl.constprop.0>:
    return state;
  }
  return NULL;
}

static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t local_port,
9000699c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900069a0:	460f      	mov	r7, r1
900069a2:	4690      	mov	r8, r2
900069a4:	461e      	mov	r6, r3

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("state != NULL", state != NULL);

  if (local_addr == NULL) {
900069a6:	4605      	mov	r5, r0
900069a8:	2800      	cmp	r0, #0
900069aa:	d03c      	beq.n	90006a26 <lwiperf_start_tcp_server_impl.constprop.0+0x8a>
    return ERR_ARG;
  }

  s = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
900069ac:	2048      	movs	r0, #72	; 0x48
900069ae:	f005 fc0b 	bl	9000c1c8 <mem_malloc>
  if (s == NULL) {
900069b2:	4604      	mov	r4, r0
900069b4:	b920      	cbnz	r0, 900069c0 <lwiperf_start_tcp_server_impl.constprop.0+0x24>
  if (s->server_pcb == NULL) {
    if (pcb != NULL) {
      tcp_close(pcb);
    }
    LWIPERF_FREE(lwiperf_state_tcp_t, s);
    return ERR_MEM;
900069b6:	f04f 35ff 	mov.w	r5, #4294967295
  tcp_accept(s->server_pcb, lwiperf_tcp_accept);

  lwiperf_list_add(&s->base);
  *state = s;
  return ERR_OK;
}
900069ba:	4628      	mov	r0, r5
900069bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  memset(s, 0, sizeof(lwiperf_state_tcp_t));
900069c0:	2248      	movs	r2, #72	; 0x48
900069c2:	2100      	movs	r1, #0
900069c4:	f00b f80a 	bl	900119dc <memset>
  s->base.tcp = 1;
900069c8:	f240 1301 	movw	r3, #257	; 0x101
  pcb = tcp_new_ip_type(LWIPERF_SERVER_IP_TYPE);
900069cc:	202e      	movs	r0, #46	; 0x2e
  s->base.tcp = 1;
900069ce:	80a3      	strh	r3, [r4, #4]
  s->base.related_master_state = related_master_state;
900069d0:	9b06      	ldr	r3, [sp, #24]
  s->report_arg = report_arg;
900069d2:	e9c4 8606 	strd	r8, r6, [r4, #24]
  s->base.related_master_state = related_master_state;
900069d6:	60a3      	str	r3, [r4, #8]
  pcb = tcp_new_ip_type(LWIPERF_SERVER_IP_TYPE);
900069d8:	f007 fae2 	bl	9000dfa0 <tcp_new_ip_type>
  if (pcb == NULL) {
900069dc:	4606      	mov	r6, r0
900069de:	2800      	cmp	r0, #0
900069e0:	d0e9      	beq.n	900069b6 <lwiperf_start_tcp_server_impl.constprop.0+0x1a>
  err = tcp_bind(pcb, local_addr, local_port);
900069e2:	4629      	mov	r1, r5
900069e4:	463a      	mov	r2, r7
900069e6:	f006 fdef 	bl	9000d5c8 <tcp_bind>
  if (err != ERR_OK) {
900069ea:	4605      	mov	r5, r0
900069ec:	2800      	cmp	r0, #0
900069ee:	d1e4      	bne.n	900069ba <lwiperf_start_tcp_server_impl.constprop.0+0x1e>
  s->server_pcb = tcp_listen_with_backlog(pcb, 1);
900069f0:	2101      	movs	r1, #1
900069f2:	4630      	mov	r0, r6
900069f4:	f006 fea4 	bl	9000d740 <tcp_listen_with_backlog>
900069f8:	60e0      	str	r0, [r4, #12]
  if (s->server_pcb == NULL) {
900069fa:	b930      	cbnz	r0, 90006a0a <lwiperf_start_tcp_server_impl.constprop.0+0x6e>
      tcp_close(pcb);
900069fc:	4630      	mov	r0, r6
900069fe:	f007 fb85 	bl	9000e10c <tcp_close>
    LWIPERF_FREE(lwiperf_state_tcp_t, s);
90006a02:	4620      	mov	r0, r4
90006a04:	f005 fa4e 	bl	9000bea4 <mem_free>
90006a08:	e7d5      	b.n	900069b6 <lwiperf_start_tcp_server_impl.constprop.0+0x1a>
  tcp_arg(s->server_pcb, s);
90006a0a:	4621      	mov	r1, r4
90006a0c:	f006 ff4a 	bl	9000d8a4 <tcp_arg>
  tcp_accept(s->server_pcb, lwiperf_tcp_accept);
90006a10:	4906      	ldr	r1, [pc, #24]	; (90006a2c <lwiperf_start_tcp_server_impl.constprop.0+0x90>)
90006a12:	68e0      	ldr	r0, [r4, #12]
90006a14:	f006 ff92 	bl	9000d93c <tcp_accept>
  item->next = lwiperf_all_connections;
90006a18:	4b05      	ldr	r3, [pc, #20]	; (90006a30 <lwiperf_start_tcp_server_impl.constprop.0+0x94>)
90006a1a:	681a      	ldr	r2, [r3, #0]
  lwiperf_all_connections = item;
90006a1c:	601c      	str	r4, [r3, #0]
  *state = s;
90006a1e:	9b07      	ldr	r3, [sp, #28]
  item->next = lwiperf_all_connections;
90006a20:	6022      	str	r2, [r4, #0]
  *state = s;
90006a22:	601c      	str	r4, [r3, #0]
  return ERR_OK;
90006a24:	e7c9      	b.n	900069ba <lwiperf_start_tcp_server_impl.constprop.0+0x1e>
    return ERR_ARG;
90006a26:	f06f 050f 	mvn.w	r5, #15
90006a2a:	e7c6      	b.n	900069ba <lwiperf_start_tcp_server_impl.constprop.0+0x1e>
90006a2c:	900066a1 	.word	0x900066a1
90006a30:	24004dd4 	.word	0x24004dd4

90006a34 <lwiperf_tx_start_impl>:
{
90006a34:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90006a38:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
90006a3c:	468a      	mov	sl, r1
90006a3e:	4617      	mov	r7, r2
90006a40:	469b      	mov	fp, r3
  LWIP_ASSERT("remote_ip != NULL", remote_ip != NULL);
90006a42:	4681      	mov	r9, r0
90006a44:	b930      	cbnz	r0, 90006a54 <lwiperf_tx_start_impl+0x20>
90006a46:	4b33      	ldr	r3, [pc, #204]	; (90006b14 <lwiperf_tx_start_impl+0xe0>)
90006a48:	f240 128b 	movw	r2, #395	; 0x18b
90006a4c:	4932      	ldr	r1, [pc, #200]	; (90006b18 <lwiperf_tx_start_impl+0xe4>)
90006a4e:	4833      	ldr	r0, [pc, #204]	; (90006b1c <lwiperf_tx_start_impl+0xe8>)
90006a50:	f00b f8ac 	bl	90011bac <iprintf>
  *new_conn = NULL;
90006a54:	2600      	movs	r6, #0
  client_conn = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
90006a56:	2048      	movs	r0, #72	; 0x48
  *new_conn = NULL;
90006a58:	f8c8 6000 	str.w	r6, [r8]
  client_conn = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
90006a5c:	f005 fbb4 	bl	9000c1c8 <mem_malloc>
  if (client_conn == NULL) {
90006a60:	4604      	mov	r4, r0
90006a62:	b138      	cbz	r0, 90006a74 <lwiperf_tx_start_impl+0x40>
  newpcb = tcp_new_ip_type(IP_GET_TYPE(remote_ip));
90006a64:	4630      	mov	r0, r6
90006a66:	f007 fa9b 	bl	9000dfa0 <tcp_new_ip_type>
  if (newpcb == NULL) {
90006a6a:	4605      	mov	r5, r0
90006a6c:	b928      	cbnz	r0, 90006a7a <lwiperf_tx_start_impl+0x46>
    LWIPERF_FREE(lwiperf_state_tcp_t, client_conn);
90006a6e:	4620      	mov	r0, r4
90006a70:	f005 fa18 	bl	9000bea4 <mem_free>
    return ERR_MEM;
90006a74:	f04f 35ff 	mov.w	r5, #4294967295
90006a78:	e041      	b.n	90006afe <lwiperf_tx_start_impl+0xca>
  memset(client_conn, 0, sizeof(lwiperf_state_tcp_t));
90006a7a:	2248      	movs	r2, #72	; 0x48
90006a7c:	4631      	mov	r1, r6
90006a7e:	4620      	mov	r0, r4
90006a80:	f00a ffac 	bl	900119dc <memset>
  client_conn->base.tcp = 1;
90006a84:	2301      	movs	r3, #1
  client_conn->conn_pcb = newpcb;
90006a86:	6125      	str	r5, [r4, #16]
  client_conn->base.tcp = 1;
90006a88:	7123      	strb	r3, [r4, #4]
  client_conn->base.related_master_state = related_master_state;
90006a8a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
90006a8c:	60a3      	str	r3, [r4, #8]
  client_conn->time_started = sys_now(); /* @todo: set this again on 'connected' */
90006a8e:	f7fa fbef 	bl	90001270 <sys_now>
  client_conn->report_arg = report_arg;
90006a92:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  memcpy(&client_conn->settings, settings, sizeof(*settings));
90006a94:	f104 0228 	add.w	r2, r4, #40	; 0x28
90006a98:	f107 0118 	add.w	r1, r7, #24
  client_conn->report_arg = report_arg;
90006a9c:	61e3      	str	r3, [r4, #28]
  client_conn->next_num = 4; /* initial nr is '4' since the header has 24 byte */
90006a9e:	2304      	movs	r3, #4
  client_conn->bytes_transferred = 0;
90006aa0:	6266      	str	r6, [r4, #36]	; 0x24
  client_conn->next_num = 4; /* initial nr is '4' since the header has 24 byte */
90006aa2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  memcpy(&client_conn->settings, settings, sizeof(*settings));
90006aa6:	463b      	mov	r3, r7
  client_conn->report_fn = report_fn;
90006aa8:	e9c4 0b05 	strd	r0, fp, [r4, #20]
  memcpy(&client_conn->settings, settings, sizeof(*settings));
90006aac:	f853 0b04 	ldr.w	r0, [r3], #4
90006ab0:	428b      	cmp	r3, r1
90006ab2:	f842 0b04 	str.w	r0, [r2], #4
90006ab6:	d1f9      	bne.n	90006aac <lwiperf_tx_start_impl+0x78>
  client_conn->have_settings_buf = 1;
90006ab8:	2301      	movs	r3, #1
  tcp_arg(newpcb, client_conn);
90006aba:	4628      	mov	r0, r5
90006abc:	4621      	mov	r1, r4
  client_conn->have_settings_buf = 1;
90006abe:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  tcp_arg(newpcb, client_conn);
90006ac2:	f006 feef 	bl	9000d8a4 <tcp_arg>
  tcp_sent(newpcb, lwiperf_tcp_client_sent);
90006ac6:	4628      	mov	r0, r5
90006ac8:	4915      	ldr	r1, [pc, #84]	; (90006b20 <lwiperf_tx_start_impl+0xec>)
90006aca:	f006 ff07 	bl	9000d8dc <tcp_sent>
  tcp_poll(newpcb, lwiperf_tcp_poll, 2U);
90006ace:	2202      	movs	r2, #2
90006ad0:	4628      	mov	r0, r5
90006ad2:	4914      	ldr	r1, [pc, #80]	; (90006b24 <lwiperf_tx_start_impl+0xf0>)
90006ad4:	f006 ff38 	bl	9000d948 <tcp_poll>
  tcp_err(newpcb, lwiperf_tcp_err);
90006ad8:	4628      	mov	r0, r5
90006ada:	4913      	ldr	r1, [pc, #76]	; (90006b28 <lwiperf_tx_start_impl+0xf4>)
90006adc:	f006 ff16 	bl	9000d90c <tcp_err>
  ip_addr_copy(remote_addr, *remote_ip);
90006ae0:	f8d9 3000 	ldr.w	r3, [r9]
  err = tcp_connect(newpcb, &remote_addr, remote_port, lwiperf_tcp_client_connected);
90006ae4:	4628      	mov	r0, r5
90006ae6:	4652      	mov	r2, sl
  ip_addr_copy(remote_addr, *remote_ip);
90006ae8:	9301      	str	r3, [sp, #4]
  err = tcp_connect(newpcb, &remote_addr, remote_port, lwiperf_tcp_client_connected);
90006aea:	a901      	add	r1, sp, #4
90006aec:	4b0f      	ldr	r3, [pc, #60]	; (90006b2c <lwiperf_tx_start_impl+0xf8>)
90006aee:	f006 ff87 	bl	9000da00 <tcp_connect>
  if (err != ERR_OK) {
90006af2:	4605      	mov	r5, r0
90006af4:	b138      	cbz	r0, 90006b06 <lwiperf_tx_start_impl+0xd2>
    lwiperf_tcp_close(client_conn, LWIPERF_TCP_ABORTED_LOCAL);
90006af6:	2102      	movs	r1, #2
90006af8:	4620      	mov	r0, r4
90006afa:	f7ff fd55 	bl	900065a8 <lwiperf_tcp_close>
}
90006afe:	4628      	mov	r0, r5
90006b00:	b003      	add	sp, #12
90006b02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  item->next = lwiperf_all_connections;
90006b06:	4b0a      	ldr	r3, [pc, #40]	; (90006b30 <lwiperf_tx_start_impl+0xfc>)
90006b08:	681a      	ldr	r2, [r3, #0]
  lwiperf_all_connections = item;
90006b0a:	601c      	str	r4, [r3, #0]
  item->next = lwiperf_all_connections;
90006b0c:	6022      	str	r2, [r4, #0]
  *new_conn = client_conn;
90006b0e:	f8c8 4000 	str.w	r4, [r8]
  return ERR_OK;
90006b12:	e7f4      	b.n	90006afe <lwiperf_tx_start_impl+0xca>
90006b14:	90012b71 	.word	0x90012b71
90006b18:	90012c68 	.word	0x90012c68
90006b1c:	90012aff 	.word	0x90012aff
90006b20:	900068d1 	.word	0x900068d1
90006b24:	90006905 	.word	0x90006905
90006b28:	900067d9 	.word	0x900067d9
90006b2c:	90006955 	.word	0x90006955
90006b30:	24004dd4 	.word	0x24004dd4

90006b34 <lwiperf_tx_start_passive>:
{
90006b34:	b530      	push	{r4, r5, lr}
  lwiperf_state_tcp_t *new_conn = NULL;
90006b36:	2300      	movs	r3, #0
{
90006b38:	b087      	sub	sp, #28
90006b3a:	4604      	mov	r4, r0
  u16_t remote_port = (u16_t)lwip_htonl(conn->settings.remote_port);
90006b3c:	6b00      	ldr	r0, [r0, #48]	; 0x30
  lwiperf_state_tcp_t *new_conn = NULL;
90006b3e:	9305      	str	r3, [sp, #20]
  u16_t remote_port = (u16_t)lwip_htonl(conn->settings.remote_port);
90006b40:	f002 fb21 	bl	90009186 <lwip_htonl>
  ret = lwiperf_tx_start_impl(&conn->conn_pcb->remote_ip, remote_port, &conn->settings, conn->report_fn, conn->report_arg,
90006b44:	ab05      	add	r3, sp, #20
90006b46:	6925      	ldr	r5, [r4, #16]
90006b48:	f104 0228 	add.w	r2, r4, #40	; 0x28
90006b4c:	b281      	uxth	r1, r0
90006b4e:	9302      	str	r3, [sp, #8]
90006b50:	1d28      	adds	r0, r5, #4
90006b52:	68a3      	ldr	r3, [r4, #8]
90006b54:	9301      	str	r3, [sp, #4]
90006b56:	69e3      	ldr	r3, [r4, #28]
90006b58:	9300      	str	r3, [sp, #0]
90006b5a:	69a3      	ldr	r3, [r4, #24]
90006b5c:	f7ff ff6a 	bl	90006a34 <lwiperf_tx_start_impl>
  if (ret == ERR_OK) {
90006b60:	4604      	mov	r4, r0
90006b62:	b958      	cbnz	r0, 90006b7c <lwiperf_tx_start_passive+0x48>
    LWIP_ASSERT("new_conn != NULL", new_conn != NULL);
90006b64:	9b05      	ldr	r3, [sp, #20]
90006b66:	b933      	cbnz	r3, 90006b76 <lwiperf_tx_start_passive+0x42>
90006b68:	4b06      	ldr	r3, [pc, #24]	; (90006b84 <lwiperf_tx_start_passive+0x50>)
90006b6a:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
90006b6e:	4906      	ldr	r1, [pc, #24]	; (90006b88 <lwiperf_tx_start_passive+0x54>)
90006b70:	4806      	ldr	r0, [pc, #24]	; (90006b8c <lwiperf_tx_start_passive+0x58>)
90006b72:	f00b f81b 	bl	90011bac <iprintf>
    new_conn->settings.flags = 0; /* prevent the remote side starting back as client again */
90006b76:	9b05      	ldr	r3, [sp, #20]
90006b78:	2200      	movs	r2, #0
90006b7a:	629a      	str	r2, [r3, #40]	; 0x28
}
90006b7c:	4620      	mov	r0, r4
90006b7e:	b007      	add	sp, #28
90006b80:	bd30      	pop	{r4, r5, pc}
90006b82:	bf00      	nop
90006b84:	90012b71 	.word	0x90012b71
90006b88:	90012c7a 	.word	0x90012c7a
90006b8c:	90012aff 	.word	0x90012aff

90006b90 <lwiperf_tcp_recv>:
{
90006b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90006b94:	461e      	mov	r6, r3
  LWIP_ASSERT("pcb mismatch", conn->conn_pcb == tpcb);
90006b96:	6903      	ldr	r3, [r0, #16]
{
90006b98:	4604      	mov	r4, r0
90006b9a:	460f      	mov	r7, r1
  LWIP_ASSERT("pcb mismatch", conn->conn_pcb == tpcb);
90006b9c:	428b      	cmp	r3, r1
{
90006b9e:	4615      	mov	r5, r2
  LWIP_ASSERT("pcb mismatch", conn->conn_pcb == tpcb);
90006ba0:	d006      	beq.n	90006bb0 <lwiperf_tcp_recv+0x20>
90006ba2:	4b46      	ldr	r3, [pc, #280]	; (90006cbc <lwiperf_tcp_recv+0x12c>)
90006ba4:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
90006ba8:	4945      	ldr	r1, [pc, #276]	; (90006cc0 <lwiperf_tcp_recv+0x130>)
90006baa:	4846      	ldr	r0, [pc, #280]	; (90006cc4 <lwiperf_tcp_recv+0x134>)
90006bac:	f00a fffe 	bl	90011bac <iprintf>
  if (err != ERR_OK) {
90006bb0:	b136      	cbz	r6, 90006bc0 <lwiperf_tcp_recv+0x30>
    lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_REMOTE);
90006bb2:	2105      	movs	r1, #5
    lwiperf_tcp_close(conn, LWIPERF_TCP_DONE_SERVER);
90006bb4:	4620      	mov	r0, r4
90006bb6:	f7ff fcf7 	bl	900065a8 <lwiperf_tcp_close>
}
90006bba:	2000      	movs	r0, #0
90006bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (p == NULL) {
90006bc0:	b94d      	cbnz	r5, 90006bd6 <lwiperf_tcp_recv+0x46>
    if (conn->settings.flags & PP_HTONL(LWIPERF_FLAGS_ANSWER_TEST)) {
90006bc2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90006bc4:	0619      	lsls	r1, r3, #24
90006bc6:	d504      	bpl.n	90006bd2 <lwiperf_tcp_recv+0x42>
      if ((conn->settings.flags & PP_HTONL(LWIPERF_FLAGS_ANSWER_NOW)) == 0) {
90006bc8:	01da      	lsls	r2, r3, #7
90006bca:	d402      	bmi.n	90006bd2 <lwiperf_tcp_recv+0x42>
        lwiperf_tx_start_passive(conn);
90006bcc:	4620      	mov	r0, r4
90006bce:	f7ff ffb1 	bl	90006b34 <lwiperf_tx_start_passive>
    lwiperf_tcp_close(conn, LWIPERF_TCP_DONE_SERVER);
90006bd2:	2100      	movs	r1, #0
90006bd4:	e7ee      	b.n	90006bb4 <lwiperf_tcp_recv+0x24>
  if ((!conn->have_settings_buf) || ((conn->bytes_transferred - 24) % (1024 * 128) == 0)) {
90006bd6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
  tot_len = p->tot_len;
90006bda:	f8b5 8008 	ldrh.w	r8, [r5, #8]
  conn->poll_count = 0;
90006bde:	f884 6020 	strb.w	r6, [r4, #32]
  if ((!conn->have_settings_buf) || ((conn->bytes_transferred - 24) % (1024 * 128) == 0)) {
90006be2:	2b00      	cmp	r3, #0
90006be4:	d05b      	beq.n	90006c9e <lwiperf_tcp_recv+0x10e>
90006be6:	6a63      	ldr	r3, [r4, #36]	; 0x24
90006be8:	03db      	lsls	r3, r3, #15
90006bea:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
90006bee:	d04b      	beq.n	90006c88 <lwiperf_tcp_recv+0xf8>
{
90006bf0:	462b      	mov	r3, r5
  packet_idx = 0;
90006bf2:	2600      	movs	r6, #0
    packet_idx += q->len;
90006bf4:	895a      	ldrh	r2, [r3, #10]
  for (q = p; q != NULL; q = q->next) {
90006bf6:	681b      	ldr	r3, [r3, #0]
    packet_idx += q->len;
90006bf8:	4416      	add	r6, r2
  for (q = p; q != NULL; q = q->next) {
90006bfa:	2b00      	cmp	r3, #0
90006bfc:	d1fa      	bne.n	90006bf4 <lwiperf_tcp_recv+0x64>
  LWIP_ASSERT("count mismatch", packet_idx == p->tot_len);
90006bfe:	892b      	ldrh	r3, [r5, #8]
90006c00:	42b3      	cmp	r3, r6
90006c02:	d006      	beq.n	90006c12 <lwiperf_tcp_recv+0x82>
90006c04:	4b2d      	ldr	r3, [pc, #180]	; (90006cbc <lwiperf_tcp_recv+0x12c>)
90006c06:	f240 222b 	movw	r2, #555	; 0x22b
90006c0a:	492f      	ldr	r1, [pc, #188]	; (90006cc8 <lwiperf_tcp_recv+0x138>)
90006c0c:	482d      	ldr	r0, [pc, #180]	; (90006cc4 <lwiperf_tcp_recv+0x134>)
90006c0e:	f00a ffcd 	bl	90011bac <iprintf>
  conn->bytes_transferred += packet_idx;
90006c12:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tcp_recved(tpcb, tot_len);
90006c14:	4641      	mov	r1, r8
  conn->bytes_transferred += packet_idx;
90006c16:	4433      	add	r3, r6
90006c18:	6263      	str	r3, [r4, #36]	; 0x24
  tcp_recved(tpcb, tot_len);
90006c1a:	e020      	b.n	90006c5e <lwiperf_tcp_recv+0xce>
      conn->have_settings_buf = 1;
90006c1c:	2301      	movs	r3, #1
        if (conn->settings.flags & PP_HTONL(LWIPERF_FLAGS_ANSWER_NOW)) {
90006c1e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      conn->have_settings_buf = 1;
90006c20:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        if (conn->settings.flags & PP_HTONL(LWIPERF_FLAGS_ANSWER_NOW)) {
90006c24:	4b29      	ldr	r3, [pc, #164]	; (90006ccc <lwiperf_tcp_recv+0x13c>)
90006c26:	4393      	bics	r3, r2
90006c28:	d110      	bne.n	90006c4c <lwiperf_tcp_recv+0xbc>
          err_t err2 = lwiperf_tx_start_passive(conn);
90006c2a:	4620      	mov	r0, r4
90006c2c:	f7ff ff82 	bl	90006b34 <lwiperf_tx_start_passive>
          if (err2 != ERR_OK) {
90006c30:	b160      	cbz	r0, 90006c4c <lwiperf_tcp_recv+0xbc>
            lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL_TXERROR);
90006c32:	2104      	movs	r1, #4
90006c34:	e02c      	b.n	90006c90 <lwiperf_tcp_recv+0x100>
      if (conn->settings.flags & PP_HTONL(LWIPERF_FLAGS_ANSWER_TEST)) {
90006c36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90006c38:	061b      	lsls	r3, r3, #24
90006c3a:	d507      	bpl.n	90006c4c <lwiperf_tcp_recv+0xbc>
        if (pbuf_memcmp(p, 0, &conn->settings, sizeof(lwiperf_settings_t)) != 0) {
90006c3c:	2318      	movs	r3, #24
90006c3e:	f104 0228 	add.w	r2, r4, #40	; 0x28
90006c42:	4631      	mov	r1, r6
90006c44:	4628      	mov	r0, r5
90006c46:	f006 fb8d 	bl	9000d364 <pbuf_memcmp>
90006c4a:	bb00      	cbnz	r0, 90006c8e <lwiperf_tcp_recv+0xfe>
    conn->bytes_transferred += sizeof(lwiperf_settings_t);
90006c4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
90006c4e:	3318      	adds	r3, #24
    if (conn->bytes_transferred <= 24) {
90006c50:	2b18      	cmp	r3, #24
    conn->bytes_transferred += sizeof(lwiperf_settings_t);
90006c52:	6263      	str	r3, [r4, #36]	; 0x24
    if (conn->bytes_transferred <= 24) {
90006c54:	d807      	bhi.n	90006c66 <lwiperf_tcp_recv+0xd6>
      conn->time_started = sys_now();
90006c56:	f7fa fb0b 	bl	90001270 <sys_now>
      tcp_recved(tpcb, p->tot_len);
90006c5a:	8929      	ldrh	r1, [r5, #8]
      conn->time_started = sys_now();
90006c5c:	6160      	str	r0, [r4, #20]
  tcp_recved(tpcb, tot_len);
90006c5e:	4638      	mov	r0, r7
90006c60:	f006 fda8 	bl	9000d7b4 <tcp_recved>
90006c64:	e017      	b.n	90006c96 <lwiperf_tcp_recv+0x106>
    conn->next_num = 4; /* 24 bytes received... */
90006c66:	2304      	movs	r3, #4
    tmp = pbuf_remove_header(p, 24);
90006c68:	2118      	movs	r1, #24
90006c6a:	4628      	mov	r0, r5
    conn->next_num = 4; /* 24 bytes received... */
90006c6c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    tmp = pbuf_remove_header(p, 24);
90006c70:	f005 ffe2 	bl	9000cc38 <pbuf_remove_header>
    LWIP_ASSERT("pbuf_remove_header failed", tmp == 0);
90006c74:	2800      	cmp	r0, #0
90006c76:	d0bb      	beq.n	90006bf0 <lwiperf_tcp_recv+0x60>
90006c78:	4b10      	ldr	r3, [pc, #64]	; (90006cbc <lwiperf_tcp_recv+0x12c>)
90006c7a:	f240 2211 	movw	r2, #529	; 0x211
90006c7e:	4914      	ldr	r1, [pc, #80]	; (90006cd0 <lwiperf_tcp_recv+0x140>)
90006c80:	4810      	ldr	r0, [pc, #64]	; (90006cc4 <lwiperf_tcp_recv+0x134>)
90006c82:	f00a ff93 	bl	90011bac <iprintf>
90006c86:	e7b3      	b.n	90006bf0 <lwiperf_tcp_recv+0x60>
    if (p->tot_len < sizeof(lwiperf_settings_t)) {
90006c88:	f1b8 0f17 	cmp.w	r8, #23
90006c8c:	d8d3      	bhi.n	90006c36 <lwiperf_tcp_recv+0xa6>
      lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL_DATAERROR);
90006c8e:	2103      	movs	r1, #3
            lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL_TXERROR);
90006c90:	4620      	mov	r0, r4
90006c92:	f7ff fc89 	bl	900065a8 <lwiperf_tcp_close>
  pbuf_free(p);
90006c96:	4628      	mov	r0, r5
90006c98:	f006 f802 	bl	9000cca0 <pbuf_free>
  return ERR_OK;
90006c9c:	e78d      	b.n	90006bba <lwiperf_tcp_recv+0x2a>
    if (p->tot_len < sizeof(lwiperf_settings_t)) {
90006c9e:	f1b8 0f17 	cmp.w	r8, #23
90006ca2:	d9f4      	bls.n	90006c8e <lwiperf_tcp_recv+0xfe>
      if (pbuf_copy_partial(p, &conn->settings, sizeof(lwiperf_settings_t), 0) != sizeof(lwiperf_settings_t)) {
90006ca4:	4633      	mov	r3, r6
90006ca6:	2218      	movs	r2, #24
90006ca8:	f104 0128 	add.w	r1, r4, #40	; 0x28
90006cac:	4628      	mov	r0, r5
90006cae:	f006 fa33 	bl	9000d118 <pbuf_copy_partial>
90006cb2:	2818      	cmp	r0, #24
90006cb4:	d0b2      	beq.n	90006c1c <lwiperf_tcp_recv+0x8c>
        lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL);
90006cb6:	2102      	movs	r1, #2
90006cb8:	e7ea      	b.n	90006c90 <lwiperf_tcp_recv+0x100>
90006cba:	bf00      	nop
90006cbc:	90012b71 	.word	0x90012b71
90006cc0:	90012c5b 	.word	0x90012c5b
90006cc4:	90012aff 	.word	0x90012aff
90006cc8:	90012ca5 	.word	0x90012ca5
90006ccc:	01000080 	.word	0x01000080
90006cd0:	90012c8b 	.word	0x90012c8b

90006cd4 <lwiperf_start_tcp_server>:
{
90006cd4:	b530      	push	{r4, r5, lr}
90006cd6:	b085      	sub	sp, #20
  lwiperf_state_tcp_t *state = NULL;
90006cd8:	2400      	movs	r4, #0
  err = lwiperf_start_tcp_server_impl(local_addr, local_port, report_fn, report_arg,
90006cda:	ad03      	add	r5, sp, #12
  lwiperf_state_tcp_t *state = NULL;
90006cdc:	9403      	str	r4, [sp, #12]
  err = lwiperf_start_tcp_server_impl(local_addr, local_port, report_fn, report_arg,
90006cde:	e9cd 4500 	strd	r4, r5, [sp]
90006ce2:	f7ff fe5b 	bl	9000699c <lwiperf_start_tcp_server_impl.constprop.0>
  if (err == ERR_OK) {
90006ce6:	b910      	cbnz	r0, 90006cee <lwiperf_start_tcp_server+0x1a>
    return state;
90006ce8:	9803      	ldr	r0, [sp, #12]
}
90006cea:	b005      	add	sp, #20
90006cec:	bd30      	pop	{r4, r5, pc}
  return NULL;
90006cee:	4620      	mov	r0, r4
90006cf0:	e7fb      	b.n	90006cea <lwiperf_start_tcp_server+0x16>
	...

90006cf4 <lwiperf_start_tcp_server_default>:
{
90006cf4:	4602      	mov	r2, r0
90006cf6:	460b      	mov	r3, r1
  return lwiperf_start_tcp_server(IP_ADDR_ANY, LWIPERF_TCP_PORT_DEFAULT,
90006cf8:	4802      	ldr	r0, [pc, #8]	; (90006d04 <lwiperf_start_tcp_server_default+0x10>)
90006cfa:	f241 3189 	movw	r1, #5001	; 0x1389
90006cfe:	f7ff bfe9 	b.w	90006cd4 <lwiperf_start_tcp_server>
90006d02:	bf00      	nop
90006d04:	90013a68 	.word	0x90013a68

90006d08 <lwiperf_report>:

static void
lwiperf_report(void *arg, enum lwiperf_report_type report_type,
  const ip_addr_t* local_addr, u16_t local_port, const ip_addr_t* remote_addr, u16_t remote_port,
  u32_t bytes_transferred, u32_t ms_duration, u32_t bandwidth_kbitpsec)
{
90006d08:	b573      	push	{r0, r1, r4, r5, r6, lr}
90006d0a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(local_addr);
  LWIP_UNUSED_ARG(local_port);

  LWIP_PLATFORM_DIAG(("IPERF report: type=%d, remote: %s:%d, total bytes: %"U32_F", duration in ms: %"U32_F", kbits/s: %"U32_F"\n",
90006d0e:	9806      	ldr	r0, [sp, #24]
{
90006d10:	9e0a      	ldr	r6, [sp, #40]	; 0x28
90006d12:	9101      	str	r1, [sp, #4]
90006d14:	9300      	str	r3, [sp, #0]
90006d16:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
  LWIP_PLATFORM_DIAG(("IPERF report: type=%d, remote: %s:%d, total bytes: %"U32_F", duration in ms: %"U32_F", kbits/s: %"U32_F"\n",
90006d1a:	f004 fca5 	bl	9000b668 <ip4addr_ntoa>
90006d1e:	4602      	mov	r2, r0
90006d20:	4805      	ldr	r0, [pc, #20]	; (90006d38 <lwiperf_report+0x30>)
90006d22:	9406      	str	r4, [sp, #24]
90006d24:	e9dd 3100 	ldrd	r3, r1, [sp]
90006d28:	e9cd 5607 	strd	r5, r6, [sp, #28]
    (int)report_type, ipaddr_ntoa(remote_addr), (int)remote_port, bytes_transferred, ms_duration, bandwidth_kbitpsec));
}
90006d2c:	b002      	add	sp, #8
90006d2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_PLATFORM_DIAG(("IPERF report: type=%d, remote: %s:%d, total bytes: %"U32_F", duration in ms: %"U32_F", kbits/s: %"U32_F"\n",
90006d32:	f00a bf3b 	b.w	90011bac <iprintf>
90006d36:	bf00      	nop
90006d38:	900132f4 	.word	0x900132f4

90006d3c <lwiperf_example_init>:
lwiperf_example_init(void)
{
//    const ip_addr_t remote_ip = {
//      .addr = inet_addr("192.168.0.198")
//    };
  lwiperf_start_tcp_server_default(lwiperf_report, NULL);
90006d3c:	2100      	movs	r1, #0
90006d3e:	4801      	ldr	r0, [pc, #4]	; (90006d44 <lwiperf_example_init+0x8>)
90006d40:	f7ff bfd8 	b.w	90006cf4 <lwiperf_start_tcp_server_default>
90006d44:	90006d09 	.word	0x90006d09

90006d48 <FATFS_LinkDriverEx>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
90006d48:	4b0e      	ldr	r3, [pc, #56]	; (90006d84 <FATFS_LinkDriverEx+0x3c>)
{
90006d4a:	b530      	push	{r4, r5, lr}
  if(disk.nbr < _VOLUMES)
90006d4c:	7a5c      	ldrb	r4, [r3, #9]
{
90006d4e:	4605      	mov	r5, r0
  if(disk.nbr < _VOLUMES)
90006d50:	f004 00ff 	and.w	r0, r4, #255	; 0xff
90006d54:	b9a4      	cbnz	r4, 90006d80 <FATFS_LinkDriverEx+0x38>
  {
    disk.is_initialized[disk.nbr] = 0;
90006d56:	7a5c      	ldrb	r4, [r3, #9]
90006d58:	5518      	strb	r0, [r3, r4]
    disk.drv[disk.nbr] = drv;
90006d5a:	7a5c      	ldrb	r4, [r3, #9]
90006d5c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
90006d60:	6065      	str	r5, [r4, #4]
    disk.lun[disk.nbr] = lun;
90006d62:	7a5c      	ldrb	r4, [r3, #9]
90006d64:	441c      	add	r4, r3
90006d66:	7222      	strb	r2, [r4, #8]
    DiskNum = disk.nbr++;
90006d68:	7a5a      	ldrb	r2, [r3, #9]
90006d6a:	1c54      	adds	r4, r2, #1
    path[0] = DiskNum + '0';
90006d6c:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
90006d6e:	b2e4      	uxtb	r4, r4
90006d70:	725c      	strb	r4, [r3, #9]
    path[1] = ':';
90006d72:	233a      	movs	r3, #58	; 0x3a
    path[0] = DiskNum + '0';
90006d74:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
90006d76:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
90006d78:	232f      	movs	r3, #47	; 0x2f
    path[3] = 0;
90006d7a:	70c8      	strb	r0, [r1, #3]
    path[2] = '/';
90006d7c:	708b      	strb	r3, [r1, #2]
    ret = 0;
  }

  return ret;
}
90006d7e:	bd30      	pop	{r4, r5, pc}
  uint8_t ret = 1;
90006d80:	2001      	movs	r0, #1
90006d82:	e7fc      	b.n	90006d7e <FATFS_LinkDriverEx+0x36>
90006d84:	24004dd8 	.word	0x24004dd8

90006d88 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
90006d88:	2200      	movs	r2, #0
90006d8a:	f7ff bfdd 	b.w	90006d48 <FATFS_LinkDriverEx>
	...

90006d90 <osKernelInitialize>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
90006d90:	f3ef 8305 	mrs	r3, IPSR
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
90006d94:	b92b      	cbnz	r3, 90006da2 <osKernelInitialize+0x12>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelInactive) {
90006d96:	4b06      	ldr	r3, [pc, #24]	; (90006db0 <osKernelInitialize+0x20>)
90006d98:	6818      	ldr	r0, [r3, #0]
90006d9a:	b928      	cbnz	r0, 90006da8 <osKernelInitialize+0x18>
        EvrFreeRTOSSetup(0U);
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
90006d9c:	2201      	movs	r2, #1
90006d9e:	601a      	str	r2, [r3, #0]
      stat = osOK;
90006da0:	4770      	bx	lr
    stat = osErrorISR;
90006da2:	f06f 0005 	mvn.w	r0, #5
90006da6:	4770      	bx	lr
    } else {
      stat = osError;
90006da8:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (stat);
}
90006dac:	4770      	bx	lr
90006dae:	bf00      	nop
90006db0:	24005040 	.word	0x24005040

90006db4 <osKernelGetState>:
  }

  return (osOK);
}

osKernelState_t osKernelGetState (void) {
90006db4:	b508      	push	{r3, lr}
  osKernelState_t state;

  switch (xTaskGetSchedulerState()) {
90006db6:	f001 ff05 	bl	90008bc4 <xTaskGetSchedulerState>
90006dba:	b138      	cbz	r0, 90006dcc <osKernelGetState+0x18>
90006dbc:	2802      	cmp	r0, #2
90006dbe:	d004      	beq.n	90006dca <osKernelGetState+0x16>
      state = osKernelLocked;
      break;

    case taskSCHEDULER_NOT_STARTED:
    default:
      if (KernelState == osKernelReady) {
90006dc0:	4b03      	ldr	r3, [pc, #12]	; (90006dd0 <osKernelGetState+0x1c>)
90006dc2:	6818      	ldr	r0, [r3, #0]
90006dc4:	1e43      	subs	r3, r0, #1
90006dc6:	4258      	negs	r0, r3
90006dc8:	4158      	adcs	r0, r3
      }
      break;
  }

  return (state);
}
90006dca:	bd08      	pop	{r3, pc}
  switch (xTaskGetSchedulerState()) {
90006dcc:	2003      	movs	r0, #3
  return (state);
90006dce:	e7fc      	b.n	90006dca <osKernelGetState+0x16>
90006dd0:	24005040 	.word	0x24005040

90006dd4 <osKernelStart>:

osStatus_t osKernelStart (void) {
90006dd4:	b510      	push	{r4, lr}
90006dd6:	f3ef 8405 	mrs	r4, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
90006dda:	b95c      	cbnz	r4, 90006df4 <osKernelStart+0x20>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelReady) {
90006ddc:	4b08      	ldr	r3, [pc, #32]	; (90006e00 <osKernelStart+0x2c>)
90006dde:	681a      	ldr	r2, [r3, #0]
90006de0:	2a01      	cmp	r2, #1
90006de2:	d10a      	bne.n	90006dfa <osKernelStart+0x26>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90006de4:	4a07      	ldr	r2, [pc, #28]	; (90006e04 <osKernelStart+0x30>)
90006de6:	77d4      	strb	r4, [r2, #31]
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
90006de8:	2202      	movs	r2, #2
90006dea:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
90006dec:	f001 fc44 	bl	90008678 <vTaskStartScheduler>
      stat = osOK;
90006df0:	4620      	mov	r0, r4
      stat = osError;
    }
  }

  return (stat);
}
90006df2:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
90006df4:	f06f 0005 	mvn.w	r0, #5
90006df8:	e7fb      	b.n	90006df2 <osKernelStart+0x1e>
      stat = osError;
90006dfa:	f04f 30ff 	mov.w	r0, #4294967295
  return (stat);
90006dfe:	e7f8      	b.n	90006df2 <osKernelStart+0x1e>
90006e00:	24005040 	.word	0x24005040
90006e04:	e000ed00 	.word	0xe000ed00

90006e08 <osKernelGetTickCount>:
90006e08:	f3ef 8305 	mrs	r3, IPSR
}

uint32_t osKernelGetTickCount (void) {
  TickType_t ticks;

  if (IS_IRQ()) {
90006e0c:	b10b      	cbz	r3, 90006e12 <osKernelGetTickCount+0xa>
    ticks = xTaskGetTickCountFromISR();
90006e0e:	f001 bc87 	b.w	90008720 <xTaskGetTickCountFromISR>
  } else {
    ticks = xTaskGetTickCount();
90006e12:	f001 bc7f 	b.w	90008714 <xTaskGetTickCount>

90006e16 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
90006e16:	b5f0      	push	{r4, r5, r6, r7, lr}
90006e18:	4614      	mov	r4, r2
90006e1a:	b087      	sub	sp, #28
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
90006e1c:	2200      	movs	r2, #0
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
90006e1e:	460b      	mov	r3, r1
  hTask = NULL;
90006e20:	9205      	str	r2, [sp, #20]
90006e22:	f3ef 8205 	mrs	r2, IPSR

  if (!IS_IRQ() && (func != NULL)) {
90006e26:	b9d2      	cbnz	r2, 90006e5e <osThreadNew+0x48>
90006e28:	b1c8      	cbz	r0, 90006e5e <osThreadNew+0x48>
    prio  = (UBaseType_t)osPriorityNormal;

    name = NULL;
    mem  = -1;

    if (attr != NULL) {
90006e2a:	2c00      	cmp	r4, #0
90006e2c:	d02f      	beq.n	90006e8e <osThreadNew+0x78>
      if (attr->name != NULL) {
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
90006e2e:	69a5      	ldr	r5, [r4, #24]
90006e30:	2d00      	cmp	r5, #0
90006e32:	bf08      	it	eq
90006e34:	2518      	moveq	r5, #24
        prio = (UBaseType_t)attr->priority;
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
90006e36:	1e69      	subs	r1, r5, #1
90006e38:	46ac      	mov	ip, r5
90006e3a:	2937      	cmp	r1, #55	; 0x37
90006e3c:	d82b      	bhi.n	90006e96 <osThreadNew+0x80>
90006e3e:	6861      	ldr	r1, [r4, #4]
90006e40:	07c9      	lsls	r1, r1, #31
90006e42:	d428      	bmi.n	90006e96 <osThreadNew+0x80>
        return (NULL);
      }

      if (attr->stack_size > 0U) {
90006e44:	6966      	ldr	r6, [r4, #20]
90006e46:	b16e      	cbz	r6, 90006e64 <osThreadNew+0x4e>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
90006e48:	08b2      	lsrs	r2, r6, #2
      if (attr->name != NULL) {
90006e4a:	6821      	ldr	r1, [r4, #0]
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
90006e4c:	e9d4 7e02 	ldrd	r7, lr, [r4, #8]
90006e50:	b157      	cbz	r7, 90006e68 <osThreadNew+0x52>
90006e52:	f1be 0f5b 	cmp.w	lr, #91	; 0x5b
90006e56:	d902      	bls.n	90006e5e <osThreadNew+0x48>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
90006e58:	6924      	ldr	r4, [r4, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
90006e5a:	b104      	cbz	r4, 90006e5e <osThreadNew+0x48>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
90006e5c:	b9ee      	cbnz	r6, 90006e9a <osThreadNew+0x84>
        #endif
      }
    }
  }

  return ((osThreadId_t)hTask);
90006e5e:	9805      	ldr	r0, [sp, #20]
}
90006e60:	b007      	add	sp, #28
90006e62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    stack = configMINIMAL_STACK_SIZE;
90006e64:	2280      	movs	r2, #128	; 0x80
90006e66:	e7f0      	b.n	90006e4a <osThreadNew+0x34>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
90006e68:	f1be 0f00 	cmp.w	lr, #0
90006e6c:	d1f7      	bne.n	90006e5e <osThreadNew+0x48>
      if (mem == 0) {
90006e6e:	6924      	ldr	r4, [r4, #16]
90006e70:	2c00      	cmp	r4, #0
90006e72:	d1f4      	bne.n	90006e5e <osThreadNew+0x48>
90006e74:	460c      	mov	r4, r1
          if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
90006e76:	a905      	add	r1, sp, #20
90006e78:	b292      	uxth	r2, r2
90006e7a:	e9cd c100 	strd	ip, r1, [sp]
90006e7e:	4621      	mov	r1, r4
90006e80:	f001 fbcd 	bl	9000861e <xTaskCreate>
90006e84:	2801      	cmp	r0, #1
            hTask = NULL;
90006e86:	bf1c      	itt	ne
90006e88:	2300      	movne	r3, #0
90006e8a:	9305      	strne	r3, [sp, #20]
90006e8c:	e7e7      	b.n	90006e5e <osThreadNew+0x48>
    prio  = (UBaseType_t)osPriorityNormal;
90006e8e:	f04f 0c18 	mov.w	ip, #24
    stack = configMINIMAL_STACK_SIZE;
90006e92:	2280      	movs	r2, #128	; 0x80
90006e94:	e7ef      	b.n	90006e76 <osThreadNew+0x60>
        return (NULL);
90006e96:	4610      	mov	r0, r2
90006e98:	e7e2      	b.n	90006e60 <osThreadNew+0x4a>
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
90006e9a:	e9cd 4701 	strd	r4, r7, [sp, #4]
90006e9e:	9500      	str	r5, [sp, #0]
90006ea0:	f001 fb85 	bl	900085ae <xTaskCreateStatic>
90006ea4:	9005      	str	r0, [sp, #20]
90006ea6:	e7da      	b.n	90006e5e <osThreadNew+0x48>

90006ea8 <osDelay>:
  /* Return flags before clearing */
  return (rflags);
}
#endif /* (configUSE_OS2_THREAD_FLAGS == 1) */

osStatus_t osDelay (uint32_t ticks) {
90006ea8:	b510      	push	{r4, lr}
90006eaa:	f3ef 8405 	mrs	r4, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
90006eae:	b924      	cbnz	r4, 90006eba <osDelay+0x12>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
90006eb0:	b110      	cbz	r0, 90006eb8 <osDelay+0x10>
      vTaskDelay(ticks);
90006eb2:	f001 fd4d 	bl	90008950 <vTaskDelay>
    stat = osOK;
90006eb6:	4620      	mov	r0, r4
    }
  }

  return (stat);
}
90006eb8:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
90006eba:	f06f 0005 	mvn.w	r0, #5
90006ebe:	e7fb      	b.n	90006eb8 <osDelay+0x10>

90006ec0 <osMutexNew>:
}

/*---------------------------------------------------------------------------*/
#if (configUSE_OS2_MUTEX == 1)

osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
90006ec0:	b570      	push	{r4, r5, r6, lr}
90006ec2:	4605      	mov	r5, r0
90006ec4:	f3ef 8605 	mrs	r6, IPSR
  const char *name;
  #endif

  hMutex = NULL;

  if (!IS_IRQ()) {
90006ec8:	b116      	cbz	r6, 90006ed0 <osMutexNew+0x10>
  hMutex = NULL;
90006eca:	2400      	movs	r4, #0
      }
    }
  }

  return ((osMutexId_t)hMutex);
}
90006ecc:	4620      	mov	r0, r4
90006ece:	bd70      	pop	{r4, r5, r6, pc}
    if (attr != NULL) {
90006ed0:	b110      	cbz	r0, 90006ed8 <osMutexNew+0x18>
      type = attr->attr_bits;
90006ed2:	6846      	ldr	r6, [r0, #4]
    if ((type & osMutexRobust) != osMutexRobust) {
90006ed4:	0733      	lsls	r3, r6, #28
90006ed6:	d4f8      	bmi.n	90006eca <osMutexNew+0xa>
    if ((type & osMutexRecursive) == osMutexRecursive) {
90006ed8:	f006 0601 	and.w	r6, r6, #1
      if (attr != NULL) {
90006edc:	b17d      	cbz	r5, 90006efe <osMutexNew+0x3e>
        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
90006ede:	e9d5 1302 	ldrd	r1, r3, [r5, #8]
90006ee2:	b151      	cbz	r1, 90006efa <osMutexNew+0x3a>
90006ee4:	2b4f      	cmp	r3, #79	; 0x4f
90006ee6:	d9f0      	bls.n	90006eca <osMutexNew+0xa>
          if (rmtx != 0U) {
90006ee8:	b1de      	cbz	r6, 90006f22 <osMutexNew+0x62>
            hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
90006eea:	2004      	movs	r0, #4
            hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
90006eec:	f000 fec2 	bl	90007c74 <xQueueCreateMutexStatic>
90006ef0:	4604      	mov	r4, r0
      if (hMutex != NULL) {
90006ef2:	2800      	cmp	r0, #0
90006ef4:	d0e9      	beq.n	90006eca <osMutexNew+0xa>
          name = attr->name;
90006ef6:	682d      	ldr	r5, [r5, #0]
90006ef8:	e00a      	b.n	90006f10 <osMutexNew+0x50>
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
90006efa:	2b00      	cmp	r3, #0
90006efc:	d1e5      	bne.n	90006eca <osMutexNew+0xa>
            if (rmtx != 0U) {
90006efe:	b196      	cbz	r6, 90006f26 <osMutexNew+0x66>
              hMutex = xSemaphoreCreateRecursiveMutex ();
90006f00:	2004      	movs	r0, #4
              hMutex = xSemaphoreCreateMutex ();
90006f02:	f000 feea 	bl	90007cda <xQueueCreateMutex>
90006f06:	4604      	mov	r4, r0
      if (hMutex != NULL) {
90006f08:	2800      	cmp	r0, #0
90006f0a:	d0de      	beq.n	90006eca <osMutexNew+0xa>
        if (attr != NULL) {
90006f0c:	2d00      	cmp	r5, #0
90006f0e:	d1f2      	bne.n	90006ef6 <osMutexNew+0x36>
        vQueueAddToRegistry (hMutex, name);
90006f10:	4629      	mov	r1, r5
90006f12:	4620      	mov	r0, r4
90006f14:	f001 f988 	bl	90008228 <vQueueAddToRegistry>
      if ((hMutex != NULL) && (rmtx != 0U)) {
90006f18:	2e00      	cmp	r6, #0
90006f1a:	d0d7      	beq.n	90006ecc <osMutexNew+0xc>
        hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
90006f1c:	f044 0401 	orr.w	r4, r4, #1
  return ((osMutexId_t)hMutex);
90006f20:	e7d4      	b.n	90006ecc <osMutexNew+0xc>
            hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
90006f22:	2001      	movs	r0, #1
90006f24:	e7e2      	b.n	90006eec <osMutexNew+0x2c>
              hMutex = xSemaphoreCreateMutex ();
90006f26:	2001      	movs	r0, #1
90006f28:	e7eb      	b.n	90006f02 <osMutexNew+0x42>

90006f2a <osMutexAcquire>:

osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
90006f2a:	4603      	mov	r3, r0
  SemaphoreHandle_t hMutex;
  osStatus_t stat;
  uint32_t rmtx;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
90006f2c:	f020 0001 	bic.w	r0, r0, #1
osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
90006f30:	b510      	push	{r4, lr}

  rmtx = (uint32_t)mutex_id & 1U;
90006f32:	f003 0301 	and.w	r3, r3, #1
osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
90006f36:	460c      	mov	r4, r1
90006f38:	f3ef 8205 	mrs	r2, IPSR

  stat = osOK;

  if (IS_IRQ()) {
90006f3c:	b98a      	cbnz	r2, 90006f62 <osMutexAcquire+0x38>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
90006f3e:	b198      	cbz	r0, 90006f68 <osMutexAcquire+0x3e>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
90006f40:	b163      	cbz	r3, 90006f5c <osMutexAcquire+0x32>
      #if (configUSE_RECURSIVE_MUTEXES == 1)
      if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
90006f42:	f001 f8ff 	bl	90008144 <xQueueTakeMutexRecursive>
90006f46:	2801      	cmp	r0, #1
90006f48:	d101      	bne.n	90006f4e <osMutexAcquire+0x24>
  stat = osOK;
90006f4a:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
90006f4c:	bd10      	pop	{r4, pc}
          stat = osErrorResource;
90006f4e:	2c00      	cmp	r4, #0
90006f50:	bf14      	ite	ne
90006f52:	f06f 0001 	mvnne.w	r0, #1
90006f56:	f06f 0002 	mvneq.w	r0, #2
90006f5a:	e7f7      	b.n	90006f4c <osMutexAcquire+0x22>
      if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
90006f5c:	f001 f82f 	bl	90007fbe <xQueueSemaphoreTake>
90006f60:	e7f1      	b.n	90006f46 <osMutexAcquire+0x1c>
    stat = osErrorISR;
90006f62:	f06f 0005 	mvn.w	r0, #5
90006f66:	e7f1      	b.n	90006f4c <osMutexAcquire+0x22>
    stat = osErrorParameter;
90006f68:	f06f 0003 	mvn.w	r0, #3
90006f6c:	e7ee      	b.n	90006f4c <osMutexAcquire+0x22>

90006f6e <osMutexRelease>:

osStatus_t osMutexRelease (osMutexId_t mutex_id) {
90006f6e:	b508      	push	{r3, lr}
90006f70:	4603      	mov	r3, r0
  SemaphoreHandle_t hMutex;
  osStatus_t stat;
  uint32_t rmtx;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
90006f72:	f020 0001 	bic.w	r0, r0, #1

  rmtx = (uint32_t)mutex_id & 1U;
90006f76:	f003 0301 	and.w	r3, r3, #1
90006f7a:	f3ef 8205 	mrs	r2, IPSR

  stat = osOK;

  if (IS_IRQ()) {
90006f7e:	b972      	cbnz	r2, 90006f9e <osMutexRelease+0x30>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
90006f80:	b180      	cbz	r0, 90006fa4 <osMutexRelease+0x36>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
90006f82:	b13b      	cbz	r3, 90006f94 <osMutexRelease+0x26>
      #if (configUSE_RECURSIVE_MUTEXES == 1)
      if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
90006f84:	f000 fe8b 	bl	90007c9e <xQueueGiveMutexRecursive>
90006f88:	2801      	cmp	r0, #1
  stat = osOK;
90006f8a:	bf0c      	ite	eq
90006f8c:	2000      	moveq	r0, #0
        stat = osErrorResource;
90006f8e:	f06f 0002 	mvnne.w	r0, #2
      }
    }
  }

  return (stat);
}
90006f92:	bd08      	pop	{r3, pc}
      if (xSemaphoreGive (hMutex) != pdPASS) {
90006f94:	461a      	mov	r2, r3
90006f96:	4619      	mov	r1, r3
90006f98:	f000 fdb9 	bl	90007b0e <xQueueGenericSend>
90006f9c:	e7f4      	b.n	90006f88 <osMutexRelease+0x1a>
    stat = osErrorISR;
90006f9e:	f06f 0005 	mvn.w	r0, #5
90006fa2:	e7f6      	b.n	90006f92 <osMutexRelease+0x24>
    stat = osErrorParameter;
90006fa4:	f06f 0003 	mvn.w	r0, #3
  return (stat);
90006fa8:	e7f3      	b.n	90006f92 <osMutexRelease+0x24>

90006faa <osSemaphoreNew>:
}
#endif /* (configUSE_OS2_MUTEX == 1) */

/*---------------------------------------------------------------------------*/

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
90006faa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
90006fac:	4604      	mov	r4, r0
90006fae:	460e      	mov	r6, r1
90006fb0:	4615      	mov	r5, r2
90006fb2:	f3ef 8205 	mrs	r2, IPSR
  const char *name;
  #endif

  hSemaphore = NULL;

  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
90006fb6:	b11a      	cbz	r2, 90006fc0 <osSemaphoreNew+0x16>
        }

        if ((hSemaphore != NULL) && (initial_count != 0U)) {
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
            vSemaphoreDelete (hSemaphore);
            hSemaphore = NULL;
90006fb8:	2400      	movs	r4, #0
      #endif
    }
  }

  return ((osSemaphoreId_t)hSemaphore);
}
90006fba:	4620      	mov	r0, r4
90006fbc:	b003      	add	sp, #12
90006fbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
90006fc0:	2800      	cmp	r0, #0
90006fc2:	d0f9      	beq.n	90006fb8 <osSemaphoreNew+0xe>
90006fc4:	4288      	cmp	r0, r1
90006fc6:	d3f7      	bcc.n	90006fb8 <osSemaphoreNew+0xe>
    if (attr != NULL) {
90006fc8:	b1e5      	cbz	r5, 90007004 <osSemaphoreNew+0x5a>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
90006fca:	e9d5 3702 	ldrd	r3, r7, [r5, #8]
90006fce:	b1bb      	cbz	r3, 90007000 <osSemaphoreNew+0x56>
90006fd0:	2f4f      	cmp	r7, #79	; 0x4f
90006fd2:	d9f1      	bls.n	90006fb8 <osSemaphoreNew+0xe>
      if (max_count == 1U) {
90006fd4:	2801      	cmp	r0, #1
90006fd6:	d12a      	bne.n	9000702e <osSemaphoreNew+0x84>
            hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
90006fd8:	2103      	movs	r1, #3
90006fda:	9100      	str	r1, [sp, #0]
90006fdc:	4611      	mov	r1, r2
90006fde:	f000 fce1 	bl	900079a4 <xQueueGenericCreateStatic>
            hSemaphore = xSemaphoreCreateBinary();
90006fe2:	4604      	mov	r4, r0
        if ((hSemaphore != NULL) && (initial_count != 0U)) {
90006fe4:	2800      	cmp	r0, #0
90006fe6:	d0e7      	beq.n	90006fb8 <osSemaphoreNew+0xe>
90006fe8:	b1de      	cbz	r6, 90007022 <osSemaphoreNew+0x78>
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
90006fea:	2300      	movs	r3, #0
90006fec:	461a      	mov	r2, r3
90006fee:	4619      	mov	r1, r3
90006ff0:	f000 fd8d 	bl	90007b0e <xQueueGenericSend>
90006ff4:	2801      	cmp	r0, #1
90006ff6:	d014      	beq.n	90007022 <osSemaphoreNew+0x78>
            vSemaphoreDelete (hSemaphore);
90006ff8:	4620      	mov	r0, r4
90006ffa:	f001 f93b 	bl	90008274 <vQueueDelete>
90006ffe:	e7db      	b.n	90006fb8 <osSemaphoreNew+0xe>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
90007000:	2f00      	cmp	r7, #0
90007002:	d1d9      	bne.n	90006fb8 <osSemaphoreNew+0xe>
      if (max_count == 1U) {
90007004:	2c01      	cmp	r4, #1
90007006:	d105      	bne.n	90007014 <osSemaphoreNew+0x6a>
            hSemaphore = xSemaphoreCreateBinary();
90007008:	2203      	movs	r2, #3
9000700a:	2100      	movs	r1, #0
9000700c:	4620      	mov	r0, r4
9000700e:	f000 fd17 	bl	90007a40 <xQueueGenericCreate>
90007012:	e7e6      	b.n	90006fe2 <osSemaphoreNew+0x38>
            hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
90007014:	4620      	mov	r0, r4
90007016:	4631      	mov	r1, r6
90007018:	f000 fd5b 	bl	90007ad2 <xQueueCreateCountingSemaphore>
      if (hSemaphore != NULL) {
9000701c:	4604      	mov	r4, r0
9000701e:	2800      	cmp	r0, #0
90007020:	d0ca      	beq.n	90006fb8 <osSemaphoreNew+0xe>
        if (attr != NULL) {
90007022:	b955      	cbnz	r5, 9000703a <osSemaphoreNew+0x90>
        vQueueAddToRegistry (hSemaphore, name);
90007024:	4629      	mov	r1, r5
90007026:	4620      	mov	r0, r4
90007028:	f001 f8fe 	bl	90008228 <vQueueAddToRegistry>
  return ((osSemaphoreId_t)hSemaphore);
9000702c:	e7c5      	b.n	90006fba <osSemaphoreNew+0x10>
            hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
9000702e:	461a      	mov	r2, r3
90007030:	f000 fd2d 	bl	90007a8e <xQueueCreateCountingSemaphoreStatic>
      if (hSemaphore != NULL) {
90007034:	4604      	mov	r4, r0
90007036:	2800      	cmp	r0, #0
90007038:	d0be      	beq.n	90006fb8 <osSemaphoreNew+0xe>
          name = attr->name;
9000703a:	682d      	ldr	r5, [r5, #0]
9000703c:	e7f2      	b.n	90007024 <osSemaphoreNew+0x7a>

9000703e <osSemaphoreAcquire>:

osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
9000703e:	b513      	push	{r0, r1, r4, lr}
90007040:	460c      	mov	r4, r1
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
90007042:	b308      	cbz	r0, 90007088 <osSemaphoreAcquire+0x4a>
90007044:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
90007048:	b1b3      	cbz	r3, 90007078 <osSemaphoreAcquire+0x3a>
    if (timeout != 0U) {
9000704a:	b9e9      	cbnz	r1, 90007088 <osSemaphoreAcquire+0x4a>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
9000704c:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
9000704e:	9101      	str	r1, [sp, #4]
      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
90007050:	f001 f89a 	bl	90008188 <xQueueReceiveFromISR>
90007054:	2801      	cmp	r0, #1
90007056:	d114      	bne.n	90007082 <osSemaphoreAcquire+0x44>
        stat = osErrorResource;
      } else {
        portYIELD_FROM_ISR (yield);
90007058:	9b01      	ldr	r3, [sp, #4]
9000705a:	b913      	cbnz	r3, 90007062 <osSemaphoreAcquire+0x24>
  stat = osOK;
9000705c:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
9000705e:	b002      	add	sp, #8
90007060:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
90007062:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007066:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
9000706a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
9000706e:	f3bf 8f4f 	dsb	sy
90007072:	f3bf 8f6f 	isb	sy
90007076:	e7f1      	b.n	9000705c <osSemaphoreAcquire+0x1e>
    if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
90007078:	f000 ffa1 	bl	90007fbe <xQueueSemaphoreTake>
9000707c:	2801      	cmp	r0, #1
9000707e:	d0ed      	beq.n	9000705c <osSemaphoreAcquire+0x1e>
      if (timeout != 0U) {
90007080:	b92c      	cbnz	r4, 9000708e <osSemaphoreAcquire+0x50>
        stat = osErrorResource;
90007082:	f06f 0002 	mvn.w	r0, #2
90007086:	e7ea      	b.n	9000705e <osSemaphoreAcquire+0x20>
    stat = osErrorParameter;
90007088:	f06f 0003 	mvn.w	r0, #3
9000708c:	e7e7      	b.n	9000705e <osSemaphoreAcquire+0x20>
        stat = osErrorTimeout;
9000708e:	f06f 0001 	mvn.w	r0, #1
  return (stat);
90007092:	e7e4      	b.n	9000705e <osSemaphoreAcquire+0x20>

90007094 <osSemaphoreRelease>:

osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
90007094:	b513      	push	{r0, r1, r4, lr}
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
90007096:	b310      	cbz	r0, 900070de <osSemaphoreRelease+0x4a>
90007098:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
9000709c:	b1b3      	cbz	r3, 900070cc <osSemaphoreRelease+0x38>
    yield = pdFALSE;
9000709e:	2400      	movs	r4, #0

    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
900070a0:	a901      	add	r1, sp, #4
    yield = pdFALSE;
900070a2:	9401      	str	r4, [sp, #4]
    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
900070a4:	f000 fe98 	bl	90007dd8 <xQueueGiveFromISR>
900070a8:	2801      	cmp	r0, #1
900070aa:	d115      	bne.n	900070d8 <osSemaphoreRelease+0x44>
      stat = osErrorResource;
    } else {
      portYIELD_FROM_ISR (yield);
900070ac:	9b01      	ldr	r3, [sp, #4]
900070ae:	b913      	cbnz	r3, 900070b6 <osSemaphoreRelease+0x22>
  stat = osOK;
900070b0:	2000      	movs	r0, #0
      stat = osErrorResource;
    }
  }

  return (stat);
}
900070b2:	b002      	add	sp, #8
900070b4:	bd10      	pop	{r4, pc}
      portYIELD_FROM_ISR (yield);
900070b6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900070ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900070be:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900070c2:	f3bf 8f4f 	dsb	sy
900070c6:	f3bf 8f6f 	isb	sy
900070ca:	e7f1      	b.n	900070b0 <osSemaphoreRelease+0x1c>
    if (xSemaphoreGive (hSemaphore) != pdPASS) {
900070cc:	461a      	mov	r2, r3
900070ce:	4619      	mov	r1, r3
900070d0:	f000 fd1d 	bl	90007b0e <xQueueGenericSend>
900070d4:	2801      	cmp	r0, #1
900070d6:	d0eb      	beq.n	900070b0 <osSemaphoreRelease+0x1c>
      stat = osErrorResource;
900070d8:	f06f 0002 	mvn.w	r0, #2
900070dc:	e7e9      	b.n	900070b2 <osSemaphoreRelease+0x1e>
    stat = osErrorParameter;
900070de:	f06f 0003 	mvn.w	r0, #3
  return (stat);
900070e2:	e7e6      	b.n	900070b2 <osSemaphoreRelease+0x1e>

900070e4 <osMessageQueueNew>:
  return (stat);
}

/*---------------------------------------------------------------------------*/

osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
900070e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
900070e6:	4605      	mov	r5, r0
900070e8:	460e      	mov	r6, r1
900070ea:	4614      	mov	r4, r2
900070ec:	f3ef 8705 	mrs	r7, IPSR
  const char *name;
  #endif

  hQueue = NULL;

  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
900070f0:	b11f      	cbz	r7, 900070fa <osMessageQueueNew+0x16>
  hQueue = NULL;
900070f2:	2500      	movs	r5, #0
    #endif

  }

  return ((osMessageQueueId_t)hQueue);
}
900070f4:	4628      	mov	r0, r5
900070f6:	b003      	add	sp, #12
900070f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
900070fa:	2800      	cmp	r0, #0
900070fc:	d0f9      	beq.n	900070f2 <osMessageQueueNew+0xe>
900070fe:	2900      	cmp	r1, #0
90007100:	d0f7      	beq.n	900070f2 <osMessageQueueNew+0xe>
    if (attr != NULL) {
90007102:	b1da      	cbz	r2, 9000713c <osMessageQueueNew+0x58>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
90007104:	e9d2 3202 	ldrd	r3, r2, [r2, #8]
90007108:	b183      	cbz	r3, 9000712c <osMessageQueueNew+0x48>
9000710a:	2a4f      	cmp	r2, #79	; 0x4f
9000710c:	d9f1      	bls.n	900070f2 <osMessageQueueNew+0xe>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
9000710e:	6922      	ldr	r2, [r4, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
90007110:	2a00      	cmp	r2, #0
90007112:	d0ee      	beq.n	900070f2 <osMessageQueueNew+0xe>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
90007114:	434d      	muls	r5, r1
90007116:	6966      	ldr	r6, [r4, #20]
90007118:	42ae      	cmp	r6, r5
9000711a:	d3ea      	bcc.n	900070f2 <osMessageQueueNew+0xe>
        hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
9000711c:	9700      	str	r7, [sp, #0]
9000711e:	f000 fc41 	bl	900079a4 <xQueueGenericCreateStatic>
    if (hQueue != NULL) {
90007122:	4605      	mov	r5, r0
90007124:	2800      	cmp	r0, #0
90007126:	d0e4      	beq.n	900070f2 <osMessageQueueNew+0xe>
        name = attr->name;
90007128:	6824      	ldr	r4, [r4, #0]
9000712a:	e011      	b.n	90007150 <osMessageQueueNew+0x6c>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
9000712c:	2a00      	cmp	r2, #0
9000712e:	d1e0      	bne.n	900070f2 <osMessageQueueNew+0xe>
90007130:	6923      	ldr	r3, [r4, #16]
90007132:	2b00      	cmp	r3, #0
90007134:	d1dd      	bne.n	900070f2 <osMessageQueueNew+0xe>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
90007136:	6963      	ldr	r3, [r4, #20]
90007138:	2b00      	cmp	r3, #0
9000713a:	d1da      	bne.n	900070f2 <osMessageQueueNew+0xe>
          hQueue = xQueueCreate (msg_count, msg_size);
9000713c:	4628      	mov	r0, r5
9000713e:	2200      	movs	r2, #0
90007140:	4631      	mov	r1, r6
90007142:	f000 fc7d 	bl	90007a40 <xQueueGenericCreate>
    if (hQueue != NULL) {
90007146:	4605      	mov	r5, r0
90007148:	2800      	cmp	r0, #0
9000714a:	d0d2      	beq.n	900070f2 <osMessageQueueNew+0xe>
      if (attr != NULL) {
9000714c:	2c00      	cmp	r4, #0
9000714e:	d1eb      	bne.n	90007128 <osMessageQueueNew+0x44>
      vQueueAddToRegistry (hQueue, name);
90007150:	4621      	mov	r1, r4
90007152:	4628      	mov	r0, r5
90007154:	f001 f868 	bl	90008228 <vQueueAddToRegistry>
  return ((osMessageQueueId_t)hQueue);
90007158:	e7cc      	b.n	900070f4 <osMessageQueueNew+0x10>

9000715a <osMessageQueuePut>:

osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
9000715a:	b573      	push	{r0, r1, r4, r5, r6, lr}
9000715c:	461c      	mov	r4, r3
9000715e:	f3ef 8605 	mrs	r6, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
90007162:	b1c6      	cbz	r6, 90007196 <osMessageQueuePut+0x3c>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
90007164:	b318      	cbz	r0, 900071ae <osMessageQueuePut+0x54>
90007166:	b311      	cbz	r1, 900071ae <osMessageQueuePut+0x54>
90007168:	bb0b      	cbnz	r3, 900071ae <osMessageQueuePut+0x54>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
9000716a:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
9000716c:	9301      	str	r3, [sp, #4]
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
9000716e:	f000 fdd1 	bl	90007d14 <xQueueGenericSendFromISR>
90007172:	2801      	cmp	r0, #1
90007174:	d118      	bne.n	900071a8 <osMessageQueuePut+0x4e>
        stat = osErrorResource;
      } else {
        portYIELD_FROM_ISR (yield);
90007176:	9b01      	ldr	r3, [sp, #4]
90007178:	b913      	cbnz	r3, 90007180 <osMessageQueuePut+0x26>
  stat = osOK;
9000717a:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
9000717c:	b002      	add	sp, #8
9000717e:	bd70      	pop	{r4, r5, r6, pc}
        portYIELD_FROM_ISR (yield);
90007180:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007184:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007188:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
9000718c:	f3bf 8f4f 	dsb	sy
90007190:	f3bf 8f6f 	isb	sy
90007194:	e7f1      	b.n	9000717a <osMessageQueuePut+0x20>
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
90007196:	b150      	cbz	r0, 900071ae <osMessageQueuePut+0x54>
90007198:	b149      	cbz	r1, 900071ae <osMessageQueuePut+0x54>
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
9000719a:	4633      	mov	r3, r6
9000719c:	4622      	mov	r2, r4
9000719e:	f000 fcb6 	bl	90007b0e <xQueueGenericSend>
900071a2:	2801      	cmp	r0, #1
900071a4:	d0e9      	beq.n	9000717a <osMessageQueuePut+0x20>
        if (timeout != 0U) {
900071a6:	b92c      	cbnz	r4, 900071b4 <osMessageQueuePut+0x5a>
          stat = osErrorResource;
900071a8:	f06f 0002 	mvn.w	r0, #2
900071ac:	e7e6      	b.n	9000717c <osMessageQueuePut+0x22>
      stat = osErrorParameter;
900071ae:	f06f 0003 	mvn.w	r0, #3
900071b2:	e7e3      	b.n	9000717c <osMessageQueuePut+0x22>
          stat = osErrorTimeout;
900071b4:	f06f 0001 	mvn.w	r0, #1
  return (stat);
900071b8:	e7e0      	b.n	9000717c <osMessageQueuePut+0x22>

900071ba <osMessageQueueGet>:

osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
900071ba:	b537      	push	{r0, r1, r2, r4, r5, lr}
900071bc:	461c      	mov	r4, r3
900071be:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
900071c2:	b1c3      	cbz	r3, 900071f6 <osMessageQueueGet+0x3c>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
900071c4:	b310      	cbz	r0, 9000720c <osMessageQueueGet+0x52>
900071c6:	b309      	cbz	r1, 9000720c <osMessageQueueGet+0x52>
900071c8:	bb04      	cbnz	r4, 9000720c <osMessageQueueGet+0x52>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
900071ca:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
900071cc:	9401      	str	r4, [sp, #4]
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
900071ce:	f000 ffdb 	bl	90008188 <xQueueReceiveFromISR>
900071d2:	2801      	cmp	r0, #1
900071d4:	d117      	bne.n	90007206 <osMessageQueueGet+0x4c>
        stat = osErrorResource;
      } else {
        portYIELD_FROM_ISR (yield);
900071d6:	9b01      	ldr	r3, [sp, #4]
900071d8:	b913      	cbnz	r3, 900071e0 <osMessageQueueGet+0x26>
  stat = osOK;
900071da:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
900071dc:	b003      	add	sp, #12
900071de:	bd30      	pop	{r4, r5, pc}
        portYIELD_FROM_ISR (yield);
900071e0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900071e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900071e8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900071ec:	f3bf 8f4f 	dsb	sy
900071f0:	f3bf 8f6f 	isb	sy
900071f4:	e7f1      	b.n	900071da <osMessageQueueGet+0x20>
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
900071f6:	b148      	cbz	r0, 9000720c <osMessageQueueGet+0x52>
900071f8:	b141      	cbz	r1, 9000720c <osMessageQueueGet+0x52>
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
900071fa:	4622      	mov	r2, r4
900071fc:	f000 fe40 	bl	90007e80 <xQueueReceive>
90007200:	2801      	cmp	r0, #1
90007202:	d0ea      	beq.n	900071da <osMessageQueueGet+0x20>
        if (timeout != 0U) {
90007204:	b92c      	cbnz	r4, 90007212 <osMessageQueueGet+0x58>
          stat = osErrorResource;
90007206:	f06f 0002 	mvn.w	r0, #2
9000720a:	e7e7      	b.n	900071dc <osMessageQueueGet+0x22>
      stat = osErrorParameter;
9000720c:	f06f 0003 	mvn.w	r0, #3
90007210:	e7e4      	b.n	900071dc <osMessageQueueGet+0x22>
          stat = osErrorTimeout;
90007212:	f06f 0001 	mvn.w	r0, #1
  return (stat);
90007216:	e7e1      	b.n	900071dc <osMessageQueueGet+0x22>

90007218 <vApplicationGetIdleTaskMemory>:
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
90007218:	4b03      	ldr	r3, [pc, #12]	; (90007228 <vApplicationGetIdleTaskMemory+0x10>)
9000721a:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
9000721c:	4b03      	ldr	r3, [pc, #12]	; (9000722c <vApplicationGetIdleTaskMemory+0x14>)
9000721e:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
90007220:	2380      	movs	r3, #128	; 0x80
90007222:	6013      	str	r3, [r2, #0]
}
90007224:	4770      	bx	lr
90007226:	bf00      	nop
90007228:	24004fe4 	.word	0x24004fe4
9000722c:	24004de4 	.word	0x24004de4

90007230 <vApplicationGetTimerTaskMemory>:
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
90007230:	4b03      	ldr	r3, [pc, #12]	; (90007240 <vApplicationGetTimerTaskMemory+0x10>)
90007232:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
90007234:	4b03      	ldr	r3, [pc, #12]	; (90007244 <vApplicationGetTimerTaskMemory+0x14>)
90007236:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
90007238:	f44f 7300 	mov.w	r3, #512	; 0x200
9000723c:	6013      	str	r3, [r2, #0]
}
9000723e:	4770      	bx	lr
90007240:	24005844 	.word	0x24005844
90007244:	24005044 	.word	0x24005044

90007248 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
90007248:	4b0f      	ldr	r3, [pc, #60]	; (90007288 <prvInsertBlockIntoFreeList+0x40>)
{
9000724a:	b510      	push	{r4, lr}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
9000724c:	461a      	mov	r2, r3
9000724e:	681b      	ldr	r3, [r3, #0]
90007250:	4283      	cmp	r3, r0
90007252:	d3fb      	bcc.n	9000724c <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
90007254:	6854      	ldr	r4, [r2, #4]
90007256:	1911      	adds	r1, r2, r4
90007258:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
9000725a:	bf01      	itttt	eq
9000725c:	6841      	ldreq	r1, [r0, #4]
9000725e:	4610      	moveq	r0, r2
90007260:	1909      	addeq	r1, r1, r4
90007262:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
90007264:	6844      	ldr	r4, [r0, #4]
90007266:	1901      	adds	r1, r0, r4
90007268:	428b      	cmp	r3, r1
9000726a:	d107      	bne.n	9000727c <prvInsertBlockIntoFreeList+0x34>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
9000726c:	4907      	ldr	r1, [pc, #28]	; (9000728c <prvInsertBlockIntoFreeList+0x44>)
9000726e:	6809      	ldr	r1, [r1, #0]
90007270:	428b      	cmp	r3, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
90007272:	bf1f      	itttt	ne
90007274:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
90007276:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
90007278:	1909      	addne	r1, r1, r4
9000727a:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
9000727c:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
9000727e:	6003      	str	r3, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
90007280:	bf18      	it	ne
90007282:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
90007284:	bd10      	pop	{r4, pc}
90007286:	bf00      	nop
90007288:	240094b8 	.word	0x240094b8
9000728c:	240058a0 	.word	0x240058a0

90007290 <pvPortMalloc>:
{
90007290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90007294:	4604      	mov	r4, r0
	vTaskSuspendAll();
90007296:	f001 fa35 	bl	90008704 <vTaskSuspendAll>
		if( pxEnd == NULL )
9000729a:	4942      	ldr	r1, [pc, #264]	; (900073a4 <pvPortMalloc+0x114>)
9000729c:	4d42      	ldr	r5, [pc, #264]	; (900073a8 <pvPortMalloc+0x118>)
9000729e:	680b      	ldr	r3, [r1, #0]
900072a0:	bb0b      	cbnz	r3, 900072e6 <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
900072a2:	4a42      	ldr	r2, [pc, #264]	; (900073ac <pvPortMalloc+0x11c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
900072a4:	0756      	lsls	r6, r2, #29
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
900072a6:	4e42      	ldr	r6, [pc, #264]	; (900073b0 <pvPortMalloc+0x120>)
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
900072a8:	bf1b      	ittet	ne
900072aa:	1dd0      	addne	r0, r2, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
900072ac:	f502 5370 	addne.w	r3, r2, #15360	; 0x3c00
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
900072b0:	f44f 5370 	moveq.w	r3, #15360	; 0x3c00
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
900072b4:	f020 0007 	bicne.w	r0, r0, #7
900072b8:	bf1c      	itt	ne
900072ba:	4602      	movne	r2, r0
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
900072bc:	1a1b      	subne	r3, r3, r0
	xStart.xBlockSize = ( size_t ) 0;
900072be:	2000      	movs	r0, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
900072c0:	4413      	add	r3, r2
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
900072c2:	6032      	str	r2, [r6, #0]
	xStart.xBlockSize = ( size_t ) 0;
900072c4:	6070      	str	r0, [r6, #4]
	uxAddress -= xHeapStructSize;
900072c6:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
900072c8:	f023 0307 	bic.w	r3, r3, #7
	pxEnd->pxNextFreeBlock = NULL;
900072cc:	e9c3 0000 	strd	r0, r0, [r3]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
900072d0:	1a98      	subs	r0, r3, r2
	pxEnd = ( void * ) uxAddress;
900072d2:	600b      	str	r3, [r1, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
900072d4:	e9c2 3000 	strd	r3, r0, [r2]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
900072d8:	4b36      	ldr	r3, [pc, #216]	; (900073b4 <pvPortMalloc+0x124>)
900072da:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
900072dc:	4b36      	ldr	r3, [pc, #216]	; (900073b8 <pvPortMalloc+0x128>)
900072de:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
900072e0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
900072e4:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
900072e6:	682f      	ldr	r7, [r5, #0]
900072e8:	4227      	tst	r7, r4
900072ea:	d007      	beq.n	900072fc <pvPortMalloc+0x6c>
			vApplicationMallocFailedHook();
900072ec:	2600      	movs	r6, #0
	( void ) xTaskResumeAll();
900072ee:	f001 fabb 	bl	90008868 <xTaskResumeAll>
			vApplicationMallocFailedHook();
900072f2:	f7f9 f937 	bl	90000564 <vApplicationMallocFailedHook>
}
900072f6:	4630      	mov	r0, r6
900072f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( xWantedSize > 0 )
900072fc:	2c00      	cmp	r4, #0
900072fe:	d0f5      	beq.n	900072ec <pvPortMalloc+0x5c>
				xWantedSize += xHeapStructSize;
90007300:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
90007304:	0760      	lsls	r0, r4, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
90007306:	bf1c      	itt	ne
90007308:	f023 0307 	bicne.w	r3, r3, #7
9000730c:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
9000730e:	2b00      	cmp	r3, #0
90007310:	d0ec      	beq.n	900072ec <pvPortMalloc+0x5c>
90007312:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 900073b8 <pvPortMalloc+0x128>
90007316:	f8d8 5000 	ldr.w	r5, [r8]
9000731a:	429d      	cmp	r5, r3
9000731c:	d3e6      	bcc.n	900072ec <pvPortMalloc+0x5c>
				pxBlock = xStart.pxNextFreeBlock;
9000731e:	4a24      	ldr	r2, [pc, #144]	; (900073b0 <pvPortMalloc+0x120>)
90007320:	6814      	ldr	r4, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
90007322:	6860      	ldr	r0, [r4, #4]
90007324:	4298      	cmp	r0, r3
90007326:	d201      	bcs.n	9000732c <pvPortMalloc+0x9c>
90007328:	6826      	ldr	r6, [r4, #0]
9000732a:	b9ae      	cbnz	r6, 90007358 <pvPortMalloc+0xc8>
				if( pxBlock != pxEnd )
9000732c:	6809      	ldr	r1, [r1, #0]
9000732e:	42a1      	cmp	r1, r4
90007330:	d0dc      	beq.n	900072ec <pvPortMalloc+0x5c>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
90007332:	6821      	ldr	r1, [r4, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
90007334:	6816      	ldr	r6, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
90007336:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
90007338:	1ac2      	subs	r2, r0, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
9000733a:	3608      	adds	r6, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
9000733c:	2a10      	cmp	r2, #16
9000733e:	d912      	bls.n	90007366 <pvPortMalloc+0xd6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
90007340:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
90007342:	0741      	lsls	r1, r0, #29
90007344:	d00b      	beq.n	9000735e <pvPortMalloc+0xce>
	__asm volatile
90007346:	f04f 0350 	mov.w	r3, #80	; 0x50
9000734a:	f383 8811 	msr	BASEPRI, r3
9000734e:	f3bf 8f6f 	isb	sy
90007352:	f3bf 8f4f 	dsb	sy
90007356:	e7fe      	b.n	90007356 <pvPortMalloc+0xc6>
90007358:	4622      	mov	r2, r4
9000735a:	4634      	mov	r4, r6
9000735c:	e7e1      	b.n	90007322 <pvPortMalloc+0x92>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
9000735e:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
90007360:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
90007362:	f7ff ff71 	bl	90007248 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
90007366:	6862      	ldr	r2, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
90007368:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
9000736a:	4912      	ldr	r1, [pc, #72]	; (900073b4 <pvPortMalloc+0x124>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
9000736c:	1aad      	subs	r5, r5, r2
					pxBlock->xBlockSize |= xBlockAllocatedBit;
9000736e:	4317      	orrs	r7, r2
					xNumberOfSuccessfulAllocations++;
90007370:	4a12      	ldr	r2, [pc, #72]	; (900073bc <pvPortMalloc+0x12c>)
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
90007372:	6808      	ldr	r0, [r1, #0]
					pxBlock->pxNextFreeBlock = NULL;
90007374:	6023      	str	r3, [r4, #0]
					xNumberOfSuccessfulAllocations++;
90007376:	6813      	ldr	r3, [r2, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
90007378:	4285      	cmp	r5, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
9000737a:	6067      	str	r7, [r4, #4]
					xNumberOfSuccessfulAllocations++;
9000737c:	f103 0301 	add.w	r3, r3, #1
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
90007380:	bf38      	it	cc
90007382:	600d      	strcc	r5, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
90007384:	f8c8 5000 	str.w	r5, [r8]
					xNumberOfSuccessfulAllocations++;
90007388:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
9000738a:	f001 fa6d 	bl	90008868 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
9000738e:	0773      	lsls	r3, r6, #29
90007390:	d0b1      	beq.n	900072f6 <pvPortMalloc+0x66>
90007392:	f04f 0350 	mov.w	r3, #80	; 0x50
90007396:	f383 8811 	msr	BASEPRI, r3
9000739a:	f3bf 8f6f 	isb	sy
9000739e:	f3bf 8f4f 	dsb	sy
900073a2:	e7fe      	b.n	900073a2 <pvPortMalloc+0x112>
900073a4:	240058a0 	.word	0x240058a0
900073a8:	240094a4 	.word	0x240094a4
900073ac:	240058a4 	.word	0x240058a4
900073b0:	240094b8 	.word	0x240094b8
900073b4:	240094ac 	.word	0x240094ac
900073b8:	240094a8 	.word	0x240094a8
900073bc:	240094b0 	.word	0x240094b0

900073c0 <vPortFree>:
{
900073c0:	b510      	push	{r4, lr}
	if( pv != NULL )
900073c2:	4604      	mov	r4, r0
900073c4:	b390      	cbz	r0, 9000742c <vPortFree+0x6c>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
900073c6:	4a1a      	ldr	r2, [pc, #104]	; (90007430 <vPortFree+0x70>)
900073c8:	f850 3c04 	ldr.w	r3, [r0, #-4]
900073cc:	6812      	ldr	r2, [r2, #0]
900073ce:	4213      	tst	r3, r2
900073d0:	d108      	bne.n	900073e4 <vPortFree+0x24>
900073d2:	f04f 0350 	mov.w	r3, #80	; 0x50
900073d6:	f383 8811 	msr	BASEPRI, r3
900073da:	f3bf 8f6f 	isb	sy
900073de:	f3bf 8f4f 	dsb	sy
900073e2:	e7fe      	b.n	900073e2 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
900073e4:	f850 1c08 	ldr.w	r1, [r0, #-8]
900073e8:	b141      	cbz	r1, 900073fc <vPortFree+0x3c>
900073ea:	f04f 0350 	mov.w	r3, #80	; 0x50
900073ee:	f383 8811 	msr	BASEPRI, r3
900073f2:	f3bf 8f6f 	isb	sy
900073f6:	f3bf 8f4f 	dsb	sy
900073fa:	e7fe      	b.n	900073fa <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
900073fc:	ea23 0302 	bic.w	r3, r3, r2
90007400:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
90007404:	f001 f97e 	bl	90008704 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
90007408:	4a0a      	ldr	r2, [pc, #40]	; (90007434 <vPortFree+0x74>)
9000740a:	f854 3c04 	ldr.w	r3, [r4, #-4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
9000740e:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
90007412:	6811      	ldr	r1, [r2, #0]
90007414:	440b      	add	r3, r1
90007416:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
90007418:	f7ff ff16 	bl	90007248 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
9000741c:	4a06      	ldr	r2, [pc, #24]	; (90007438 <vPortFree+0x78>)
9000741e:	6813      	ldr	r3, [r2, #0]
90007420:	3301      	adds	r3, #1
}
90007422:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					xNumberOfSuccessfulFrees++;
90007426:	6013      	str	r3, [r2, #0]
				( void ) xTaskResumeAll();
90007428:	f001 ba1e 	b.w	90008868 <xTaskResumeAll>
}
9000742c:	bd10      	pop	{r4, pc}
9000742e:	bf00      	nop
90007430:	240094a4 	.word	0x240094a4
90007434:	240094a8 	.word	0x240094a8
90007438:	240094b4 	.word	0x240094b4

9000743c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9000743c:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
90007440:	f04f 32ff 	mov.w	r2, #4294967295
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
90007444:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
90007446:	6103      	str	r3, [r0, #16]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
90007448:	e9c0 2302 	strd	r2, r3, [r0, #8]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
9000744c:	2300      	movs	r3, #0
9000744e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
90007450:	4770      	bx	lr

90007452 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
90007452:	2300      	movs	r3, #0
90007454:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
90007456:	4770      	bx	lr

90007458 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
90007458:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
9000745a:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
9000745c:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
9000745e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
90007460:	689a      	ldr	r2, [r3, #8]
90007462:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
90007464:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
90007466:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxContainer = pxList;
90007468:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
9000746a:	3301      	adds	r3, #1
9000746c:	6003      	str	r3, [r0, #0]
}
9000746e:	4770      	bx	lr

90007470 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
90007470:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
90007472:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
90007474:	1c63      	adds	r3, r4, #1
90007476:	d10a      	bne.n	9000748e <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
90007478:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
9000747a:	685a      	ldr	r2, [r3, #4]
9000747c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
9000747e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
90007480:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
90007482:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
90007484:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxContainer = pxList;
90007486:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
90007488:	3301      	adds	r3, #1
9000748a:	6003      	str	r3, [r0, #0]
}
9000748c:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
9000748e:	f100 0208 	add.w	r2, r0, #8
90007492:	4613      	mov	r3, r2
90007494:	6852      	ldr	r2, [r2, #4]
90007496:	6815      	ldr	r5, [r2, #0]
90007498:	42a5      	cmp	r5, r4
9000749a:	d9fa      	bls.n	90007492 <vListInsert+0x22>
9000749c:	e7ed      	b.n	9000747a <vListInsert+0xa>

9000749e <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
9000749e:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
900074a0:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
900074a4:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
900074a6:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
900074a8:	6859      	ldr	r1, [r3, #4]
900074aa:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
900074ac:	bf08      	it	eq
900074ae:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
900074b0:	2200      	movs	r2, #0
900074b2:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
900074b4:	681a      	ldr	r2, [r3, #0]
900074b6:	3a01      	subs	r2, #1
900074b8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
900074ba:	6818      	ldr	r0, [r3, #0]
}
900074bc:	4770      	bx	lr
	...

900074c0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
900074c0:	4808      	ldr	r0, [pc, #32]	; (900074e4 <prvPortStartFirstTask+0x24>)
900074c2:	6800      	ldr	r0, [r0, #0]
900074c4:	6800      	ldr	r0, [r0, #0]
900074c6:	f380 8808 	msr	MSP, r0
900074ca:	f04f 0000 	mov.w	r0, #0
900074ce:	f380 8814 	msr	CONTROL, r0
900074d2:	b662      	cpsie	i
900074d4:	b661      	cpsie	f
900074d6:	f3bf 8f4f 	dsb	sy
900074da:	f3bf 8f6f 	isb	sy
900074de:	df00      	svc	0
900074e0:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
900074e2:	0000      	.short	0x0000
900074e4:	e000ed08 	.word	0xe000ed08

900074e8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
900074e8:	f8df 000c 	ldr.w	r0, [pc, #12]	; 900074f8 <vPortEnableVFP+0x10>
900074ec:	6801      	ldr	r1, [r0, #0]
900074ee:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
900074f2:	6001      	str	r1, [r0, #0]
900074f4:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
900074f6:	0000      	.short	0x0000
900074f8:	e000ed88 	.word	0xe000ed88

900074fc <prvTaskExitError>:
volatile uint32_t ulDummy = 0;
900074fc:	2300      	movs	r3, #0
{
900074fe:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
90007500:	9301      	str	r3, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
90007502:	4b0d      	ldr	r3, [pc, #52]	; (90007538 <prvTaskExitError+0x3c>)
90007504:	681b      	ldr	r3, [r3, #0]
90007506:	3301      	adds	r3, #1
90007508:	d008      	beq.n	9000751c <prvTaskExitError+0x20>
9000750a:	f04f 0350 	mov.w	r3, #80	; 0x50
9000750e:	f383 8811 	msr	BASEPRI, r3
90007512:	f3bf 8f6f 	isb	sy
90007516:	f3bf 8f4f 	dsb	sy
9000751a:	e7fe      	b.n	9000751a <prvTaskExitError+0x1e>
9000751c:	f04f 0350 	mov.w	r3, #80	; 0x50
90007520:	f383 8811 	msr	BASEPRI, r3
90007524:	f3bf 8f6f 	isb	sy
90007528:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
9000752c:	9b01      	ldr	r3, [sp, #4]
9000752e:	2b00      	cmp	r3, #0
90007530:	d0fc      	beq.n	9000752c <prvTaskExitError+0x30>
}
90007532:	b002      	add	sp, #8
90007534:	4770      	bx	lr
90007536:	bf00      	nop
90007538:	2400002c 	.word	0x2400002c

9000753c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
9000753c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
90007540:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
90007544:	f840 2c20 	str.w	r2, [r0, #-32]
}
90007548:	3844      	subs	r0, #68	; 0x44
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
9000754a:	6403      	str	r3, [r0, #64]	; 0x40
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
9000754c:	4b03      	ldr	r3, [pc, #12]	; (9000755c <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
9000754e:	63c1      	str	r1, [r0, #60]	; 0x3c
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
90007550:	6383      	str	r3, [r0, #56]	; 0x38
	*pxTopOfStack = portINITIAL_EXC_RETURN;
90007552:	f06f 0302 	mvn.w	r3, #2
90007556:	6203      	str	r3, [r0, #32]
}
90007558:	4770      	bx	lr
9000755a:	bf00      	nop
9000755c:	900074fd 	.word	0x900074fd

90007560 <SVC_Handler>:
	__asm volatile (
90007560:	4b07      	ldr	r3, [pc, #28]	; (90007580 <pxCurrentTCBConst2>)
90007562:	6819      	ldr	r1, [r3, #0]
90007564:	6808      	ldr	r0, [r1, #0]
90007566:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000756a:	f380 8809 	msr	PSP, r0
9000756e:	f3bf 8f6f 	isb	sy
90007572:	f04f 0000 	mov.w	r0, #0
90007576:	f380 8811 	msr	BASEPRI, r0
9000757a:	4770      	bx	lr
9000757c:	f3af 8000 	nop.w

90007580 <pxCurrentTCBConst2>:
90007580:	24009508 	.word	0x24009508

90007584 <vPortEnterCritical>:
90007584:	f04f 0350 	mov.w	r3, #80	; 0x50
90007588:	f383 8811 	msr	BASEPRI, r3
9000758c:	f3bf 8f6f 	isb	sy
90007590:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
90007594:	4a0a      	ldr	r2, [pc, #40]	; (900075c0 <vPortEnterCritical+0x3c>)
90007596:	6813      	ldr	r3, [r2, #0]
90007598:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
9000759a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
9000759c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
9000759e:	d10e      	bne.n	900075be <vPortEnterCritical+0x3a>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
900075a0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900075a4:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
900075a8:	b2db      	uxtb	r3, r3
900075aa:	b143      	cbz	r3, 900075be <vPortEnterCritical+0x3a>
900075ac:	f04f 0350 	mov.w	r3, #80	; 0x50
900075b0:	f383 8811 	msr	BASEPRI, r3
900075b4:	f3bf 8f6f 	isb	sy
900075b8:	f3bf 8f4f 	dsb	sy
900075bc:	e7fe      	b.n	900075bc <vPortEnterCritical+0x38>
}
900075be:	4770      	bx	lr
900075c0:	2400002c 	.word	0x2400002c

900075c4 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
900075c4:	4a08      	ldr	r2, [pc, #32]	; (900075e8 <vPortExitCritical+0x24>)
900075c6:	6813      	ldr	r3, [r2, #0]
900075c8:	b943      	cbnz	r3, 900075dc <vPortExitCritical+0x18>
900075ca:	f04f 0350 	mov.w	r3, #80	; 0x50
900075ce:	f383 8811 	msr	BASEPRI, r3
900075d2:	f3bf 8f6f 	isb	sy
900075d6:	f3bf 8f4f 	dsb	sy
900075da:	e7fe      	b.n	900075da <vPortExitCritical+0x16>
	uxCriticalNesting--;
900075dc:	3b01      	subs	r3, #1
900075de:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
900075e0:	b90b      	cbnz	r3, 900075e6 <vPortExitCritical+0x22>
	__asm volatile
900075e2:	f383 8811 	msr	BASEPRI, r3
}
900075e6:	4770      	bx	lr
900075e8:	2400002c 	.word	0x2400002c
900075ec:	00000000 	.word	0x00000000

900075f0 <PendSV_Handler>:
	__asm volatile
900075f0:	f3ef 8009 	mrs	r0, PSP
900075f4:	f3bf 8f6f 	isb	sy
900075f8:	4b15      	ldr	r3, [pc, #84]	; (90007650 <pxCurrentTCBConst>)
900075fa:	681a      	ldr	r2, [r3, #0]
900075fc:	f01e 0f10 	tst.w	lr, #16
90007600:	bf08      	it	eq
90007602:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
90007606:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000760a:	6010      	str	r0, [r2, #0]
9000760c:	e92d 0009 	stmdb	sp!, {r0, r3}
90007610:	f04f 0050 	mov.w	r0, #80	; 0x50
90007614:	f380 8811 	msr	BASEPRI, r0
90007618:	f3bf 8f4f 	dsb	sy
9000761c:	f3bf 8f6f 	isb	sy
90007620:	f001 f9ba 	bl	90008998 <vTaskSwitchContext>
90007624:	f04f 0000 	mov.w	r0, #0
90007628:	f380 8811 	msr	BASEPRI, r0
9000762c:	bc09      	pop	{r0, r3}
9000762e:	6819      	ldr	r1, [r3, #0]
90007630:	6808      	ldr	r0, [r1, #0]
90007632:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90007636:	f01e 0f10 	tst.w	lr, #16
9000763a:	bf08      	it	eq
9000763c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
90007640:	f380 8809 	msr	PSP, r0
90007644:	f3bf 8f6f 	isb	sy
90007648:	4770      	bx	lr
9000764a:	bf00      	nop
9000764c:	f3af 8000 	nop.w

90007650 <pxCurrentTCBConst>:
90007650:	24009508 	.word	0x24009508

90007654 <xPortSysTickHandler>:
{
90007654:	b508      	push	{r3, lr}
	__asm volatile
90007656:	f04f 0350 	mov.w	r3, #80	; 0x50
9000765a:	f383 8811 	msr	BASEPRI, r3
9000765e:	f3bf 8f6f 	isb	sy
90007662:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
90007666:	f001 f863 	bl	90008730 <xTaskIncrementTick>
9000766a:	b128      	cbz	r0, 90007678 <xPortSysTickHandler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
9000766c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007670:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007674:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
90007678:	2300      	movs	r3, #0
9000767a:	f383 8811 	msr	BASEPRI, r3
}
9000767e:	bd08      	pop	{r3, pc}

90007680 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
90007680:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
90007684:	2300      	movs	r3, #0
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
90007686:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
	portNVIC_SYSTICK_CTRL_REG = 0UL;
9000768a:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
9000768c:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
9000768e:	4b04      	ldr	r3, [pc, #16]	; (900076a0 <vPortSetupTimerInterrupt+0x20>)
90007690:	681b      	ldr	r3, [r3, #0]
90007692:	fbb3 f3f1 	udiv	r3, r3, r1
90007696:	3b01      	subs	r3, #1
90007698:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
9000769a:	2307      	movs	r3, #7
9000769c:	6113      	str	r3, [r2, #16]
}
9000769e:	4770      	bx	lr
900076a0:	2400001c 	.word	0x2400001c

900076a4 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
900076a4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
{
900076a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
900076aa:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
900076ae:	4a3a      	ldr	r2, [pc, #232]	; (90007798 <xPortStartScheduler+0xf4>)
900076b0:	4291      	cmp	r1, r2
900076b2:	d108      	bne.n	900076c6 <xPortStartScheduler+0x22>
	__asm volatile
900076b4:	f04f 0350 	mov.w	r3, #80	; 0x50
900076b8:	f383 8811 	msr	BASEPRI, r3
900076bc:	f3bf 8f6f 	isb	sy
900076c0:	f3bf 8f4f 	dsb	sy
900076c4:	e7fe      	b.n	900076c4 <xPortStartScheduler+0x20>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
900076c6:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
900076ca:	4b34      	ldr	r3, [pc, #208]	; (9000779c <xPortStartScheduler+0xf8>)
900076cc:	429a      	cmp	r2, r3
900076ce:	d108      	bne.n	900076e2 <xPortStartScheduler+0x3e>
900076d0:	f04f 0350 	mov.w	r3, #80	; 0x50
900076d4:	f383 8811 	msr	BASEPRI, r3
900076d8:	f3bf 8f6f 	isb	sy
900076dc:	f3bf 8f4f 	dsb	sy
900076e0:	e7fe      	b.n	900076e0 <xPortStartScheduler+0x3c>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
900076e2:	4b2f      	ldr	r3, [pc, #188]	; (900077a0 <xPortStartScheduler+0xfc>)
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
900076e4:	2100      	movs	r1, #0
		ulOriginalPriority = *pucFirstUserPriorityRegister;
900076e6:	781a      	ldrb	r2, [r3, #0]
900076e8:	b2d2      	uxtb	r2, r2
900076ea:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
900076ec:	22ff      	movs	r2, #255	; 0xff
900076ee:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
900076f0:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
900076f2:	4a2c      	ldr	r2, [pc, #176]	; (900077a4 <xPortStartScheduler+0x100>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
900076f4:	b2db      	uxtb	r3, r3
900076f6:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
900076fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
900076fe:	f003 0350 	and.w	r3, r3, #80	; 0x50
90007702:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
90007704:	2307      	movs	r3, #7
90007706:	4a28      	ldr	r2, [pc, #160]	; (900077a8 <xPortStartScheduler+0x104>)
90007708:	6013      	str	r3, [r2, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
9000770a:	f89d 0003 	ldrb.w	r0, [sp, #3]
9000770e:	1e5c      	subs	r4, r3, #1
90007710:	0600      	lsls	r0, r0, #24
90007712:	d40c      	bmi.n	9000772e <xPortStartScheduler+0x8a>
90007714:	b111      	cbz	r1, 9000771c <xPortStartScheduler+0x78>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
90007716:	2b03      	cmp	r3, #3
90007718:	6013      	str	r3, [r2, #0]
9000771a:	d011      	beq.n	90007740 <xPortStartScheduler+0x9c>
9000771c:	f04f 0350 	mov.w	r3, #80	; 0x50
90007720:	f383 8811 	msr	BASEPRI, r3
90007724:	f3bf 8f6f 	isb	sy
90007728:	f3bf 8f4f 	dsb	sy
9000772c:	e7fe      	b.n	9000772c <xPortStartScheduler+0x88>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
9000772e:	f89d 3003 	ldrb.w	r3, [sp, #3]
90007732:	2101      	movs	r1, #1
90007734:	005b      	lsls	r3, r3, #1
90007736:	b2db      	uxtb	r3, r3
90007738:	f88d 3003 	strb.w	r3, [sp, #3]
9000773c:	4623      	mov	r3, r4
9000773e:	e7e4      	b.n	9000770a <xPortStartScheduler+0x66>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
90007740:	f44f 7340 	mov.w	r3, #768	; 0x300
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
90007744:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
	uxCriticalNesting = 0;
90007748:	2500      	movs	r5, #0
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
9000774a:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
9000774c:	9b01      	ldr	r3, [sp, #4]
9000774e:	4a14      	ldr	r2, [pc, #80]	; (900077a0 <xPortStartScheduler+0xfc>)
90007750:	b2db      	uxtb	r3, r3
90007752:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
90007754:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
90007758:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
9000775c:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
90007760:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
90007764:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
90007768:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
9000776c:	f7ff ff88 	bl	90007680 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
90007770:	4b0e      	ldr	r3, [pc, #56]	; (900077ac <xPortStartScheduler+0x108>)
90007772:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
90007774:	f7ff feb8 	bl	900074e8 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
90007778:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
9000777c:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
90007780:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
90007784:	f7ff fe9c 	bl	900074c0 <prvPortStartFirstTask>
	vTaskSwitchContext();
90007788:	f001 f906 	bl	90008998 <vTaskSwitchContext>
}
9000778c:	4628      	mov	r0, r5
	prvTaskExitError();
9000778e:	f7ff feb5 	bl	900074fc <prvTaskExitError>
}
90007792:	b003      	add	sp, #12
90007794:	bd30      	pop	{r4, r5, pc}
90007796:	bf00      	nop
90007798:	410fc271 	.word	0x410fc271
9000779c:	410fc270 	.word	0x410fc270
900077a0:	e000e400 	.word	0xe000e400
900077a4:	240094c0 	.word	0x240094c0
900077a8:	240094c4 	.word	0x240094c4
900077ac:	2400002c 	.word	0x2400002c

900077b0 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
900077b0:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
900077b4:	2b0f      	cmp	r3, #15
900077b6:	d90e      	bls.n	900077d6 <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
900077b8:	4a11      	ldr	r2, [pc, #68]	; (90007800 <vPortValidateInterruptPriority+0x50>)
900077ba:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
900077bc:	4a11      	ldr	r2, [pc, #68]	; (90007804 <vPortValidateInterruptPriority+0x54>)
900077be:	7812      	ldrb	r2, [r2, #0]
900077c0:	429a      	cmp	r2, r3
900077c2:	d908      	bls.n	900077d6 <vPortValidateInterruptPriority+0x26>
900077c4:	f04f 0350 	mov.w	r3, #80	; 0x50
900077c8:	f383 8811 	msr	BASEPRI, r3
900077cc:	f3bf 8f6f 	isb	sy
900077d0:	f3bf 8f4f 	dsb	sy
900077d4:	e7fe      	b.n	900077d4 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
900077d6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900077da:	4a0b      	ldr	r2, [pc, #44]	; (90007808 <vPortValidateInterruptPriority+0x58>)
900077dc:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
900077e0:	6812      	ldr	r2, [r2, #0]
900077e2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
900077e6:	4293      	cmp	r3, r2
900077e8:	d908      	bls.n	900077fc <vPortValidateInterruptPriority+0x4c>
900077ea:	f04f 0350 	mov.w	r3, #80	; 0x50
900077ee:	f383 8811 	msr	BASEPRI, r3
900077f2:	f3bf 8f6f 	isb	sy
900077f6:	f3bf 8f4f 	dsb	sy
900077fa:	e7fe      	b.n	900077fa <vPortValidateInterruptPriority+0x4a>
	}
900077fc:	4770      	bx	lr
900077fe:	bf00      	nop
90007800:	e000e3f0 	.word	0xe000e3f0
90007804:	240094c0 	.word	0x240094c0
90007808:	240094c4 	.word	0x240094c4

9000780c <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
9000780c:	b510      	push	{r4, lr}
9000780e:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
90007810:	f7ff feb8 	bl	90007584 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
90007814:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
90007816:	f7ff fed5 	bl	900075c4 <vPortExitCritical>

	return xReturn;
}
9000781a:	fab4 f084 	clz	r0, r4
9000781e:	0940      	lsrs	r0, r0, #5
90007820:	bd10      	pop	{r4, pc}

90007822 <prvCopyDataToQueue>:
{
90007822:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90007824:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
90007826:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
90007828:	4604      	mov	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
9000782a:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
9000782c:	b952      	cbnz	r2, 90007844 <prvCopyDataToQueue+0x22>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9000782e:	6807      	ldr	r7, [r0, #0]
90007830:	bb47      	cbnz	r7, 90007884 <prvCopyDataToQueue+0x62>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
90007832:	6880      	ldr	r0, [r0, #8]
90007834:	f001 fa16 	bl	90008c64 <xTaskPriorityDisinherit>
90007838:	4605      	mov	r5, r0
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
9000783a:	60a7      	str	r7, [r4, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
9000783c:	3601      	adds	r6, #1
}
9000783e:	4628      	mov	r0, r5
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
90007840:	63a6      	str	r6, [r4, #56]	; 0x38
}
90007842:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	else if( xPosition == queueSEND_TO_BACK )
90007844:	b965      	cbnz	r5, 90007860 <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
90007846:	6840      	ldr	r0, [r0, #4]
90007848:	f00a f8ba 	bl	900119c0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
9000784c:	6863      	ldr	r3, [r4, #4]
9000784e:	6c22      	ldr	r2, [r4, #64]	; 0x40
90007850:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
90007852:	68a2      	ldr	r2, [r4, #8]
90007854:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
90007856:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
90007858:	d3f0      	bcc.n	9000783c <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
9000785a:	6823      	ldr	r3, [r4, #0]
9000785c:	6063      	str	r3, [r4, #4]
9000785e:	e7ed      	b.n	9000783c <prvCopyDataToQueue+0x1a>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
90007860:	68c0      	ldr	r0, [r0, #12]
90007862:	f00a f8ad 	bl	900119c0 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
90007866:	6c22      	ldr	r2, [r4, #64]	; 0x40
90007868:	68e3      	ldr	r3, [r4, #12]
9000786a:	4251      	negs	r1, r2
9000786c:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9000786e:	6822      	ldr	r2, [r4, #0]
90007870:	4293      	cmp	r3, r2
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
90007872:	60e3      	str	r3, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
90007874:	bf3e      	ittt	cc
90007876:	68a3      	ldrcc	r3, [r4, #8]
90007878:	185b      	addcc	r3, r3, r1
9000787a:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
9000787c:	2d02      	cmp	r5, #2
9000787e:	d101      	bne.n	90007884 <prvCopyDataToQueue+0x62>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
90007880:	b116      	cbz	r6, 90007888 <prvCopyDataToQueue+0x66>
				--uxMessagesWaiting;
90007882:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
90007884:	2500      	movs	r5, #0
90007886:	e7d9      	b.n	9000783c <prvCopyDataToQueue+0x1a>
90007888:	4635      	mov	r5, r6
9000788a:	e7d7      	b.n	9000783c <prvCopyDataToQueue+0x1a>

9000788c <prvCopyDataFromQueue>:
{
9000788c:	4603      	mov	r3, r0
9000788e:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
90007890:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
90007892:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
90007894:	b162      	cbz	r2, 900078b0 <prvCopyDataFromQueue+0x24>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
90007896:	68dc      	ldr	r4, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
90007898:	6899      	ldr	r1, [r3, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
9000789a:	4414      	add	r4, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
9000789c:	428c      	cmp	r4, r1
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
9000789e:	60dc      	str	r4, [r3, #12]
}
900078a0:	f85d 4b04 	ldr.w	r4, [sp], #4
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
900078a4:	bf24      	itt	cs
900078a6:	6819      	ldrcs	r1, [r3, #0]
900078a8:	60d9      	strcs	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
900078aa:	68d9      	ldr	r1, [r3, #12]
900078ac:	f00a b888 	b.w	900119c0 <memcpy>
}
900078b0:	f85d 4b04 	ldr.w	r4, [sp], #4
900078b4:	4770      	bx	lr

900078b6 <prvUnlockQueue>:
{
900078b6:	b570      	push	{r4, r5, r6, lr}
900078b8:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
900078ba:	f7ff fe63 	bl	90007584 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
900078be:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
900078c2:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
900078c6:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
900078c8:	2d00      	cmp	r5, #0
900078ca:	dc14      	bgt.n	900078f6 <prvUnlockQueue+0x40>
		pxQueue->cTxLock = queueUNLOCKED;
900078cc:	23ff      	movs	r3, #255	; 0xff
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
900078ce:	f104 0610 	add.w	r6, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
900078d2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
900078d6:	f7ff fe75 	bl	900075c4 <vPortExitCritical>
	taskENTER_CRITICAL();
900078da:	f7ff fe53 	bl	90007584 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
900078de:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
900078e2:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
900078e4:	2d00      	cmp	r5, #0
900078e6:	dc12      	bgt.n	9000790e <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
900078e8:	23ff      	movs	r3, #255	; 0xff
900078ea:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
}
900078ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
900078f2:	f7ff be67 	b.w	900075c4 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
900078f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
900078f8:	2b00      	cmp	r3, #0
900078fa:	d0e7      	beq.n	900078cc <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
900078fc:	4630      	mov	r0, r6
900078fe:	f001 f8c9 	bl	90008a94 <xTaskRemoveFromEventList>
90007902:	b108      	cbz	r0, 90007908 <prvUnlockQueue+0x52>
						vTaskMissedYield();
90007904:	f001 f952 	bl	90008bac <vTaskMissedYield>
			--cTxLock;
90007908:	3d01      	subs	r5, #1
9000790a:	b26d      	sxtb	r5, r5
9000790c:	e7dc      	b.n	900078c8 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9000790e:	6923      	ldr	r3, [r4, #16]
90007910:	2b00      	cmp	r3, #0
90007912:	d0e9      	beq.n	900078e8 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
90007914:	4630      	mov	r0, r6
90007916:	f001 f8bd 	bl	90008a94 <xTaskRemoveFromEventList>
9000791a:	b108      	cbz	r0, 90007920 <prvUnlockQueue+0x6a>
					vTaskMissedYield();
9000791c:	f001 f946 	bl	90008bac <vTaskMissedYield>
				--cRxLock;
90007920:	3d01      	subs	r5, #1
90007922:	b26d      	sxtb	r5, r5
90007924:	e7de      	b.n	900078e4 <prvUnlockQueue+0x2e>

90007926 <xQueueGenericReset>:
{
90007926:	b538      	push	{r3, r4, r5, lr}
90007928:	460d      	mov	r5, r1
	configASSERT( pxQueue );
9000792a:	4604      	mov	r4, r0
9000792c:	b940      	cbnz	r0, 90007940 <xQueueGenericReset+0x1a>
9000792e:	f04f 0350 	mov.w	r3, #80	; 0x50
90007932:	f383 8811 	msr	BASEPRI, r3
90007936:	f3bf 8f6f 	isb	sy
9000793a:	f3bf 8f4f 	dsb	sy
9000793e:	e7fe      	b.n	9000793e <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
90007940:	f7ff fe20 	bl	90007584 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
90007944:	6822      	ldr	r2, [r4, #0]
90007946:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
		pxQueue->pcWriteTo = pxQueue->pcHead;
9000794a:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
9000794c:	434b      	muls	r3, r1
9000794e:	18d0      	adds	r0, r2, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
90007950:	1a5b      	subs	r3, r3, r1
90007952:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
90007954:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
90007956:	2000      	movs	r0, #0
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
90007958:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
9000795a:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
9000795c:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
9000795e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
90007962:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
90007966:	b9a5      	cbnz	r5, 90007992 <xQueueGenericReset+0x6c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
90007968:	6923      	ldr	r3, [r4, #16]
9000796a:	b173      	cbz	r3, 9000798a <xQueueGenericReset+0x64>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9000796c:	f104 0010 	add.w	r0, r4, #16
90007970:	f001 f890 	bl	90008a94 <xTaskRemoveFromEventList>
90007974:	b148      	cbz	r0, 9000798a <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
90007976:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
9000797a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
9000797e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90007982:	f3bf 8f4f 	dsb	sy
90007986:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
9000798a:	f7ff fe1b 	bl	900075c4 <vPortExitCritical>
}
9000798e:	2001      	movs	r0, #1
90007990:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
90007992:	f104 0010 	add.w	r0, r4, #16
90007996:	f7ff fd51 	bl	9000743c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
9000799a:	f104 0024 	add.w	r0, r4, #36	; 0x24
9000799e:	f7ff fd4d 	bl	9000743c <vListInitialise>
900079a2:	e7f2      	b.n	9000798a <xQueueGenericReset+0x64>

900079a4 <xQueueGenericCreateStatic>:
	{
900079a4:	b513      	push	{r0, r1, r4, lr}
900079a6:	461c      	mov	r4, r3
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
900079a8:	b940      	cbnz	r0, 900079bc <xQueueGenericCreateStatic+0x18>
900079aa:	f04f 0350 	mov.w	r3, #80	; 0x50
900079ae:	f383 8811 	msr	BASEPRI, r3
900079b2:	f3bf 8f6f 	isb	sy
900079b6:	f3bf 8f4f 	dsb	sy
900079ba:	e7fe      	b.n	900079ba <xQueueGenericCreateStatic+0x16>
		configASSERT( pxStaticQueue != NULL );
900079bc:	b943      	cbnz	r3, 900079d0 <xQueueGenericCreateStatic+0x2c>
900079be:	f04f 0350 	mov.w	r3, #80	; 0x50
900079c2:	f383 8811 	msr	BASEPRI, r3
900079c6:	f3bf 8f6f 	isb	sy
900079ca:	f3bf 8f4f 	dsb	sy
900079ce:	e7fe      	b.n	900079ce <xQueueGenericCreateStatic+0x2a>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
900079d0:	b14a      	cbz	r2, 900079e6 <xQueueGenericCreateStatic+0x42>
900079d2:	b991      	cbnz	r1, 900079fa <xQueueGenericCreateStatic+0x56>
900079d4:	f04f 0350 	mov.w	r3, #80	; 0x50
900079d8:	f383 8811 	msr	BASEPRI, r3
900079dc:	f3bf 8f6f 	isb	sy
900079e0:	f3bf 8f4f 	dsb	sy
900079e4:	e7fe      	b.n	900079e4 <xQueueGenericCreateStatic+0x40>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
900079e6:	b141      	cbz	r1, 900079fa <xQueueGenericCreateStatic+0x56>
900079e8:	f04f 0350 	mov.w	r3, #80	; 0x50
900079ec:	f383 8811 	msr	BASEPRI, r3
900079f0:	f3bf 8f6f 	isb	sy
900079f4:	f3bf 8f4f 	dsb	sy
900079f8:	e7fe      	b.n	900079f8 <xQueueGenericCreateStatic+0x54>
			volatile size_t xSize = sizeof( StaticQueue_t );
900079fa:	2350      	movs	r3, #80	; 0x50
900079fc:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
900079fe:	9b01      	ldr	r3, [sp, #4]
90007a00:	2b50      	cmp	r3, #80	; 0x50
90007a02:	d008      	beq.n	90007a16 <xQueueGenericCreateStatic+0x72>
90007a04:	f04f 0350 	mov.w	r3, #80	; 0x50
90007a08:	f383 8811 	msr	BASEPRI, r3
90007a0c:	f3bf 8f6f 	isb	sy
90007a10:	f3bf 8f4f 	dsb	sy
90007a14:	e7fe      	b.n	90007a14 <xQueueGenericCreateStatic+0x70>
	if( uxItemSize == ( UBaseType_t ) 0 )
90007a16:	2900      	cmp	r1, #0
90007a18:	bf08      	it	eq
90007a1a:	4622      	moveq	r2, r4
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
90007a1c:	9b01      	ldr	r3, [sp, #4]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
90007a1e:	2301      	movs	r3, #1
90007a20:	6022      	str	r2, [r4, #0]
90007a22:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
90007a26:	e9c4 010f 	strd	r0, r1, [r4, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
90007a2a:	4619      	mov	r1, r3
90007a2c:	4620      	mov	r0, r4
90007a2e:	f7ff ff7a 	bl	90007926 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
90007a32:	f89d 3010 	ldrb.w	r3, [sp, #16]
	}
90007a36:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
90007a38:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
	}
90007a3c:	b002      	add	sp, #8
90007a3e:	bd10      	pop	{r4, pc}

90007a40 <xQueueGenericCreate>:
	{
90007a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90007a42:	460d      	mov	r5, r1
90007a44:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
90007a46:	4606      	mov	r6, r0
90007a48:	b940      	cbnz	r0, 90007a5c <xQueueGenericCreate+0x1c>
90007a4a:	f04f 0350 	mov.w	r3, #80	; 0x50
90007a4e:	f383 8811 	msr	BASEPRI, r3
90007a52:	f3bf 8f6f 	isb	sy
90007a56:	f3bf 8f4f 	dsb	sy
90007a5a:	e7fe      	b.n	90007a5a <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90007a5c:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
90007a5e:	3050      	adds	r0, #80	; 0x50
90007a60:	f7ff fc16 	bl	90007290 <pvPortMalloc>
		if( pxNewQueue != NULL )
90007a64:	4604      	mov	r4, r0
90007a66:	b170      	cbz	r0, 90007a86 <xQueueGenericCreate+0x46>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
90007a68:	2300      	movs	r3, #0
90007a6a:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
	if( uxItemSize == ( UBaseType_t ) 0 )
90007a6e:	b165      	cbz	r5, 90007a8a <xQueueGenericCreate+0x4a>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
90007a70:	f100 0350 	add.w	r3, r0, #80	; 0x50
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
90007a74:	2101      	movs	r1, #1
90007a76:	4620      	mov	r0, r4
90007a78:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
90007a7a:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
90007a7e:	f7ff ff52 	bl	90007926 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
90007a82:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
90007a86:	4620      	mov	r0, r4
90007a88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
90007a8a:	4603      	mov	r3, r0
90007a8c:	e7f2      	b.n	90007a74 <xQueueGenericCreate+0x34>

90007a8e <xQueueCreateCountingSemaphoreStatic>:
	{
90007a8e:	b513      	push	{r0, r1, r4, lr}
90007a90:	4613      	mov	r3, r2
90007a92:	460c      	mov	r4, r1
		configASSERT( uxMaxCount != 0 );
90007a94:	b940      	cbnz	r0, 90007aa8 <xQueueCreateCountingSemaphoreStatic+0x1a>
90007a96:	f04f 0350 	mov.w	r3, #80	; 0x50
90007a9a:	f383 8811 	msr	BASEPRI, r3
90007a9e:	f3bf 8f6f 	isb	sy
90007aa2:	f3bf 8f4f 	dsb	sy
90007aa6:	e7fe      	b.n	90007aa6 <xQueueCreateCountingSemaphoreStatic+0x18>
		configASSERT( uxInitialCount <= uxMaxCount );
90007aa8:	4288      	cmp	r0, r1
90007aaa:	d208      	bcs.n	90007abe <xQueueCreateCountingSemaphoreStatic+0x30>
90007aac:	f04f 0350 	mov.w	r3, #80	; 0x50
90007ab0:	f383 8811 	msr	BASEPRI, r3
90007ab4:	f3bf 8f6f 	isb	sy
90007ab8:	f3bf 8f4f 	dsb	sy
90007abc:	e7fe      	b.n	90007abc <xQueueCreateCountingSemaphoreStatic+0x2e>
		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
90007abe:	2202      	movs	r2, #2
90007ac0:	9200      	str	r2, [sp, #0]
90007ac2:	2200      	movs	r2, #0
90007ac4:	4611      	mov	r1, r2
90007ac6:	f7ff ff6d 	bl	900079a4 <xQueueGenericCreateStatic>
		if( xHandle != NULL )
90007aca:	b100      	cbz	r0, 90007ace <xQueueCreateCountingSemaphoreStatic+0x40>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
90007acc:	6384      	str	r4, [r0, #56]	; 0x38
	}
90007ace:	b002      	add	sp, #8
90007ad0:	bd10      	pop	{r4, pc}

90007ad2 <xQueueCreateCountingSemaphore>:
	{
90007ad2:	b510      	push	{r4, lr}
90007ad4:	460c      	mov	r4, r1
		configASSERT( uxMaxCount != 0 );
90007ad6:	b940      	cbnz	r0, 90007aea <xQueueCreateCountingSemaphore+0x18>
90007ad8:	f04f 0350 	mov.w	r3, #80	; 0x50
90007adc:	f383 8811 	msr	BASEPRI, r3
90007ae0:	f3bf 8f6f 	isb	sy
90007ae4:	f3bf 8f4f 	dsb	sy
90007ae8:	e7fe      	b.n	90007ae8 <xQueueCreateCountingSemaphore+0x16>
		configASSERT( uxInitialCount <= uxMaxCount );
90007aea:	4288      	cmp	r0, r1
90007aec:	d208      	bcs.n	90007b00 <xQueueCreateCountingSemaphore+0x2e>
90007aee:	f04f 0350 	mov.w	r3, #80	; 0x50
90007af2:	f383 8811 	msr	BASEPRI, r3
90007af6:	f3bf 8f6f 	isb	sy
90007afa:	f3bf 8f4f 	dsb	sy
90007afe:	e7fe      	b.n	90007afe <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
90007b00:	2202      	movs	r2, #2
90007b02:	2100      	movs	r1, #0
90007b04:	f7ff ff9c 	bl	90007a40 <xQueueGenericCreate>
		if( xHandle != NULL )
90007b08:	b100      	cbz	r0, 90007b0c <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
90007b0a:	6384      	str	r4, [r0, #56]	; 0x38
	}
90007b0c:	bd10      	pop	{r4, pc}

90007b0e <xQueueGenericSend>:
{
90007b0e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
90007b12:	b085      	sub	sp, #20
90007b14:	4688      	mov	r8, r1
90007b16:	461f      	mov	r7, r3
	configASSERT( pxQueue );
90007b18:	4604      	mov	r4, r0
{
90007b1a:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
90007b1c:	b940      	cbnz	r0, 90007b30 <xQueueGenericSend+0x22>
90007b1e:	f04f 0350 	mov.w	r3, #80	; 0x50
90007b22:	f383 8811 	msr	BASEPRI, r3
90007b26:	f3bf 8f6f 	isb	sy
90007b2a:	f3bf 8f4f 	dsb	sy
90007b2e:	e7fe      	b.n	90007b2e <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
90007b30:	b951      	cbnz	r1, 90007b48 <xQueueGenericSend+0x3a>
90007b32:	6c03      	ldr	r3, [r0, #64]	; 0x40
90007b34:	b143      	cbz	r3, 90007b48 <xQueueGenericSend+0x3a>
90007b36:	f04f 0350 	mov.w	r3, #80	; 0x50
90007b3a:	f383 8811 	msr	BASEPRI, r3
90007b3e:	f3bf 8f6f 	isb	sy
90007b42:	f3bf 8f4f 	dsb	sy
90007b46:	e7fe      	b.n	90007b46 <xQueueGenericSend+0x38>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
90007b48:	2f02      	cmp	r7, #2
90007b4a:	d10b      	bne.n	90007b64 <xQueueGenericSend+0x56>
90007b4c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007b4e:	2b01      	cmp	r3, #1
90007b50:	d008      	beq.n	90007b64 <xQueueGenericSend+0x56>
90007b52:	f04f 0350 	mov.w	r3, #80	; 0x50
90007b56:	f383 8811 	msr	BASEPRI, r3
90007b5a:	f3bf 8f6f 	isb	sy
90007b5e:	f3bf 8f4f 	dsb	sy
90007b62:	e7fe      	b.n	90007b62 <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
90007b64:	f001 f82e 	bl	90008bc4 <xTaskGetSchedulerState>
90007b68:	4606      	mov	r6, r0
90007b6a:	b950      	cbnz	r0, 90007b82 <xQueueGenericSend+0x74>
90007b6c:	9b01      	ldr	r3, [sp, #4]
90007b6e:	b14b      	cbz	r3, 90007b84 <xQueueGenericSend+0x76>
90007b70:	f04f 0350 	mov.w	r3, #80	; 0x50
90007b74:	f383 8811 	msr	BASEPRI, r3
90007b78:	f3bf 8f6f 	isb	sy
90007b7c:	f3bf 8f4f 	dsb	sy
90007b80:	e7fe      	b.n	90007b80 <xQueueGenericSend+0x72>
90007b82:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
90007b84:	f04f 0900 	mov.w	r9, #0
90007b88:	e037      	b.n	90007bfa <xQueueGenericSend+0xec>
				if( xTicksToWait == ( TickType_t ) 0 )
90007b8a:	9d01      	ldr	r5, [sp, #4]
90007b8c:	b91d      	cbnz	r5, 90007b96 <xQueueGenericSend+0x88>
					taskEXIT_CRITICAL();
90007b8e:	f7ff fd19 	bl	900075c4 <vPortExitCritical>
			return errQUEUE_FULL;
90007b92:	2000      	movs	r0, #0
90007b94:	e052      	b.n	90007c3c <xQueueGenericSend+0x12e>
				else if( xEntryTimeSet == pdFALSE )
90007b96:	b916      	cbnz	r6, 90007b9e <xQueueGenericSend+0x90>
					vTaskInternalSetTimeOutState( &xTimeOut );
90007b98:	a802      	add	r0, sp, #8
90007b9a:	f000 ffbf 	bl	90008b1c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
90007b9e:	f7ff fd11 	bl	900075c4 <vPortExitCritical>
		vTaskSuspendAll();
90007ba2:	f000 fdaf 	bl	90008704 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
90007ba6:	f7ff fced 	bl	90007584 <vPortEnterCritical>
90007baa:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
90007bae:	2bff      	cmp	r3, #255	; 0xff
90007bb0:	d101      	bne.n	90007bb6 <xQueueGenericSend+0xa8>
90007bb2:	f884 9044 	strb.w	r9, [r4, #68]	; 0x44
90007bb6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
90007bba:	2bff      	cmp	r3, #255	; 0xff
90007bbc:	d101      	bne.n	90007bc2 <xQueueGenericSend+0xb4>
90007bbe:	f884 9045 	strb.w	r9, [r4, #69]	; 0x45
90007bc2:	f7ff fcff 	bl	900075c4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
90007bc6:	a901      	add	r1, sp, #4
90007bc8:	a802      	add	r0, sp, #8
90007bca:	f000 ffb3 	bl	90008b34 <xTaskCheckForTimeOut>
90007bce:	2800      	cmp	r0, #0
90007bd0:	d14a      	bne.n	90007c68 <xQueueGenericSend+0x15a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
90007bd2:	f7ff fcd7 	bl	90007584 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
90007bd6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90007bd8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007bda:	429a      	cmp	r2, r3
90007bdc:	d131      	bne.n	90007c42 <xQueueGenericSend+0x134>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
90007bde:	f7ff fcf1 	bl	900075c4 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
90007be2:	9901      	ldr	r1, [sp, #4]
90007be4:	f104 0010 	add.w	r0, r4, #16
90007be8:	f000 ff1c 	bl	90008a24 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
90007bec:	4620      	mov	r0, r4
90007bee:	f7ff fe62 	bl	900078b6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
90007bf2:	f000 fe39 	bl	90008868 <xTaskResumeAll>
90007bf6:	b360      	cbz	r0, 90007c52 <xQueueGenericSend+0x144>
90007bf8:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
90007bfa:	f7ff fcc3 	bl	90007584 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
90007bfe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90007c00:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007c02:	429a      	cmp	r2, r3
90007c04:	d301      	bcc.n	90007c0a <xQueueGenericSend+0xfc>
90007c06:	2f02      	cmp	r7, #2
90007c08:	d1bf      	bne.n	90007b8a <xQueueGenericSend+0x7c>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
90007c0a:	463a      	mov	r2, r7
90007c0c:	4641      	mov	r1, r8
90007c0e:	4620      	mov	r0, r4
90007c10:	f7ff fe07 	bl	90007822 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
90007c14:	6a63      	ldr	r3, [r4, #36]	; 0x24
90007c16:	b11b      	cbz	r3, 90007c20 <xQueueGenericSend+0x112>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
90007c18:	f104 0024 	add.w	r0, r4, #36	; 0x24
90007c1c:	f000 ff3a 	bl	90008a94 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
90007c20:	b148      	cbz	r0, 90007c36 <xQueueGenericSend+0x128>
						queueYIELD_IF_USING_PREEMPTION();
90007c22:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007c26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007c2a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90007c2e:	f3bf 8f4f 	dsb	sy
90007c32:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
90007c36:	f7ff fcc5 	bl	900075c4 <vPortExitCritical>
				return pdPASS;
90007c3a:	2001      	movs	r0, #1
}
90007c3c:	b005      	add	sp, #20
90007c3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	taskEXIT_CRITICAL();
90007c42:	f7ff fcbf 	bl	900075c4 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
90007c46:	4620      	mov	r0, r4
90007c48:	f7ff fe35 	bl	900078b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
90007c4c:	f000 fe0c 	bl	90008868 <xTaskResumeAll>
90007c50:	e7d2      	b.n	90007bf8 <xQueueGenericSend+0xea>
					portYIELD_WITHIN_API();
90007c52:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007c56:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007c5a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90007c5e:	f3bf 8f4f 	dsb	sy
90007c62:	f3bf 8f6f 	isb	sy
90007c66:	e7c7      	b.n	90007bf8 <xQueueGenericSend+0xea>
			prvUnlockQueue( pxQueue );
90007c68:	4620      	mov	r0, r4
90007c6a:	f7ff fe24 	bl	900078b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
90007c6e:	f000 fdfb 	bl	90008868 <xTaskResumeAll>
90007c72:	e78e      	b.n	90007b92 <xQueueGenericSend+0x84>

90007c74 <xQueueCreateMutexStatic>:
		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
90007c74:	2200      	movs	r2, #0
	{
90007c76:	460b      	mov	r3, r1
90007c78:	b513      	push	{r0, r1, r4, lr}
		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
90007c7a:	4611      	mov	r1, r2
90007c7c:	9000      	str	r0, [sp, #0]
90007c7e:	2001      	movs	r0, #1
90007c80:	f7ff fe90 	bl	900079a4 <xQueueGenericCreateStatic>
		if( pxNewQueue != NULL )
90007c84:	4604      	mov	r4, r0
90007c86:	b138      	cbz	r0, 90007c98 <xQueueCreateMutexStatic+0x24>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
90007c88:	2300      	movs	r3, #0
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
90007c8a:	461a      	mov	r2, r3
90007c8c:	4619      	mov	r1, r3
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
90007c8e:	6083      	str	r3, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
90007c90:	6003      	str	r3, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
90007c92:	60c3      	str	r3, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
90007c94:	f7ff ff3b 	bl	90007b0e <xQueueGenericSend>
	}
90007c98:	4620      	mov	r0, r4
90007c9a:	b002      	add	sp, #8
90007c9c:	bd10      	pop	{r4, pc}

90007c9e <xQueueGiveMutexRecursive>:
	{
90007c9e:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxMutex );
90007ca0:	4604      	mov	r4, r0
90007ca2:	b940      	cbnz	r0, 90007cb6 <xQueueGiveMutexRecursive+0x18>
90007ca4:	f04f 0350 	mov.w	r3, #80	; 0x50
90007ca8:	f383 8811 	msr	BASEPRI, r3
90007cac:	f3bf 8f6f 	isb	sy
90007cb0:	f3bf 8f4f 	dsb	sy
90007cb4:	e7fe      	b.n	90007cb4 <xQueueGiveMutexRecursive+0x16>
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
90007cb6:	6885      	ldr	r5, [r0, #8]
90007cb8:	f000 ff7e 	bl	90008bb8 <xTaskGetCurrentTaskHandle>
90007cbc:	4285      	cmp	r5, r0
90007cbe:	d10a      	bne.n	90007cd6 <xQueueGiveMutexRecursive+0x38>
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
90007cc0:	68e3      	ldr	r3, [r4, #12]
90007cc2:	3b01      	subs	r3, #1
90007cc4:	60e3      	str	r3, [r4, #12]
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
90007cc6:	b923      	cbnz	r3, 90007cd2 <xQueueGiveMutexRecursive+0x34>
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
90007cc8:	461a      	mov	r2, r3
90007cca:	4619      	mov	r1, r3
90007ccc:	4620      	mov	r0, r4
90007cce:	f7ff ff1e 	bl	90007b0e <xQueueGenericSend>
			xReturn = pdPASS;
90007cd2:	2001      	movs	r0, #1
		return xReturn;
90007cd4:	e000      	b.n	90007cd8 <xQueueGiveMutexRecursive+0x3a>
			xReturn = pdFAIL;
90007cd6:	2000      	movs	r0, #0
	}
90007cd8:	bd38      	pop	{r3, r4, r5, pc}

90007cda <xQueueCreateMutex>:
	{
90007cda:	b570      	push	{r4, r5, r6, lr}
90007cdc:	4606      	mov	r6, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
90007cde:	2050      	movs	r0, #80	; 0x50
90007ce0:	f7ff fad6 	bl	90007290 <pvPortMalloc>
		if( pxNewQueue != NULL )
90007ce4:	4604      	mov	r4, r0
90007ce6:	b198      	cbz	r0, 90007d10 <xQueueCreateMutex+0x36>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
90007ce8:	2500      	movs	r5, #0
	pxNewQueue->uxLength = uxQueueLength;
90007cea:	2101      	movs	r1, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
90007cec:	6000      	str	r0, [r0, #0]
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
90007cee:	f880 5046 	strb.w	r5, [r0, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
90007cf2:	e9c0 150f 	strd	r1, r5, [r0, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
90007cf6:	f7ff fe16 	bl	90007926 <xQueueGenericReset>
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
90007cfa:	462b      	mov	r3, r5
90007cfc:	462a      	mov	r2, r5
90007cfe:	4629      	mov	r1, r5
90007d00:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
90007d02:	f884 604c 	strb.w	r6, [r4, #76]	; 0x4c
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
90007d06:	60a5      	str	r5, [r4, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
90007d08:	6025      	str	r5, [r4, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
90007d0a:	60e5      	str	r5, [r4, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
90007d0c:	f7ff feff 	bl	90007b0e <xQueueGenericSend>
	}
90007d10:	4620      	mov	r0, r4
90007d12:	bd70      	pop	{r4, r5, r6, pc}

90007d14 <xQueueGenericSendFromISR>:
{
90007d14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
90007d18:	4689      	mov	r9, r1
90007d1a:	4690      	mov	r8, r2
90007d1c:	461f      	mov	r7, r3
	configASSERT( pxQueue );
90007d1e:	4604      	mov	r4, r0
90007d20:	b940      	cbnz	r0, 90007d34 <xQueueGenericSendFromISR+0x20>
90007d22:	f04f 0350 	mov.w	r3, #80	; 0x50
90007d26:	f383 8811 	msr	BASEPRI, r3
90007d2a:	f3bf 8f6f 	isb	sy
90007d2e:	f3bf 8f4f 	dsb	sy
90007d32:	e7fe      	b.n	90007d32 <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
90007d34:	b951      	cbnz	r1, 90007d4c <xQueueGenericSendFromISR+0x38>
90007d36:	6c03      	ldr	r3, [r0, #64]	; 0x40
90007d38:	b143      	cbz	r3, 90007d4c <xQueueGenericSendFromISR+0x38>
90007d3a:	f04f 0350 	mov.w	r3, #80	; 0x50
90007d3e:	f383 8811 	msr	BASEPRI, r3
90007d42:	f3bf 8f6f 	isb	sy
90007d46:	f3bf 8f4f 	dsb	sy
90007d4a:	e7fe      	b.n	90007d4a <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
90007d4c:	2f02      	cmp	r7, #2
90007d4e:	d10b      	bne.n	90007d68 <xQueueGenericSendFromISR+0x54>
90007d50:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007d52:	2b01      	cmp	r3, #1
90007d54:	d008      	beq.n	90007d68 <xQueueGenericSendFromISR+0x54>
90007d56:	f04f 0350 	mov.w	r3, #80	; 0x50
90007d5a:	f383 8811 	msr	BASEPRI, r3
90007d5e:	f3bf 8f6f 	isb	sy
90007d62:	f3bf 8f4f 	dsb	sy
90007d66:	e7fe      	b.n	90007d66 <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
90007d68:	f7ff fd22 	bl	900077b0 <vPortValidateInterruptPriority>
	__asm volatile
90007d6c:	f3ef 8611 	mrs	r6, BASEPRI
90007d70:	f04f 0350 	mov.w	r3, #80	; 0x50
90007d74:	f383 8811 	msr	BASEPRI, r3
90007d78:	f3bf 8f6f 	isb	sy
90007d7c:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
90007d80:	6ba2      	ldr	r2, [r4, #56]	; 0x38
90007d82:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007d84:	429a      	cmp	r2, r3
90007d86:	d301      	bcc.n	90007d8c <xQueueGenericSendFromISR+0x78>
90007d88:	2f02      	cmp	r7, #2
90007d8a:	d123      	bne.n	90007dd4 <xQueueGenericSendFromISR+0xc0>
			const int8_t cTxLock = pxQueue->cTxLock;
90007d8c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
90007d90:	463a      	mov	r2, r7
90007d92:	4649      	mov	r1, r9
90007d94:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
90007d96:	b26d      	sxtb	r5, r5
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
90007d98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
90007d9a:	f7ff fd42 	bl	90007822 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
90007d9e:	1c6b      	adds	r3, r5, #1
90007da0:	d113      	bne.n	90007dca <xQueueGenericSendFromISR+0xb6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
90007da2:	6a63      	ldr	r3, [r4, #36]	; 0x24
90007da4:	b90b      	cbnz	r3, 90007daa <xQueueGenericSendFromISR+0x96>
			xReturn = pdPASS;
90007da6:	2001      	movs	r0, #1
90007da8:	e00b      	b.n	90007dc2 <xQueueGenericSendFromISR+0xae>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
90007daa:	f104 0024 	add.w	r0, r4, #36	; 0x24
90007dae:	f000 fe71 	bl	90008a94 <xTaskRemoveFromEventList>
90007db2:	2800      	cmp	r0, #0
90007db4:	d0f7      	beq.n	90007da6 <xQueueGenericSendFromISR+0x92>
							if( pxHigherPriorityTaskWoken != NULL )
90007db6:	f1b8 0f00 	cmp.w	r8, #0
90007dba:	d0f4      	beq.n	90007da6 <xQueueGenericSendFromISR+0x92>
								*pxHigherPriorityTaskWoken = pdTRUE;
90007dbc:	2001      	movs	r0, #1
90007dbe:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
90007dc2:	f386 8811 	msr	BASEPRI, r6
}
90007dc6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
90007dca:	3501      	adds	r5, #1
90007dcc:	b26d      	sxtb	r5, r5
90007dce:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
90007dd2:	e7e8      	b.n	90007da6 <xQueueGenericSendFromISR+0x92>
			xReturn = errQUEUE_FULL;
90007dd4:	2000      	movs	r0, #0
90007dd6:	e7f4      	b.n	90007dc2 <xQueueGenericSendFromISR+0xae>

90007dd8 <xQueueGiveFromISR>:
{
90007dd8:	b570      	push	{r4, r5, r6, lr}
90007dda:	460d      	mov	r5, r1
	configASSERT( pxQueue );
90007ddc:	4604      	mov	r4, r0
90007dde:	b940      	cbnz	r0, 90007df2 <xQueueGiveFromISR+0x1a>
	__asm volatile
90007de0:	f04f 0350 	mov.w	r3, #80	; 0x50
90007de4:	f383 8811 	msr	BASEPRI, r3
90007de8:	f3bf 8f6f 	isb	sy
90007dec:	f3bf 8f4f 	dsb	sy
90007df0:	e7fe      	b.n	90007df0 <xQueueGiveFromISR+0x18>
	configASSERT( pxQueue->uxItemSize == 0 );
90007df2:	6c03      	ldr	r3, [r0, #64]	; 0x40
90007df4:	b143      	cbz	r3, 90007e08 <xQueueGiveFromISR+0x30>
90007df6:	f04f 0350 	mov.w	r3, #80	; 0x50
90007dfa:	f383 8811 	msr	BASEPRI, r3
90007dfe:	f3bf 8f6f 	isb	sy
90007e02:	f3bf 8f4f 	dsb	sy
90007e06:	e7fe      	b.n	90007e06 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
90007e08:	6803      	ldr	r3, [r0, #0]
90007e0a:	b953      	cbnz	r3, 90007e22 <xQueueGiveFromISR+0x4a>
90007e0c:	6883      	ldr	r3, [r0, #8]
90007e0e:	b143      	cbz	r3, 90007e22 <xQueueGiveFromISR+0x4a>
90007e10:	f04f 0350 	mov.w	r3, #80	; 0x50
90007e14:	f383 8811 	msr	BASEPRI, r3
90007e18:	f3bf 8f6f 	isb	sy
90007e1c:	f3bf 8f4f 	dsb	sy
90007e20:	e7fe      	b.n	90007e20 <xQueueGiveFromISR+0x48>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
90007e22:	f7ff fcc5 	bl	900077b0 <vPortValidateInterruptPriority>
	__asm volatile
90007e26:	f3ef 8611 	mrs	r6, BASEPRI
90007e2a:	f04f 0350 	mov.w	r3, #80	; 0x50
90007e2e:	f383 8811 	msr	BASEPRI, r3
90007e32:	f3bf 8f6f 	isb	sy
90007e36:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
90007e3a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
90007e3c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90007e3e:	4293      	cmp	r3, r2
90007e40:	d91c      	bls.n	90007e7c <xQueueGiveFromISR+0xa4>
			const int8_t cTxLock = pxQueue->cTxLock;
90007e42:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
90007e46:	3201      	adds	r2, #1
			if( cTxLock == queueUNLOCKED )
90007e48:	29ff      	cmp	r1, #255	; 0xff
			const int8_t cTxLock = pxQueue->cTxLock;
90007e4a:	b24b      	sxtb	r3, r1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
90007e4c:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
90007e4e:	d110      	bne.n	90007e72 <xQueueGiveFromISR+0x9a>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
90007e50:	6a63      	ldr	r3, [r4, #36]	; 0x24
90007e52:	b90b      	cbnz	r3, 90007e58 <xQueueGiveFromISR+0x80>
			xReturn = pdPASS;
90007e54:	2001      	movs	r0, #1
90007e56:	e009      	b.n	90007e6c <xQueueGiveFromISR+0x94>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
90007e58:	f104 0024 	add.w	r0, r4, #36	; 0x24
90007e5c:	f000 fe1a 	bl	90008a94 <xTaskRemoveFromEventList>
90007e60:	2800      	cmp	r0, #0
90007e62:	d0f7      	beq.n	90007e54 <xQueueGiveFromISR+0x7c>
							if( pxHigherPriorityTaskWoken != NULL )
90007e64:	2d00      	cmp	r5, #0
90007e66:	d0f5      	beq.n	90007e54 <xQueueGiveFromISR+0x7c>
								*pxHigherPriorityTaskWoken = pdTRUE;
90007e68:	2001      	movs	r0, #1
90007e6a:	6028      	str	r0, [r5, #0]
	__asm volatile
90007e6c:	f386 8811 	msr	BASEPRI, r6
}
90007e70:	bd70      	pop	{r4, r5, r6, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
90007e72:	3301      	adds	r3, #1
90007e74:	b25b      	sxtb	r3, r3
90007e76:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
90007e7a:	e7eb      	b.n	90007e54 <xQueueGiveFromISR+0x7c>
			xReturn = errQUEUE_FULL;
90007e7c:	2000      	movs	r0, #0
90007e7e:	e7f5      	b.n	90007e6c <xQueueGiveFromISR+0x94>

90007e80 <xQueueReceive>:
{
90007e80:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
90007e84:	460f      	mov	r7, r1
	configASSERT( ( pxQueue ) );
90007e86:	4604      	mov	r4, r0
{
90007e88:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
90007e8a:	b940      	cbnz	r0, 90007e9e <xQueueReceive+0x1e>
	__asm volatile
90007e8c:	f04f 0350 	mov.w	r3, #80	; 0x50
90007e90:	f383 8811 	msr	BASEPRI, r3
90007e94:	f3bf 8f6f 	isb	sy
90007e98:	f3bf 8f4f 	dsb	sy
90007e9c:	e7fe      	b.n	90007e9c <xQueueReceive+0x1c>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
90007e9e:	b951      	cbnz	r1, 90007eb6 <xQueueReceive+0x36>
90007ea0:	6c03      	ldr	r3, [r0, #64]	; 0x40
90007ea2:	b143      	cbz	r3, 90007eb6 <xQueueReceive+0x36>
90007ea4:	f04f 0350 	mov.w	r3, #80	; 0x50
90007ea8:	f383 8811 	msr	BASEPRI, r3
90007eac:	f3bf 8f6f 	isb	sy
90007eb0:	f3bf 8f4f 	dsb	sy
90007eb4:	e7fe      	b.n	90007eb4 <xQueueReceive+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
90007eb6:	f000 fe85 	bl	90008bc4 <xTaskGetSchedulerState>
90007eba:	4606      	mov	r6, r0
90007ebc:	b950      	cbnz	r0, 90007ed4 <xQueueReceive+0x54>
90007ebe:	9b01      	ldr	r3, [sp, #4]
90007ec0:	b14b      	cbz	r3, 90007ed6 <xQueueReceive+0x56>
90007ec2:	f04f 0350 	mov.w	r3, #80	; 0x50
90007ec6:	f383 8811 	msr	BASEPRI, r3
90007eca:	f3bf 8f6f 	isb	sy
90007ece:	f3bf 8f4f 	dsb	sy
90007ed2:	e7fe      	b.n	90007ed2 <xQueueReceive+0x52>
90007ed4:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
90007ed6:	f04f 0800 	mov.w	r8, #0
90007eda:	e03d      	b.n	90007f58 <xQueueReceive+0xd8>
				if( xTicksToWait == ( TickType_t ) 0 )
90007edc:	9d01      	ldr	r5, [sp, #4]
90007ede:	b91d      	cbnz	r5, 90007ee8 <xQueueReceive+0x68>
					taskEXIT_CRITICAL();
90007ee0:	f7ff fb70 	bl	900075c4 <vPortExitCritical>
				return errQUEUE_EMPTY;
90007ee4:	2000      	movs	r0, #0
90007ee6:	e056      	b.n	90007f96 <xQueueReceive+0x116>
				else if( xEntryTimeSet == pdFALSE )
90007ee8:	b916      	cbnz	r6, 90007ef0 <xQueueReceive+0x70>
					vTaskInternalSetTimeOutState( &xTimeOut );
90007eea:	a802      	add	r0, sp, #8
90007eec:	f000 fe16 	bl	90008b1c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
90007ef0:	f7ff fb68 	bl	900075c4 <vPortExitCritical>
		vTaskSuspendAll();
90007ef4:	f000 fc06 	bl	90008704 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
90007ef8:	f7ff fb44 	bl	90007584 <vPortEnterCritical>
90007efc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
90007f00:	2bff      	cmp	r3, #255	; 0xff
90007f02:	d101      	bne.n	90007f08 <xQueueReceive+0x88>
90007f04:	f884 8044 	strb.w	r8, [r4, #68]	; 0x44
90007f08:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
90007f0c:	2bff      	cmp	r3, #255	; 0xff
90007f0e:	d101      	bne.n	90007f14 <xQueueReceive+0x94>
90007f10:	f884 8045 	strb.w	r8, [r4, #69]	; 0x45
90007f14:	f7ff fb56 	bl	900075c4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
90007f18:	a901      	add	r1, sp, #4
90007f1a:	a802      	add	r0, sp, #8
90007f1c:	f000 fe0a 	bl	90008b34 <xTaskCheckForTimeOut>
90007f20:	2800      	cmp	r0, #0
90007f22:	d141      	bne.n	90007fa8 <xQueueReceive+0x128>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
90007f24:	4620      	mov	r0, r4
90007f26:	f7ff fc71 	bl	9000780c <prvIsQueueEmpty>
90007f2a:	b3b8      	cbz	r0, 90007f9c <xQueueReceive+0x11c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
90007f2c:	9901      	ldr	r1, [sp, #4]
90007f2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
90007f32:	f000 fd77 	bl	90008a24 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
90007f36:	4620      	mov	r0, r4
90007f38:	f7ff fcbd 	bl	900078b6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
90007f3c:	f000 fc94 	bl	90008868 <xTaskResumeAll>
90007f40:	b948      	cbnz	r0, 90007f56 <xQueueReceive+0xd6>
					portYIELD_WITHIN_API();
90007f42:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007f46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007f4a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90007f4e:	f3bf 8f4f 	dsb	sy
90007f52:	f3bf 8f6f 	isb	sy
90007f56:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
90007f58:	f7ff fb14 	bl	90007584 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
90007f5c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
90007f5e:	2d00      	cmp	r5, #0
90007f60:	d0bc      	beq.n	90007edc <xQueueReceive+0x5c>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
90007f62:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
90007f64:	4639      	mov	r1, r7
90007f66:	4620      	mov	r0, r4
90007f68:	f7ff fc90 	bl	9000788c <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
90007f6c:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
90007f6e:	6923      	ldr	r3, [r4, #16]
90007f70:	b173      	cbz	r3, 90007f90 <xQueueReceive+0x110>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
90007f72:	f104 0010 	add.w	r0, r4, #16
90007f76:	f000 fd8d 	bl	90008a94 <xTaskRemoveFromEventList>
90007f7a:	b148      	cbz	r0, 90007f90 <xQueueReceive+0x110>
						queueYIELD_IF_USING_PREEMPTION();
90007f7c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90007f80:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90007f84:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90007f88:	f3bf 8f4f 	dsb	sy
90007f8c:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
90007f90:	f7ff fb18 	bl	900075c4 <vPortExitCritical>
				return pdPASS;
90007f94:	2001      	movs	r0, #1
}
90007f96:	b004      	add	sp, #16
90007f98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				prvUnlockQueue( pxQueue );
90007f9c:	4620      	mov	r0, r4
90007f9e:	f7ff fc8a 	bl	900078b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
90007fa2:	f000 fc61 	bl	90008868 <xTaskResumeAll>
90007fa6:	e7d6      	b.n	90007f56 <xQueueReceive+0xd6>
			prvUnlockQueue( pxQueue );
90007fa8:	4620      	mov	r0, r4
90007faa:	f7ff fc84 	bl	900078b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
90007fae:	f000 fc5b 	bl	90008868 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
90007fb2:	4620      	mov	r0, r4
90007fb4:	f7ff fc2a 	bl	9000780c <prvIsQueueEmpty>
90007fb8:	2800      	cmp	r0, #0
90007fba:	d0cc      	beq.n	90007f56 <xQueueReceive+0xd6>
90007fbc:	e792      	b.n	90007ee4 <xQueueReceive+0x64>

90007fbe <xQueueSemaphoreTake>:
{
90007fbe:	b5f0      	push	{r4, r5, r6, r7, lr}
90007fc0:	b085      	sub	sp, #20
	configASSERT( ( pxQueue ) );
90007fc2:	4604      	mov	r4, r0
{
90007fc4:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
90007fc6:	b940      	cbnz	r0, 90007fda <xQueueSemaphoreTake+0x1c>
90007fc8:	f04f 0350 	mov.w	r3, #80	; 0x50
90007fcc:	f383 8811 	msr	BASEPRI, r3
90007fd0:	f3bf 8f6f 	isb	sy
90007fd4:	f3bf 8f4f 	dsb	sy
90007fd8:	e7fe      	b.n	90007fd8 <xQueueSemaphoreTake+0x1a>
	configASSERT( pxQueue->uxItemSize == 0 );
90007fda:	6c05      	ldr	r5, [r0, #64]	; 0x40
90007fdc:	b145      	cbz	r5, 90007ff0 <xQueueSemaphoreTake+0x32>
90007fde:	f04f 0350 	mov.w	r3, #80	; 0x50
90007fe2:	f383 8811 	msr	BASEPRI, r3
90007fe6:	f3bf 8f6f 	isb	sy
90007fea:	f3bf 8f4f 	dsb	sy
90007fee:	e7fe      	b.n	90007fee <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
90007ff0:	f000 fde8 	bl	90008bc4 <xTaskGetSchedulerState>
90007ff4:	4606      	mov	r6, r0
90007ff6:	b950      	cbnz	r0, 9000800e <xQueueSemaphoreTake+0x50>
90007ff8:	9b01      	ldr	r3, [sp, #4]
90007ffa:	b15b      	cbz	r3, 90008014 <xQueueSemaphoreTake+0x56>
90007ffc:	f04f 0350 	mov.w	r3, #80	; 0x50
90008000:	f383 8811 	msr	BASEPRI, r3
90008004:	f3bf 8f6f 	isb	sy
90008008:	f3bf 8f4f 	dsb	sy
9000800c:	e7fe      	b.n	9000800c <xQueueSemaphoreTake+0x4e>
9000800e:	462e      	mov	r6, r5
		prvLockQueue( pxQueue );
90008010:	2700      	movs	r7, #0
90008012:	e053      	b.n	900080bc <xQueueSemaphoreTake+0xfe>
90008014:	4605      	mov	r5, r0
90008016:	e7fb      	b.n	90008010 <xQueueSemaphoreTake+0x52>
				if( xTicksToWait == ( TickType_t ) 0 )
90008018:	9b01      	ldr	r3, [sp, #4]
9000801a:	b963      	cbnz	r3, 90008036 <xQueueSemaphoreTake+0x78>
						configASSERT( xInheritanceOccurred == pdFALSE );
9000801c:	b145      	cbz	r5, 90008030 <xQueueSemaphoreTake+0x72>
9000801e:	f04f 0350 	mov.w	r3, #80	; 0x50
90008022:	f383 8811 	msr	BASEPRI, r3
90008026:	f3bf 8f6f 	isb	sy
9000802a:	f3bf 8f4f 	dsb	sy
9000802e:	e7fe      	b.n	9000802e <xQueueSemaphoreTake+0x70>
					taskEXIT_CRITICAL();
90008030:	f7ff fac8 	bl	900075c4 <vPortExitCritical>
					return errQUEUE_EMPTY;
90008034:	e062      	b.n	900080fc <xQueueSemaphoreTake+0x13e>
				else if( xEntryTimeSet == pdFALSE )
90008036:	b916      	cbnz	r6, 9000803e <xQueueSemaphoreTake+0x80>
					vTaskInternalSetTimeOutState( &xTimeOut );
90008038:	a802      	add	r0, sp, #8
9000803a:	f000 fd6f 	bl	90008b1c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
9000803e:	f7ff fac1 	bl	900075c4 <vPortExitCritical>
		vTaskSuspendAll();
90008042:	f000 fb5f 	bl	90008704 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
90008046:	f7ff fa9d 	bl	90007584 <vPortEnterCritical>
9000804a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
9000804e:	2bff      	cmp	r3, #255	; 0xff
90008050:	d101      	bne.n	90008056 <xQueueSemaphoreTake+0x98>
90008052:	f884 7044 	strb.w	r7, [r4, #68]	; 0x44
90008056:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
9000805a:	2bff      	cmp	r3, #255	; 0xff
9000805c:	d101      	bne.n	90008062 <xQueueSemaphoreTake+0xa4>
9000805e:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
90008062:	f7ff faaf 	bl	900075c4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
90008066:	a901      	add	r1, sp, #4
90008068:	a802      	add	r0, sp, #8
9000806a:	f000 fd63 	bl	90008b34 <xTaskCheckForTimeOut>
9000806e:	2800      	cmp	r0, #0
90008070:	d14d      	bne.n	9000810e <xQueueSemaphoreTake+0x150>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
90008072:	4620      	mov	r0, r4
90008074:	f7ff fbca 	bl	9000780c <prvIsQueueEmpty>
90008078:	2800      	cmp	r0, #0
9000807a:	d042      	beq.n	90008102 <xQueueSemaphoreTake+0x144>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9000807c:	6823      	ldr	r3, [r4, #0]
9000807e:	b93b      	cbnz	r3, 90008090 <xQueueSemaphoreTake+0xd2>
						taskENTER_CRITICAL();
90008080:	f7ff fa80 	bl	90007584 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
90008084:	68a0      	ldr	r0, [r4, #8]
90008086:	f000 fdad 	bl	90008be4 <xTaskPriorityInherit>
9000808a:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
9000808c:	f7ff fa9a 	bl	900075c4 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
90008090:	9901      	ldr	r1, [sp, #4]
90008092:	f104 0024 	add.w	r0, r4, #36	; 0x24
90008096:	f000 fcc5 	bl	90008a24 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
9000809a:	4620      	mov	r0, r4
9000809c:	f7ff fc0b 	bl	900078b6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
900080a0:	f000 fbe2 	bl	90008868 <xTaskResumeAll>
900080a4:	b948      	cbnz	r0, 900080ba <xQueueSemaphoreTake+0xfc>
					portYIELD_WITHIN_API();
900080a6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900080aa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900080ae:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900080b2:	f3bf 8f4f 	dsb	sy
900080b6:	f3bf 8f6f 	isb	sy
900080ba:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
900080bc:	f7ff fa62 	bl	90007584 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
900080c0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
900080c2:	2b00      	cmp	r3, #0
900080c4:	d0a8      	beq.n	90008018 <xQueueSemaphoreTake+0x5a>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
900080c6:	3b01      	subs	r3, #1
900080c8:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
900080ca:	6823      	ldr	r3, [r4, #0]
900080cc:	b913      	cbnz	r3, 900080d4 <xQueueSemaphoreTake+0x116>
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
900080ce:	f000 fe5f 	bl	90008d90 <pvTaskIncrementMutexHeldCount>
900080d2:	60a0      	str	r0, [r4, #8]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
900080d4:	6923      	ldr	r3, [r4, #16]
900080d6:	b173      	cbz	r3, 900080f6 <xQueueSemaphoreTake+0x138>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
900080d8:	f104 0010 	add.w	r0, r4, #16
900080dc:	f000 fcda 	bl	90008a94 <xTaskRemoveFromEventList>
900080e0:	b148      	cbz	r0, 900080f6 <xQueueSemaphoreTake+0x138>
						queueYIELD_IF_USING_PREEMPTION();
900080e2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900080e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900080ea:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900080ee:	f3bf 8f4f 	dsb	sy
900080f2:	f3bf 8f6f 	isb	sy
				return pdPASS;
900080f6:	2501      	movs	r5, #1
				taskEXIT_CRITICAL();
900080f8:	f7ff fa64 	bl	900075c4 <vPortExitCritical>
}
900080fc:	4628      	mov	r0, r5
900080fe:	b005      	add	sp, #20
90008100:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
90008102:	4620      	mov	r0, r4
90008104:	f7ff fbd7 	bl	900078b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
90008108:	f000 fbae 	bl	90008868 <xTaskResumeAll>
9000810c:	e7d5      	b.n	900080ba <xQueueSemaphoreTake+0xfc>
			prvUnlockQueue( pxQueue );
9000810e:	4620      	mov	r0, r4
90008110:	f7ff fbd1 	bl	900078b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
90008114:	f000 fba8 	bl	90008868 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
90008118:	4620      	mov	r0, r4
9000811a:	f7ff fb77 	bl	9000780c <prvIsQueueEmpty>
9000811e:	2800      	cmp	r0, #0
90008120:	d0cb      	beq.n	900080ba <xQueueSemaphoreTake+0xfc>
					if( xInheritanceOccurred != pdFALSE )
90008122:	2d00      	cmp	r5, #0
90008124:	d0ea      	beq.n	900080fc <xQueueSemaphoreTake+0x13e>
						taskENTER_CRITICAL();
90008126:	f7ff fa2d 	bl	90007584 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
9000812a:	6a61      	ldr	r1, [r4, #36]	; 0x24
9000812c:	b119      	cbz	r1, 90008136 <xQueueSemaphoreTake+0x178>
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
9000812e:	6b23      	ldr	r3, [r4, #48]	; 0x30
90008130:	6819      	ldr	r1, [r3, #0]
90008132:	f1c1 0138 	rsb	r1, r1, #56	; 0x38
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
90008136:	68a0      	ldr	r0, [r4, #8]
				return errQUEUE_EMPTY;
90008138:	2500      	movs	r5, #0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
9000813a:	f000 fdd7 	bl	90008cec <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
9000813e:	f7ff fa41 	bl	900075c4 <vPortExitCritical>
90008142:	e7db      	b.n	900080fc <xQueueSemaphoreTake+0x13e>

90008144 <xQueueTakeMutexRecursive>:
	{
90008144:	b537      	push	{r0, r1, r2, r4, r5, lr}
		configASSERT( pxMutex );
90008146:	4604      	mov	r4, r0
90008148:	b940      	cbnz	r0, 9000815c <xQueueTakeMutexRecursive+0x18>
9000814a:	f04f 0350 	mov.w	r3, #80	; 0x50
9000814e:	f383 8811 	msr	BASEPRI, r3
90008152:	f3bf 8f6f 	isb	sy
90008156:	f3bf 8f4f 	dsb	sy
9000815a:	e7fe      	b.n	9000815a <xQueueTakeMutexRecursive+0x16>
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
9000815c:	6885      	ldr	r5, [r0, #8]
9000815e:	9101      	str	r1, [sp, #4]
90008160:	f000 fd2a 	bl	90008bb8 <xTaskGetCurrentTaskHandle>
90008164:	4285      	cmp	r5, r0
90008166:	9901      	ldr	r1, [sp, #4]
90008168:	d105      	bne.n	90008176 <xQueueTakeMutexRecursive+0x32>
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
9000816a:	68e3      	ldr	r3, [r4, #12]
			xReturn = pdPASS;
9000816c:	2001      	movs	r0, #1
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
9000816e:	3301      	adds	r3, #1
90008170:	60e3      	str	r3, [r4, #12]
	}
90008172:	b003      	add	sp, #12
90008174:	bd30      	pop	{r4, r5, pc}
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
90008176:	4620      	mov	r0, r4
90008178:	f7ff ff21 	bl	90007fbe <xQueueSemaphoreTake>
			if( xReturn != pdFAIL )
9000817c:	2800      	cmp	r0, #0
9000817e:	d0f8      	beq.n	90008172 <xQueueTakeMutexRecursive+0x2e>
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
90008180:	68e3      	ldr	r3, [r4, #12]
90008182:	3301      	adds	r3, #1
90008184:	60e3      	str	r3, [r4, #12]
		return xReturn;
90008186:	e7f4      	b.n	90008172 <xQueueTakeMutexRecursive+0x2e>

90008188 <xQueueReceiveFromISR>:
{
90008188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9000818c:	4689      	mov	r9, r1
9000818e:	4690      	mov	r8, r2
	configASSERT( pxQueue );
90008190:	4605      	mov	r5, r0
90008192:	b940      	cbnz	r0, 900081a6 <xQueueReceiveFromISR+0x1e>
90008194:	f04f 0350 	mov.w	r3, #80	; 0x50
90008198:	f383 8811 	msr	BASEPRI, r3
9000819c:	f3bf 8f6f 	isb	sy
900081a0:	f3bf 8f4f 	dsb	sy
900081a4:	e7fe      	b.n	900081a4 <xQueueReceiveFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
900081a6:	b951      	cbnz	r1, 900081be <xQueueReceiveFromISR+0x36>
900081a8:	6c03      	ldr	r3, [r0, #64]	; 0x40
900081aa:	b143      	cbz	r3, 900081be <xQueueReceiveFromISR+0x36>
900081ac:	f04f 0350 	mov.w	r3, #80	; 0x50
900081b0:	f383 8811 	msr	BASEPRI, r3
900081b4:	f3bf 8f6f 	isb	sy
900081b8:	f3bf 8f4f 	dsb	sy
900081bc:	e7fe      	b.n	900081bc <xQueueReceiveFromISR+0x34>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
900081be:	f7ff faf7 	bl	900077b0 <vPortValidateInterruptPriority>
	__asm volatile
900081c2:	f3ef 8711 	mrs	r7, BASEPRI
900081c6:	f04f 0350 	mov.w	r3, #80	; 0x50
900081ca:	f383 8811 	msr	BASEPRI, r3
900081ce:	f3bf 8f6f 	isb	sy
900081d2:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
900081d6:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
900081d8:	b31c      	cbz	r4, 90008222 <xQueueReceiveFromISR+0x9a>
			const int8_t cRxLock = pxQueue->cRxLock;
900081da:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
900081de:	4649      	mov	r1, r9
900081e0:	4628      	mov	r0, r5
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
900081e2:	3c01      	subs	r4, #1
			const int8_t cRxLock = pxQueue->cRxLock;
900081e4:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
900081e6:	f7ff fb51 	bl	9000788c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
900081ea:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
900081ec:	1c73      	adds	r3, r6, #1
900081ee:	d113      	bne.n	90008218 <xQueueReceiveFromISR+0x90>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
900081f0:	692b      	ldr	r3, [r5, #16]
900081f2:	b90b      	cbnz	r3, 900081f8 <xQueueReceiveFromISR+0x70>
			xReturn = pdPASS;
900081f4:	2001      	movs	r0, #1
900081f6:	e00b      	b.n	90008210 <xQueueReceiveFromISR+0x88>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
900081f8:	f105 0010 	add.w	r0, r5, #16
900081fc:	f000 fc4a 	bl	90008a94 <xTaskRemoveFromEventList>
90008200:	2800      	cmp	r0, #0
90008202:	d0f7      	beq.n	900081f4 <xQueueReceiveFromISR+0x6c>
						if( pxHigherPriorityTaskWoken != NULL )
90008204:	f1b8 0f00 	cmp.w	r8, #0
90008208:	d0f4      	beq.n	900081f4 <xQueueReceiveFromISR+0x6c>
							*pxHigherPriorityTaskWoken = pdTRUE;
9000820a:	2001      	movs	r0, #1
9000820c:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
90008210:	f387 8811 	msr	BASEPRI, r7
}
90008214:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
90008218:	3601      	adds	r6, #1
9000821a:	b276      	sxtb	r6, r6
9000821c:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
90008220:	e7e8      	b.n	900081f4 <xQueueReceiveFromISR+0x6c>
			xReturn = pdFAIL;
90008222:	4620      	mov	r0, r4
90008224:	e7f4      	b.n	90008210 <xQueueReceiveFromISR+0x88>
	...

90008228 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
90008228:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
9000822a:	4a07      	ldr	r2, [pc, #28]	; (90008248 <vQueueAddToRegistry+0x20>)
	{
9000822c:	b510      	push	{r4, lr}
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
9000822e:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
90008232:	b92c      	cbnz	r4, 90008240 <vQueueAddToRegistry+0x18>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
90008234:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
90008238:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
9000823c:	6058      	str	r0, [r3, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
9000823e:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
90008240:	3301      	adds	r3, #1
90008242:	2b08      	cmp	r3, #8
90008244:	d1f3      	bne.n	9000822e <vQueueAddToRegistry+0x6>
90008246:	e7fa      	b.n	9000823e <vQueueAddToRegistry+0x16>
90008248:	240094c8 	.word	0x240094c8

9000824c <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
9000824c:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
9000824e:	4a08      	ldr	r2, [pc, #32]	; (90008270 <vQueueUnregisterQueue+0x24>)
	{
90008250:	b510      	push	{r4, lr}
			if( xQueueRegistry[ ux ].xHandle == xQueue )
90008252:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
90008256:	684c      	ldr	r4, [r1, #4]
90008258:	4284      	cmp	r4, r0
9000825a:	d104      	bne.n	90008266 <vQueueUnregisterQueue+0x1a>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
9000825c:	2000      	movs	r0, #0
9000825e:	f842 0033 	str.w	r0, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
90008262:	6048      	str	r0, [r1, #4]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
90008264:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
90008266:	3301      	adds	r3, #1
90008268:	2b08      	cmp	r3, #8
9000826a:	d1f2      	bne.n	90008252 <vQueueUnregisterQueue+0x6>
9000826c:	e7fa      	b.n	90008264 <vQueueUnregisterQueue+0x18>
9000826e:	bf00      	nop
90008270:	240094c8 	.word	0x240094c8

90008274 <vQueueDelete>:
{
90008274:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
90008276:	4604      	mov	r4, r0
90008278:	b940      	cbnz	r0, 9000828c <vQueueDelete+0x18>
	__asm volatile
9000827a:	f04f 0350 	mov.w	r3, #80	; 0x50
9000827e:	f383 8811 	msr	BASEPRI, r3
90008282:	f3bf 8f6f 	isb	sy
90008286:	f3bf 8f4f 	dsb	sy
9000828a:	e7fe      	b.n	9000828a <vQueueDelete+0x16>
		vQueueUnregisterQueue( pxQueue );
9000828c:	f7ff ffde 	bl	9000824c <vQueueUnregisterQueue>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
90008290:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
90008294:	b923      	cbnz	r3, 900082a0 <vQueueDelete+0x2c>
			vPortFree( pxQueue );
90008296:	4620      	mov	r0, r4
}
90008298:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			vPortFree( pxQueue );
9000829c:	f7ff b890 	b.w	900073c0 <vPortFree>
}
900082a0:	bd10      	pop	{r4, pc}

900082a2 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
900082a2:	b570      	push	{r4, r5, r6, lr}
900082a4:	4604      	mov	r4, r0
900082a6:	460d      	mov	r5, r1
900082a8:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
900082aa:	f7ff f96b 	bl	90007584 <vPortEnterCritical>
900082ae:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
900082b2:	2bff      	cmp	r3, #255	; 0xff
900082b4:	d102      	bne.n	900082bc <vQueueWaitForMessageRestricted+0x1a>
900082b6:	2300      	movs	r3, #0
900082b8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
900082bc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
900082c0:	2bff      	cmp	r3, #255	; 0xff
900082c2:	d102      	bne.n	900082ca <vQueueWaitForMessageRestricted+0x28>
900082c4:	2300      	movs	r3, #0
900082c6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
900082ca:	f7ff f97b 	bl	900075c4 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
900082ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
900082d0:	b92b      	cbnz	r3, 900082de <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
900082d2:	4632      	mov	r2, r6
900082d4:	4629      	mov	r1, r5
900082d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
900082da:	f000 fbbd 	bl	90008a58 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
900082de:	4620      	mov	r0, r4
	}
900082e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
900082e4:	f7ff bae7 	b.w	900078b6 <prvUnlockQueue>

900082e8 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
900082e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900082ec:	4604      	mov	r4, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
900082ee:	f7ff f949 	bl	90007584 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
900082f2:	4b2f      	ldr	r3, [pc, #188]	; (900083b0 <prvAddNewTaskToReadyList+0xc8>)
		if( pxCurrentTCB == NULL )
900082f4:	4e2f      	ldr	r6, [pc, #188]	; (900083b4 <prvAddNewTaskToReadyList+0xcc>)
		uxCurrentNumberOfTasks++;
900082f6:	681a      	ldr	r2, [r3, #0]
900082f8:	4f2f      	ldr	r7, [pc, #188]	; (900083b8 <prvAddNewTaskToReadyList+0xd0>)
900082fa:	3201      	adds	r2, #1
900082fc:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
900082fe:	6835      	ldr	r5, [r6, #0]
90008300:	2d00      	cmp	r5, #0
90008302:	d14a      	bne.n	9000839a <prvAddNewTaskToReadyList+0xb2>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
90008304:	6034      	str	r4, [r6, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
90008306:	681b      	ldr	r3, [r3, #0]
90008308:	2b01      	cmp	r3, #1
9000830a:	d11f      	bne.n	9000834c <prvAddNewTaskToReadyList+0x64>
9000830c:	46b8      	mov	r8, r7

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
9000830e:	3501      	adds	r5, #1
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
90008310:	4640      	mov	r0, r8
90008312:	f7ff f893 	bl	9000743c <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
90008316:	f108 0814 	add.w	r8, r8, #20
9000831a:	2d38      	cmp	r5, #56	; 0x38
9000831c:	d1f7      	bne.n	9000830e <prvAddNewTaskToReadyList+0x26>
	}

	vListInitialise( &xDelayedTaskList1 );
9000831e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 900083e0 <prvAddNewTaskToReadyList+0xf8>
	vListInitialise( &xDelayedTaskList2 );
90008322:	4d26      	ldr	r5, [pc, #152]	; (900083bc <prvAddNewTaskToReadyList+0xd4>)
	vListInitialise( &xDelayedTaskList1 );
90008324:	4640      	mov	r0, r8
90008326:	f7ff f889 	bl	9000743c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
9000832a:	4628      	mov	r0, r5
9000832c:	f7ff f886 	bl	9000743c <vListInitialise>
	vListInitialise( &xPendingReadyList );
90008330:	4823      	ldr	r0, [pc, #140]	; (900083c0 <prvAddNewTaskToReadyList+0xd8>)
90008332:	f7ff f883 	bl	9000743c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
90008336:	4823      	ldr	r0, [pc, #140]	; (900083c4 <prvAddNewTaskToReadyList+0xdc>)
90008338:	f7ff f880 	bl	9000743c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
9000833c:	4822      	ldr	r0, [pc, #136]	; (900083c8 <prvAddNewTaskToReadyList+0xe0>)
9000833e:	f7ff f87d 	bl	9000743c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
90008342:	4b22      	ldr	r3, [pc, #136]	; (900083cc <prvAddNewTaskToReadyList+0xe4>)
90008344:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
90008348:	4b21      	ldr	r3, [pc, #132]	; (900083d0 <prvAddNewTaskToReadyList+0xe8>)
9000834a:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
9000834c:	4a21      	ldr	r2, [pc, #132]	; (900083d4 <prvAddNewTaskToReadyList+0xec>)
9000834e:	6813      	ldr	r3, [r2, #0]
90008350:	3301      	adds	r3, #1
90008352:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
90008354:	4a20      	ldr	r2, [pc, #128]	; (900083d8 <prvAddNewTaskToReadyList+0xf0>)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
90008356:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
90008358:	6811      	ldr	r1, [r2, #0]
9000835a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
9000835c:	428b      	cmp	r3, r1
9000835e:	d900      	bls.n	90008362 <prvAddNewTaskToReadyList+0x7a>
90008360:	6013      	str	r3, [r2, #0]
90008362:	2014      	movs	r0, #20
90008364:	1d21      	adds	r1, r4, #4
90008366:	fb00 7003 	mla	r0, r0, r3, r7
9000836a:	f7ff f875 	bl	90007458 <vListInsertEnd>
	taskEXIT_CRITICAL();
9000836e:	f7ff f929 	bl	900075c4 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
90008372:	4b1a      	ldr	r3, [pc, #104]	; (900083dc <prvAddNewTaskToReadyList+0xf4>)
90008374:	681b      	ldr	r3, [r3, #0]
90008376:	b173      	cbz	r3, 90008396 <prvAddNewTaskToReadyList+0xae>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
90008378:	6833      	ldr	r3, [r6, #0]
9000837a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
9000837c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
9000837e:	429a      	cmp	r2, r3
90008380:	d209      	bcs.n	90008396 <prvAddNewTaskToReadyList+0xae>
			taskYIELD_IF_USING_PREEMPTION();
90008382:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90008386:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
9000838a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
9000838e:	f3bf 8f4f 	dsb	sy
90008392:	f3bf 8f6f 	isb	sy
}
90008396:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( xSchedulerRunning == pdFALSE )
9000839a:	4b10      	ldr	r3, [pc, #64]	; (900083dc <prvAddNewTaskToReadyList+0xf4>)
9000839c:	681b      	ldr	r3, [r3, #0]
9000839e:	2b00      	cmp	r3, #0
900083a0:	d1d4      	bne.n	9000834c <prvAddNewTaskToReadyList+0x64>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
900083a2:	6833      	ldr	r3, [r6, #0]
900083a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
900083a6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
900083a8:	429a      	cmp	r2, r3
900083aa:	d8cf      	bhi.n	9000834c <prvAddNewTaskToReadyList+0x64>
					pxCurrentTCB = pxNewTCB;
900083ac:	6034      	str	r4, [r6, #0]
900083ae:	e7cd      	b.n	9000834c <prvAddNewTaskToReadyList+0x64>
900083b0:	24009974 	.word	0x24009974
900083b4:	24009508 	.word	0x24009508
900083b8:	24009514 	.word	0x24009514
900083bc:	2400999c 	.word	0x2400999c
900083c0:	240099bc 	.word	0x240099bc
900083c4:	240099e8 	.word	0x240099e8
900083c8:	240099d4 	.word	0x240099d4
900083cc:	2400950c 	.word	0x2400950c
900083d0:	24009510 	.word	0x24009510
900083d4:	24009980 	.word	0x24009980
900083d8:	24009984 	.word	0x24009984
900083dc:	240099d0 	.word	0x240099d0
900083e0:	24009988 	.word	0x24009988

900083e4 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
900083e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
900083e6:	4b15      	ldr	r3, [pc, #84]	; (9000843c <prvAddCurrentTaskToDelayedList+0x58>)
{
900083e8:	4604      	mov	r4, r0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
900083ea:	4e15      	ldr	r6, [pc, #84]	; (90008440 <prvAddCurrentTaskToDelayedList+0x5c>)
{
900083ec:	460f      	mov	r7, r1
const TickType_t xConstTickCount = xTickCount;
900083ee:	681d      	ldr	r5, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
900083f0:	6830      	ldr	r0, [r6, #0]
900083f2:	3004      	adds	r0, #4
900083f4:	f7ff f853 	bl	9000749e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
900083f8:	1c63      	adds	r3, r4, #1
900083fa:	d107      	bne.n	9000840c <prvAddCurrentTaskToDelayedList+0x28>
900083fc:	b137      	cbz	r7, 9000840c <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
900083fe:	6831      	ldr	r1, [r6, #0]
90008400:	4810      	ldr	r0, [pc, #64]	; (90008444 <prvAddCurrentTaskToDelayedList+0x60>)
90008402:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
90008404:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
90008408:	f7ff b826 	b.w	90007458 <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
9000840c:	192c      	adds	r4, r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
9000840e:	6833      	ldr	r3, [r6, #0]
90008410:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
90008412:	d307      	bcc.n	90008424 <prvAddCurrentTaskToDelayedList+0x40>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
90008414:	4b0c      	ldr	r3, [pc, #48]	; (90008448 <prvAddCurrentTaskToDelayedList+0x64>)
90008416:	6818      	ldr	r0, [r3, #0]
90008418:	6831      	ldr	r1, [r6, #0]
}
9000841a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
9000841e:	3104      	adds	r1, #4
90008420:	f7ff b826 	b.w	90007470 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
90008424:	4b09      	ldr	r3, [pc, #36]	; (9000844c <prvAddCurrentTaskToDelayedList+0x68>)
90008426:	6818      	ldr	r0, [r3, #0]
90008428:	6831      	ldr	r1, [r6, #0]
9000842a:	3104      	adds	r1, #4
9000842c:	f7ff f820 	bl	90007470 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
90008430:	4b07      	ldr	r3, [pc, #28]	; (90008450 <prvAddCurrentTaskToDelayedList+0x6c>)
90008432:	681a      	ldr	r2, [r3, #0]
90008434:	42a2      	cmp	r2, r4
90008436:	d900      	bls.n	9000843a <prvAddCurrentTaskToDelayedList+0x56>
					xNextTaskUnblockTime = xTimeToWake;
90008438:	601c      	str	r4, [r3, #0]
}
9000843a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9000843c:	240099fc 	.word	0x240099fc
90008440:	24009508 	.word	0x24009508
90008444:	240099d4 	.word	0x240099d4
90008448:	24009510 	.word	0x24009510
9000844c:	2400950c 	.word	0x2400950c
90008450:	240099b0 	.word	0x240099b0

90008454 <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
90008454:	4a06      	ldr	r2, [pc, #24]	; (90008470 <prvResetNextTaskUnblockTime+0x1c>)
90008456:	6813      	ldr	r3, [r2, #0]
90008458:	6819      	ldr	r1, [r3, #0]
9000845a:	4b06      	ldr	r3, [pc, #24]	; (90008474 <prvResetNextTaskUnblockTime+0x20>)
9000845c:	b919      	cbnz	r1, 90008466 <prvResetNextTaskUnblockTime+0x12>
		xNextTaskUnblockTime = portMAX_DELAY;
9000845e:	f04f 32ff 	mov.w	r2, #4294967295
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
90008462:	601a      	str	r2, [r3, #0]
}
90008464:	4770      	bx	lr
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
90008466:	6812      	ldr	r2, [r2, #0]
90008468:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
9000846a:	68d2      	ldr	r2, [r2, #12]
9000846c:	6852      	ldr	r2, [r2, #4]
9000846e:	e7f8      	b.n	90008462 <prvResetNextTaskUnblockTime+0xe>
90008470:	2400950c 	.word	0x2400950c
90008474:	240099b0 	.word	0x240099b0

90008478 <prvDeleteTCB>:
	{
90008478:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
9000847a:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
	{
9000847e:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
90008480:	b93b      	cbnz	r3, 90008492 <prvDeleteTCB+0x1a>
				vPortFree( pxTCB->pxStack );
90008482:	6b00      	ldr	r0, [r0, #48]	; 0x30
90008484:	f7fe ff9c 	bl	900073c0 <vPortFree>
				vPortFree( pxTCB );
90008488:	4620      	mov	r0, r4
	}
9000848a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
9000848e:	f7fe bf97 	b.w	900073c0 <vPortFree>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
90008492:	2b01      	cmp	r3, #1
90008494:	d0f9      	beq.n	9000848a <prvDeleteTCB+0x12>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
90008496:	2b02      	cmp	r3, #2
90008498:	d008      	beq.n	900084ac <prvDeleteTCB+0x34>
9000849a:	f04f 0350 	mov.w	r3, #80	; 0x50
9000849e:	f383 8811 	msr	BASEPRI, r3
900084a2:	f3bf 8f6f 	isb	sy
900084a6:	f3bf 8f4f 	dsb	sy
900084aa:	e7fe      	b.n	900084aa <prvDeleteTCB+0x32>
	}
900084ac:	bd10      	pop	{r4, pc}
	...

900084b0 <prvIdleTask>:
{
900084b0:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
900084b2:	4c14      	ldr	r4, [pc, #80]	; (90008504 <prvIdleTask+0x54>)
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900084b4:	4f14      	ldr	r7, [pc, #80]	; (90008508 <prvIdleTask+0x58>)
				--uxCurrentNumberOfTasks;
900084b6:	4d15      	ldr	r5, [pc, #84]	; (9000850c <prvIdleTask+0x5c>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
900084b8:	6823      	ldr	r3, [r4, #0]
900084ba:	b983      	cbnz	r3, 900084de <prvIdleTask+0x2e>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
900084bc:	4b14      	ldr	r3, [pc, #80]	; (90008510 <prvIdleTask+0x60>)
900084be:	681b      	ldr	r3, [r3, #0]
900084c0:	2b01      	cmp	r3, #1
900084c2:	d909      	bls.n	900084d8 <prvIdleTask+0x28>
				taskYIELD();
900084c4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900084c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900084cc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900084d0:	f3bf 8f4f 	dsb	sy
900084d4:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
900084d8:	f7f8 f841 	bl	9000055e <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
900084dc:	e7eb      	b.n	900084b6 <prvIdleTask+0x6>
			taskENTER_CRITICAL();
900084de:	f7ff f851 	bl	90007584 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900084e2:	68fb      	ldr	r3, [r7, #12]
900084e4:	68de      	ldr	r6, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
900084e6:	1d30      	adds	r0, r6, #4
900084e8:	f7fe ffd9 	bl	9000749e <uxListRemove>
				--uxCurrentNumberOfTasks;
900084ec:	682b      	ldr	r3, [r5, #0]
900084ee:	3b01      	subs	r3, #1
900084f0:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
900084f2:	6823      	ldr	r3, [r4, #0]
900084f4:	3b01      	subs	r3, #1
900084f6:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
900084f8:	f7ff f864 	bl	900075c4 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
900084fc:	4630      	mov	r0, r6
900084fe:	f7ff ffbb 	bl	90008478 <prvDeleteTCB>
90008502:	e7d9      	b.n	900084b8 <prvIdleTask+0x8>
90008504:	24009978 	.word	0x24009978
90008508:	240099e8 	.word	0x240099e8
9000850c:	24009974 	.word	0x24009974
90008510:	24009514 	.word	0x24009514

90008514 <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
90008514:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
90008518:	ea4f 0982 	mov.w	r9, r2, lsl #2
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
9000851c:	4606      	mov	r6, r0
9000851e:	460d      	mov	r5, r1
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
90008520:	21a5      	movs	r1, #165	; 0xa5
90008522:	464a      	mov	r2, r9
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
90008524:	461f      	mov	r7, r3
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
90008526:	f1a9 0904 	sub.w	r9, r9, #4
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
9000852a:	e9dd 8409 	ldrd	r8, r4, [sp, #36]	; 0x24
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
9000852e:	6b20      	ldr	r0, [r4, #48]	; 0x30
90008530:	f009 fa54 	bl	900119dc <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
90008534:	6b22      	ldr	r2, [r4, #48]	; 0x30
90008536:	4491      	add	r9, r2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
90008538:	f029 0907 	bic.w	r9, r9, #7
	if( pcName != NULL )
9000853c:	b3a5      	cbz	r5, 900085a8 <prvInitialiseNewTask.constprop.0+0x94>
9000853e:	1e6b      	subs	r3, r5, #1
90008540:	f104 0234 	add.w	r2, r4, #52	; 0x34
90008544:	350f      	adds	r5, #15
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
90008546:	f813 0f01 	ldrb.w	r0, [r3, #1]!
9000854a:	f802 0b01 	strb.w	r0, [r2], #1
			if( pcName[ x ] == ( char ) 0x00 )
9000854e:	b108      	cbz	r0, 90008554 <prvInitialiseNewTask.constprop.0+0x40>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
90008550:	42ab      	cmp	r3, r5
90008552:	d1f8      	bne.n	90008546 <prvInitialiseNewTask.constprop.0+0x32>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
90008554:	2300      	movs	r3, #0
90008556:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
9000855a:	9d08      	ldr	r5, [sp, #32]
		pxNewTCB->uxMutexesHeld = 0;
9000855c:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
90008560:	1d20      	adds	r0, r4, #4
90008562:	2d37      	cmp	r5, #55	; 0x37
		pxNewTCB->uxMutexesHeld = 0;
90008564:	f8c4 a050 	str.w	sl, [r4, #80]	; 0x50
90008568:	bf28      	it	cs
9000856a:	2537      	movcs	r5, #55	; 0x37
	pxNewTCB->uxPriority = uxPriority;
9000856c:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
9000856e:	64e5      	str	r5, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008570:	f1c5 0538 	rsb	r5, r5, #56	; 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
90008574:	f7fe ff6d 	bl	90007452 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
90008578:	f104 0018 	add.w	r0, r4, #24
9000857c:	f7fe ff69 	bl	90007452 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
90008580:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
90008584:	463a      	mov	r2, r7
90008586:	4631      	mov	r1, r6
90008588:	4648      	mov	r0, r9
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
9000858a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9000858c:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
9000858e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
90008590:	f884 a058 	strb.w	sl, [r4, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
90008594:	f7fe ffd2 	bl	9000753c <pxPortInitialiseStack>
90008598:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
9000859a:	f1b8 0f00 	cmp.w	r8, #0
9000859e:	d001      	beq.n	900085a4 <prvInitialiseNewTask.constprop.0+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
900085a0:	f8c8 4000 	str.w	r4, [r8]
}
900085a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
900085a8:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
900085ac:	e7d5      	b.n	9000855a <prvInitialiseNewTask.constprop.0+0x46>

900085ae <xTaskCreateStatic>:
	{
900085ae:	b570      	push	{r4, r5, r6, lr}
900085b0:	b086      	sub	sp, #24
900085b2:	e9dd 540b 	ldrd	r5, r4, [sp, #44]	; 0x2c
		configASSERT( puxStackBuffer != NULL );
900085b6:	b945      	cbnz	r5, 900085ca <xTaskCreateStatic+0x1c>
900085b8:	f04f 0350 	mov.w	r3, #80	; 0x50
900085bc:	f383 8811 	msr	BASEPRI, r3
900085c0:	f3bf 8f6f 	isb	sy
900085c4:	f3bf 8f4f 	dsb	sy
900085c8:	e7fe      	b.n	900085c8 <xTaskCreateStatic+0x1a>
		configASSERT( pxTaskBuffer != NULL );
900085ca:	b944      	cbnz	r4, 900085de <xTaskCreateStatic+0x30>
900085cc:	f04f 0350 	mov.w	r3, #80	; 0x50
900085d0:	f383 8811 	msr	BASEPRI, r3
900085d4:	f3bf 8f6f 	isb	sy
900085d8:	f3bf 8f4f 	dsb	sy
900085dc:	e7fe      	b.n	900085dc <xTaskCreateStatic+0x2e>
			volatile size_t xSize = sizeof( StaticTask_t );
900085de:	265c      	movs	r6, #92	; 0x5c
900085e0:	9605      	str	r6, [sp, #20]
			configASSERT( xSize == sizeof( TCB_t ) );
900085e2:	9e05      	ldr	r6, [sp, #20]
900085e4:	2e5c      	cmp	r6, #92	; 0x5c
900085e6:	d008      	beq.n	900085fa <xTaskCreateStatic+0x4c>
900085e8:	f04f 0350 	mov.w	r3, #80	; 0x50
900085ec:	f383 8811 	msr	BASEPRI, r3
900085f0:	f3bf 8f6f 	isb	sy
900085f4:	f3bf 8f4f 	dsb	sy
900085f8:	e7fe      	b.n	900085f8 <xTaskCreateStatic+0x4a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
900085fa:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
900085fc:	2502      	movs	r5, #2
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
900085fe:	9e05      	ldr	r6, [sp, #20]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
90008600:	f884 5059 	strb.w	r5, [r4, #89]	; 0x59
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
90008604:	ad04      	add	r5, sp, #16
90008606:	9402      	str	r4, [sp, #8]
90008608:	9501      	str	r5, [sp, #4]
9000860a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
9000860c:	9500      	str	r5, [sp, #0]
9000860e:	f7ff ff81 	bl	90008514 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
90008612:	4620      	mov	r0, r4
90008614:	f7ff fe68 	bl	900082e8 <prvAddNewTaskToReadyList>
	}
90008618:	9804      	ldr	r0, [sp, #16]
9000861a:	b006      	add	sp, #24
9000861c:	bd70      	pop	{r4, r5, r6, pc}

9000861e <xTaskCreate>:
	{
9000861e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
90008622:	4607      	mov	r7, r0
90008624:	b085      	sub	sp, #20
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
90008626:	0090      	lsls	r0, r2, #2
	{
90008628:	4688      	mov	r8, r1
9000862a:	4616      	mov	r6, r2
9000862c:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
9000862e:	f7fe fe2f 	bl	90007290 <pvPortMalloc>
			if( pxStack != NULL )
90008632:	4605      	mov	r5, r0
90008634:	b1e8      	cbz	r0, 90008672 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
90008636:	205c      	movs	r0, #92	; 0x5c
90008638:	f7fe fe2a 	bl	90007290 <pvPortMalloc>
				if( pxNewTCB != NULL )
9000863c:	4604      	mov	r4, r0
9000863e:	b1a8      	cbz	r0, 9000866c <xTaskCreate+0x4e>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
90008640:	2300      	movs	r3, #0
					pxNewTCB->pxStack = pxStack;
90008642:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
90008644:	4632      	mov	r2, r6
90008646:	4641      	mov	r1, r8
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
90008648:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
9000864c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9000864e:	9002      	str	r0, [sp, #8]
90008650:	4638      	mov	r0, r7
90008652:	9301      	str	r3, [sp, #4]
90008654:	9b0c      	ldr	r3, [sp, #48]	; 0x30
90008656:	9300      	str	r3, [sp, #0]
90008658:	464b      	mov	r3, r9
9000865a:	f7ff ff5b 	bl	90008514 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
9000865e:	4620      	mov	r0, r4
90008660:	f7ff fe42 	bl	900082e8 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
90008664:	2001      	movs	r0, #1
	}
90008666:	b005      	add	sp, #20
90008668:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
9000866c:	4628      	mov	r0, r5
9000866e:	f7fe fea7 	bl	900073c0 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
90008672:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
90008676:	e7f6      	b.n	90008666 <xTaskCreate+0x48>

90008678 <vTaskStartScheduler>:
{
90008678:	b510      	push	{r4, lr}
9000867a:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
9000867c:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
9000867e:	aa07      	add	r2, sp, #28
90008680:	a906      	add	r1, sp, #24
90008682:	a805      	add	r0, sp, #20
		StackType_t *pxIdleTaskStackBuffer = NULL;
90008684:	e9cd 4405 	strd	r4, r4, [sp, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
90008688:	f7fe fdc6 	bl	90007218 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
9000868c:	9b05      	ldr	r3, [sp, #20]
9000868e:	9a07      	ldr	r2, [sp, #28]
90008690:	9302      	str	r3, [sp, #8]
90008692:	9b06      	ldr	r3, [sp, #24]
90008694:	4916      	ldr	r1, [pc, #88]	; (900086f0 <vTaskStartScheduler+0x78>)
90008696:	4817      	ldr	r0, [pc, #92]	; (900086f4 <vTaskStartScheduler+0x7c>)
90008698:	e9cd 4300 	strd	r4, r3, [sp]
9000869c:	4623      	mov	r3, r4
9000869e:	f7ff ff86 	bl	900085ae <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
900086a2:	b318      	cbz	r0, 900086ec <vTaskStartScheduler+0x74>
			xReturn = xTimerCreateTimerTask();
900086a4:	f000 fbd2 	bl	90008e4c <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
900086a8:	2801      	cmp	r0, #1
900086aa:	d114      	bne.n	900086d6 <vTaskStartScheduler+0x5e>
900086ac:	f04f 0350 	mov.w	r3, #80	; 0x50
900086b0:	f383 8811 	msr	BASEPRI, r3
900086b4:	f3bf 8f6f 	isb	sy
900086b8:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
900086bc:	4b0e      	ldr	r3, [pc, #56]	; (900086f8 <vTaskStartScheduler+0x80>)
900086be:	f04f 32ff 	mov.w	r2, #4294967295
900086c2:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
900086c4:	4b0d      	ldr	r3, [pc, #52]	; (900086fc <vTaskStartScheduler+0x84>)
900086c6:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
900086c8:	4b0d      	ldr	r3, [pc, #52]	; (90008700 <vTaskStartScheduler+0x88>)
900086ca:	601c      	str	r4, [r3, #0]
}
900086cc:	b008      	add	sp, #32
900086ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
900086d2:	f7fe bfe7 	b.w	900076a4 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
900086d6:	3001      	adds	r0, #1
900086d8:	d108      	bne.n	900086ec <vTaskStartScheduler+0x74>
900086da:	f04f 0350 	mov.w	r3, #80	; 0x50
900086de:	f383 8811 	msr	BASEPRI, r3
900086e2:	f3bf 8f6f 	isb	sy
900086e6:	f3bf 8f4f 	dsb	sy
900086ea:	e7fe      	b.n	900086ea <vTaskStartScheduler+0x72>
}
900086ec:	b008      	add	sp, #32
900086ee:	bd10      	pop	{r4, pc}
900086f0:	9001334f 	.word	0x9001334f
900086f4:	900084b1 	.word	0x900084b1
900086f8:	240099b0 	.word	0x240099b0
900086fc:	240099d0 	.word	0x240099d0
90008700:	240099fc 	.word	0x240099fc

90008704 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
90008704:	4a02      	ldr	r2, [pc, #8]	; (90008710 <vTaskSuspendAll+0xc>)
90008706:	6813      	ldr	r3, [r2, #0]
90008708:	3301      	adds	r3, #1
9000870a:	6013      	str	r3, [r2, #0]
}
9000870c:	4770      	bx	lr
9000870e:	bf00      	nop
90008710:	2400997c 	.word	0x2400997c

90008714 <xTaskGetTickCount>:
		xTicks = xTickCount;
90008714:	4b01      	ldr	r3, [pc, #4]	; (9000871c <xTaskGetTickCount+0x8>)
90008716:	6818      	ldr	r0, [r3, #0]
}
90008718:	4770      	bx	lr
9000871a:	bf00      	nop
9000871c:	240099fc 	.word	0x240099fc

90008720 <xTaskGetTickCountFromISR>:
{
90008720:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
90008722:	f7ff f845 	bl	900077b0 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
90008726:	4b01      	ldr	r3, [pc, #4]	; (9000872c <xTaskGetTickCountFromISR+0xc>)
90008728:	6818      	ldr	r0, [r3, #0]
}
9000872a:	bd08      	pop	{r3, pc}
9000872c:	240099fc 	.word	0x240099fc

90008730 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
90008730:	4b42      	ldr	r3, [pc, #264]	; (9000883c <xTaskIncrementTick+0x10c>)
90008732:	681b      	ldr	r3, [r3, #0]
{
90008734:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
90008738:	2b00      	cmp	r3, #0
9000873a:	d177      	bne.n	9000882c <xTaskIncrementTick+0xfc>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
9000873c:	4b40      	ldr	r3, [pc, #256]	; (90008840 <xTaskIncrementTick+0x110>)
9000873e:	681d      	ldr	r5, [r3, #0]
90008740:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
90008742:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
90008744:	b9bd      	cbnz	r5, 90008776 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
90008746:	4b3f      	ldr	r3, [pc, #252]	; (90008844 <xTaskIncrementTick+0x114>)
90008748:	681a      	ldr	r2, [r3, #0]
9000874a:	6812      	ldr	r2, [r2, #0]
9000874c:	b142      	cbz	r2, 90008760 <xTaskIncrementTick+0x30>
9000874e:	f04f 0350 	mov.w	r3, #80	; 0x50
90008752:	f383 8811 	msr	BASEPRI, r3
90008756:	f3bf 8f6f 	isb	sy
9000875a:	f3bf 8f4f 	dsb	sy
9000875e:	e7fe      	b.n	9000875e <xTaskIncrementTick+0x2e>
90008760:	4a39      	ldr	r2, [pc, #228]	; (90008848 <xTaskIncrementTick+0x118>)
90008762:	6819      	ldr	r1, [r3, #0]
90008764:	6810      	ldr	r0, [r2, #0]
90008766:	6018      	str	r0, [r3, #0]
90008768:	6011      	str	r1, [r2, #0]
9000876a:	4a38      	ldr	r2, [pc, #224]	; (9000884c <xTaskIncrementTick+0x11c>)
9000876c:	6813      	ldr	r3, [r2, #0]
9000876e:	3301      	adds	r3, #1
90008770:	6013      	str	r3, [r2, #0]
90008772:	f7ff fe6f 	bl	90008454 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
90008776:	4e36      	ldr	r6, [pc, #216]	; (90008850 <xTaskIncrementTick+0x120>)
BaseType_t xSwitchRequired = pdFALSE;
90008778:	2400      	movs	r4, #0
9000877a:	4f36      	ldr	r7, [pc, #216]	; (90008854 <xTaskIncrementTick+0x124>)
		if( xConstTickCount >= xNextTaskUnblockTime )
9000877c:	6833      	ldr	r3, [r6, #0]
9000877e:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 90008860 <xTaskIncrementTick+0x130>
90008782:	429d      	cmp	r5, r3
90008784:	d216      	bcs.n	900087b4 <xTaskIncrementTick+0x84>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
90008786:	f8d8 3000 	ldr.w	r3, [r8]
9000878a:	2214      	movs	r2, #20
9000878c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000878e:	4353      	muls	r3, r2
90008790:	58fb      	ldr	r3, [r7, r3]
				xSwitchRequired = pdTRUE;
90008792:	2b02      	cmp	r3, #2
			if( xPendedTicks == ( TickType_t ) 0 )
90008794:	4b30      	ldr	r3, [pc, #192]	; (90008858 <xTaskIncrementTick+0x128>)
90008796:	681b      	ldr	r3, [r3, #0]
				xSwitchRequired = pdTRUE;
90008798:	bf28      	it	cs
9000879a:	2401      	movcs	r4, #1
			if( xPendedTicks == ( TickType_t ) 0 )
9000879c:	b90b      	cbnz	r3, 900087a2 <xTaskIncrementTick+0x72>
				vApplicationTickHook();
9000879e:	f7f7 fedf 	bl	90000560 <vApplicationTickHook>
			if( xYieldPending != pdFALSE )
900087a2:	4b2e      	ldr	r3, [pc, #184]	; (9000885c <xTaskIncrementTick+0x12c>)
900087a4:	681b      	ldr	r3, [r3, #0]
				xSwitchRequired = pdTRUE;
900087a6:	2b00      	cmp	r3, #0
900087a8:	bf18      	it	ne
900087aa:	2401      	movne	r4, #1
}
900087ac:	4620      	mov	r0, r4
900087ae:	b003      	add	sp, #12
900087b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
900087b4:	f8df 908c 	ldr.w	r9, [pc, #140]	; 90008844 <xTaskIncrementTick+0x114>
					prvAddTaskToReadyList( pxTCB );
900087b8:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 90008864 <xTaskIncrementTick+0x134>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
900087bc:	f8d9 3000 	ldr.w	r3, [r9]
900087c0:	681b      	ldr	r3, [r3, #0]
900087c2:	b91b      	cbnz	r3, 900087cc <xTaskIncrementTick+0x9c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
900087c4:	f04f 33ff 	mov.w	r3, #4294967295
900087c8:	6033      	str	r3, [r6, #0]
					break;
900087ca:	e7dc      	b.n	90008786 <xTaskIncrementTick+0x56>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900087cc:	f8d9 3000 	ldr.w	r3, [r9]
900087d0:	68db      	ldr	r3, [r3, #12]
900087d2:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
900087d6:	f8db 2004 	ldr.w	r2, [fp, #4]
					if( xConstTickCount < xItemValue )
900087da:	4295      	cmp	r5, r2
900087dc:	d201      	bcs.n	900087e2 <xTaskIncrementTick+0xb2>
						xNextTaskUnblockTime = xItemValue;
900087de:	6032      	str	r2, [r6, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
900087e0:	e7d1      	b.n	90008786 <xTaskIncrementTick+0x56>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
900087e2:	f10b 0104 	add.w	r1, fp, #4
900087e6:	4608      	mov	r0, r1
900087e8:	9101      	str	r1, [sp, #4]
900087ea:	f7fe fe58 	bl	9000749e <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
900087ee:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
900087f2:	9901      	ldr	r1, [sp, #4]
900087f4:	b122      	cbz	r2, 90008800 <xTaskIncrementTick+0xd0>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
900087f6:	f10b 0018 	add.w	r0, fp, #24
900087fa:	f7fe fe50 	bl	9000749e <uxListRemove>
900087fe:	9901      	ldr	r1, [sp, #4]
					prvAddTaskToReadyList( pxTCB );
90008800:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
90008804:	f8da 2000 	ldr.w	r2, [sl]
90008808:	4290      	cmp	r0, r2
9000880a:	d901      	bls.n	90008810 <xTaskIncrementTick+0xe0>
9000880c:	f8ca 0000 	str.w	r0, [sl]
90008810:	2314      	movs	r3, #20
90008812:	fb03 7000 	mla	r0, r3, r0, r7
90008816:	f7fe fe1f 	bl	90007458 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9000881a:	f8d8 1000 	ldr.w	r1, [r8]
9000881e:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
90008822:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
90008824:	429a      	cmp	r2, r3
90008826:	bf28      	it	cs
90008828:	2401      	movcs	r4, #1
9000882a:	e7c7      	b.n	900087bc <xTaskIncrementTick+0x8c>
		++xPendedTicks;
9000882c:	4a0a      	ldr	r2, [pc, #40]	; (90008858 <xTaskIncrementTick+0x128>)
BaseType_t xSwitchRequired = pdFALSE;
9000882e:	2400      	movs	r4, #0
		++xPendedTicks;
90008830:	6813      	ldr	r3, [r2, #0]
90008832:	3301      	adds	r3, #1
90008834:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
90008836:	f7f7 fe93 	bl	90000560 <vApplicationTickHook>
	return xSwitchRequired;
9000883a:	e7b7      	b.n	900087ac <xTaskIncrementTick+0x7c>
9000883c:	2400997c 	.word	0x2400997c
90008840:	240099fc 	.word	0x240099fc
90008844:	2400950c 	.word	0x2400950c
90008848:	24009510 	.word	0x24009510
9000884c:	240099b4 	.word	0x240099b4
90008850:	240099b0 	.word	0x240099b0
90008854:	24009514 	.word	0x24009514
90008858:	240099b8 	.word	0x240099b8
9000885c:	24009a00 	.word	0x24009a00
90008860:	24009508 	.word	0x24009508
90008864:	24009984 	.word	0x24009984

90008868 <xTaskResumeAll>:
{
90008868:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
9000886a:	4c31      	ldr	r4, [pc, #196]	; (90008930 <xTaskResumeAll+0xc8>)
9000886c:	6823      	ldr	r3, [r4, #0]
9000886e:	b943      	cbnz	r3, 90008882 <xTaskResumeAll+0x1a>
90008870:	f04f 0350 	mov.w	r3, #80	; 0x50
90008874:	f383 8811 	msr	BASEPRI, r3
90008878:	f3bf 8f6f 	isb	sy
9000887c:	f3bf 8f4f 	dsb	sy
90008880:	e7fe      	b.n	90008880 <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
90008882:	f7fe fe7f 	bl	90007584 <vPortEnterCritical>
		--uxSchedulerSuspended;
90008886:	6823      	ldr	r3, [r4, #0]
90008888:	3b01      	subs	r3, #1
9000888a:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9000888c:	6824      	ldr	r4, [r4, #0]
9000888e:	b12c      	cbz	r4, 9000889c <xTaskResumeAll+0x34>
BaseType_t xAlreadyYielded = pdFALSE;
90008890:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
90008892:	f7fe fe97 	bl	900075c4 <vPortExitCritical>
}
90008896:	4620      	mov	r0, r4
90008898:	b003      	add	sp, #12
9000889a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
9000889c:	4b25      	ldr	r3, [pc, #148]	; (90008934 <xTaskResumeAll+0xcc>)
9000889e:	681b      	ldr	r3, [r3, #0]
900088a0:	2b00      	cmp	r3, #0
900088a2:	d0f5      	beq.n	90008890 <xTaskResumeAll+0x28>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
900088a4:	4d24      	ldr	r5, [pc, #144]	; (90008938 <xTaskResumeAll+0xd0>)
					prvAddTaskToReadyList( pxTCB );
900088a6:	4e25      	ldr	r6, [pc, #148]	; (9000893c <xTaskResumeAll+0xd4>)
900088a8:	4f25      	ldr	r7, [pc, #148]	; (90008940 <xTaskResumeAll+0xd8>)
900088aa:	e01e      	b.n	900088ea <xTaskResumeAll+0x82>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900088ac:	68eb      	ldr	r3, [r5, #12]
900088ae:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
900088b0:	f104 0018 	add.w	r0, r4, #24
900088b4:	f7fe fdf3 	bl	9000749e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
900088b8:	1d21      	adds	r1, r4, #4
900088ba:	4608      	mov	r0, r1
900088bc:	9101      	str	r1, [sp, #4]
900088be:	f7fe fdee 	bl	9000749e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
900088c2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
900088c4:	6832      	ldr	r2, [r6, #0]
900088c6:	9901      	ldr	r1, [sp, #4]
900088c8:	4293      	cmp	r3, r2
900088ca:	d900      	bls.n	900088ce <xTaskResumeAll+0x66>
900088cc:	6033      	str	r3, [r6, #0]
900088ce:	2014      	movs	r0, #20
900088d0:	fb00 7003 	mla	r0, r0, r3, r7
900088d4:	f7fe fdc0 	bl	90007458 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
900088d8:	4b1a      	ldr	r3, [pc, #104]	; (90008944 <xTaskResumeAll+0xdc>)
900088da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
900088dc:	681b      	ldr	r3, [r3, #0]
900088de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900088e0:	429a      	cmp	r2, r3
900088e2:	d302      	bcc.n	900088ea <xTaskResumeAll+0x82>
						xYieldPending = pdTRUE;
900088e4:	4b18      	ldr	r3, [pc, #96]	; (90008948 <xTaskResumeAll+0xe0>)
900088e6:	2201      	movs	r2, #1
900088e8:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
900088ea:	682b      	ldr	r3, [r5, #0]
900088ec:	2b00      	cmp	r3, #0
900088ee:	d1dd      	bne.n	900088ac <xTaskResumeAll+0x44>
				if( pxTCB != NULL )
900088f0:	b10c      	cbz	r4, 900088f6 <xTaskResumeAll+0x8e>
					prvResetNextTaskUnblockTime();
900088f2:	f7ff fdaf 	bl	90008454 <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
900088f6:	4d15      	ldr	r5, [pc, #84]	; (9000894c <xTaskResumeAll+0xe4>)
900088f8:	682c      	ldr	r4, [r5, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
900088fa:	b144      	cbz	r4, 9000890e <xTaskResumeAll+0xa6>
								xYieldPending = pdTRUE;
900088fc:	4e12      	ldr	r6, [pc, #72]	; (90008948 <xTaskResumeAll+0xe0>)
900088fe:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
90008900:	f7ff ff16 	bl	90008730 <xTaskIncrementTick>
90008904:	b100      	cbz	r0, 90008908 <xTaskResumeAll+0xa0>
								xYieldPending = pdTRUE;
90008906:	6037      	str	r7, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
90008908:	3c01      	subs	r4, #1
9000890a:	d1f9      	bne.n	90008900 <xTaskResumeAll+0x98>
						xPendedTicks = 0;
9000890c:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
9000890e:	4b0e      	ldr	r3, [pc, #56]	; (90008948 <xTaskResumeAll+0xe0>)
90008910:	681b      	ldr	r3, [r3, #0]
90008912:	2b00      	cmp	r3, #0
90008914:	d0bc      	beq.n	90008890 <xTaskResumeAll+0x28>
					taskYIELD_IF_USING_PREEMPTION();
90008916:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
9000891a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
9000891e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90008922:	f3bf 8f4f 	dsb	sy
90008926:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
9000892a:	2401      	movs	r4, #1
9000892c:	e7b1      	b.n	90008892 <xTaskResumeAll+0x2a>
9000892e:	bf00      	nop
90008930:	2400997c 	.word	0x2400997c
90008934:	24009974 	.word	0x24009974
90008938:	240099bc 	.word	0x240099bc
9000893c:	24009984 	.word	0x24009984
90008940:	24009514 	.word	0x24009514
90008944:	24009508 	.word	0x24009508
90008948:	24009a00 	.word	0x24009a00
9000894c:	240099b8 	.word	0x240099b8

90008950 <vTaskDelay>:
	{
90008950:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
90008952:	b950      	cbnz	r0, 9000896a <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
90008954:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
90008958:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
9000895c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
90008960:	f3bf 8f4f 	dsb	sy
90008964:	f3bf 8f6f 	isb	sy
	}
90008968:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
9000896a:	4b0a      	ldr	r3, [pc, #40]	; (90008994 <vTaskDelay+0x44>)
9000896c:	6819      	ldr	r1, [r3, #0]
9000896e:	b141      	cbz	r1, 90008982 <vTaskDelay+0x32>
90008970:	f04f 0350 	mov.w	r3, #80	; 0x50
90008974:	f383 8811 	msr	BASEPRI, r3
90008978:	f3bf 8f6f 	isb	sy
9000897c:	f3bf 8f4f 	dsb	sy
90008980:	e7fe      	b.n	90008980 <vTaskDelay+0x30>
			vTaskSuspendAll();
90008982:	f7ff febf 	bl	90008704 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
90008986:	f7ff fd2d 	bl	900083e4 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
9000898a:	f7ff ff6d 	bl	90008868 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
9000898e:	2800      	cmp	r0, #0
90008990:	d0e0      	beq.n	90008954 <vTaskDelay+0x4>
90008992:	e7e9      	b.n	90008968 <vTaskDelay+0x18>
90008994:	2400997c 	.word	0x2400997c

90008998 <vTaskSwitchContext>:
{
90008998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
9000899a:	4b1d      	ldr	r3, [pc, #116]	; (90008a10 <vTaskSwitchContext+0x78>)
9000899c:	681a      	ldr	r2, [r3, #0]
9000899e:	4b1d      	ldr	r3, [pc, #116]	; (90008a14 <vTaskSwitchContext+0x7c>)
900089a0:	b112      	cbz	r2, 900089a8 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
900089a2:	2201      	movs	r2, #1
900089a4:	601a      	str	r2, [r3, #0]
}
900089a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
900089a8:	4c1b      	ldr	r4, [pc, #108]	; (90008a18 <vTaskSwitchContext+0x80>)
		xYieldPending = pdFALSE;
900089aa:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
900089ac:	6822      	ldr	r2, [r4, #0]
900089ae:	6823      	ldr	r3, [r4, #0]
900089b0:	6812      	ldr	r2, [r2, #0]
900089b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900089b4:	429a      	cmp	r2, r3
900089b6:	d804      	bhi.n	900089c2 <vTaskSwitchContext+0x2a>
900089b8:	6820      	ldr	r0, [r4, #0]
900089ba:	6821      	ldr	r1, [r4, #0]
900089bc:	3134      	adds	r1, #52	; 0x34
900089be:	f7f7 fdd0 	bl	90000562 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900089c2:	4e16      	ldr	r6, [pc, #88]	; (90008a1c <vTaskSwitchContext+0x84>)
900089c4:	2714      	movs	r7, #20
900089c6:	4916      	ldr	r1, [pc, #88]	; (90008a20 <vTaskSwitchContext+0x88>)
900089c8:	6832      	ldr	r2, [r6, #0]
900089ca:	fb07 f302 	mul.w	r3, r7, r2
900089ce:	58cd      	ldr	r5, [r1, r3]
900089d0:	18c8      	adds	r0, r1, r3
900089d2:	b185      	cbz	r5, 900089f6 <vTaskSwitchContext+0x5e>
900089d4:	6845      	ldr	r5, [r0, #4]
900089d6:	3308      	adds	r3, #8
900089d8:	686d      	ldr	r5, [r5, #4]
900089da:	440b      	add	r3, r1
900089dc:	429d      	cmp	r5, r3
900089de:	6045      	str	r5, [r0, #4]
900089e0:	bf04      	itt	eq
900089e2:	686b      	ldreq	r3, [r5, #4]
900089e4:	6043      	streq	r3, [r0, #4]
900089e6:	2314      	movs	r3, #20
900089e8:	fb03 1102 	mla	r1, r3, r2, r1
900089ec:	684b      	ldr	r3, [r1, #4]
900089ee:	68db      	ldr	r3, [r3, #12]
900089f0:	6023      	str	r3, [r4, #0]
900089f2:	6032      	str	r2, [r6, #0]
}
900089f4:	e7d7      	b.n	900089a6 <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
900089f6:	b942      	cbnz	r2, 90008a0a <vTaskSwitchContext+0x72>
900089f8:	f04f 0350 	mov.w	r3, #80	; 0x50
900089fc:	f383 8811 	msr	BASEPRI, r3
90008a00:	f3bf 8f6f 	isb	sy
90008a04:	f3bf 8f4f 	dsb	sy
90008a08:	e7fe      	b.n	90008a08 <vTaskSwitchContext+0x70>
90008a0a:	3a01      	subs	r2, #1
90008a0c:	e7dd      	b.n	900089ca <vTaskSwitchContext+0x32>
90008a0e:	bf00      	nop
90008a10:	2400997c 	.word	0x2400997c
90008a14:	24009a00 	.word	0x24009a00
90008a18:	24009508 	.word	0x24009508
90008a1c:	24009984 	.word	0x24009984
90008a20:	24009514 	.word	0x24009514

90008a24 <vTaskPlaceOnEventList>:
{
90008a24:	b510      	push	{r4, lr}
90008a26:	460c      	mov	r4, r1
	configASSERT( pxEventList );
90008a28:	b940      	cbnz	r0, 90008a3c <vTaskPlaceOnEventList+0x18>
90008a2a:	f04f 0350 	mov.w	r3, #80	; 0x50
90008a2e:	f383 8811 	msr	BASEPRI, r3
90008a32:	f3bf 8f6f 	isb	sy
90008a36:	f3bf 8f4f 	dsb	sy
90008a3a:	e7fe      	b.n	90008a3a <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
90008a3c:	4b05      	ldr	r3, [pc, #20]	; (90008a54 <vTaskPlaceOnEventList+0x30>)
90008a3e:	6819      	ldr	r1, [r3, #0]
90008a40:	3118      	adds	r1, #24
90008a42:	f7fe fd15 	bl	90007470 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
90008a46:	4620      	mov	r0, r4
90008a48:	2101      	movs	r1, #1
}
90008a4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
90008a4e:	f7ff bcc9 	b.w	900083e4 <prvAddCurrentTaskToDelayedList>
90008a52:	bf00      	nop
90008a54:	24009508 	.word	0x24009508

90008a58 <vTaskPlaceOnEventListRestricted>:
	{
90008a58:	b538      	push	{r3, r4, r5, lr}
90008a5a:	460d      	mov	r5, r1
90008a5c:	4614      	mov	r4, r2
		configASSERT( pxEventList );
90008a5e:	b940      	cbnz	r0, 90008a72 <vTaskPlaceOnEventListRestricted+0x1a>
90008a60:	f04f 0350 	mov.w	r3, #80	; 0x50
90008a64:	f383 8811 	msr	BASEPRI, r3
90008a68:	f3bf 8f6f 	isb	sy
90008a6c:	f3bf 8f4f 	dsb	sy
90008a70:	e7fe      	b.n	90008a70 <vTaskPlaceOnEventListRestricted+0x18>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
90008a72:	4b07      	ldr	r3, [pc, #28]	; (90008a90 <vTaskPlaceOnEventListRestricted+0x38>)
90008a74:	6819      	ldr	r1, [r3, #0]
90008a76:	3118      	adds	r1, #24
90008a78:	f7fe fcee 	bl	90007458 <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
90008a7c:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
90008a7e:	4621      	mov	r1, r4
90008a80:	bf0c      	ite	eq
90008a82:	4628      	moveq	r0, r5
90008a84:	f04f 30ff 	movne.w	r0, #4294967295
	}
90008a88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
90008a8c:	f7ff bcaa 	b.w	900083e4 <prvAddCurrentTaskToDelayedList>
90008a90:	24009508 	.word	0x24009508

90008a94 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
90008a94:	68c3      	ldr	r3, [r0, #12]
{
90008a96:	b513      	push	{r0, r1, r4, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
90008a98:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
90008a9a:	b944      	cbnz	r4, 90008aae <xTaskRemoveFromEventList+0x1a>
90008a9c:	f04f 0350 	mov.w	r3, #80	; 0x50
90008aa0:	f383 8811 	msr	BASEPRI, r3
90008aa4:	f3bf 8f6f 	isb	sy
90008aa8:	f3bf 8f4f 	dsb	sy
90008aac:	e7fe      	b.n	90008aac <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
90008aae:	f104 0118 	add.w	r1, r4, #24
90008ab2:	4608      	mov	r0, r1
90008ab4:	9101      	str	r1, [sp, #4]
90008ab6:	f7fe fcf2 	bl	9000749e <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
90008aba:	4b12      	ldr	r3, [pc, #72]	; (90008b04 <xTaskRemoveFromEventList+0x70>)
90008abc:	9901      	ldr	r1, [sp, #4]
90008abe:	681b      	ldr	r3, [r3, #0]
90008ac0:	b9e3      	cbnz	r3, 90008afc <xTaskRemoveFromEventList+0x68>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
90008ac2:	1d21      	adds	r1, r4, #4
90008ac4:	4608      	mov	r0, r1
90008ac6:	9101      	str	r1, [sp, #4]
90008ac8:	f7fe fce9 	bl	9000749e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
90008acc:	4a0e      	ldr	r2, [pc, #56]	; (90008b08 <xTaskRemoveFromEventList+0x74>)
90008ace:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90008ad0:	6810      	ldr	r0, [r2, #0]
90008ad2:	9901      	ldr	r1, [sp, #4]
90008ad4:	4283      	cmp	r3, r0
90008ad6:	d900      	bls.n	90008ada <xTaskRemoveFromEventList+0x46>
90008ad8:	6013      	str	r3, [r2, #0]
90008ada:	4a0c      	ldr	r2, [pc, #48]	; (90008b0c <xTaskRemoveFromEventList+0x78>)
90008adc:	2014      	movs	r0, #20
90008ade:	fb00 2003 	mla	r0, r0, r3, r2
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
90008ae2:	f7fe fcb9 	bl	90007458 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
90008ae6:	4b0a      	ldr	r3, [pc, #40]	; (90008b10 <xTaskRemoveFromEventList+0x7c>)
90008ae8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
90008aea:	681b      	ldr	r3, [r3, #0]
90008aec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90008aee:	429a      	cmp	r2, r3
90008af0:	d906      	bls.n	90008b00 <xTaskRemoveFromEventList+0x6c>
		xYieldPending = pdTRUE;
90008af2:	2001      	movs	r0, #1
90008af4:	4b07      	ldr	r3, [pc, #28]	; (90008b14 <xTaskRemoveFromEventList+0x80>)
90008af6:	6018      	str	r0, [r3, #0]
}
90008af8:	b002      	add	sp, #8
90008afa:	bd10      	pop	{r4, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
90008afc:	4806      	ldr	r0, [pc, #24]	; (90008b18 <xTaskRemoveFromEventList+0x84>)
90008afe:	e7f0      	b.n	90008ae2 <xTaskRemoveFromEventList+0x4e>
		xReturn = pdFALSE;
90008b00:	2000      	movs	r0, #0
	return xReturn;
90008b02:	e7f9      	b.n	90008af8 <xTaskRemoveFromEventList+0x64>
90008b04:	2400997c 	.word	0x2400997c
90008b08:	24009984 	.word	0x24009984
90008b0c:	24009514 	.word	0x24009514
90008b10:	24009508 	.word	0x24009508
90008b14:	24009a00 	.word	0x24009a00
90008b18:	240099bc 	.word	0x240099bc

90008b1c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
90008b1c:	4b03      	ldr	r3, [pc, #12]	; (90008b2c <vTaskInternalSetTimeOutState+0x10>)
90008b1e:	681b      	ldr	r3, [r3, #0]
90008b20:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
90008b22:	4b03      	ldr	r3, [pc, #12]	; (90008b30 <vTaskInternalSetTimeOutState+0x14>)
90008b24:	681b      	ldr	r3, [r3, #0]
90008b26:	6043      	str	r3, [r0, #4]
}
90008b28:	4770      	bx	lr
90008b2a:	bf00      	nop
90008b2c:	240099b4 	.word	0x240099b4
90008b30:	240099fc 	.word	0x240099fc

90008b34 <xTaskCheckForTimeOut>:
{
90008b34:	b570      	push	{r4, r5, r6, lr}
90008b36:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
90008b38:	4605      	mov	r5, r0
90008b3a:	b940      	cbnz	r0, 90008b4e <xTaskCheckForTimeOut+0x1a>
90008b3c:	f04f 0350 	mov.w	r3, #80	; 0x50
90008b40:	f383 8811 	msr	BASEPRI, r3
90008b44:	f3bf 8f6f 	isb	sy
90008b48:	f3bf 8f4f 	dsb	sy
90008b4c:	e7fe      	b.n	90008b4c <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
90008b4e:	b941      	cbnz	r1, 90008b62 <xTaskCheckForTimeOut+0x2e>
90008b50:	f04f 0350 	mov.w	r3, #80	; 0x50
90008b54:	f383 8811 	msr	BASEPRI, r3
90008b58:	f3bf 8f6f 	isb	sy
90008b5c:	f3bf 8f4f 	dsb	sy
90008b60:	e7fe      	b.n	90008b60 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
90008b62:	f7fe fd0f 	bl	90007584 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
90008b66:	4b0f      	ldr	r3, [pc, #60]	; (90008ba4 <xTaskCheckForTimeOut+0x70>)
90008b68:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
90008b6a:	6823      	ldr	r3, [r4, #0]
90008b6c:	1c5a      	adds	r2, r3, #1
90008b6e:	d010      	beq.n	90008b92 <xTaskCheckForTimeOut+0x5e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
90008b70:	480d      	ldr	r0, [pc, #52]	; (90008ba8 <xTaskCheckForTimeOut+0x74>)
90008b72:	682e      	ldr	r6, [r5, #0]
90008b74:	6800      	ldr	r0, [r0, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
90008b76:	686a      	ldr	r2, [r5, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
90008b78:	4286      	cmp	r6, r0
90008b7a:	d001      	beq.n	90008b80 <xTaskCheckForTimeOut+0x4c>
90008b7c:	428a      	cmp	r2, r1
90008b7e:	d90f      	bls.n	90008ba0 <xTaskCheckForTimeOut+0x6c>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
90008b80:	1a88      	subs	r0, r1, r2
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
90008b82:	4283      	cmp	r3, r0
90008b84:	d90a      	bls.n	90008b9c <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= xElapsedTime;
90008b86:	1a5b      	subs	r3, r3, r1
			vTaskInternalSetTimeOutState( pxTimeOut );
90008b88:	4628      	mov	r0, r5
			*pxTicksToWait -= xElapsedTime;
90008b8a:	4413      	add	r3, r2
90008b8c:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
90008b8e:	f7ff ffc5 	bl	90008b1c <vTaskInternalSetTimeOutState>
				xReturn = pdFALSE;
90008b92:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
90008b94:	f7fe fd16 	bl	900075c4 <vPortExitCritical>
}
90008b98:	4620      	mov	r0, r4
90008b9a:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
90008b9c:	2300      	movs	r3, #0
90008b9e:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
90008ba0:	2401      	movs	r4, #1
90008ba2:	e7f7      	b.n	90008b94 <xTaskCheckForTimeOut+0x60>
90008ba4:	240099fc 	.word	0x240099fc
90008ba8:	240099b4 	.word	0x240099b4

90008bac <vTaskMissedYield>:
	xYieldPending = pdTRUE;
90008bac:	4b01      	ldr	r3, [pc, #4]	; (90008bb4 <vTaskMissedYield+0x8>)
90008bae:	2201      	movs	r2, #1
90008bb0:	601a      	str	r2, [r3, #0]
}
90008bb2:	4770      	bx	lr
90008bb4:	24009a00 	.word	0x24009a00

90008bb8 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
90008bb8:	4b01      	ldr	r3, [pc, #4]	; (90008bc0 <xTaskGetCurrentTaskHandle+0x8>)
90008bba:	6818      	ldr	r0, [r3, #0]
	}
90008bbc:	4770      	bx	lr
90008bbe:	bf00      	nop
90008bc0:	24009508 	.word	0x24009508

90008bc4 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
90008bc4:	4b05      	ldr	r3, [pc, #20]	; (90008bdc <xTaskGetSchedulerState+0x18>)
90008bc6:	681b      	ldr	r3, [r3, #0]
90008bc8:	b133      	cbz	r3, 90008bd8 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
90008bca:	4b05      	ldr	r3, [pc, #20]	; (90008be0 <xTaskGetSchedulerState+0x1c>)
90008bcc:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
90008bce:	2b00      	cmp	r3, #0
90008bd0:	bf0c      	ite	eq
90008bd2:	2002      	moveq	r0, #2
90008bd4:	2000      	movne	r0, #0
90008bd6:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
90008bd8:	2001      	movs	r0, #1
	}
90008bda:	4770      	bx	lr
90008bdc:	240099d0 	.word	0x240099d0
90008be0:	2400997c 	.word	0x2400997c

90008be4 <xTaskPriorityInherit>:
	{
90008be4:	b573      	push	{r0, r1, r4, r5, r6, lr}
		if( pxMutexHolder != NULL )
90008be6:	4604      	mov	r4, r0
90008be8:	b340      	cbz	r0, 90008c3c <xTaskPriorityInherit+0x58>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
90008bea:	4d1b      	ldr	r5, [pc, #108]	; (90008c58 <xTaskPriorityInherit+0x74>)
90008bec:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
90008bee:	682a      	ldr	r2, [r5, #0]
90008bf0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
90008bf2:	4293      	cmp	r3, r2
90008bf4:	d228      	bcs.n	90008c48 <xTaskPriorityInherit+0x64>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
90008bf6:	6982      	ldr	r2, [r0, #24]
90008bf8:	2a00      	cmp	r2, #0
90008bfa:	db04      	blt.n	90008c06 <xTaskPriorityInherit+0x22>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008bfc:	682a      	ldr	r2, [r5, #0]
90008bfe:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
90008c00:	f1c2 0238 	rsb	r2, r2, #56	; 0x38
90008c04:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
90008c06:	2214      	movs	r2, #20
90008c08:	4e14      	ldr	r6, [pc, #80]	; (90008c5c <xTaskPriorityInherit+0x78>)
90008c0a:	fb02 6303 	mla	r3, r2, r3, r6
90008c0e:	6962      	ldr	r2, [r4, #20]
90008c10:	429a      	cmp	r2, r3
90008c12:	d115      	bne.n	90008c40 <xTaskPriorityInherit+0x5c>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
90008c14:	1d21      	adds	r1, r4, #4
90008c16:	4608      	mov	r0, r1
90008c18:	9101      	str	r1, [sp, #4]
90008c1a:	f7fe fc40 	bl	9000749e <uxListRemove>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
90008c1e:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxMutexHolderTCB );
90008c20:	4a0f      	ldr	r2, [pc, #60]	; (90008c60 <xTaskPriorityInherit+0x7c>)
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
90008c22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
90008c24:	6810      	ldr	r0, [r2, #0]
90008c26:	9901      	ldr	r1, [sp, #4]
90008c28:	4283      	cmp	r3, r0
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
90008c2a:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
90008c2c:	d900      	bls.n	90008c30 <xTaskPriorityInherit+0x4c>
90008c2e:	6013      	str	r3, [r2, #0]
90008c30:	2014      	movs	r0, #20
90008c32:	fb00 6003 	mla	r0, r0, r3, r6
90008c36:	f7fe fc0f 	bl	90007458 <vListInsertEnd>
				xReturn = pdTRUE;
90008c3a:	2001      	movs	r0, #1
	}
90008c3c:	b002      	add	sp, #8
90008c3e:	bd70      	pop	{r4, r5, r6, pc}
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
90008c40:	682b      	ldr	r3, [r5, #0]
90008c42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90008c44:	62e3      	str	r3, [r4, #44]	; 0x2c
90008c46:	e7f8      	b.n	90008c3a <xTaskPriorityInherit+0x56>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
90008c48:	682b      	ldr	r3, [r5, #0]
90008c4a:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
90008c4c:	6adc      	ldr	r4, [r3, #44]	; 0x2c
90008c4e:	42a0      	cmp	r0, r4
90008c50:	bf2c      	ite	cs
90008c52:	2000      	movcs	r0, #0
90008c54:	2001      	movcc	r0, #1
90008c56:	e7f1      	b.n	90008c3c <xTaskPriorityInherit+0x58>
90008c58:	24009508 	.word	0x24009508
90008c5c:	24009514 	.word	0x24009514
90008c60:	24009984 	.word	0x24009984

90008c64 <xTaskPriorityDisinherit>:
	{
90008c64:	b513      	push	{r0, r1, r4, lr}
		if( pxMutexHolder != NULL )
90008c66:	b910      	cbnz	r0, 90008c6e <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
90008c68:	2000      	movs	r0, #0
	}
90008c6a:	b002      	add	sp, #8
90008c6c:	bd10      	pop	{r4, pc}
			configASSERT( pxTCB == pxCurrentTCB );
90008c6e:	4b1c      	ldr	r3, [pc, #112]	; (90008ce0 <xTaskPriorityDisinherit+0x7c>)
90008c70:	681c      	ldr	r4, [r3, #0]
90008c72:	4284      	cmp	r4, r0
90008c74:	d008      	beq.n	90008c88 <xTaskPriorityDisinherit+0x24>
90008c76:	f04f 0350 	mov.w	r3, #80	; 0x50
90008c7a:	f383 8811 	msr	BASEPRI, r3
90008c7e:	f3bf 8f6f 	isb	sy
90008c82:	f3bf 8f4f 	dsb	sy
90008c86:	e7fe      	b.n	90008c86 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
90008c88:	6d23      	ldr	r3, [r4, #80]	; 0x50
90008c8a:	b943      	cbnz	r3, 90008c9e <xTaskPriorityDisinherit+0x3a>
90008c8c:	f04f 0350 	mov.w	r3, #80	; 0x50
90008c90:	f383 8811 	msr	BASEPRI, r3
90008c94:	f3bf 8f6f 	isb	sy
90008c98:	f3bf 8f4f 	dsb	sy
90008c9c:	e7fe      	b.n	90008c9c <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
90008c9e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			( pxTCB->uxMutexesHeld )--;
90008ca0:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
90008ca2:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
90008ca4:	6523      	str	r3, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
90008ca6:	4291      	cmp	r1, r2
90008ca8:	d0de      	beq.n	90008c68 <xTaskPriorityDisinherit+0x4>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
90008caa:	2b00      	cmp	r3, #0
90008cac:	d1dc      	bne.n	90008c68 <xTaskPriorityDisinherit+0x4>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
90008cae:	1d21      	adds	r1, r4, #4
90008cb0:	4608      	mov	r0, r1
90008cb2:	9101      	str	r1, [sp, #4]
90008cb4:	f7fe fbf3 	bl	9000749e <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
90008cb8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
					prvAddTaskToReadyList( pxTCB );
90008cba:	9901      	ldr	r1, [sp, #4]
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008cbc:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
					pxTCB->uxPriority = pxTCB->uxBasePriority;
90008cc0:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008cc2:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
90008cc4:	4a07      	ldr	r2, [pc, #28]	; (90008ce4 <xTaskPriorityDisinherit+0x80>)
90008cc6:	6810      	ldr	r0, [r2, #0]
90008cc8:	4283      	cmp	r3, r0
90008cca:	d900      	bls.n	90008cce <xTaskPriorityDisinherit+0x6a>
90008ccc:	6013      	str	r3, [r2, #0]
90008cce:	4a06      	ldr	r2, [pc, #24]	; (90008ce8 <xTaskPriorityDisinherit+0x84>)
90008cd0:	2014      	movs	r0, #20
90008cd2:	fb00 2003 	mla	r0, r0, r3, r2
90008cd6:	f7fe fbbf 	bl	90007458 <vListInsertEnd>
					xReturn = pdTRUE;
90008cda:	2001      	movs	r0, #1
		return xReturn;
90008cdc:	e7c5      	b.n	90008c6a <xTaskPriorityDisinherit+0x6>
90008cde:	bf00      	nop
90008ce0:	24009508 	.word	0x24009508
90008ce4:	24009984 	.word	0x24009984
90008ce8:	24009514 	.word	0x24009514

90008cec <vTaskPriorityDisinheritAfterTimeout>:
	{
90008cec:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if( pxMutexHolder != NULL )
90008cee:	4604      	mov	r4, r0
90008cf0:	2800      	cmp	r0, #0
90008cf2:	d044      	beq.n	90008d7e <vTaskPriorityDisinheritAfterTimeout+0x92>
			configASSERT( pxTCB->uxMutexesHeld );
90008cf4:	6d02      	ldr	r2, [r0, #80]	; 0x50
90008cf6:	b942      	cbnz	r2, 90008d0a <vTaskPriorityDisinheritAfterTimeout+0x1e>
90008cf8:	f04f 0350 	mov.w	r3, #80	; 0x50
90008cfc:	f383 8811 	msr	BASEPRI, r3
90008d00:	f3bf 8f6f 	isb	sy
90008d04:	f3bf 8f4f 	dsb	sy
90008d08:	e7fe      	b.n	90008d08 <vTaskPriorityDisinheritAfterTimeout+0x1c>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
90008d0a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
90008d0c:	4299      	cmp	r1, r3
90008d0e:	bf38      	it	cc
90008d10:	4619      	movcc	r1, r3
			if( pxTCB->uxPriority != uxPriorityToUse )
90008d12:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
90008d14:	428b      	cmp	r3, r1
90008d16:	d032      	beq.n	90008d7e <vTaskPriorityDisinheritAfterTimeout+0x92>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
90008d18:	2a01      	cmp	r2, #1
90008d1a:	d130      	bne.n	90008d7e <vTaskPriorityDisinheritAfterTimeout+0x92>
					configASSERT( pxTCB != pxCurrentTCB );
90008d1c:	4a19      	ldr	r2, [pc, #100]	; (90008d84 <vTaskPriorityDisinheritAfterTimeout+0x98>)
90008d1e:	6812      	ldr	r2, [r2, #0]
90008d20:	4282      	cmp	r2, r0
90008d22:	d108      	bne.n	90008d36 <vTaskPriorityDisinheritAfterTimeout+0x4a>
90008d24:	f04f 0350 	mov.w	r3, #80	; 0x50
90008d28:	f383 8811 	msr	BASEPRI, r3
90008d2c:	f3bf 8f6f 	isb	sy
90008d30:	f3bf 8f4f 	dsb	sy
90008d34:	e7fe      	b.n	90008d34 <vTaskPriorityDisinheritAfterTimeout+0x48>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
90008d36:	6982      	ldr	r2, [r0, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
90008d38:	4d13      	ldr	r5, [pc, #76]	; (90008d88 <vTaskPriorityDisinheritAfterTimeout+0x9c>)
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
90008d3a:	2a00      	cmp	r2, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
90008d3c:	f04f 0214 	mov.w	r2, #20
					pxTCB->uxPriority = uxPriorityToUse;
90008d40:	62c1      	str	r1, [r0, #44]	; 0x2c
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
90008d42:	fb02 5303 	mla	r3, r2, r3, r5
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008d46:	bfa8      	it	ge
90008d48:	f1c1 0138 	rsbge	r1, r1, #56	; 0x38
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
90008d4c:	6942      	ldr	r2, [r0, #20]
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008d4e:	bfa8      	it	ge
90008d50:	6181      	strge	r1, [r0, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
90008d52:	429a      	cmp	r2, r3
90008d54:	d113      	bne.n	90008d7e <vTaskPriorityDisinheritAfterTimeout+0x92>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
90008d56:	1d01      	adds	r1, r0, #4
90008d58:	4608      	mov	r0, r1
90008d5a:	9101      	str	r1, [sp, #4]
90008d5c:	f7fe fb9f 	bl	9000749e <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
90008d60:	4a0a      	ldr	r2, [pc, #40]	; (90008d8c <vTaskPriorityDisinheritAfterTimeout+0xa0>)
90008d62:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90008d64:	6810      	ldr	r0, [r2, #0]
90008d66:	9901      	ldr	r1, [sp, #4]
90008d68:	4283      	cmp	r3, r0
90008d6a:	d900      	bls.n	90008d6e <vTaskPriorityDisinheritAfterTimeout+0x82>
90008d6c:	6013      	str	r3, [r2, #0]
90008d6e:	2014      	movs	r0, #20
90008d70:	fb00 5003 	mla	r0, r0, r3, r5
	}
90008d74:	b003      	add	sp, #12
90008d76:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
						prvAddTaskToReadyList( pxTCB );
90008d7a:	f7fe bb6d 	b.w	90007458 <vListInsertEnd>
	}
90008d7e:	b003      	add	sp, #12
90008d80:	bd30      	pop	{r4, r5, pc}
90008d82:	bf00      	nop
90008d84:	24009508 	.word	0x24009508
90008d88:	24009514 	.word	0x24009514
90008d8c:	24009984 	.word	0x24009984

90008d90 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
90008d90:	4b04      	ldr	r3, [pc, #16]	; (90008da4 <pvTaskIncrementMutexHeldCount+0x14>)
90008d92:	681a      	ldr	r2, [r3, #0]
90008d94:	b11a      	cbz	r2, 90008d9e <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
90008d96:	6819      	ldr	r1, [r3, #0]
90008d98:	6d0a      	ldr	r2, [r1, #80]	; 0x50
90008d9a:	3201      	adds	r2, #1
90008d9c:	650a      	str	r2, [r1, #80]	; 0x50
		return pxCurrentTCB;
90008d9e:	6818      	ldr	r0, [r3, #0]
	}
90008da0:	4770      	bx	lr
90008da2:	bf00      	nop
90008da4:	24009508 	.word	0x24009508

90008da8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
90008da8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
90008daa:	4c11      	ldr	r4, [pc, #68]	; (90008df0 <prvCheckForValidListAndQueue+0x48>)
	taskENTER_CRITICAL();
90008dac:	f7fe fbea 	bl	90007584 <vPortEnterCritical>
		if( xTimerQueue == NULL )
90008db0:	6825      	ldr	r5, [r4, #0]
90008db2:	b9bd      	cbnz	r5, 90008de4 <prvCheckForValidListAndQueue+0x3c>
		{
			vListInitialise( &xActiveTimerList1 );
90008db4:	4f0f      	ldr	r7, [pc, #60]	; (90008df4 <prvCheckForValidListAndQueue+0x4c>)
			vListInitialise( &xActiveTimerList2 );
90008db6:	4e10      	ldr	r6, [pc, #64]	; (90008df8 <prvCheckForValidListAndQueue+0x50>)
			vListInitialise( &xActiveTimerList1 );
90008db8:	4638      	mov	r0, r7
90008dba:	f7fe fb3f 	bl	9000743c <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
90008dbe:	4630      	mov	r0, r6
90008dc0:	f7fe fb3c 	bl	9000743c <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
90008dc4:	4b0d      	ldr	r3, [pc, #52]	; (90008dfc <prvCheckForValidListAndQueue+0x54>)
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
90008dc6:	4a0e      	ldr	r2, [pc, #56]	; (90008e00 <prvCheckForValidListAndQueue+0x58>)
90008dc8:	2110      	movs	r1, #16
			pxCurrentTimerList = &xActiveTimerList1;
90008dca:	601f      	str	r7, [r3, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
90008dcc:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
90008dce:	4b0d      	ldr	r3, [pc, #52]	; (90008e04 <prvCheckForValidListAndQueue+0x5c>)
90008dd0:	601e      	str	r6, [r3, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
90008dd2:	4b0d      	ldr	r3, [pc, #52]	; (90008e08 <prvCheckForValidListAndQueue+0x60>)
90008dd4:	9500      	str	r5, [sp, #0]
90008dd6:	f7fe fde5 	bl	900079a4 <xQueueGenericCreateStatic>
90008dda:	6020      	str	r0, [r4, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
90008ddc:	b110      	cbz	r0, 90008de4 <prvCheckForValidListAndQueue+0x3c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
90008dde:	490b      	ldr	r1, [pc, #44]	; (90008e0c <prvCheckForValidListAndQueue+0x64>)
90008de0:	f7ff fa22 	bl	90008228 <vQueueAddToRegistry>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
90008de4:	b003      	add	sp, #12
90008de6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
90008dea:	f7fe bbeb 	b.w	900075c4 <vPortExitCritical>
90008dee:	bf00      	nop
90008df0:	24009b28 	.word	0x24009b28
90008df4:	24009aac 	.word	0x24009aac
90008df8:	24009ac0 	.word	0x24009ac0
90008dfc:	24009a04 	.word	0x24009a04
90008e00:	24009a0c 	.word	0x24009a0c
90008e04:	24009a08 	.word	0x24009a08
90008e08:	24009ad8 	.word	0x24009ad8
90008e0c:	90013354 	.word	0x90013354

90008e10 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
90008e10:	4291      	cmp	r1, r2
{
90008e12:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
90008e14:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
90008e16:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
90008e18:	d80a      	bhi.n	90008e30 <prvInsertTimerInActiveList+0x20>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
90008e1a:	1ad2      	subs	r2, r2, r3
90008e1c:	6983      	ldr	r3, [r0, #24]
90008e1e:	429a      	cmp	r2, r3
90008e20:	d20d      	bcs.n	90008e3e <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
90008e22:	1d01      	adds	r1, r0, #4
90008e24:	4b07      	ldr	r3, [pc, #28]	; (90008e44 <prvInsertTimerInActiveList+0x34>)
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
90008e26:	6818      	ldr	r0, [r3, #0]
90008e28:	f7fe fb22 	bl	90007470 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
90008e2c:	2000      	movs	r0, #0
}
90008e2e:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
90008e30:	429a      	cmp	r2, r3
90008e32:	d201      	bcs.n	90008e38 <prvInsertTimerInActiveList+0x28>
90008e34:	4299      	cmp	r1, r3
90008e36:	d202      	bcs.n	90008e3e <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
90008e38:	1d01      	adds	r1, r0, #4
90008e3a:	4b03      	ldr	r3, [pc, #12]	; (90008e48 <prvInsertTimerInActiveList+0x38>)
90008e3c:	e7f3      	b.n	90008e26 <prvInsertTimerInActiveList+0x16>
			xProcessTimerNow = pdTRUE;
90008e3e:	2001      	movs	r0, #1
	return xProcessTimerNow;
90008e40:	e7f5      	b.n	90008e2e <prvInsertTimerInActiveList+0x1e>
90008e42:	bf00      	nop
90008e44:	24009a08 	.word	0x24009a08
90008e48:	24009a04 	.word	0x24009a04

90008e4c <xTimerCreateTimerTask>:
{
90008e4c:	b510      	push	{r4, lr}
90008e4e:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
90008e50:	f7ff ffaa 	bl	90008da8 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
90008e54:	4b12      	ldr	r3, [pc, #72]	; (90008ea0 <xTimerCreateTimerTask+0x54>)
90008e56:	681b      	ldr	r3, [r3, #0]
90008e58:	b1b3      	cbz	r3, 90008e88 <xTimerCreateTimerTask+0x3c>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
90008e5a:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
90008e5c:	aa07      	add	r2, sp, #28
90008e5e:	a906      	add	r1, sp, #24
90008e60:	a805      	add	r0, sp, #20
			StackType_t *pxTimerTaskStackBuffer = NULL;
90008e62:	e9cd 4405 	strd	r4, r4, [sp, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
90008e66:	f7fe f9e3 	bl	90007230 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
90008e6a:	9b05      	ldr	r3, [sp, #20]
90008e6c:	9a07      	ldr	r2, [sp, #28]
90008e6e:	9302      	str	r3, [sp, #8]
90008e70:	9b06      	ldr	r3, [sp, #24]
90008e72:	490c      	ldr	r1, [pc, #48]	; (90008ea4 <xTimerCreateTimerTask+0x58>)
90008e74:	9301      	str	r3, [sp, #4]
90008e76:	2302      	movs	r3, #2
90008e78:	480b      	ldr	r0, [pc, #44]	; (90008ea8 <xTimerCreateTimerTask+0x5c>)
90008e7a:	9300      	str	r3, [sp, #0]
90008e7c:	4623      	mov	r3, r4
90008e7e:	f7ff fb96 	bl	900085ae <xTaskCreateStatic>
90008e82:	4b0a      	ldr	r3, [pc, #40]	; (90008eac <xTimerCreateTimerTask+0x60>)
90008e84:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
90008e86:	b940      	cbnz	r0, 90008e9a <xTimerCreateTimerTask+0x4e>
90008e88:	f04f 0350 	mov.w	r3, #80	; 0x50
90008e8c:	f383 8811 	msr	BASEPRI, r3
90008e90:	f3bf 8f6f 	isb	sy
90008e94:	f3bf 8f4f 	dsb	sy
	configASSERT( xReturn );
90008e98:	e7fe      	b.n	90008e98 <xTimerCreateTimerTask+0x4c>
}
90008e9a:	2001      	movs	r0, #1
90008e9c:	b008      	add	sp, #32
90008e9e:	bd10      	pop	{r4, pc}
90008ea0:	24009b28 	.word	0x24009b28
90008ea4:	90013359 	.word	0x90013359
90008ea8:	90008fb1 	.word	0x90008fb1
90008eac:	24009b2c 	.word	0x24009b2c

90008eb0 <xTimerGenericCommand>:
{
90008eb0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
90008eb2:	4616      	mov	r6, r2
	configASSERT( xTimer );
90008eb4:	4604      	mov	r4, r0
{
90008eb6:	461a      	mov	r2, r3
	configASSERT( xTimer );
90008eb8:	b940      	cbnz	r0, 90008ecc <xTimerGenericCommand+0x1c>
90008eba:	f04f 0350 	mov.w	r3, #80	; 0x50
90008ebe:	f383 8811 	msr	BASEPRI, r3
90008ec2:	f3bf 8f6f 	isb	sy
90008ec6:	f3bf 8f4f 	dsb	sy
90008eca:	e7fe      	b.n	90008eca <xTimerGenericCommand+0x1a>
	if( xTimerQueue != NULL )
90008ecc:	4d0c      	ldr	r5, [pc, #48]	; (90008f00 <xTimerGenericCommand+0x50>)
90008ece:	6828      	ldr	r0, [r5, #0]
90008ed0:	b178      	cbz	r0, 90008ef2 <xTimerGenericCommand+0x42>
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
90008ed2:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.pxTimer = xTimer;
90008ed4:	9402      	str	r4, [sp, #8]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
90008ed6:	e9cd 1600 	strd	r1, r6, [sp]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
90008eda:	dc0c      	bgt.n	90008ef6 <xTimerGenericCommand+0x46>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
90008edc:	f7ff fe72 	bl	90008bc4 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
90008ee0:	2300      	movs	r3, #0
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
90008ee2:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
90008ee4:	4669      	mov	r1, sp
90008ee6:	6828      	ldr	r0, [r5, #0]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
90008ee8:	bf0c      	ite	eq
90008eea:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
90008eec:	461a      	movne	r2, r3
90008eee:	f7fe fe0e 	bl	90007b0e <xQueueGenericSend>
}
90008ef2:	b004      	add	sp, #16
90008ef4:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
90008ef6:	2300      	movs	r3, #0
90008ef8:	4669      	mov	r1, sp
90008efa:	f7fe ff0b 	bl	90007d14 <xQueueGenericSendFromISR>
90008efe:	e7f8      	b.n	90008ef2 <xTimerGenericCommand+0x42>
90008f00:	24009b28 	.word	0x24009b28

90008f04 <prvSampleTimeNow>:
{
90008f04:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	if( xTimeNow < xLastTime )
90008f08:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 90008fac <prvSampleTimeNow+0xa8>
{
90008f0c:	4606      	mov	r6, r0
	xTimeNow = xTaskGetTickCount();
90008f0e:	f7ff fc01 	bl	90008714 <xTaskGetTickCount>
90008f12:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
90008f14:	f8d8 3000 	ldr.w	r3, [r8]
90008f18:	4283      	cmp	r3, r0
90008f1a:	d940      	bls.n	90008f9e <prvSampleTimeNow+0x9a>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
90008f1c:	4f21      	ldr	r7, [pc, #132]	; (90008fa4 <prvSampleTimeNow+0xa0>)
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
90008f1e:	f04f 0900 	mov.w	r9, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
90008f22:	683b      	ldr	r3, [r7, #0]
90008f24:	681a      	ldr	r2, [r3, #0]
90008f26:	b95a      	cbnz	r2, 90008f40 <prvSampleTimeNow+0x3c>
	pxCurrentTimerList = pxOverflowTimerList;
90008f28:	4a1f      	ldr	r2, [pc, #124]	; (90008fa8 <prvSampleTimeNow+0xa4>)
90008f2a:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
90008f2c:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
90008f2e:	2301      	movs	r3, #1
	pxCurrentTimerList = pxOverflowTimerList;
90008f30:	6039      	str	r1, [r7, #0]
}
90008f32:	4628      	mov	r0, r5
		*pxTimerListsWereSwitched = pdFALSE;
90008f34:	6033      	str	r3, [r6, #0]
	xLastTime = xTimeNow;
90008f36:	f8c8 5000 	str.w	r5, [r8]
}
90008f3a:	b004      	add	sp, #16
90008f3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
90008f40:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
90008f42:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
90008f44:	f8d3 a000 	ldr.w	sl, [r3]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
90008f48:	1d21      	adds	r1, r4, #4
90008f4a:	4608      	mov	r0, r1
90008f4c:	9103      	str	r1, [sp, #12]
90008f4e:	f7fe faa6 	bl	9000749e <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
90008f52:	6a23      	ldr	r3, [r4, #32]
90008f54:	4620      	mov	r0, r4
90008f56:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
90008f58:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
90008f5c:	9903      	ldr	r1, [sp, #12]
90008f5e:	f013 0f04 	tst.w	r3, #4
90008f62:	d0de      	beq.n	90008f22 <prvSampleTimeNow+0x1e>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
90008f64:	69a3      	ldr	r3, [r4, #24]
90008f66:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
90008f68:	459a      	cmp	sl, r3
90008f6a:	d205      	bcs.n	90008f78 <prvSampleTimeNow+0x74>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
90008f6c:	6838      	ldr	r0, [r7, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
90008f6e:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
90008f70:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
90008f72:	f7fe fa7d 	bl	90007470 <vListInsert>
90008f76:	e7d4      	b.n	90008f22 <prvSampleTimeNow+0x1e>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
90008f78:	2300      	movs	r3, #0
90008f7a:	4652      	mov	r2, sl
90008f7c:	4620      	mov	r0, r4
90008f7e:	f8cd 9000 	str.w	r9, [sp]
90008f82:	4619      	mov	r1, r3
90008f84:	f7ff ff94 	bl	90008eb0 <xTimerGenericCommand>
				configASSERT( xResult );
90008f88:	2800      	cmp	r0, #0
90008f8a:	d1ca      	bne.n	90008f22 <prvSampleTimeNow+0x1e>
90008f8c:	f04f 0350 	mov.w	r3, #80	; 0x50
90008f90:	f383 8811 	msr	BASEPRI, r3
90008f94:	f3bf 8f6f 	isb	sy
90008f98:	f3bf 8f4f 	dsb	sy
90008f9c:	e7fe      	b.n	90008f9c <prvSampleTimeNow+0x98>
		*pxTimerListsWereSwitched = pdFALSE;
90008f9e:	2300      	movs	r3, #0
90008fa0:	e7c7      	b.n	90008f32 <prvSampleTimeNow+0x2e>
90008fa2:	bf00      	nop
90008fa4:	24009a04 	.word	0x24009a04
90008fa8:	24009a08 	.word	0x24009a08
90008fac:	24009ad4 	.word	0x24009ad4

90008fb0 <prvTimerTask>:
{
90008fb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
90008fb4:	4d6f      	ldr	r5, [pc, #444]	; (90009174 <prvTimerTask+0x1c4>)
{
90008fb6:	b089      	sub	sp, #36	; 0x24
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
90008fb8:	4e6f      	ldr	r6, [pc, #444]	; (90009178 <prvTimerTask+0x1c8>)
		vApplicationDaemonTaskStartupHook();
90008fba:	f7f7 fad4 	bl	90000566 <vApplicationDaemonTaskStartupHook>
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
90008fbe:	682b      	ldr	r3, [r5, #0]
90008fc0:	f8d3 8000 	ldr.w	r8, [r3]
90008fc4:	f1b8 0f00 	cmp.w	r8, #0
90008fc8:	d035      	beq.n	90009036 <prvTimerTask+0x86>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
90008fca:	68db      	ldr	r3, [r3, #12]
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
90008fcc:	2400      	movs	r4, #0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
90008fce:	f8d3 8000 	ldr.w	r8, [r3]
	vTaskSuspendAll();
90008fd2:	f7ff fb97 	bl	90008704 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
90008fd6:	a804      	add	r0, sp, #16
90008fd8:	f7ff ff94 	bl	90008f04 <prvSampleTimeNow>
		if( xTimerListsWereSwitched == pdFALSE )
90008fdc:	9b04      	ldr	r3, [sp, #16]
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
90008fde:	4681      	mov	r9, r0
		if( xTimerListsWereSwitched == pdFALSE )
90008fe0:	2b00      	cmp	r3, #0
90008fe2:	d169      	bne.n	900090b8 <prvTimerTask+0x108>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
90008fe4:	2c00      	cmp	r4, #0
90008fe6:	d14c      	bne.n	90009082 <prvTimerTask+0xd2>
90008fe8:	4540      	cmp	r0, r8
90008fea:	d350      	bcc.n	9000908e <prvTimerTask+0xde>
				( void ) xTaskResumeAll();
90008fec:	f7ff fc3c 	bl	90008868 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
90008ff0:	682b      	ldr	r3, [r5, #0]
90008ff2:	68db      	ldr	r3, [r3, #12]
90008ff4:	68df      	ldr	r7, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
90008ff6:	1d38      	adds	r0, r7, #4
90008ff8:	f7fe fa51 	bl	9000749e <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
90008ffc:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
90009000:	0758      	lsls	r0, r3, #29
90009002:	d51a      	bpl.n	9000903a <prvTimerTask+0x8a>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
90009004:	69b9      	ldr	r1, [r7, #24]
90009006:	4643      	mov	r3, r8
90009008:	464a      	mov	r2, r9
9000900a:	4638      	mov	r0, r7
9000900c:	4441      	add	r1, r8
9000900e:	f7ff feff 	bl	90008e10 <prvInsertTimerInActiveList>
90009012:	b1b0      	cbz	r0, 90009042 <prvTimerTask+0x92>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
90009014:	4623      	mov	r3, r4
90009016:	4642      	mov	r2, r8
90009018:	4621      	mov	r1, r4
9000901a:	4638      	mov	r0, r7
9000901c:	9400      	str	r4, [sp, #0]
9000901e:	f7ff ff47 	bl	90008eb0 <xTimerGenericCommand>
			configASSERT( xResult );
90009022:	b970      	cbnz	r0, 90009042 <prvTimerTask+0x92>
90009024:	f04f 0350 	mov.w	r3, #80	; 0x50
90009028:	f383 8811 	msr	BASEPRI, r3
9000902c:	f3bf 8f6f 	isb	sy
90009030:	f3bf 8f4f 	dsb	sy
90009034:	e7fe      	b.n	90009034 <prvTimerTask+0x84>
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
90009036:	2401      	movs	r4, #1
90009038:	e7cb      	b.n	90008fd2 <prvTimerTask+0x22>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
9000903a:	f023 0301 	bic.w	r3, r3, #1
9000903e:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
90009042:	6a3b      	ldr	r3, [r7, #32]
90009044:	4638      	mov	r0, r7
90009046:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
90009048:	2200      	movs	r2, #0
9000904a:	a904      	add	r1, sp, #16
9000904c:	6830      	ldr	r0, [r6, #0]
9000904e:	f7fe ff17 	bl	90007e80 <xQueueReceive>
90009052:	2800      	cmp	r0, #0
90009054:	d0b3      	beq.n	90008fbe <prvTimerTask+0xe>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
90009056:	9b04      	ldr	r3, [sp, #16]
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
90009058:	9806      	ldr	r0, [sp, #24]
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
9000905a:	2b00      	cmp	r3, #0
9000905c:	db2f      	blt.n	900090be <prvTimerTask+0x10e>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
9000905e:	9c06      	ldr	r4, [sp, #24]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
90009060:	6963      	ldr	r3, [r4, #20]
90009062:	2b00      	cmp	r3, #0
90009064:	d132      	bne.n	900090cc <prvTimerTask+0x11c>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
90009066:	a803      	add	r0, sp, #12
90009068:	f7ff ff4c 	bl	90008f04 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
9000906c:	9b04      	ldr	r3, [sp, #16]
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
9000906e:	4602      	mov	r2, r0
			switch( xMessage.xMessageID )
90009070:	2b09      	cmp	r3, #9
90009072:	d8e9      	bhi.n	90009048 <prvTimerTask+0x98>
90009074:	e8df f003 	tbb	[pc, r3]
90009078:	572e2e2e 	.word	0x572e2e2e
9000907c:	2e2e765e 	.word	0x2e2e765e
90009080:	5e57      	.short	0x5e57
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
90009082:	4b3e      	ldr	r3, [pc, #248]	; (9000917c <prvTimerTask+0x1cc>)
90009084:	681b      	ldr	r3, [r3, #0]
90009086:	681c      	ldr	r4, [r3, #0]
90009088:	fab4 f484 	clz	r4, r4
9000908c:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
9000908e:	4622      	mov	r2, r4
90009090:	eba8 0109 	sub.w	r1, r8, r9
90009094:	6830      	ldr	r0, [r6, #0]
90009096:	f7ff f904 	bl	900082a2 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
9000909a:	f7ff fbe5 	bl	90008868 <xTaskResumeAll>
9000909e:	2800      	cmp	r0, #0
900090a0:	d1d2      	bne.n	90009048 <prvTimerTask+0x98>
					portYIELD_WITHIN_API();
900090a2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
900090a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
900090aa:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
900090ae:	f3bf 8f4f 	dsb	sy
900090b2:	f3bf 8f6f 	isb	sy
900090b6:	e7c7      	b.n	90009048 <prvTimerTask+0x98>
			( void ) xTaskResumeAll();
900090b8:	f7ff fbd6 	bl	90008868 <xTaskResumeAll>
}
900090bc:	e7c4      	b.n	90009048 <prvTimerTask+0x98>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
900090be:	9b05      	ldr	r3, [sp, #20]
900090c0:	9907      	ldr	r1, [sp, #28]
900090c2:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
900090c4:	9b04      	ldr	r3, [sp, #16]
900090c6:	2b00      	cmp	r3, #0
900090c8:	dbbe      	blt.n	90009048 <prvTimerTask+0x98>
900090ca:	e7c8      	b.n	9000905e <prvTimerTask+0xae>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
900090cc:	1d20      	adds	r0, r4, #4
900090ce:	f7fe f9e6 	bl	9000749e <uxListRemove>
900090d2:	e7c8      	b.n	90009066 <prvTimerTask+0xb6>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
900090d4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
900090d8:	4620      	mov	r0, r4
900090da:	69a1      	ldr	r1, [r4, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
900090dc:	f043 0301 	orr.w	r3, r3, #1
900090e0:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
900090e4:	9b05      	ldr	r3, [sp, #20]
900090e6:	4419      	add	r1, r3
900090e8:	f7ff fe92 	bl	90008e10 <prvInsertTimerInActiveList>
900090ec:	2800      	cmp	r0, #0
900090ee:	d0ab      	beq.n	90009048 <prvTimerTask+0x98>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
900090f0:	6a23      	ldr	r3, [r4, #32]
900090f2:	4620      	mov	r0, r4
900090f4:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
900090f6:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
900090fa:	0759      	lsls	r1, r3, #29
900090fc:	d5a4      	bpl.n	90009048 <prvTimerTask+0x98>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
900090fe:	69a2      	ldr	r2, [r4, #24]
90009100:	2300      	movs	r3, #0
90009102:	9905      	ldr	r1, [sp, #20]
90009104:	4620      	mov	r0, r4
90009106:	9300      	str	r3, [sp, #0]
90009108:	440a      	add	r2, r1
9000910a:	4619      	mov	r1, r3
9000910c:	f7ff fed0 	bl	90008eb0 <xTimerGenericCommand>
							configASSERT( xResult );
90009110:	2800      	cmp	r0, #0
90009112:	d199      	bne.n	90009048 <prvTimerTask+0x98>
90009114:	f04f 0350 	mov.w	r3, #80	; 0x50
90009118:	f383 8811 	msr	BASEPRI, r3
9000911c:	f3bf 8f6f 	isb	sy
90009120:	f3bf 8f4f 	dsb	sy
90009124:	e7fe      	b.n	90009124 <prvTimerTask+0x174>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
90009126:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
9000912a:	f023 0301 	bic.w	r3, r3, #1
9000912e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
90009132:	e789      	b.n	90009048 <prvTimerTask+0x98>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
90009134:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
90009138:	f043 0301 	orr.w	r3, r3, #1
9000913c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
90009140:	9905      	ldr	r1, [sp, #20]
90009142:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
90009144:	b941      	cbnz	r1, 90009158 <prvTimerTask+0x1a8>
90009146:	f04f 0350 	mov.w	r3, #80	; 0x50
9000914a:	f383 8811 	msr	BASEPRI, r3
9000914e:	f3bf 8f6f 	isb	sy
90009152:	f3bf 8f4f 	dsb	sy
90009156:	e7fe      	b.n	90009156 <prvTimerTask+0x1a6>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
90009158:	4603      	mov	r3, r0
9000915a:	4401      	add	r1, r0
9000915c:	4620      	mov	r0, r4
9000915e:	f7ff fe57 	bl	90008e10 <prvInsertTimerInActiveList>
					break;
90009162:	e771      	b.n	90009048 <prvTimerTask+0x98>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
90009164:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
90009168:	079a      	lsls	r2, r3, #30
9000916a:	d4de      	bmi.n	9000912a <prvTimerTask+0x17a>
							vPortFree( pxTimer );
9000916c:	4620      	mov	r0, r4
9000916e:	f7fe f927 	bl	900073c0 <vPortFree>
90009172:	e769      	b.n	90009048 <prvTimerTask+0x98>
90009174:	24009a04 	.word	0x24009a04
90009178:	24009b28 	.word	0x24009b28
9000917c:	24009a08 	.word	0x24009a08

90009180 <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return PP_HTONS(n);
90009180:	ba40      	rev16	r0, r0
}
90009182:	b280      	uxth	r0, r0
90009184:	4770      	bx	lr

90009186 <lwip_htonl>:
 */
u32_t
lwip_htonl(u32_t n)
{
  return PP_HTONL(n);
}
90009186:	ba00      	rev	r0, r0
90009188:	4770      	bx	lr

9000918a <dhcp_set_state>:
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
9000918a:	7943      	ldrb	r3, [r0, #5]
9000918c:	428b      	cmp	r3, r1
    dhcp->state = new_state;
    dhcp->tries = 0;
9000918e:	bf1f      	itttt	ne
90009190:	2300      	movne	r3, #0
    dhcp->state = new_state;
90009192:	7141      	strbne	r1, [r0, #5]
    dhcp->tries = 0;
90009194:	7183      	strbne	r3, [r0, #6]
    dhcp->request_timeout = 0;
90009196:	8103      	strhne	r3, [r0, #8]
  }
}
90009198:	4770      	bx	lr
	...

9000919c <dhcp_option_short>:
  return options_out_len;
}

static u16_t
dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
{
9000919c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
9000919e:	1c87      	adds	r7, r0, #2
{
900091a0:	4604      	mov	r4, r0
900091a2:	460d      	mov	r5, r1
900091a4:	4616      	mov	r6, r2
  LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
900091a6:	2f44      	cmp	r7, #68	; 0x44
900091a8:	d906      	bls.n	900091b8 <dhcp_option_short+0x1c>
900091aa:	4b07      	ldr	r3, [pc, #28]	; (900091c8 <dhcp_option_short+0x2c>)
900091ac:	f240 52ae 	movw	r2, #1454	; 0x5ae
900091b0:	4906      	ldr	r1, [pc, #24]	; (900091cc <dhcp_option_short+0x30>)
900091b2:	4807      	ldr	r0, [pc, #28]	; (900091d0 <dhcp_option_short+0x34>)
900091b4:	f008 fcfa 	bl	90011bac <iprintf>
  options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
900091b8:	0a33      	lsrs	r3, r6, #8
  options[options_out_len++] = (u8_t) (value & 0x00ffU);
  return options_out_len;
}
900091ba:	b2b8      	uxth	r0, r7
  options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
900091bc:	552b      	strb	r3, [r5, r4]
900091be:	3401      	adds	r4, #1
  options[options_out_len++] = (u8_t) (value & 0x00ffU);
900091c0:	b2a4      	uxth	r4, r4
900091c2:	552e      	strb	r6, [r5, r4]
}
900091c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
900091c6:	bf00      	nop
900091c8:	90013361 	.word	0x90013361
900091cc:	9001339d 	.word	0x9001339d
900091d0:	90012aff 	.word	0x90012aff

900091d4 <dhcp_option>:
{
900091d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900091d6:	461e      	mov	r6, r3
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
900091d8:	3302      	adds	r3, #2
{
900091da:	4604      	mov	r4, r0
900091dc:	460d      	mov	r5, r1
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
900091de:	fa50 f383 	uxtab	r3, r0, r3
{
900091e2:	4617      	mov	r7, r2
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
900091e4:	2b44      	cmp	r3, #68	; 0x44
900091e6:	d906      	bls.n	900091f6 <dhcp_option+0x22>
900091e8:	4b06      	ldr	r3, [pc, #24]	; (90009204 <dhcp_option+0x30>)
900091ea:	f240 529a 	movw	r2, #1434	; 0x59a
900091ee:	4906      	ldr	r1, [pc, #24]	; (90009208 <dhcp_option+0x34>)
900091f0:	4806      	ldr	r0, [pc, #24]	; (9000920c <dhcp_option+0x38>)
900091f2:	f008 fcdb 	bl	90011bac <iprintf>
  options[options_out_len++] = option_type;
900091f6:	1c63      	adds	r3, r4, #1
  options[options_out_len++] = option_len;
900091f8:	1ca0      	adds	r0, r4, #2
  options[options_out_len++] = option_type;
900091fa:	552f      	strb	r7, [r5, r4]
  options[options_out_len++] = option_len;
900091fc:	b29b      	uxth	r3, r3
}
900091fe:	b280      	uxth	r0, r0
  options[options_out_len++] = option_len;
90009200:	54ee      	strb	r6, [r5, r3]
}
90009202:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
90009204:	90013361 	.word	0x90013361
90009208:	900133d8 	.word	0x900133d8
9000920c:	90012aff 	.word	0x90012aff

90009210 <dhcp_option_byte>:
  LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
90009210:	2843      	cmp	r0, #67	; 0x43
{
90009212:	b570      	push	{r4, r5, r6, lr}
90009214:	4604      	mov	r4, r0
90009216:	460d      	mov	r5, r1
90009218:	4616      	mov	r6, r2
  LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
9000921a:	d906      	bls.n	9000922a <dhcp_option_byte+0x1a>
9000921c:	4b05      	ldr	r3, [pc, #20]	; (90009234 <dhcp_option_byte+0x24>)
9000921e:	f240 52a6 	movw	r2, #1446	; 0x5a6
90009222:	4905      	ldr	r1, [pc, #20]	; (90009238 <dhcp_option_byte+0x28>)
90009224:	4805      	ldr	r0, [pc, #20]	; (9000923c <dhcp_option_byte+0x2c>)
90009226:	f008 fcc1 	bl	90011bac <iprintf>
  options[options_out_len++] = value;
9000922a:	1c60      	adds	r0, r4, #1
9000922c:	552e      	strb	r6, [r5, r4]
}
9000922e:	b280      	uxth	r0, r0
90009230:	bd70      	pop	{r4, r5, r6, pc}
90009232:	bf00      	nop
90009234:	90013361 	.word	0x90013361
90009238:	9001341a 	.word	0x9001341a
9000923c:	90012aff 	.word	0x90012aff

90009240 <dhcp_option_long>:

static u16_t
dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
{
90009240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
90009242:	1d07      	adds	r7, r0, #4
{
90009244:	4604      	mov	r4, r0
90009246:	460d      	mov	r5, r1
90009248:	4616      	mov	r6, r2
  LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
9000924a:	2f44      	cmp	r7, #68	; 0x44
9000924c:	d906      	bls.n	9000925c <dhcp_option_long+0x1c>
9000924e:	4b0b      	ldr	r3, [pc, #44]	; (9000927c <dhcp_option_long+0x3c>)
90009250:	f240 52b7 	movw	r2, #1463	; 0x5b7
90009254:	490a      	ldr	r1, [pc, #40]	; (90009280 <dhcp_option_long+0x40>)
90009256:	480b      	ldr	r0, [pc, #44]	; (90009284 <dhcp_option_long+0x44>)
90009258:	f008 fca8 	bl	90011bac <iprintf>
  options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
9000925c:	0e33      	lsrs	r3, r6, #24
  options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
9000925e:	0c32      	lsrs	r2, r6, #16
  options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
90009260:	552b      	strb	r3, [r5, r4]
90009262:	1c63      	adds	r3, r4, #1
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
  return options_out_len;
}
90009264:	b2b8      	uxth	r0, r7
  options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
90009266:	b29b      	uxth	r3, r3
90009268:	54ea      	strb	r2, [r5, r3]
9000926a:	1ca3      	adds	r3, r4, #2
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
9000926c:	3403      	adds	r4, #3
9000926e:	0a32      	lsrs	r2, r6, #8
90009270:	b29b      	uxth	r3, r3
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
90009272:	b2a4      	uxth	r4, r4
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
90009274:	54ea      	strb	r2, [r5, r3]
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
90009276:	552e      	strb	r6, [r5, r4]
}
90009278:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9000927a:	bf00      	nop
9000927c:	90013361 	.word	0x90013361
90009280:	9001344f 	.word	0x9001344f
90009284:	90012aff 	.word	0x90012aff

90009288 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static struct pbuf *
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t *options_out_len)
{
90009288:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
9000928c:	460e      	mov	r6, r1
9000928e:	4690      	mov	r8, r2
90009290:	4699      	mov	r9, r3
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return NULL;);
90009292:	4605      	mov	r5, r0
90009294:	b958      	cbnz	r0, 900092ae <dhcp_create_msg+0x26>
90009296:	462f      	mov	r7, r5
90009298:	4b3f      	ldr	r3, [pc, #252]	; (90009398 <dhcp_create_msg+0x110>)
9000929a:	f240 7269 	movw	r2, #1897	; 0x769
9000929e:	493f      	ldr	r1, [pc, #252]	; (9000939c <dhcp_create_msg+0x114>)
900092a0:	483f      	ldr	r0, [pc, #252]	; (900093a0 <dhcp_create_msg+0x118>)
900092a2:	f008 fc83 	bl	90011bac <iprintf>
  options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
  if (options_out_len) {
    *options_out_len = options_out_len_loc;
  }
  return p_out;
}
900092a6:	4638      	mov	r0, r7
900092a8:	b003      	add	sp, #12
900092aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return NULL;);
900092ae:	b941      	cbnz	r1, 900092c2 <dhcp_create_msg+0x3a>
900092b0:	4b39      	ldr	r3, [pc, #228]	; (90009398 <dhcp_create_msg+0x110>)
900092b2:	f240 726a 	movw	r2, #1898	; 0x76a
900092b6:	493b      	ldr	r1, [pc, #236]	; (900093a4 <dhcp_create_msg+0x11c>)
900092b8:	4637      	mov	r7, r6
900092ba:	4839      	ldr	r0, [pc, #228]	; (900093a0 <dhcp_create_msg+0x118>)
900092bc:	f008 fc76 	bl	90011bac <iprintf>
900092c0:	e7f1      	b.n	900092a6 <dhcp_create_msg+0x1e>
  p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
900092c2:	f44f 7220 	mov.w	r2, #640	; 0x280
900092c6:	f44f 719a 	mov.w	r1, #308	; 0x134
900092ca:	2036      	movs	r0, #54	; 0x36
900092cc:	f003 fd50 	bl	9000cd70 <pbuf_alloc>
  if (p_out == NULL) {
900092d0:	4607      	mov	r7, r0
900092d2:	2800      	cmp	r0, #0
900092d4:	d0e7      	beq.n	900092a6 <dhcp_create_msg+0x1e>
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
900092d6:	8943      	ldrh	r3, [r0, #10]
900092d8:	f5b3 7f9a 	cmp.w	r3, #308	; 0x134
900092dc:	d206      	bcs.n	900092ec <dhcp_create_msg+0x64>
900092de:	4b2e      	ldr	r3, [pc, #184]	; (90009398 <dhcp_create_msg+0x110>)
900092e0:	f240 7271 	movw	r2, #1905	; 0x771
900092e4:	4930      	ldr	r1, [pc, #192]	; (900093a8 <dhcp_create_msg+0x120>)
900092e6:	482e      	ldr	r0, [pc, #184]	; (900093a0 <dhcp_create_msg+0x118>)
900092e8:	f008 fc60 	bl	90011bac <iprintf>
  if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
900092ec:	f1b8 0f03 	cmp.w	r8, #3
900092f0:	d102      	bne.n	900092f8 <dhcp_create_msg+0x70>
900092f2:	7973      	ldrb	r3, [r6, #5]
900092f4:	2b03      	cmp	r3, #3
900092f6:	d107      	bne.n	90009308 <dhcp_create_msg+0x80>
    if (dhcp->tries == 0) {
900092f8:	79b3      	ldrb	r3, [r6, #6]
900092fa:	4c2c      	ldr	r4, [pc, #176]	; (900093ac <dhcp_create_msg+0x124>)
900092fc:	b913      	cbnz	r3, 90009304 <dhcp_create_msg+0x7c>
      xid = LWIP_RAND();
900092fe:	f008 fc6d 	bl	90011bdc <rand>
90009302:	6020      	str	r0, [r4, #0]
    dhcp->xid = xid;
90009304:	6823      	ldr	r3, [r4, #0]
90009306:	6033      	str	r3, [r6, #0]
  msg_out = (struct dhcp_msg *)p_out->payload;
90009308:	687c      	ldr	r4, [r7, #4]
  memset(msg_out, 0, sizeof(struct dhcp_msg));
9000930a:	f44f 729a 	mov.w	r2, #308	; 0x134
9000930e:	2100      	movs	r1, #0
90009310:	4620      	mov	r0, r4
90009312:	f008 fb63 	bl	900119dc <memset>
  msg_out->op = DHCP_BOOTREQUEST;
90009316:	2301      	movs	r3, #1
90009318:	7023      	strb	r3, [r4, #0]
  msg_out->htype = LWIP_IANA_HWTYPE_ETHERNET;
9000931a:	7063      	strb	r3, [r4, #1]
  msg_out->hlen = netif->hwaddr_len;
9000931c:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
90009320:	70a3      	strb	r3, [r4, #2]
  msg_out->xid = lwip_htonl(dhcp->xid);
90009322:	6830      	ldr	r0, [r6, #0]
90009324:	f7ff ff2f 	bl	90009186 <lwip_htonl>
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
90009328:	f1b8 0f04 	cmp.w	r8, #4
  msg_out->xid = lwip_htonl(dhcp->xid);
9000932c:	6060      	str	r0, [r4, #4]
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
9000932e:	d00a      	beq.n	90009346 <dhcp_create_msg+0xbe>
90009330:	f1a8 0307 	sub.w	r3, r8, #7
90009334:	2b01      	cmp	r3, #1
90009336:	d906      	bls.n	90009346 <dhcp_create_msg+0xbe>
90009338:	f1b8 0f03 	cmp.w	r8, #3
9000933c:	d105      	bne.n	9000934a <dhcp_create_msg+0xc2>
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
9000933e:	7973      	ldrb	r3, [r6, #5]
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
90009340:	3b04      	subs	r3, #4
90009342:	2b01      	cmp	r3, #1
90009344:	d801      	bhi.n	9000934a <dhcp_create_msg+0xc2>
    ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
90009346:	686b      	ldr	r3, [r5, #4]
90009348:	60e3      	str	r3, [r4, #12]
9000934a:	f105 032e 	add.w	r3, r5, #46	; 0x2e
9000934e:	f104 021c 	add.w	r2, r4, #28
90009352:	3534      	adds	r5, #52	; 0x34
    msg_out->chaddr[i] = netif->hwaddr[i];
90009354:	f813 1b01 	ldrb.w	r1, [r3], #1
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
90009358:	42ab      	cmp	r3, r5
    msg_out->chaddr[i] = netif->hwaddr[i];
9000935a:	f802 1b01 	strb.w	r1, [r2], #1
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
9000935e:	d1f9      	bne.n	90009354 <dhcp_create_msg+0xcc>
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
90009360:	f06f 027d 	mvn.w	r2, #125	; 0x7d
90009364:	2363      	movs	r3, #99	; 0x63
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
90009366:	f104 01f0 	add.w	r1, r4, #240	; 0xf0
9000936a:	2000      	movs	r0, #0
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
9000936c:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
90009370:	2253      	movs	r2, #83	; 0x53
90009372:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
90009376:	f884 20ee 	strb.w	r2, [r4, #238]	; 0xee
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
9000937a:	2235      	movs	r2, #53	; 0x35
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
9000937c:	f884 30ef 	strb.w	r3, [r4, #239]	; 0xef
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
90009380:	2301      	movs	r3, #1
90009382:	9101      	str	r1, [sp, #4]
90009384:	f7ff ff26 	bl	900091d4 <dhcp_option>
  options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
90009388:	4642      	mov	r2, r8
9000938a:	9901      	ldr	r1, [sp, #4]
9000938c:	f7ff ff40 	bl	90009210 <dhcp_option_byte>
    *options_out_len = options_out_len_loc;
90009390:	f8a9 0000 	strh.w	r0, [r9]
90009394:	e787      	b.n	900092a6 <dhcp_create_msg+0x1e>
90009396:	bf00      	nop
90009398:	90013361 	.word	0x90013361
9000939c:	90013489 	.word	0x90013489
900093a0:	90012aff 	.word	0x90012aff
900093a4:	900134a8 	.word	0x900134a8
900093a8:	900134c6 	.word	0x900134c6
900093ac:	24009b68 	.word	0x24009b68

900093b0 <dhcp_option_trailer>:
 * Adds the END option to the DHCP message, and if
 * necessary, up to three padding bytes.
 */
static void
dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
{
900093b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900093b2:	4604      	mov	r4, r0
  options[options_out_len++] = DHCP_OPTION_END;
900093b4:	23ff      	movs	r3, #255	; 0xff
{
900093b6:	4608      	mov	r0, r1
900093b8:	4617      	mov	r7, r2
  options[options_out_len++] = DHCP_OPTION_END;
900093ba:	1c66      	adds	r6, r4, #1
  /* packet is too small, or not 4 byte aligned? */
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
         (options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    options[options_out_len++] = 0;
900093bc:	f1c4 0543 	rsb	r5, r4, #67	; 0x43
  options[options_out_len++] = DHCP_OPTION_END;
900093c0:	550b      	strb	r3, [r1, r4]
    options[options_out_len++] = 0;
900093c2:	2100      	movs	r1, #0
  options[options_out_len++] = DHCP_OPTION_END;
900093c4:	b2b6      	uxth	r6, r6
  }
  /* shrink the pbuf to the actual content length */
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
900093c6:	34f1      	adds	r4, #241	; 0xf1
    options[options_out_len++] = 0;
900093c8:	b2ad      	uxth	r5, r5
900093ca:	2e44      	cmp	r6, #68	; 0x44
900093cc:	4430      	add	r0, r6
900093ce:	bf94      	ite	ls
900093d0:	462a      	movls	r2, r5
900093d2:	2200      	movhi	r2, #0
900093d4:	f008 fb02 	bl	900119dc <memset>
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
900093d8:	2e44      	cmp	r6, #68	; 0x44
900093da:	4638      	mov	r0, r7
900093dc:	bf94      	ite	ls
900093de:	4629      	movls	r1, r5
900093e0:	2100      	movhi	r1, #0
900093e2:	4421      	add	r1, r4
}
900093e4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
900093e8:	b289      	uxth	r1, r1
900093ea:	f003 bd53 	b.w	9000ce94 <pbuf_realloc>
	...

900093f0 <dhcp_discover>:
{
900093f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  ip4_addr_set_any(&dhcp->offered_ip_addr);
900093f4:	2300      	movs	r3, #0
  struct dhcp *dhcp = netif_dhcp_data(netif);
900093f6:	6a84      	ldr	r4, [r0, #40]	; 0x28
{
900093f8:	b086      	sub	sp, #24
900093fa:	4606      	mov	r6, r0
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
900093fc:	2106      	movs	r1, #6
900093fe:	4620      	mov	r0, r4
  ip4_addr_set_any(&dhcp->offered_ip_addr);
90009400:	61e3      	str	r3, [r4, #28]
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
90009402:	2201      	movs	r2, #1
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
90009404:	f7ff fec1 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
90009408:	f10d 0316 	add.w	r3, sp, #22
9000940c:	4621      	mov	r1, r4
9000940e:	4630      	mov	r0, r6
90009410:	f7ff ff3a 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
90009414:	4605      	mov	r5, r0
90009416:	2800      	cmp	r0, #0
90009418:	d039      	beq.n	9000948e <dhcp_discover+0x9e>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
9000941a:	6841      	ldr	r1, [r0, #4]
9000941c:	2302      	movs	r3, #2
9000941e:	2239      	movs	r2, #57	; 0x39
90009420:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90009424:	31f0      	adds	r1, #240	; 0xf0
90009426:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 900094dc <dhcp_discover+0xec>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000942a:	2704      	movs	r7, #4
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
9000942c:	9103      	str	r1, [sp, #12]
9000942e:	f7ff fed1 	bl	900091d4 <dhcp_option>
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
90009432:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
90009434:	9903      	ldr	r1, [sp, #12]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
90009436:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
9000943a:	f7ff feaf 	bl	9000919c <dhcp_option_short>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000943e:	9903      	ldr	r1, [sp, #12]
90009440:	2304      	movs	r3, #4
90009442:	2237      	movs	r2, #55	; 0x37
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
90009444:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
90009448:	f7ff fec4 	bl	900091d4 <dhcp_option>
9000944c:	9903      	ldr	r1, [sp, #12]
9000944e:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009452:	3f01      	subs	r7, #1
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
90009454:	f818 2b01 	ldrb.w	r2, [r8], #1
90009458:	f8bd 0016 	ldrh.w	r0, [sp, #22]
9000945c:	9103      	str	r1, [sp, #12]
9000945e:	f7ff fed7 	bl	90009210 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009462:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
90009466:	9903      	ldr	r1, [sp, #12]
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
90009468:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000946c:	d1f1      	bne.n	90009452 <dhcp_discover+0x62>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
9000946e:	462a      	mov	r2, r5
90009470:	f7ff ff9e 	bl	900093b0 <dhcp_option_trailer>
    udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
90009474:	4b16      	ldr	r3, [pc, #88]	; (900094d0 <dhcp_discover+0xe0>)
90009476:	4817      	ldr	r0, [pc, #92]	; (900094d4 <dhcp_discover+0xe4>)
90009478:	4629      	mov	r1, r5
9000947a:	4a17      	ldr	r2, [pc, #92]	; (900094d8 <dhcp_discover+0xe8>)
9000947c:	e9cd 6300 	strd	r6, r3, [sp]
90009480:	2343      	movs	r3, #67	; 0x43
90009482:	6800      	ldr	r0, [r0, #0]
90009484:	f008 f8b4 	bl	900115f0 <udp_sendto_if_src>
    pbuf_free(p_out);
90009488:	4628      	mov	r0, r5
9000948a:	f003 fc09 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
9000948e:	79a3      	ldrb	r3, [r4, #6]
}
90009490:	2000      	movs	r0, #0
  if (dhcp->tries < 255) {
90009492:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
90009494:	bf1c      	itt	ne
90009496:	3301      	addne	r3, #1
90009498:	71a3      	strbne	r3, [r4, #6]
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
9000949a:	79a2      	ldrb	r2, [r4, #6]
9000949c:	2a05      	cmp	r2, #5
9000949e:	bf97      	itett	ls
900094a0:	2301      	movls	r3, #1
900094a2:	f64e 2360 	movwhi	r3, #60000	; 0xea60
900094a6:	4093      	lslls	r3, r2
900094a8:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
900094ac:	bf98      	it	ls
900094ae:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
900094b2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
900094b6:	bf9c      	itt	ls
900094b8:	00db      	lslls	r3, r3, #3
900094ba:	b29b      	uxthls	r3, r3
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
900094bc:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
900094c0:	b29b      	uxth	r3, r3
900094c2:	fbb3 f3f2 	udiv	r3, r3, r2
900094c6:	8123      	strh	r3, [r4, #8]
}
900094c8:	b006      	add	sp, #24
900094ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
900094ce:	bf00      	nop
900094d0:	90013a68 	.word	0x90013a68
900094d4:	24009b30 	.word	0x24009b30
900094d8:	90013a6c 	.word	0x90013a6c
900094dc:	90013695 	.word	0x90013695

900094e0 <dhcp_check>:
{
900094e0:	b538      	push	{r3, r4, r5, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
900094e2:	6a84      	ldr	r4, [r0, #40]	; 0x28
{
900094e4:	4605      	mov	r5, r0
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
900094e6:	2108      	movs	r1, #8
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
900094e8:	2200      	movs	r2, #0
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
900094ea:	4620      	mov	r0, r4
900094ec:	f7ff fe4d 	bl	9000918a <dhcp_set_state>
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
900094f0:	f104 011c 	add.w	r1, r4, #28
900094f4:	4628      	mov	r0, r5
900094f6:	f001 fb87 	bl	9000ac08 <etharp_query>
  if (dhcp->tries < 255) {
900094fa:	79a3      	ldrb	r3, [r4, #6]
900094fc:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
900094fe:	bf1c      	itt	ne
90009500:	3301      	addne	r3, #1
90009502:	71a3      	strbne	r3, [r4, #6]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
90009504:	2301      	movs	r3, #1
90009506:	8123      	strh	r3, [r4, #8]
}
90009508:	bd38      	pop	{r3, r4, r5, pc}
	...

9000950c <dhcp_bind>:
{
9000950c:	b513      	push	{r0, r1, r4, lr}
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
9000950e:	4604      	mov	r4, r0
90009510:	b948      	cbnz	r0, 90009526 <dhcp_bind+0x1a>
90009512:	4b3e      	ldr	r3, [pc, #248]	; (9000960c <dhcp_bind+0x100>)
90009514:	f240 4215 	movw	r2, #1045	; 0x415
90009518:	493d      	ldr	r1, [pc, #244]	; (90009610 <dhcp_bind+0x104>)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
9000951a:	483e      	ldr	r0, [pc, #248]	; (90009614 <dhcp_bind+0x108>)
}
9000951c:	b002      	add	sp, #8
9000951e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
90009522:	f008 bb43 	b.w	90011bac <iprintf>
  dhcp = netif_dhcp_data(netif);
90009526:	6a80      	ldr	r0, [r0, #40]	; 0x28
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
90009528:	b920      	cbnz	r0, 90009534 <dhcp_bind+0x28>
9000952a:	4b38      	ldr	r3, [pc, #224]	; (9000960c <dhcp_bind+0x100>)
9000952c:	f240 4217 	movw	r2, #1047	; 0x417
90009530:	4939      	ldr	r1, [pc, #228]	; (90009618 <dhcp_bind+0x10c>)
90009532:	e7f2      	b.n	9000951a <dhcp_bind+0xe>
  dhcp->lease_used = 0;
90009534:	2300      	movs	r3, #0
90009536:	8243      	strh	r3, [r0, #18]
  if (dhcp->offered_t0_lease != 0xffffffffUL) {
90009538:	6a83      	ldr	r3, [r0, #40]	; 0x28
9000953a:	1c5a      	adds	r2, r3, #1
9000953c:	d00c      	beq.n	90009558 <dhcp_bind+0x4c>
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
9000953e:	331e      	adds	r3, #30
    if (timeout > 0xffff) {
90009540:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
90009544:	bf36      	itet	cc
90009546:	223c      	movcc	r2, #60	; 0x3c
      timeout = 0xffff;
90009548:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
9000954c:	fbb3 f3f2 	udivcc	r3, r3, r2
    dhcp->t0_timeout = (u16_t)timeout;
90009550:	b29a      	uxth	r2, r3
    if (dhcp->t0_timeout == 0) {
90009552:	2b00      	cmp	r3, #0
90009554:	d043      	beq.n	900095de <dhcp_bind+0xd2>
    dhcp->t0_timeout = (u16_t)timeout;
90009556:	8282      	strh	r2, [r0, #20]
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
90009558:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
9000955a:	1c59      	adds	r1, r3, #1
9000955c:	d00e      	beq.n	9000957c <dhcp_bind+0x70>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
9000955e:	331e      	adds	r3, #30
    if (timeout > 0xffff) {
90009560:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
90009564:	bf36      	itet	cc
90009566:	223c      	movcc	r2, #60	; 0x3c
      timeout = 0xffff;
90009568:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
9000956c:	fbb3 f3f2 	udivcc	r3, r3, r2
    dhcp->t1_timeout = (u16_t)timeout;
90009570:	b29a      	uxth	r2, r3
    if (dhcp->t1_timeout == 0) {
90009572:	2b00      	cmp	r3, #0
90009574:	d036      	beq.n	900095e4 <dhcp_bind+0xd8>
    dhcp->t1_timeout = (u16_t)timeout;
90009576:	8142      	strh	r2, [r0, #10]
    dhcp->t1_renew_time = dhcp->t1_timeout;
90009578:	8943      	ldrh	r3, [r0, #10]
9000957a:	81c3      	strh	r3, [r0, #14]
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
9000957c:	6b03      	ldr	r3, [r0, #48]	; 0x30
9000957e:	1c5a      	adds	r2, r3, #1
90009580:	d00d      	beq.n	9000959e <dhcp_bind+0x92>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
90009582:	331e      	adds	r3, #30
    if (timeout > 0xffff) {
90009584:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
90009588:	bf36      	itet	cc
9000958a:	223c      	movcc	r2, #60	; 0x3c
      timeout = 0xffff;
9000958c:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
90009590:	fbb3 f3f2 	udivcc	r3, r3, r2
    dhcp->t2_timeout = (u16_t)timeout;
90009594:	b29a      	uxth	r2, r3
    if (dhcp->t2_timeout == 0) {
90009596:	b343      	cbz	r3, 900095ea <dhcp_bind+0xde>
    dhcp->t2_timeout = (u16_t)timeout;
90009598:	8182      	strh	r2, [r0, #12]
    dhcp->t2_rebind_time = dhcp->t2_timeout;
9000959a:	8983      	ldrh	r3, [r0, #12]
9000959c:	8203      	strh	r3, [r0, #16]
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
9000959e:	8983      	ldrh	r3, [r0, #12]
900095a0:	8942      	ldrh	r2, [r0, #10]
900095a2:	429a      	cmp	r2, r3
900095a4:	d302      	bcc.n	900095ac <dhcp_bind+0xa0>
900095a6:	b10b      	cbz	r3, 900095ac <dhcp_bind+0xa0>
    dhcp->t1_timeout = 0;
900095a8:	2300      	movs	r3, #0
900095aa:	8143      	strh	r3, [r0, #10]
  if (dhcp->subnet_mask_given) {
900095ac:	79c3      	ldrb	r3, [r0, #7]
900095ae:	b1fb      	cbz	r3, 900095f0 <dhcp_bind+0xe4>
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
900095b0:	6a03      	ldr	r3, [r0, #32]
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
900095b2:	9300      	str	r3, [sp, #0]
  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
900095b4:	6a43      	ldr	r3, [r0, #36]	; 0x24
900095b6:	9301      	str	r3, [sp, #4]
  if (ip4_addr_isany_val(gw_addr)) {
900095b8:	b92b      	cbnz	r3, 900095c6 <dhcp_bind+0xba>
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
900095ba:	69c3      	ldr	r3, [r0, #28]
900095bc:	9a00      	ldr	r2, [sp, #0]
900095be:	4013      	ands	r3, r2
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
900095c0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
900095c4:	9301      	str	r3, [sp, #4]
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
900095c6:	210a      	movs	r1, #10
  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
900095c8:	466a      	mov	r2, sp
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
900095ca:	f7ff fdde 	bl	9000918a <dhcp_set_state>
  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
900095ce:	f100 011c 	add.w	r1, r0, #28
900095d2:	ab01      	add	r3, sp, #4
900095d4:	4620      	mov	r0, r4
900095d6:	f003 f8c5 	bl	9000c764 <netif_set_addr>
}
900095da:	b002      	add	sp, #8
900095dc:	bd10      	pop	{r4, pc}
      dhcp->t0_timeout = 1;
900095de:	2301      	movs	r3, #1
900095e0:	8283      	strh	r3, [r0, #20]
900095e2:	e7b9      	b.n	90009558 <dhcp_bind+0x4c>
      dhcp->t1_timeout = 1;
900095e4:	2301      	movs	r3, #1
900095e6:	8143      	strh	r3, [r0, #10]
900095e8:	e7c6      	b.n	90009578 <dhcp_bind+0x6c>
      dhcp->t2_timeout = 1;
900095ea:	2301      	movs	r3, #1
900095ec:	8183      	strh	r3, [r0, #12]
900095ee:	e7d4      	b.n	9000959a <dhcp_bind+0x8e>
    if (first_octet <= 127) {
900095f0:	f990 201c 	ldrsb.w	r2, [r0, #28]
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
900095f4:	7f03      	ldrb	r3, [r0, #28]
    if (first_octet <= 127) {
900095f6:	2a00      	cmp	r2, #0
900095f8:	db01      	blt.n	900095fe <dhcp_bind+0xf2>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
900095fa:	23ff      	movs	r3, #255	; 0xff
900095fc:	e7d9      	b.n	900095b2 <dhcp_bind+0xa6>
    } else if (first_octet >= 192) {
900095fe:	2bbf      	cmp	r3, #191	; 0xbf
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
90009600:	bf8c      	ite	hi
90009602:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
90009606:	f64f 73ff 	movwls	r3, #65535	; 0xffff
9000960a:	e7d2      	b.n	900095b2 <dhcp_bind+0xa6>
9000960c:	90013361 	.word	0x90013361
90009610:	90013506 	.word	0x90013506
90009614:	90012aff 	.word	0x90012aff
90009618:	9001351f 	.word	0x9001351f

9000961c <dhcp_inc_pcb_refcount>:
{
9000961c:	b538      	push	{r3, r4, r5, lr}
  if (dhcp_pcb_refcount == 0) {
9000961e:	4d15      	ldr	r5, [pc, #84]	; (90009674 <dhcp_inc_pcb_refcount+0x58>)
90009620:	782b      	ldrb	r3, [r5, #0]
90009622:	b9f3      	cbnz	r3, 90009662 <dhcp_inc_pcb_refcount+0x46>
    LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);
90009624:	4c14      	ldr	r4, [pc, #80]	; (90009678 <dhcp_inc_pcb_refcount+0x5c>)
90009626:	6823      	ldr	r3, [r4, #0]
90009628:	b12b      	cbz	r3, 90009636 <dhcp_inc_pcb_refcount+0x1a>
9000962a:	4b14      	ldr	r3, [pc, #80]	; (9000967c <dhcp_inc_pcb_refcount+0x60>)
9000962c:	22e5      	movs	r2, #229	; 0xe5
9000962e:	4914      	ldr	r1, [pc, #80]	; (90009680 <dhcp_inc_pcb_refcount+0x64>)
90009630:	4814      	ldr	r0, [pc, #80]	; (90009684 <dhcp_inc_pcb_refcount+0x68>)
90009632:	f008 fabb 	bl	90011bac <iprintf>
    dhcp_pcb = udp_new();
90009636:	f008 f963 	bl	90011900 <udp_new>
9000963a:	6020      	str	r0, [r4, #0]
    if (dhcp_pcb == NULL) {
9000963c:	b1b0      	cbz	r0, 9000966c <dhcp_inc_pcb_refcount+0x50>
    ip_set_option(dhcp_pcb, SOF_BROADCAST);
9000963e:	7a42      	ldrb	r2, [r0, #9]
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
90009640:	4911      	ldr	r1, [pc, #68]	; (90009688 <dhcp_inc_pcb_refcount+0x6c>)
    ip_set_option(dhcp_pcb, SOF_BROADCAST);
90009642:	f042 0220 	orr.w	r2, r2, #32
90009646:	7242      	strb	r2, [r0, #9]
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
90009648:	2244      	movs	r2, #68	; 0x44
9000964a:	f007 ff6b 	bl	90011524 <udp_bind>
    udp_connect(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_SERVER);
9000964e:	2243      	movs	r2, #67	; 0x43
90009650:	490d      	ldr	r1, [pc, #52]	; (90009688 <dhcp_inc_pcb_refcount+0x6c>)
90009652:	6820      	ldr	r0, [r4, #0]
90009654:	f008 f8e0 	bl	90011818 <udp_connect>
    udp_recv(dhcp_pcb, dhcp_recv, NULL);
90009658:	2200      	movs	r2, #0
9000965a:	490c      	ldr	r1, [pc, #48]	; (9000968c <dhcp_inc_pcb_refcount+0x70>)
9000965c:	6820      	ldr	r0, [r4, #0]
9000965e:	f008 f917 	bl	90011890 <udp_recv>
  dhcp_pcb_refcount++;
90009662:	782b      	ldrb	r3, [r5, #0]
  return ERR_OK;
90009664:	2000      	movs	r0, #0
  dhcp_pcb_refcount++;
90009666:	3301      	adds	r3, #1
90009668:	702b      	strb	r3, [r5, #0]
}
9000966a:	bd38      	pop	{r3, r4, r5, pc}
      return ERR_MEM;
9000966c:	f04f 30ff 	mov.w	r0, #4294967295
90009670:	e7fb      	b.n	9000966a <dhcp_inc_pcb_refcount+0x4e>
90009672:	bf00      	nop
90009674:	24009b34 	.word	0x24009b34
90009678:	24009b30 	.word	0x24009b30
9000967c:	90013361 	.word	0x90013361
90009680:	90013537 	.word	0x90013537
90009684:	90012aff 	.word	0x90012aff
90009688:	90013a68 	.word	0x90013a68
9000968c:	900099d1 	.word	0x900099d1

90009690 <dhcp_dec_pcb_refcount>:
{
90009690:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
90009692:	4d0a      	ldr	r5, [pc, #40]	; (900096bc <dhcp_dec_pcb_refcount+0x2c>)
90009694:	782b      	ldrb	r3, [r5, #0]
90009696:	b92b      	cbnz	r3, 900096a4 <dhcp_dec_pcb_refcount+0x14>
90009698:	4b09      	ldr	r3, [pc, #36]	; (900096c0 <dhcp_dec_pcb_refcount+0x30>)
9000969a:	22ff      	movs	r2, #255	; 0xff
9000969c:	4909      	ldr	r1, [pc, #36]	; (900096c4 <dhcp_dec_pcb_refcount+0x34>)
9000969e:	480a      	ldr	r0, [pc, #40]	; (900096c8 <dhcp_dec_pcb_refcount+0x38>)
900096a0:	f008 fa84 	bl	90011bac <iprintf>
  dhcp_pcb_refcount--;
900096a4:	782c      	ldrb	r4, [r5, #0]
900096a6:	3c01      	subs	r4, #1
900096a8:	b2e4      	uxtb	r4, r4
900096aa:	702c      	strb	r4, [r5, #0]
  if (dhcp_pcb_refcount == 0) {
900096ac:	b924      	cbnz	r4, 900096b8 <dhcp_dec_pcb_refcount+0x28>
    udp_remove(dhcp_pcb);
900096ae:	4d07      	ldr	r5, [pc, #28]	; (900096cc <dhcp_dec_pcb_refcount+0x3c>)
900096b0:	6828      	ldr	r0, [r5, #0]
900096b2:	f008 f8ff 	bl	900118b4 <udp_remove>
    dhcp_pcb = NULL;
900096b6:	602c      	str	r4, [r5, #0]
}
900096b8:	bd38      	pop	{r3, r4, r5, pc}
900096ba:	bf00      	nop
900096bc:	24009b34 	.word	0x24009b34
900096c0:	90013361 	.word	0x90013361
900096c4:	9001355c 	.word	0x9001355c
900096c8:	90012aff 	.word	0x90012aff
900096cc:	24009b30 	.word	0x24009b30

900096d0 <dhcp_reboot.isra.0>:
dhcp_reboot(struct netif *netif)
900096d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
900096d4:	6a84      	ldr	r4, [r0, #40]	; 0x28
dhcp_reboot(struct netif *netif)
900096d6:	b085      	sub	sp, #20
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
900096d8:	2103      	movs	r1, #3
dhcp_reboot(struct netif *netif)
900096da:	4607      	mov	r7, r0
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
900096dc:	4620      	mov	r0, r4
900096de:	f7ff fd54 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
900096e2:	460a      	mov	r2, r1
900096e4:	f10d 030e 	add.w	r3, sp, #14
900096e8:	4621      	mov	r1, r4
900096ea:	4638      	mov	r0, r7
900096ec:	f7ff fdcc 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
900096f0:	4606      	mov	r6, r0
900096f2:	2800      	cmp	r0, #0
900096f4:	d04b      	beq.n	9000978e <dhcp_reboot.isra.0+0xbe>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
900096f6:	6845      	ldr	r5, [r0, #4]
900096f8:	2302      	movs	r3, #2
900096fa:	2239      	movs	r2, #57	; 0x39
900096fc:	f8bd 000e 	ldrh.w	r0, [sp, #14]
90009700:	35f0      	adds	r5, #240	; 0xf0
90009702:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 900097d0 <dhcp_reboot.isra.0+0x100>
90009706:	4629      	mov	r1, r5
90009708:	f7ff fd64 	bl	900091d4 <dhcp_option>
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
9000970c:	f44f 7210 	mov.w	r2, #576	; 0x240
90009710:	4629      	mov	r1, r5
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
90009712:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
90009716:	f7ff fd41 	bl	9000919c <dhcp_option_short>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
9000971a:	2304      	movs	r3, #4
9000971c:	2232      	movs	r2, #50	; 0x32
9000971e:	4629      	mov	r1, r5
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
90009720:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
90009724:	f7ff fd56 	bl	900091d4 <dhcp_option>
90009728:	4680      	mov	r8, r0
9000972a:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
9000972e:	69e0      	ldr	r0, [r4, #28]
90009730:	f7ff fd29 	bl	90009186 <lwip_htonl>
90009734:	4629      	mov	r1, r5
90009736:	4602      	mov	r2, r0
90009738:	4640      	mov	r0, r8
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000973a:	f04f 0804 	mov.w	r8, #4
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
9000973e:	f7ff fd7f 	bl	90009240 <dhcp_option_long>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
90009742:	2304      	movs	r3, #4
90009744:	2237      	movs	r2, #55	; 0x37
90009746:	4629      	mov	r1, r5
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
90009748:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000974c:	f7ff fd42 	bl	900091d4 <dhcp_option>
90009750:	f8ad 000e 	strh.w	r0, [sp, #14]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009754:	f108 38ff 	add.w	r8, r8, #4294967295
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
90009758:	f819 2b01 	ldrb.w	r2, [r9], #1
9000975c:	4629      	mov	r1, r5
9000975e:	f8bd 000e 	ldrh.w	r0, [sp, #14]
90009762:	f7ff fd55 	bl	90009210 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009766:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000976a:	f8ad 000e 	strh.w	r0, [sp, #14]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000976e:	d1f1      	bne.n	90009754 <dhcp_reboot.isra.0+0x84>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
90009770:	4632      	mov	r2, r6
90009772:	4629      	mov	r1, r5
90009774:	f7ff fe1c 	bl	900093b0 <dhcp_option_trailer>
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
90009778:	4813      	ldr	r0, [pc, #76]	; (900097c8 <dhcp_reboot.isra.0+0xf8>)
9000977a:	9700      	str	r7, [sp, #0]
9000977c:	2343      	movs	r3, #67	; 0x43
9000977e:	4a13      	ldr	r2, [pc, #76]	; (900097cc <dhcp_reboot.isra.0+0xfc>)
90009780:	4631      	mov	r1, r6
90009782:	6800      	ldr	r0, [r0, #0]
90009784:	f007 ffcc 	bl	90011720 <udp_sendto_if>
    pbuf_free(p_out);
90009788:	4630      	mov	r0, r6
9000978a:	f003 fa89 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
9000978e:	79a3      	ldrb	r3, [r4, #6]
90009790:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
90009792:	bf1c      	itt	ne
90009794:	3301      	addne	r3, #1
90009796:	71a3      	strbne	r3, [r4, #6]
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
90009798:	79a3      	ldrb	r3, [r4, #6]
9000979a:	2b09      	cmp	r3, #9
9000979c:	bf96      	itet	ls
9000979e:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
900097a2:	f242 7310 	movwhi	r3, #10000	; 0x2710
900097a6:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
900097aa:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
900097ae:	bf9c      	itt	ls
900097b0:	00db      	lslls	r3, r3, #3
900097b2:	b29b      	uxthls	r3, r3
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
900097b4:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
900097b8:	b29b      	uxth	r3, r3
900097ba:	fbb3 f3f2 	udiv	r3, r3, r2
900097be:	8123      	strh	r3, [r4, #8]
}
900097c0:	b005      	add	sp, #20
900097c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
900097c6:	bf00      	nop
900097c8:	24009b30 	.word	0x24009b30
900097cc:	90013a6c 	.word	0x90013a6c
900097d0:	90013695 	.word	0x90013695

900097d4 <dhcp_handle_ack.isra.0>:
dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
900097d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
900097d6:	2300      	movs	r3, #0
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
900097d8:	4d22      	ldr	r5, [pc, #136]	; (90009864 <dhcp_handle_ack.isra.0+0x90>)
dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
900097da:	4604      	mov	r4, r0
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
900097dc:	e9c0 3308 	strd	r3, r3, [r0, #32]
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
900097e0:	78eb      	ldrb	r3, [r5, #3]
900097e2:	b113      	cbz	r3, 900097ea <dhcp_handle_ack.isra.0+0x16>
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
900097e4:	4b20      	ldr	r3, [pc, #128]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
900097e6:	68db      	ldr	r3, [r3, #12]
900097e8:	6283      	str	r3, [r0, #40]	; 0x28
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
900097ea:	792b      	ldrb	r3, [r5, #4]
900097ec:	2b00      	cmp	r3, #0
900097ee:	d031      	beq.n	90009854 <dhcp_handle_ack.isra.0+0x80>
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
900097f0:	4b1d      	ldr	r3, [pc, #116]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
900097f2:	691b      	ldr	r3, [r3, #16]
900097f4:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
900097f6:	796b      	ldrb	r3, [r5, #5]
900097f8:	2b00      	cmp	r3, #0
900097fa:	d02e      	beq.n	9000985a <dhcp_handle_ack.isra.0+0x86>
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
900097fc:	4b1a      	ldr	r3, [pc, #104]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
900097fe:	695b      	ldr	r3, [r3, #20]
90009800:	6323      	str	r3, [r4, #48]	; 0x30
  ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
90009802:	690b      	ldr	r3, [r1, #16]
90009804:	61e3      	str	r3, [r4, #28]
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
90009806:	79ab      	ldrb	r3, [r5, #6]
90009808:	b12b      	cbz	r3, 90009816 <dhcp_handle_ack.isra.0+0x42>
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
9000980a:	4b17      	ldr	r3, [pc, #92]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
9000980c:	6998      	ldr	r0, [r3, #24]
9000980e:	f7ff fcba 	bl	90009186 <lwip_htonl>
    dhcp->subnet_mask_given = 1;
90009812:	2301      	movs	r3, #1
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
90009814:	6220      	str	r0, [r4, #32]
    dhcp->subnet_mask_given = 0;
90009816:	71e3      	strb	r3, [r4, #7]
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
90009818:	79eb      	ldrb	r3, [r5, #7]
9000981a:	b123      	cbz	r3, 90009826 <dhcp_handle_ack.isra.0+0x52>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
9000981c:	4b12      	ldr	r3, [pc, #72]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
9000981e:	69d8      	ldr	r0, [r3, #28]
90009820:	f7ff fcb1 	bl	90009186 <lwip_htonl>
90009824:	6260      	str	r0, [r4, #36]	; 0x24
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
90009826:	7a2b      	ldrb	r3, [r5, #8]
90009828:	b193      	cbz	r3, 90009850 <dhcp_handle_ack.isra.0+0x7c>
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
9000982a:	4c0f      	ldr	r4, [pc, #60]	; (90009868 <dhcp_handle_ack.isra.0+0x94>)
9000982c:	6a20      	ldr	r0, [r4, #32]
9000982e:	f7ff fcaa 	bl	90009186 <lwip_htonl>
    dns_setserver(n, &dns_addr);
90009832:	a901      	add	r1, sp, #4
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
90009834:	9001      	str	r0, [sp, #4]
    dns_setserver(n, &dns_addr);
90009836:	2000      	movs	r0, #0
90009838:	f000 ff5c 	bl	9000a6f4 <dns_setserver>
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
9000983c:	7a6b      	ldrb	r3, [r5, #9]
9000983e:	b13b      	cbz	r3, 90009850 <dhcp_handle_ack.isra.0+0x7c>
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
90009840:	6a60      	ldr	r0, [r4, #36]	; 0x24
90009842:	f7ff fca0 	bl	90009186 <lwip_htonl>
    dns_setserver(n, &dns_addr);
90009846:	a901      	add	r1, sp, #4
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
90009848:	9001      	str	r0, [sp, #4]
    dns_setserver(n, &dns_addr);
9000984a:	2001      	movs	r0, #1
9000984c:	f000 ff52 	bl	9000a6f4 <dns_setserver>
}
90009850:	b003      	add	sp, #12
90009852:	bd30      	pop	{r4, r5, pc}
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
90009854:	6aa3      	ldr	r3, [r4, #40]	; 0x28
90009856:	085b      	lsrs	r3, r3, #1
90009858:	e7cc      	b.n	900097f4 <dhcp_handle_ack.isra.0+0x20>
    dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
9000985a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
9000985c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
90009860:	08db      	lsrs	r3, r3, #3
90009862:	e7cd      	b.n	90009800 <dhcp_handle_ack.isra.0+0x2c>
90009864:	24009b35 	.word	0x24009b35
90009868:	24009b40 	.word	0x24009b40

9000986c <dhcp_select.isra.0>:
dhcp_select(struct netif *netif)
9000986c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
90009870:	4607      	mov	r7, r0
dhcp_select(struct netif *netif)
90009872:	b085      	sub	sp, #20
  LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
90009874:	b948      	cbnz	r0, 9000988a <dhcp_select.isra.0+0x1e>
90009876:	4b4e      	ldr	r3, [pc, #312]	; (900099b0 <dhcp_select.isra.0+0x144>)
90009878:	f240 1277 	movw	r2, #375	; 0x177
9000987c:	494d      	ldr	r1, [pc, #308]	; (900099b4 <dhcp_select.isra.0+0x148>)
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
9000987e:	484e      	ldr	r0, [pc, #312]	; (900099b8 <dhcp_select.isra.0+0x14c>)
}
90009880:	b005      	add	sp, #20
90009882:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
90009886:	f008 b991 	b.w	90011bac <iprintf>
  dhcp = netif_dhcp_data(netif);
9000988a:	6a84      	ldr	r4, [r0, #40]	; 0x28
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
9000988c:	b924      	cbnz	r4, 90009898 <dhcp_select.isra.0+0x2c>
9000988e:	4b48      	ldr	r3, [pc, #288]	; (900099b0 <dhcp_select.isra.0+0x144>)
90009890:	f240 1279 	movw	r2, #377	; 0x179
90009894:	4949      	ldr	r1, [pc, #292]	; (900099bc <dhcp_select.isra.0+0x150>)
90009896:	e7f2      	b.n	9000987e <dhcp_select.isra.0+0x12>
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
90009898:	2101      	movs	r1, #1
9000989a:	4620      	mov	r0, r4
9000989c:	f7ff fc75 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
900098a0:	2203      	movs	r2, #3
900098a2:	f10d 030e 	add.w	r3, sp, #14
900098a6:	4621      	mov	r1, r4
900098a8:	4638      	mov	r0, r7
900098aa:	f7ff fced 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
900098ae:	4606      	mov	r6, r0
900098b0:	2800      	cmp	r0, #0
900098b2:	d05e      	beq.n	90009972 <dhcp_select.isra.0+0x106>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
900098b4:	6845      	ldr	r5, [r0, #4]
900098b6:	2302      	movs	r3, #2
900098b8:	2239      	movs	r2, #57	; 0x39
900098ba:	f8bd 000e 	ldrh.w	r0, [sp, #14]
900098be:	35f0      	adds	r5, #240	; 0xf0
900098c0:	f8df 9108 	ldr.w	r9, [pc, #264]	; 900099cc <dhcp_select.isra.0+0x160>
900098c4:	4629      	mov	r1, r5
900098c6:	f7ff fc85 	bl	900091d4 <dhcp_option>
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
900098ca:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
900098cc:	4629      	mov	r1, r5
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
900098ce:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
900098d2:	f7ff fc63 	bl	9000919c <dhcp_option_short>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
900098d6:	2304      	movs	r3, #4
900098d8:	2232      	movs	r2, #50	; 0x32
900098da:	4629      	mov	r1, r5
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
900098dc:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
900098e0:	f7ff fc78 	bl	900091d4 <dhcp_option>
900098e4:	4680      	mov	r8, r0
900098e6:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
900098ea:	69e0      	ldr	r0, [r4, #28]
900098ec:	f7ff fc4b 	bl	90009186 <lwip_htonl>
900098f0:	4629      	mov	r1, r5
900098f2:	4602      	mov	r2, r0
900098f4:	4640      	mov	r0, r8
900098f6:	f7ff fca3 	bl	90009240 <dhcp_option_long>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
900098fa:	2304      	movs	r3, #4
900098fc:	2236      	movs	r2, #54	; 0x36
900098fe:	4629      	mov	r1, r5
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
90009900:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
90009904:	f7ff fc66 	bl	900091d4 <dhcp_option>
90009908:	4680      	mov	r8, r0
9000990a:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
9000990e:	69a0      	ldr	r0, [r4, #24]
90009910:	f7ff fc39 	bl	90009186 <lwip_htonl>
90009914:	4629      	mov	r1, r5
90009916:	4602      	mov	r2, r0
90009918:	4640      	mov	r0, r8
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000991a:	f04f 0804 	mov.w	r8, #4
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
9000991e:	f7ff fc8f 	bl	90009240 <dhcp_option_long>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
90009922:	2304      	movs	r3, #4
90009924:	2237      	movs	r2, #55	; 0x37
90009926:	4629      	mov	r1, r5
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
90009928:	f8ad 000e 	strh.w	r0, [sp, #14]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000992c:	f7ff fc52 	bl	900091d4 <dhcp_option>
90009930:	f8ad 000e 	strh.w	r0, [sp, #14]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009934:	f108 38ff 	add.w	r8, r8, #4294967295
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
90009938:	f819 2b01 	ldrb.w	r2, [r9], #1
9000993c:	4629      	mov	r1, r5
9000993e:	f8bd 000e 	ldrh.w	r0, [sp, #14]
90009942:	f7ff fc65 	bl	90009210 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
90009946:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000994a:	f8ad 000e 	strh.w	r0, [sp, #14]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000994e:	d1f1      	bne.n	90009934 <dhcp_select.isra.0+0xc8>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
90009950:	4632      	mov	r2, r6
90009952:	4629      	mov	r1, r5
90009954:	f7ff fd2c 	bl	900093b0 <dhcp_option_trailer>
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
90009958:	4b19      	ldr	r3, [pc, #100]	; (900099c0 <dhcp_select.isra.0+0x154>)
9000995a:	481a      	ldr	r0, [pc, #104]	; (900099c4 <dhcp_select.isra.0+0x158>)
9000995c:	4631      	mov	r1, r6
9000995e:	4a1a      	ldr	r2, [pc, #104]	; (900099c8 <dhcp_select.isra.0+0x15c>)
90009960:	e9cd 7300 	strd	r7, r3, [sp]
90009964:	2343      	movs	r3, #67	; 0x43
90009966:	6800      	ldr	r0, [r0, #0]
90009968:	f007 fe42 	bl	900115f0 <udp_sendto_if_src>
    pbuf_free(p_out);
9000996c:	4630      	mov	r0, r6
9000996e:	f003 f997 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
90009972:	79a3      	ldrb	r3, [r4, #6]
90009974:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
90009976:	bf1c      	itt	ne
90009978:	3301      	addne	r3, #1
9000997a:	71a3      	strbne	r3, [r4, #6]
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
9000997c:	79a2      	ldrb	r2, [r4, #6]
9000997e:	2a05      	cmp	r2, #5
90009980:	bf97      	itett	ls
90009982:	2301      	movls	r3, #1
90009984:	f64e 2360 	movwhi	r3, #60000	; 0xea60
90009988:	4093      	lslls	r3, r2
9000998a:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
9000998e:	bf98      	it	ls
90009990:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
90009994:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
90009998:	bf9c      	itt	ls
9000999a:	00db      	lslls	r3, r3, #3
9000999c:	b29b      	uxthls	r3, r3
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000999e:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
900099a2:	b29b      	uxth	r3, r3
900099a4:	fbb3 f3f2 	udiv	r3, r3, r2
900099a8:	8123      	strh	r3, [r4, #8]
}
900099aa:	b005      	add	sp, #20
900099ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
900099b0:	90013361 	.word	0x90013361
900099b4:	90013580 	.word	0x90013580
900099b8:	90012aff 	.word	0x90012aff
900099bc:	9001359b 	.word	0x9001359b
900099c0:	90013a68 	.word	0x90013a68
900099c4:	24009b30 	.word	0x24009b30
900099c8:	90013a6c 	.word	0x90013a6c
900099cc:	90013695 	.word	0x90013695

900099d0 <dhcp_recv>:
  struct netif *netif = ip_current_input_netif();
900099d0:	4b93      	ldr	r3, [pc, #588]	; (90009c20 <dhcp_recv+0x250>)
{
900099d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct netif *netif = ip_current_input_netif();
900099d6:	685f      	ldr	r7, [r3, #4]
{
900099d8:	b08b      	sub	sp, #44	; 0x2c
  struct dhcp *dhcp = netif_dhcp_data(netif);
900099da:	6abb      	ldr	r3, [r7, #40]	; 0x28
{
900099dc:	9201      	str	r2, [sp, #4]
  struct dhcp *dhcp = netif_dhcp_data(netif);
900099de:	9302      	str	r3, [sp, #8]
  if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
900099e0:	2b00      	cmp	r3, #0
900099e2:	d041      	beq.n	90009a68 <dhcp_recv+0x98>
900099e4:	791b      	ldrb	r3, [r3, #4]
900099e6:	2b00      	cmp	r3, #0
900099e8:	d03e      	beq.n	90009a68 <dhcp_recv+0x98>
  if (p->len < DHCP_MIN_REPLY_LEN) {
900099ea:	8953      	ldrh	r3, [r2, #10]
900099ec:	2b2b      	cmp	r3, #43	; 0x2b
900099ee:	d93b      	bls.n	90009a68 <dhcp_recv+0x98>
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
900099f0:	6852      	ldr	r2, [r2, #4]
  if (reply_msg->op != DHCP_BOOTREPLY) {
900099f2:	7813      	ldrb	r3, [r2, #0]
900099f4:	2b02      	cmp	r3, #2
900099f6:	d137      	bne.n	90009a68 <dhcp_recv+0x98>
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
900099f8:	f897 4034 	ldrb.w	r4, [r7, #52]	; 0x34
900099fc:	f107 002e 	add.w	r0, r7, #46	; 0x2e
90009a00:	f102 011c 	add.w	r1, r2, #28
90009a04:	2300      	movs	r3, #0
90009a06:	b2dd      	uxtb	r5, r3
90009a08:	42ac      	cmp	r4, r5
90009a0a:	d901      	bls.n	90009a10 <dhcp_recv+0x40>
90009a0c:	2b06      	cmp	r3, #6
90009a0e:	d124      	bne.n	90009a5a <dhcp_recv+0x8a>
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
90009a10:	6850      	ldr	r0, [r2, #4]
90009a12:	f7ff fbb8 	bl	90009186 <lwip_htonl>
90009a16:	9b02      	ldr	r3, [sp, #8]
90009a18:	681b      	ldr	r3, [r3, #0]
90009a1a:	4298      	cmp	r0, r3
90009a1c:	d124      	bne.n	90009a68 <dhcp_recv+0x98>
  dhcp_clear_all_options(dhcp);
90009a1e:	f8df a22c 	ldr.w	sl, [pc, #556]	; 90009c4c <dhcp_recv+0x27c>
90009a22:	2300      	movs	r3, #0
  if (p->len < DHCP_SNAME_OFS) {
90009a24:	9a01      	ldr	r2, [sp, #4]
  dhcp_clear_all_options(dhcp);
90009a26:	f8ca 3004 	str.w	r3, [sl, #4]
90009a2a:	f8aa 3008 	strh.w	r3, [sl, #8]
  if (p->len < DHCP_SNAME_OFS) {
90009a2e:	8952      	ldrh	r2, [r2, #10]
  dhcp_clear_all_options(dhcp);
90009a30:	f8ca 3000 	str.w	r3, [sl]
  if (p->len < DHCP_SNAME_OFS) {
90009a34:	2a2b      	cmp	r2, #43	; 0x2b
90009a36:	d917      	bls.n	90009a68 <dhcp_recv+0x98>
  options_idx_max = p->tot_len;
90009a38:	9a01      	ldr	r2, [sp, #4]
  options_idx = DHCP_OPTIONS_OFS;
90009a3a:	f04f 0bf0 	mov.w	fp, #240	; 0xf0
  int parse_sname_as_options = 0;
90009a3e:	9304      	str	r3, [sp, #16]
  options_idx_max = p->tot_len;
90009a40:	f8b2 9008 	ldrh.w	r9, [r2, #8]
  options_idx = DHCP_OPTIONS_OFS;
90009a44:	f8dd 8004 	ldr.w	r8, [sp, #4]
  while ((q != NULL) && (options_idx >= q->len)) {
90009a48:	f8b8 300a 	ldrh.w	r3, [r8, #10]
90009a4c:	455b      	cmp	r3, fp
90009a4e:	d911      	bls.n	90009a74 <dhcp_recv+0xa4>
  options = (u8_t *)q->payload;
90009a50:	f8d8 3004 	ldr.w	r3, [r8, #4]
90009a54:	465e      	mov	r6, fp
90009a56:	9305      	str	r3, [sp, #20]
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
90009a58:	e0fd      	b.n	90009c56 <dhcp_recv+0x286>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
90009a5a:	f810 6b01 	ldrb.w	r6, [r0], #1
90009a5e:	3301      	adds	r3, #1
90009a60:	f811 5b01 	ldrb.w	r5, [r1], #1
90009a64:	42ae      	cmp	r6, r5
90009a66:	d0ce      	beq.n	90009a06 <dhcp_recv+0x36>
  pbuf_free(p);
90009a68:	9801      	ldr	r0, [sp, #4]
}
90009a6a:	b00b      	add	sp, #44	; 0x2c
90009a6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
90009a70:	f003 b916 	b.w	9000cca0 <pbuf_free>
    options_idx = (u16_t)(options_idx - q->len);
90009a74:	ebab 0203 	sub.w	r2, fp, r3
    options_idx_max = (u16_t)(options_idx_max - q->len);
90009a78:	eba9 0903 	sub.w	r9, r9, r3
    q = q->next;
90009a7c:	f8d8 8000 	ldr.w	r8, [r8]
    options_idx = (u16_t)(options_idx - q->len);
90009a80:	fa1f fb82 	uxth.w	fp, r2
    options_idx_max = (u16_t)(options_idx_max - q->len);
90009a84:	fa1f f989 	uxth.w	r9, r9
  while ((q != NULL) && (options_idx >= q->len)) {
90009a88:	f1b8 0f00 	cmp.w	r8, #0
90009a8c:	d1dc      	bne.n	90009a48 <dhcp_recv+0x78>
90009a8e:	e7eb      	b.n	90009a68 <dhcp_recv+0x98>
    u16_t val_offset = (u16_t)(offset + 2);
90009a90:	1cb3      	adds	r3, r6, #2
90009a92:	b29b      	uxth	r3, r3
    if (val_offset < offset) {
90009a94:	42b3      	cmp	r3, r6
    u16_t val_offset = (u16_t)(offset + 2);
90009a96:	9303      	str	r3, [sp, #12]
    if (val_offset < offset) {
90009a98:	d3e6      	bcc.n	90009a68 <dhcp_recv+0x98>
    if ((offset + 1) < q->len) {
90009a9a:	1c73      	adds	r3, r6, #1
90009a9c:	f8b8 100a 	ldrh.w	r1, [r8, #10]
90009aa0:	428b      	cmp	r3, r1
90009aa2:	da0e      	bge.n	90009ac2 <dhcp_recv+0xf2>
      len = options[offset + 1];
90009aa4:	9b05      	ldr	r3, [sp, #20]
90009aa6:	4433      	add	r3, r6
90009aa8:	785b      	ldrb	r3, [r3, #1]
    switch (op) {
90009aaa:	2a06      	cmp	r2, #6
90009aac:	f200 81e0 	bhi.w	90009e70 <dhcp_recv+0x4a0>
90009ab0:	2a06      	cmp	r2, #6
90009ab2:	f200 8082 	bhi.w	90009bba <dhcp_recv+0x1ea>
90009ab6:	e8df f002 	tbb	[pc, r2]
90009aba:	0c67      	.short	0x0c67
90009abc:	80801480 	.word	0x80801480
90009ac0:	1c          	.byte	0x1c
90009ac1:	00          	.byte	0x00
      len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
90009ac2:	f8d8 3000 	ldr.w	r3, [r8]
90009ac6:	2b00      	cmp	r3, #0
90009ac8:	f000 8143 	beq.w	90009d52 <dhcp_recv+0x382>
90009acc:	685b      	ldr	r3, [r3, #4]
90009ace:	781b      	ldrb	r3, [r3, #0]
90009ad0:	e7eb      	b.n	90009aaa <dhcp_recv+0xda>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009ad2:	2b04      	cmp	r3, #4
90009ad4:	f000 8168 	beq.w	90009da8 <dhcp_recv+0x3d8>
90009ad8:	4b52      	ldr	r3, [pc, #328]	; (90009c24 <dhcp_recv+0x254>)
90009ada:	f240 622e 	movw	r2, #1582	; 0x62e
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009ade:	4952      	ldr	r1, [pc, #328]	; (90009c28 <dhcp_recv+0x258>)
90009ae0:	e00d      	b.n	90009afe <dhcp_recv+0x12e>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
90009ae2:	2b03      	cmp	r3, #3
90009ae4:	f200 819a 	bhi.w	90009e1c <dhcp_recv+0x44c>
90009ae8:	4b4e      	ldr	r3, [pc, #312]	; (90009c24 <dhcp_recv+0x254>)
90009aea:	f240 6233 	movw	r2, #1587	; 0x633
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
90009aee:	494f      	ldr	r1, [pc, #316]	; (90009c2c <dhcp_recv+0x25c>)
90009af0:	e005      	b.n	90009afe <dhcp_recv+0x12e>
        LWIP_ERROR("len %% 4 == 0", len % 4 == 0, return ERR_VAL;);
90009af2:	0799      	lsls	r1, r3, #30
90009af4:	d007      	beq.n	90009b06 <dhcp_recv+0x136>
90009af6:	4b4b      	ldr	r3, [pc, #300]	; (90009c24 <dhcp_recv+0x254>)
90009af8:	f240 6239 	movw	r2, #1593	; 0x639
90009afc:	494c      	ldr	r1, [pc, #304]	; (90009c30 <dhcp_recv+0x260>)
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009afe:	484d      	ldr	r0, [pc, #308]	; (90009c34 <dhcp_recv+0x264>)
90009b00:	f008 f854 	bl	90011bac <iprintf>
90009b04:	e7b0      	b.n	90009a68 <dhcp_recv+0x98>
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
90009b06:	2b08      	cmp	r3, #8
90009b08:	461c      	mov	r4, r3
90009b0a:	bf28      	it	cs
90009b0c:	2408      	movcs	r4, #8
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
90009b0e:	429c      	cmp	r4, r3
90009b10:	d936      	bls.n	90009b80 <dhcp_recv+0x1b0>
90009b12:	4b44      	ldr	r3, [pc, #272]	; (90009c24 <dhcp_recv+0x254>)
90009b14:	f240 623c 	movw	r2, #1596	; 0x63c
90009b18:	e7e9      	b.n	90009aee <dhcp_recv+0x11e>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009b1a:	2b04      	cmp	r3, #4
90009b1c:	f000 8181 	beq.w	90009e22 <dhcp_recv+0x452>
90009b20:	4b40      	ldr	r3, [pc, #256]	; (90009c24 <dhcp_recv+0x254>)
90009b22:	f240 6241 	movw	r2, #1601	; 0x641
90009b26:	e7da      	b.n	90009ade <dhcp_recv+0x10e>
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
90009b28:	2b01      	cmp	r3, #1
90009b2a:	d004      	beq.n	90009b36 <dhcp_recv+0x166>
90009b2c:	4b3d      	ldr	r3, [pc, #244]	; (90009c24 <dhcp_recv+0x254>)
90009b2e:	f240 624f 	movw	r2, #1615	; 0x64f
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
90009b32:	4941      	ldr	r1, [pc, #260]	; (90009c38 <dhcp_recv+0x268>)
90009b34:	e7e3      	b.n	90009afe <dhcp_recv+0x12e>
        LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
90009b36:	f1bb 0ff0 	cmp.w	fp, #240	; 0xf0
90009b3a:	f000 8175 	beq.w	90009e28 <dhcp_recv+0x458>
90009b3e:	4b39      	ldr	r3, [pc, #228]	; (90009c24 <dhcp_recv+0x254>)
90009b40:	f240 6251 	movw	r2, #1617	; 0x651
90009b44:	493d      	ldr	r1, [pc, #244]	; (90009c3c <dhcp_recv+0x26c>)
90009b46:	e7da      	b.n	90009afe <dhcp_recv+0x12e>
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
90009b48:	2b01      	cmp	r3, #1
90009b4a:	f000 8173 	beq.w	90009e34 <dhcp_recv+0x464>
90009b4e:	4b35      	ldr	r3, [pc, #212]	; (90009c24 <dhcp_recv+0x254>)
90009b50:	f240 6255 	movw	r2, #1621	; 0x655
90009b54:	e7ed      	b.n	90009b32 <dhcp_recv+0x162>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009b56:	2b04      	cmp	r3, #4
90009b58:	f000 8169 	beq.w	90009e2e <dhcp_recv+0x45e>
90009b5c:	4b31      	ldr	r3, [pc, #196]	; (90009c24 <dhcp_recv+0x254>)
90009b5e:	f240 6259 	movw	r2, #1625	; 0x659
90009b62:	e7bc      	b.n	90009ade <dhcp_recv+0x10e>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009b64:	2b04      	cmp	r3, #4
90009b66:	f000 8165 	beq.w	90009e34 <dhcp_recv+0x464>
90009b6a:	4b2e      	ldr	r3, [pc, #184]	; (90009c24 <dhcp_recv+0x254>)
90009b6c:	f240 625d 	movw	r2, #1629	; 0x65d
90009b70:	e7b5      	b.n	90009ade <dhcp_recv+0x10e>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
90009b72:	2b04      	cmp	r3, #4
90009b74:	f000 8161 	beq.w	90009e3a <dhcp_recv+0x46a>
90009b78:	4b2a      	ldr	r3, [pc, #168]	; (90009c24 <dhcp_recv+0x254>)
90009b7a:	f240 6261 	movw	r2, #1633	; 0x661
90009b7e:	e7ae      	b.n	90009ade <dhcp_recv+0x10e>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
90009b80:	2508      	movs	r5, #8
    if (op == DHCP_OPTION_PAD) {
90009b82:	2a00      	cmp	r2, #0
90009b84:	f040 8112 	bne.w	90009dac <dhcp_recv+0x3dc>
      offset++;
90009b88:	3601      	adds	r6, #1
90009b8a:	b2b6      	uxth	r6, r6
    if (offset >= q->len) {
90009b8c:	f8b8 300a 	ldrh.w	r3, [r8, #10]
90009b90:	42b3      	cmp	r3, r6
90009b92:	d860      	bhi.n	90009c56 <dhcp_recv+0x286>
      offset = (u16_t)(offset - q->len);
90009b94:	1af6      	subs	r6, r6, r3
      offset_max = (u16_t)(offset_max - q->len);
90009b96:	eba9 0903 	sub.w	r9, r9, r3
      offset = (u16_t)(offset - q->len);
90009b9a:	b2b6      	uxth	r6, r6
      offset_max = (u16_t)(offset_max - q->len);
90009b9c:	fa1f f989 	uxth.w	r9, r9
      if (offset < offset_max) {
90009ba0:	454e      	cmp	r6, r9
90009ba2:	f4bf af61 	bcs.w	90009a68 <dhcp_recv+0x98>
        q = q->next;
90009ba6:	f8d8 8000 	ldr.w	r8, [r8]
        LWIP_ERROR("next pbuf was null", q != NULL, return ERR_VAL;);
90009baa:	f1b8 0f00 	cmp.w	r8, #0
90009bae:	d14f      	bne.n	90009c50 <dhcp_recv+0x280>
90009bb0:	4b1c      	ldr	r3, [pc, #112]	; (90009c24 <dhcp_recv+0x254>)
90009bb2:	f240 629d 	movw	r2, #1693	; 0x69d
90009bb6:	4922      	ldr	r1, [pc, #136]	; (90009c40 <dhcp_recv+0x270>)
90009bb8:	e7a1      	b.n	90009afe <dhcp_recv+0x12e>
    switch (op) {
90009bba:	f04f 35ff 	mov.w	r5, #4294967295
90009bbe:	2400      	movs	r4, #0
90009bc0:	e7df      	b.n	90009b82 <dhcp_recv+0x1b2>
            dhcp_got_option(dhcp, decode_idx);
90009bc2:	9a06      	ldr	r2, [sp, #24]
90009bc4:	2301      	movs	r3, #1
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
90009bc6:	9809      	ldr	r0, [sp, #36]	; 0x24
            decode_len = (u8_t)(decode_len - 4);
90009bc8:	3c04      	subs	r4, #4
            dhcp_got_option(dhcp, decode_idx);
90009bca:	f802 3b01 	strb.w	r3, [r2], #1
90009bce:	9206      	str	r2, [sp, #24]
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
90009bd0:	f7ff fad9 	bl	90009186 <lwip_htonl>
90009bd4:	4b1b      	ldr	r3, [pc, #108]	; (90009c44 <dhcp_recv+0x274>)
            decode_len = (u8_t)(decode_len - 4);
90009bd6:	b2e4      	uxtb	r4, r4
            if (next_val_offset < val_offset) {
90009bd8:	9a03      	ldr	r2, [sp, #12]
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
90009bda:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
            next_val_offset = (u16_t)(val_offset + 4);
90009bde:	9b03      	ldr	r3, [sp, #12]
90009be0:	3304      	adds	r3, #4
90009be2:	b29b      	uxth	r3, r3
            if (next_val_offset < val_offset) {
90009be4:	429a      	cmp	r2, r3
90009be6:	f63f af3f 	bhi.w	90009a68 <dhcp_recv+0x98>
            decode_idx++;
90009bea:	3501      	adds	r5, #1
            goto decode_next;
90009bec:	9303      	str	r3, [sp, #12]
90009bee:	e0ee      	b.n	90009dce <dhcp_recv+0x3fe>
          } else if (decode_len == 4) {
90009bf0:	d10b      	bne.n	90009c0a <dhcp_recv+0x23a>
            value = lwip_ntohl(value);
90009bf2:	9809      	ldr	r0, [sp, #36]	; 0x24
90009bf4:	f7ff fac7 	bl	90009186 <lwip_htonl>
90009bf8:	9009      	str	r0, [sp, #36]	; 0x24
          dhcp_got_option(dhcp, decode_idx);
90009bfa:	2301      	movs	r3, #1
          dhcp_set_option_value(dhcp, decode_idx, value);
90009bfc:	9a09      	ldr	r2, [sp, #36]	; 0x24
          dhcp_got_option(dhcp, decode_idx);
90009bfe:	f80a 3005 	strb.w	r3, [sl, r5]
          dhcp_set_option_value(dhcp, decode_idx, value);
90009c02:	4b10      	ldr	r3, [pc, #64]	; (90009c44 <dhcp_recv+0x274>)
90009c04:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
90009c08:	e7c0      	b.n	90009b8c <dhcp_recv+0x1bc>
            LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
90009c0a:	2c01      	cmp	r4, #1
90009c0c:	d004      	beq.n	90009c18 <dhcp_recv+0x248>
90009c0e:	4b05      	ldr	r3, [pc, #20]	; (90009c24 <dhcp_recv+0x254>)
90009c10:	f44f 62d2 	mov.w	r2, #1680	; 0x690
90009c14:	490c      	ldr	r1, [pc, #48]	; (90009c48 <dhcp_recv+0x278>)
90009c16:	e772      	b.n	90009afe <dhcp_recv+0x12e>
            value = ((u8_t *)&value)[0];
90009c18:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
90009c1c:	9309      	str	r3, [sp, #36]	; 0x24
90009c1e:	e7ec      	b.n	90009bfa <dhcp_recv+0x22a>
90009c20:	2400a0e8 	.word	0x2400a0e8
90009c24:	90013361 	.word	0x90013361
90009c28:	900135b5 	.word	0x900135b5
90009c2c:	900135be 	.word	0x900135be
90009c30:	90013608 	.word	0x90013608
90009c34:	90012aff 	.word	0x90012aff
90009c38:	900135d0 	.word	0x900135d0
90009c3c:	900135d9 	.word	0x900135d9
90009c40:	90013629 	.word	0x90013629
90009c44:	24009b40 	.word	0x24009b40
90009c48:	90013616 	.word	0x90013616
90009c4c:	24009b35 	.word	0x24009b35
        options = (u8_t *)q->payload;
90009c50:	f8d8 3004 	ldr.w	r3, [r8, #4]
90009c54:	9305      	str	r3, [sp, #20]
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
90009c56:	454e      	cmp	r6, r9
90009c58:	d204      	bcs.n	90009c64 <dhcp_recv+0x294>
90009c5a:	9b05      	ldr	r3, [sp, #20]
90009c5c:	5d9a      	ldrb	r2, [r3, r6]
90009c5e:	2aff      	cmp	r2, #255	; 0xff
90009c60:	f47f af16 	bne.w	90009a90 <dhcp_recv+0xc0>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
90009c64:	f89a 3000 	ldrb.w	r3, [sl]
90009c68:	b9db      	cbnz	r3, 90009ca2 <dhcp_recv+0x2d2>
  } else if (parse_sname_as_options) {
90009c6a:	9b04      	ldr	r3, [sp, #16]
90009c6c:	bb13      	cbnz	r3, 90009cb4 <dhcp_recv+0x2e4>
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
90009c6e:	f89a 3001 	ldrb.w	r3, [sl, #1]
90009c72:	2b00      	cmp	r3, #0
90009c74:	f43f aef8 	beq.w	90009a68 <dhcp_recv+0x98>
  msg_in = (struct dhcp_msg *)p->payload;
90009c78:	9b01      	ldr	r3, [sp, #4]
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
90009c7a:	4a82      	ldr	r2, [pc, #520]	; (90009e84 <dhcp_recv+0x4b4>)
  msg_in = (struct dhcp_msg *)p->payload;
90009c7c:	6859      	ldr	r1, [r3, #4]
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
90009c7e:	7913      	ldrb	r3, [r2, #4]
  if (msg_type == DHCP_ACK) {
90009c80:	2b05      	cmp	r3, #5
90009c82:	d132      	bne.n	90009cea <dhcp_recv+0x31a>
    if (dhcp->state == DHCP_STATE_REQUESTING) {
90009c84:	9b02      	ldr	r3, [sp, #8]
90009c86:	795b      	ldrb	r3, [r3, #5]
90009c88:	2b01      	cmp	r3, #1
90009c8a:	d123      	bne.n	90009cd4 <dhcp_recv+0x304>
      dhcp_handle_ack(netif, msg_in);
90009c8c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
90009c8e:	f7ff fda1 	bl	900097d4 <dhcp_handle_ack.isra.0>
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
90009c92:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
        dhcp_check(netif);
90009c96:	4638      	mov	r0, r7
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
90009c98:	071b      	lsls	r3, r3, #28
90009c9a:	d523      	bpl.n	90009ce4 <dhcp_recv+0x314>
        dhcp_check(netif);
90009c9c:	f7ff fc20 	bl	900094e0 <dhcp_check>
90009ca0:	e6e2      	b.n	90009a68 <dhcp_recv+0x98>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
90009ca2:	4b78      	ldr	r3, [pc, #480]	; (90009e84 <dhcp_recv+0x4b4>)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
90009ca4:	2200      	movs	r2, #0
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
90009ca6:	681b      	ldr	r3, [r3, #0]
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
90009ca8:	f88a 2000 	strb.w	r2, [sl]
    if (overload == DHCP_OVERLOAD_FILE) {
90009cac:	2b01      	cmp	r3, #1
90009cae:	d00c      	beq.n	90009cca <dhcp_recv+0x2fa>
    } else if (overload == DHCP_OVERLOAD_SNAME) {
90009cb0:	2b02      	cmp	r3, #2
90009cb2:	d106      	bne.n	90009cc2 <dhcp_recv+0x2f2>
    parse_sname_as_options = 0;
90009cb4:	2300      	movs	r3, #0
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
90009cb6:	f04f 096c 	mov.w	r9, #108	; 0x6c
    options_idx = DHCP_SNAME_OFS;
90009cba:	f04f 0b2c 	mov.w	fp, #44	; 0x2c
    parse_sname_as_options = 0;
90009cbe:	9304      	str	r3, [sp, #16]
90009cc0:	e6c0      	b.n	90009a44 <dhcp_recv+0x74>
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
90009cc2:	2b03      	cmp	r3, #3
90009cc4:	d1d1      	bne.n	90009c6a <dhcp_recv+0x29a>
      parse_sname_as_options = 1;
90009cc6:	2301      	movs	r3, #1
90009cc8:	9304      	str	r3, [sp, #16]
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
90009cca:	f04f 09ec 	mov.w	r9, #236	; 0xec
    options_idx = DHCP_FILE_OFS;
90009cce:	f04f 0b6c 	mov.w	fp, #108	; 0x6c
90009cd2:	e6b7      	b.n	90009a44 <dhcp_recv+0x74>
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
90009cd4:	3b03      	subs	r3, #3
90009cd6:	2b02      	cmp	r3, #2
90009cd8:	f63f aec6 	bhi.w	90009a68 <dhcp_recv+0x98>
      dhcp_handle_ack(netif, msg_in);
90009cdc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
90009cde:	f7ff fd79 	bl	900097d4 <dhcp_handle_ack.isra.0>
      dhcp_bind(netif);
90009ce2:	4638      	mov	r0, r7
90009ce4:	f7ff fc12 	bl	9000950c <dhcp_bind>
90009ce8:	e6be      	b.n	90009a68 <dhcp_recv+0x98>
  else if ((msg_type == DHCP_NAK) &&
90009cea:	2b06      	cmp	r3, #6
90009cec:	d115      	bne.n	90009d1a <dhcp_recv+0x34a>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
90009cee:	9b02      	ldr	r3, [sp, #8]
90009cf0:	795b      	ldrb	r3, [r3, #5]
  else if ((msg_type == DHCP_NAK) &&
90009cf2:	1eda      	subs	r2, r3, #3
90009cf4:	2a02      	cmp	r2, #2
90009cf6:	d902      	bls.n	90009cfe <dhcp_recv+0x32e>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
90009cf8:	2b01      	cmp	r3, #1
90009cfa:	f47f aeb5 	bne.w	90009a68 <dhcp_recv+0x98>
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
90009cfe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
90009d00:	210c      	movs	r1, #12
90009d02:	f7ff fa42 	bl	9000918a <dhcp_set_state>
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
90009d06:	4b60      	ldr	r3, [pc, #384]	; (90009e88 <dhcp_recv+0x4b8>)
90009d08:	4638      	mov	r0, r7
90009d0a:	461a      	mov	r2, r3
90009d0c:	4619      	mov	r1, r3
90009d0e:	f002 fd29 	bl	9000c764 <netif_set_addr>
  dhcp_discover(netif);
90009d12:	4638      	mov	r0, r7
90009d14:	f7ff fb6c 	bl	900093f0 <dhcp_discover>
}
90009d18:	e6a6      	b.n	90009a68 <dhcp_recv+0x98>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
90009d1a:	2b02      	cmp	r3, #2
90009d1c:	f47f aea4 	bne.w	90009a68 <dhcp_recv+0x98>
90009d20:	9b02      	ldr	r3, [sp, #8]
90009d22:	795b      	ldrb	r3, [r3, #5]
90009d24:	2b06      	cmp	r3, #6
90009d26:	f47f ae9f 	bne.w	90009a68 <dhcp_recv+0x98>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
90009d2a:	f89a 3002 	ldrb.w	r3, [sl, #2]
90009d2e:	2b00      	cmp	r3, #0
90009d30:	f43f ae9a 	beq.w	90009a68 <dhcp_recv+0x98>
  struct dhcp *dhcp = netif_dhcp_data(netif);
90009d34:	6abc      	ldr	r4, [r7, #40]	; 0x28
    dhcp->request_timeout = 0; /* stop timer */
90009d36:	9b04      	ldr	r3, [sp, #16]
    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
90009d38:	6890      	ldr	r0, [r2, #8]
    dhcp->request_timeout = 0; /* stop timer */
90009d3a:	8123      	strh	r3, [r4, #8]
    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
90009d3c:	9102      	str	r1, [sp, #8]
90009d3e:	f7ff fa22 	bl	90009186 <lwip_htonl>
    ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
90009d42:	9902      	ldr	r1, [sp, #8]
    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
90009d44:	61a0      	str	r0, [r4, #24]
    dhcp_select(netif);
90009d46:	4638      	mov	r0, r7
    ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
90009d48:	690b      	ldr	r3, [r1, #16]
90009d4a:	61e3      	str	r3, [r4, #28]
    dhcp_select(netif);
90009d4c:	f7ff fd8e 	bl	9000986c <dhcp_select.isra.0>
90009d50:	e68a      	b.n	90009a68 <dhcp_recv+0x98>
    switch (op) {
90009d52:	2a3b      	cmp	r2, #59	; 0x3b
90009d54:	d80a      	bhi.n	90009d6c <dhcp_recv+0x39c>
90009d56:	2a32      	cmp	r2, #50	; 0x32
90009d58:	d80d      	bhi.n	90009d76 <dhcp_recv+0x3a6>
90009d5a:	2a03      	cmp	r2, #3
90009d5c:	f43f aec4 	beq.w	90009ae8 <dhcp_recv+0x118>
90009d60:	2a06      	cmp	r2, #6
90009d62:	f43f aec6 	beq.w	90009af2 <dhcp_recv+0x122>
90009d66:	2a01      	cmp	r2, #1
90009d68:	f43f aeb6 	beq.w	90009ad8 <dhcp_recv+0x108>
90009d6c:	2400      	movs	r4, #0
90009d6e:	f04f 35ff 	mov.w	r5, #4294967295
90009d72:	4623      	mov	r3, r4
90009d74:	e705      	b.n	90009b82 <dhcp_recv+0x1b2>
90009d76:	f1a2 0333 	sub.w	r3, r2, #51	; 0x33
90009d7a:	2b08      	cmp	r3, #8
90009d7c:	d8f6      	bhi.n	90009d6c <dhcp_recv+0x39c>
90009d7e:	a101      	add	r1, pc, #4	; (adr r1, 90009d84 <dhcp_recv+0x3b4>)
90009d80:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
90009d84:	90009b21 	.word	0x90009b21
90009d88:	90009b2d 	.word	0x90009b2d
90009d8c:	90009b4f 	.word	0x90009b4f
90009d90:	90009b5d 	.word	0x90009b5d
90009d94:	90009d6d 	.word	0x90009d6d
90009d98:	90009d6d 	.word	0x90009d6d
90009d9c:	90009d6d 	.word	0x90009d6d
90009da0:	90009b6b 	.word	0x90009b6b
90009da4:	90009b79 	.word	0x90009b79
90009da8:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
90009daa:	2506      	movs	r5, #6
      if (offset + len + 2 > 0xFFFF) {
90009dac:	441e      	add	r6, r3
90009dae:	f64f 72fd 	movw	r2, #65533	; 0xfffd
90009db2:	4296      	cmp	r6, r2
90009db4:	f73f ae58 	bgt.w	90009a68 <dhcp_recv+0x98>
      offset = (u16_t)(offset + len + 2);
90009db8:	9a03      	ldr	r2, [sp, #12]
90009dba:	4413      	add	r3, r2
90009dbc:	b29e      	uxth	r6, r3
      if (decode_len > 0) {
90009dbe:	2c00      	cmp	r4, #0
90009dc0:	f43f aee4 	beq.w	90009b8c <dhcp_recv+0x1bc>
        u32_t value = 0;
90009dc4:	2300      	movs	r3, #0
90009dc6:	9309      	str	r3, [sp, #36]	; 0x24
90009dc8:	eb0a 0305 	add.w	r3, sl, r5
90009dcc:	9306      	str	r3, [sp, #24]
        LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
90009dce:	2d09      	cmp	r5, #9
90009dd0:	d906      	bls.n	90009de0 <dhcp_recv+0x410>
90009dd2:	4b2e      	ldr	r3, [pc, #184]	; (90009e8c <dhcp_recv+0x4bc>)
90009dd4:	f44f 62cf 	mov.w	r2, #1656	; 0x678
90009dd8:	492d      	ldr	r1, [pc, #180]	; (90009e90 <dhcp_recv+0x4c0>)
90009dda:	482e      	ldr	r0, [pc, #184]	; (90009e94 <dhcp_recv+0x4c4>)
90009ddc:	f007 fee6 	bl	90011bac <iprintf>
        if (!dhcp_option_given(dhcp, decode_idx)) {
90009de0:	9b06      	ldr	r3, [sp, #24]
90009de2:	781b      	ldrb	r3, [r3, #0]
90009de4:	2b00      	cmp	r3, #0
90009de6:	f47f aed1 	bne.w	90009b8c <dhcp_recv+0x1bc>
          copy_len = LWIP_MIN(decode_len, 4);
90009dea:	2c04      	cmp	r4, #4
90009dec:	4622      	mov	r2, r4
          if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
90009dee:	9b03      	ldr	r3, [sp, #12]
90009df0:	a909      	add	r1, sp, #36	; 0x24
          copy_len = LWIP_MIN(decode_len, 4);
90009df2:	bf28      	it	cs
90009df4:	2204      	movcs	r2, #4
          if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
90009df6:	4640      	mov	r0, r8
90009df8:	9207      	str	r2, [sp, #28]
90009dfa:	f003 f98d 	bl	9000d118 <pbuf_copy_partial>
90009dfe:	9a07      	ldr	r2, [sp, #28]
90009e00:	4282      	cmp	r2, r0
90009e02:	f47f ae31 	bne.w	90009a68 <dhcp_recv+0x98>
          if (decode_len > 4) {
90009e06:	2c04      	cmp	r4, #4
90009e08:	f67f aef2 	bls.w	90009bf0 <dhcp_recv+0x220>
            LWIP_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
90009e0c:	07a2      	lsls	r2, r4, #30
90009e0e:	f43f aed8 	beq.w	90009bc2 <dhcp_recv+0x1f2>
90009e12:	4b1e      	ldr	r3, [pc, #120]	; (90009e8c <dhcp_recv+0x4bc>)
90009e14:	f240 6281 	movw	r2, #1665	; 0x681
90009e18:	491f      	ldr	r1, [pc, #124]	; (90009e98 <dhcp_recv+0x4c8>)
90009e1a:	e670      	b.n	90009afe <dhcp_recv+0x12e>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
90009e1c:	2507      	movs	r5, #7
        decode_len = 4; /* only copy the first given router */
90009e1e:	2404      	movs	r4, #4
90009e20:	e7c4      	b.n	90009dac <dhcp_recv+0x3dc>
90009e22:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
90009e24:	2503      	movs	r5, #3
90009e26:	e7c1      	b.n	90009dac <dhcp_recv+0x3dc>
    decode_len = len;
90009e28:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
90009e2a:	2500      	movs	r5, #0
90009e2c:	e7be      	b.n	90009dac <dhcp_recv+0x3dc>
90009e2e:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
90009e30:	2502      	movs	r5, #2
90009e32:	e7bb      	b.n	90009dac <dhcp_recv+0x3dc>
90009e34:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_T1;
90009e36:	461d      	mov	r5, r3
90009e38:	e7b8      	b.n	90009dac <dhcp_recv+0x3dc>
90009e3a:	461c      	mov	r4, r3
        decode_idx = DHCP_OPTION_IDX_T2;
90009e3c:	2505      	movs	r5, #5
    if (op == DHCP_OPTION_PAD) {
90009e3e:	e7b5      	b.n	90009dac <dhcp_recv+0x3dc>
    switch (op) {
90009e40:	2908      	cmp	r1, #8
90009e42:	f63f aeba 	bhi.w	90009bba <dhcp_recv+0x1ea>
90009e46:	a001      	add	r0, pc, #4	; (adr r0, 90009e4c <dhcp_recv+0x47c>)
90009e48:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
90009e4c:	90009b1b 	.word	0x90009b1b
90009e50:	90009b29 	.word	0x90009b29
90009e54:	90009b49 	.word	0x90009b49
90009e58:	90009b57 	.word	0x90009b57
90009e5c:	90009bbb 	.word	0x90009bbb
90009e60:	90009bbb 	.word	0x90009bbb
90009e64:	90009bbb 	.word	0x90009bbb
90009e68:	90009b65 	.word	0x90009b65
90009e6c:	90009b73 	.word	0x90009b73
90009e70:	f1a2 0133 	sub.w	r1, r2, #51	; 0x33
90009e74:	b2c8      	uxtb	r0, r1
90009e76:	2808      	cmp	r0, #8
90009e78:	d9e2      	bls.n	90009e40 <dhcp_recv+0x470>
90009e7a:	f04f 35ff 	mov.w	r5, #4294967295
90009e7e:	2400      	movs	r4, #0
90009e80:	e794      	b.n	90009dac <dhcp_recv+0x3dc>
90009e82:	bf00      	nop
90009e84:	24009b40 	.word	0x24009b40
90009e88:	90013a68 	.word	0x90013a68
90009e8c:	90013361 	.word	0x90013361
90009e90:	900135f0 	.word	0x900135f0
90009e94:	90012aff 	.word	0x90012aff
90009e98:	90013601 	.word	0x90013601

90009e9c <dhcp_network_changed>:
{
90009e9c:	b538      	push	{r3, r4, r5, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
90009e9e:	6a85      	ldr	r5, [r0, #40]	; 0x28
{
90009ea0:	4604      	mov	r4, r0
  if (!dhcp) {
90009ea2:	b1fd      	cbz	r5, 90009ee4 <dhcp_network_changed+0x48>
  switch (dhcp->state) {
90009ea4:	796b      	ldrb	r3, [r5, #5]
90009ea6:	2b05      	cmp	r3, #5
90009ea8:	d809      	bhi.n	90009ebe <dhcp_network_changed+0x22>
90009eaa:	2b02      	cmp	r3, #2
90009eac:	d809      	bhi.n	90009ec2 <dhcp_network_changed+0x26>
90009eae:	b1cb      	cbz	r3, 90009ee4 <dhcp_network_changed+0x48>
      dhcp->tries = 0;
90009eb0:	2300      	movs	r3, #0
      dhcp_discover(netif);
90009eb2:	4620      	mov	r0, r4
      dhcp->tries = 0;
90009eb4:	71ab      	strb	r3, [r5, #6]
}
90009eb6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      dhcp_discover(netif);
90009eba:	f7ff ba99 	b.w	900093f0 <dhcp_discover>
  switch (dhcp->state) {
90009ebe:	2b0a      	cmp	r3, #10
90009ec0:	d106      	bne.n	90009ed0 <dhcp_network_changed+0x34>
      dhcp->tries = 0;
90009ec2:	2300      	movs	r3, #0
      dhcp_reboot(netif);
90009ec4:	4620      	mov	r0, r4
      dhcp->tries = 0;
90009ec6:	71ab      	strb	r3, [r5, #6]
}
90009ec8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      dhcp_reboot(netif);
90009ecc:	f7ff bc00 	b.w	900096d0 <dhcp_reboot.isra.0>
      LWIP_ASSERT("invalid dhcp->state", dhcp->state <= DHCP_STATE_BACKING_OFF);
90009ed0:	2b0c      	cmp	r3, #12
90009ed2:	d9ed      	bls.n	90009eb0 <dhcp_network_changed+0x14>
90009ed4:	4b04      	ldr	r3, [pc, #16]	; (90009ee8 <dhcp_network_changed+0x4c>)
90009ed6:	f240 326d 	movw	r2, #877	; 0x36d
90009eda:	4904      	ldr	r1, [pc, #16]	; (90009eec <dhcp_network_changed+0x50>)
90009edc:	4804      	ldr	r0, [pc, #16]	; (90009ef0 <dhcp_network_changed+0x54>)
90009ede:	f007 fe65 	bl	90011bac <iprintf>
90009ee2:	e7e5      	b.n	90009eb0 <dhcp_network_changed+0x14>
}
90009ee4:	bd38      	pop	{r3, r4, r5, pc}
90009ee6:	bf00      	nop
90009ee8:	90013361 	.word	0x90013361
90009eec:	90013660 	.word	0x90013660
90009ef0:	90012aff 	.word	0x90012aff

90009ef4 <dhcp_arp_reply>:
{
90009ef4:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
90009ef6:	4606      	mov	r6, r0
{
90009ef8:	b087      	sub	sp, #28
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
90009efa:	b948      	cbnz	r0, 90009f10 <dhcp_arp_reply+0x1c>
90009efc:	4b28      	ldr	r3, [pc, #160]	; (90009fa0 <dhcp_arp_reply+0xac>)
90009efe:	f240 328b 	movw	r2, #907	; 0x38b
90009f02:	4928      	ldr	r1, [pc, #160]	; (90009fa4 <dhcp_arp_reply+0xb0>)
90009f04:	4828      	ldr	r0, [pc, #160]	; (90009fa8 <dhcp_arp_reply+0xb4>)
}
90009f06:	b007      	add	sp, #28
90009f08:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
90009f0c:	f007 be4e 	b.w	90011bac <iprintf>
  dhcp = netif_dhcp_data(netif);
90009f10:	6a84      	ldr	r4, [r0, #40]	; 0x28
  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
90009f12:	2c00      	cmp	r4, #0
90009f14:	d041      	beq.n	90009f9a <dhcp_arp_reply+0xa6>
90009f16:	7963      	ldrb	r3, [r4, #5]
90009f18:	2b08      	cmp	r3, #8
90009f1a:	d13e      	bne.n	90009f9a <dhcp_arp_reply+0xa6>
    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
90009f1c:	680a      	ldr	r2, [r1, #0]
90009f1e:	69e3      	ldr	r3, [r4, #28]
90009f20:	429a      	cmp	r2, r3
90009f22:	d13a      	bne.n	90009f9a <dhcp_arp_reply+0xa6>
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
90009f24:	210c      	movs	r1, #12
90009f26:	4620      	mov	r0, r4
90009f28:	f7ff f92f 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
90009f2c:	2204      	movs	r2, #4
90009f2e:	f10d 0316 	add.w	r3, sp, #22
90009f32:	4621      	mov	r1, r4
90009f34:	4630      	mov	r0, r6
90009f36:	f7ff f9a7 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
90009f3a:	4605      	mov	r5, r0
90009f3c:	b330      	cbz	r0, 90009f8c <dhcp_arp_reply+0x98>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
90009f3e:	6841      	ldr	r1, [r0, #4]
90009f40:	2304      	movs	r3, #4
90009f42:	2232      	movs	r2, #50	; 0x32
90009f44:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90009f48:	31f0      	adds	r1, #240	; 0xf0
90009f4a:	9103      	str	r1, [sp, #12]
90009f4c:	f7ff f942 	bl	900091d4 <dhcp_option>
90009f50:	4607      	mov	r7, r0
90009f52:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
90009f56:	69e0      	ldr	r0, [r4, #28]
90009f58:	f7ff f915 	bl	90009186 <lwip_htonl>
90009f5c:	9903      	ldr	r1, [sp, #12]
90009f5e:	4602      	mov	r2, r0
90009f60:	4638      	mov	r0, r7
90009f62:	f7ff f96d 	bl	90009240 <dhcp_option_long>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
90009f66:	462a      	mov	r2, r5
90009f68:	9903      	ldr	r1, [sp, #12]
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
90009f6a:	f8ad 0016 	strh.w	r0, [sp, #22]
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
90009f6e:	f7ff fa1f 	bl	900093b0 <dhcp_option_trailer>
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
90009f72:	4b0e      	ldr	r3, [pc, #56]	; (90009fac <dhcp_arp_reply+0xb8>)
90009f74:	4629      	mov	r1, r5
90009f76:	480e      	ldr	r0, [pc, #56]	; (90009fb0 <dhcp_arp_reply+0xbc>)
90009f78:	4a0e      	ldr	r2, [pc, #56]	; (90009fb4 <dhcp_arp_reply+0xc0>)
90009f7a:	e9cd 6300 	strd	r6, r3, [sp]
90009f7e:	2343      	movs	r3, #67	; 0x43
90009f80:	6800      	ldr	r0, [r0, #0]
90009f82:	f007 fb35 	bl	900115f0 <udp_sendto_if_src>
    pbuf_free(p_out);
90009f86:	4628      	mov	r0, r5
90009f88:	f002 fe8a 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
90009f8c:	79a3      	ldrb	r3, [r4, #6]
90009f8e:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
90009f90:	bf1c      	itt	ne
90009f92:	3301      	addne	r3, #1
90009f94:	71a3      	strbne	r3, [r4, #6]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
90009f96:	2314      	movs	r3, #20
90009f98:	8123      	strh	r3, [r4, #8]
}
90009f9a:	b007      	add	sp, #28
90009f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
90009f9e:	bf00      	nop
90009fa0:	90013361 	.word	0x90013361
90009fa4:	90013511 	.word	0x90013511
90009fa8:	90012aff 	.word	0x90012aff
90009fac:	90013a68 	.word	0x90013a68
90009fb0:	24009b30 	.word	0x24009b30
90009fb4:	90013a6c 	.word	0x90013a6c

90009fb8 <dhcp_renew>:
{
90009fb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
90009fbc:	6a84      	ldr	r4, [r0, #40]	; 0x28
{
90009fbe:	b086      	sub	sp, #24
90009fc0:	4606      	mov	r6, r0
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
90009fc2:	2105      	movs	r1, #5
90009fc4:	4620      	mov	r0, r4
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
90009fc6:	2203      	movs	r2, #3
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
90009fc8:	f7ff f8df 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
90009fcc:	f10d 0316 	add.w	r3, sp, #22
90009fd0:	4621      	mov	r1, r4
90009fd2:	4630      	mov	r0, r6
90009fd4:	f7ff f958 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
90009fd8:	4605      	mov	r5, r0
90009fda:	2800      	cmp	r0, #0
90009fdc:	d056      	beq.n	9000a08c <dhcp_renew+0xd4>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
90009fde:	6841      	ldr	r1, [r0, #4]
90009fe0:	2302      	movs	r3, #2
90009fe2:	2239      	movs	r2, #57	; 0x39
90009fe4:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90009fe8:	31f0      	adds	r1, #240	; 0xf0
90009fea:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 9000a098 <dhcp_renew+0xe0>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
90009fee:	2704      	movs	r7, #4
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
90009ff0:	9103      	str	r1, [sp, #12]
90009ff2:	f7ff f8ef 	bl	900091d4 <dhcp_option>
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
90009ff6:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
90009ff8:	9903      	ldr	r1, [sp, #12]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
90009ffa:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
90009ffe:	f7ff f8cd 	bl	9000919c <dhcp_option_short>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000a002:	9903      	ldr	r1, [sp, #12]
9000a004:	2304      	movs	r3, #4
9000a006:	2237      	movs	r2, #55	; 0x37
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
9000a008:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000a00c:	f7ff f8e2 	bl	900091d4 <dhcp_option>
9000a010:	9903      	ldr	r1, [sp, #12]
9000a012:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a016:	3f01      	subs	r7, #1
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000a018:	f818 2b01 	ldrb.w	r2, [r8], #1
9000a01c:	f8bd 0016 	ldrh.w	r0, [sp, #22]
9000a020:	9103      	str	r1, [sp, #12]
9000a022:	f7ff f8f5 	bl	90009210 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a026:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
9000a02a:	9903      	ldr	r1, [sp, #12]
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000a02c:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a030:	d1f1      	bne.n	9000a016 <dhcp_renew+0x5e>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
9000a032:	462a      	mov	r2, r5
9000a034:	f7ff f9bc 	bl	900093b0 <dhcp_option_trailer>
    result = udp_sendto_if(dhcp_pcb, p_out, &dhcp->server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
9000a038:	4816      	ldr	r0, [pc, #88]	; (9000a094 <dhcp_renew+0xdc>)
9000a03a:	9600      	str	r6, [sp, #0]
9000a03c:	2343      	movs	r3, #67	; 0x43
9000a03e:	f104 0218 	add.w	r2, r4, #24
9000a042:	4629      	mov	r1, r5
9000a044:	6800      	ldr	r0, [r0, #0]
9000a046:	f007 fb6b 	bl	90011720 <udp_sendto_if>
9000a04a:	4606      	mov	r6, r0
    pbuf_free(p_out);
9000a04c:	4628      	mov	r0, r5
9000a04e:	f002 fe27 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
9000a052:	79a3      	ldrb	r3, [r4, #6]
}
9000a054:	4630      	mov	r0, r6
  if (dhcp->tries < 255) {
9000a056:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
9000a058:	bf1c      	itt	ne
9000a05a:	3301      	addne	r3, #1
9000a05c:	71a3      	strbne	r3, [r4, #6]
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
9000a05e:	79a3      	ldrb	r3, [r4, #6]
9000a060:	2b09      	cmp	r3, #9
9000a062:	bf96      	itet	ls
9000a064:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
9000a068:	f644 6320 	movwhi	r3, #20000	; 0x4e20
9000a06c:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000a070:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
9000a074:	bf9c      	itt	ls
9000a076:	011b      	lslls	r3, r3, #4
9000a078:	b29b      	uxthls	r3, r3
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000a07a:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
9000a07e:	b29b      	uxth	r3, r3
9000a080:	fbb3 f3f2 	udiv	r3, r3, r2
9000a084:	8123      	strh	r3, [r4, #8]
}
9000a086:	b006      	add	sp, #24
9000a088:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    result = ERR_MEM;
9000a08c:	f04f 36ff 	mov.w	r6, #4294967295
9000a090:	e7df      	b.n	9000a052 <dhcp_renew+0x9a>
9000a092:	bf00      	nop
9000a094:	24009b30 	.word	0x24009b30
9000a098:	90013695 	.word	0x90013695

9000a09c <dhcp_supplied_address>:
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
9000a09c:	b150      	cbz	r0, 9000a0b4 <dhcp_supplied_address+0x18>
9000a09e:	6a80      	ldr	r0, [r0, #40]	; 0x28
9000a0a0:	b140      	cbz	r0, 9000a0b4 <dhcp_supplied_address+0x18>
    struct dhcp *dhcp = netif_dhcp_data(netif);
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
9000a0a2:	7940      	ldrb	r0, [r0, #5]
9000a0a4:	280a      	cmp	r0, #10
9000a0a6:	d006      	beq.n	9000a0b6 <dhcp_supplied_address+0x1a>
9000a0a8:	3804      	subs	r0, #4
9000a0aa:	2801      	cmp	r0, #1
9000a0ac:	bf8c      	ite	hi
9000a0ae:	2000      	movhi	r0, #0
9000a0b0:	2001      	movls	r0, #1
9000a0b2:	b2c0      	uxtb	r0, r0
           (dhcp->state == DHCP_STATE_REBINDING);
  }
  return 0;
}
9000a0b4:	4770      	bx	lr
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
9000a0b6:	2001      	movs	r0, #1
9000a0b8:	e7fb      	b.n	9000a0b2 <dhcp_supplied_address+0x16>
	...

9000a0bc <dhcp_release_and_stop>:
{
9000a0bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct dhcp *dhcp = netif_dhcp_data(netif);
9000a0be:	6a84      	ldr	r4, [r0, #40]	; 0x28
{
9000a0c0:	b087      	sub	sp, #28
9000a0c2:	4606      	mov	r6, r0
  if (dhcp == NULL) {
9000a0c4:	2c00      	cmp	r4, #0
9000a0c6:	d050      	beq.n	9000a16a <dhcp_release_and_stop+0xae>
  if (dhcp->state == DHCP_STATE_OFF) {
9000a0c8:	7963      	ldrb	r3, [r4, #5]
9000a0ca:	2b00      	cmp	r3, #0
9000a0cc:	d04d      	beq.n	9000a16a <dhcp_release_and_stop+0xae>
  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
9000a0ce:	69a3      	ldr	r3, [r4, #24]
9000a0d0:	9305      	str	r3, [sp, #20]
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
9000a0d2:	2300      	movs	r3, #0
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
9000a0d4:	e9c4 3306 	strd	r3, r3, [r4, #24]
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
9000a0d8:	e9c4 3308 	strd	r3, r3, [r4, #32]
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
9000a0dc:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
9000a0e0:	62a3      	str	r3, [r4, #40]	; 0x28
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
9000a0e2:	81e3      	strh	r3, [r4, #14]
9000a0e4:	6123      	str	r3, [r4, #16]
9000a0e6:	82a3      	strh	r3, [r4, #20]
  if (dhcp_supplied_address(netif)) {
9000a0e8:	f7ff ffd8 	bl	9000a09c <dhcp_supplied_address>
9000a0ec:	b368      	cbz	r0, 9000a14a <dhcp_release_and_stop+0x8e>
    p_out = dhcp_create_msg(netif, dhcp, DHCP_RELEASE, &options_out_len);
9000a0ee:	f10d 0312 	add.w	r3, sp, #18
9000a0f2:	2207      	movs	r2, #7
9000a0f4:	4621      	mov	r1, r4
9000a0f6:	4630      	mov	r0, r6
9000a0f8:	f7ff f8c6 	bl	90009288 <dhcp_create_msg>
    if (p_out != NULL) {
9000a0fc:	4605      	mov	r5, r0
9000a0fe:	b320      	cbz	r0, 9000a14a <dhcp_release_and_stop+0x8e>
      options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
9000a100:	6841      	ldr	r1, [r0, #4]
9000a102:	2304      	movs	r3, #4
9000a104:	2236      	movs	r2, #54	; 0x36
9000a106:	f8bd 0012 	ldrh.w	r0, [sp, #18]
9000a10a:	31f0      	adds	r1, #240	; 0xf0
9000a10c:	9103      	str	r1, [sp, #12]
9000a10e:	f7ff f861 	bl	900091d4 <dhcp_option>
9000a112:	4607      	mov	r7, r0
9000a114:	f8ad 0012 	strh.w	r0, [sp, #18]
      options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
9000a118:	9805      	ldr	r0, [sp, #20]
9000a11a:	f7ff f834 	bl	90009186 <lwip_htonl>
9000a11e:	9903      	ldr	r1, [sp, #12]
9000a120:	4602      	mov	r2, r0
9000a122:	4638      	mov	r0, r7
9000a124:	f7ff f88c 	bl	90009240 <dhcp_option_long>
      dhcp_option_trailer(options_out_len, msg_out->options, p_out);
9000a128:	462a      	mov	r2, r5
9000a12a:	9903      	ldr	r1, [sp, #12]
      options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
9000a12c:	f8ad 0012 	strh.w	r0, [sp, #18]
      dhcp_option_trailer(options_out_len, msg_out->options, p_out);
9000a130:	f7ff f93e 	bl	900093b0 <dhcp_option_trailer>
      udp_sendto_if(dhcp_pcb, p_out, &server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
9000a134:	480e      	ldr	r0, [pc, #56]	; (9000a170 <dhcp_release_and_stop+0xb4>)
9000a136:	2343      	movs	r3, #67	; 0x43
9000a138:	9600      	str	r6, [sp, #0]
9000a13a:	aa05      	add	r2, sp, #20
9000a13c:	4629      	mov	r1, r5
9000a13e:	6800      	ldr	r0, [r0, #0]
9000a140:	f007 faee 	bl	90011720 <udp_sendto_if>
      pbuf_free(p_out);
9000a144:	4628      	mov	r0, r5
9000a146:	f002 fdab 	bl	9000cca0 <pbuf_free>
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
9000a14a:	4b0a      	ldr	r3, [pc, #40]	; (9000a174 <dhcp_release_and_stop+0xb8>)
9000a14c:	4630      	mov	r0, r6
9000a14e:	4619      	mov	r1, r3
9000a150:	461a      	mov	r2, r3
9000a152:	f002 fb07 	bl	9000c764 <netif_set_addr>
  dhcp_set_state(dhcp, DHCP_STATE_OFF);
9000a156:	2100      	movs	r1, #0
9000a158:	4620      	mov	r0, r4
9000a15a:	f7ff f816 	bl	9000918a <dhcp_set_state>
  if (dhcp->pcb_allocated != 0) {
9000a15e:	7923      	ldrb	r3, [r4, #4]
9000a160:	b11b      	cbz	r3, 9000a16a <dhcp_release_and_stop+0xae>
    dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
9000a162:	f7ff fa95 	bl	90009690 <dhcp_dec_pcb_refcount>
    dhcp->pcb_allocated = 0;
9000a166:	2300      	movs	r3, #0
9000a168:	7123      	strb	r3, [r4, #4]
}
9000a16a:	b007      	add	sp, #28
9000a16c:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000a16e:	bf00      	nop
9000a170:	24009b30 	.word	0x24009b30
9000a174:	90013a68 	.word	0x90013a68

9000a178 <dhcp_start>:
{
9000a178:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
9000a17a:	4604      	mov	r4, r0
9000a17c:	b950      	cbnz	r0, 9000a194 <dhcp_start+0x1c>
9000a17e:	4b24      	ldr	r3, [pc, #144]	; (9000a210 <dhcp_start+0x98>)
9000a180:	f240 22e7 	movw	r2, #743	; 0x2e7
9000a184:	4923      	ldr	r1, [pc, #140]	; (9000a214 <dhcp_start+0x9c>)
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
9000a186:	4824      	ldr	r0, [pc, #144]	; (9000a218 <dhcp_start+0xa0>)
9000a188:	f007 fd10 	bl	90011bac <iprintf>
9000a18c:	f06f 020f 	mvn.w	r2, #15
}
9000a190:	4610      	mov	r0, r2
9000a192:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
9000a194:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
9000a198:	07da      	lsls	r2, r3, #31
9000a19a:	d404      	bmi.n	9000a1a6 <dhcp_start+0x2e>
9000a19c:	4b1c      	ldr	r3, [pc, #112]	; (9000a210 <dhcp_start+0x98>)
9000a19e:	f44f 723a 	mov.w	r2, #744	; 0x2e8
9000a1a2:	491e      	ldr	r1, [pc, #120]	; (9000a21c <dhcp_start+0xa4>)
9000a1a4:	e7ef      	b.n	9000a186 <dhcp_start+0xe>
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
9000a1a6:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
  dhcp = netif_dhcp_data(netif);
9000a1a8:	6a85      	ldr	r5, [r0, #40]	; 0x28
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
9000a1aa:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
9000a1ae:	d202      	bcs.n	9000a1b6 <dhcp_start+0x3e>
    return ERR_MEM;
9000a1b0:	f04f 32ff 	mov.w	r2, #4294967295
9000a1b4:	e7ec      	b.n	9000a190 <dhcp_start+0x18>
  if (dhcp == NULL) {
9000a1b6:	b9dd      	cbnz	r5, 9000a1f0 <dhcp_start+0x78>
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
9000a1b8:	2034      	movs	r0, #52	; 0x34
9000a1ba:	f002 f805 	bl	9000c1c8 <mem_malloc>
    if (dhcp == NULL) {
9000a1be:	4605      	mov	r5, r0
9000a1c0:	2800      	cmp	r0, #0
9000a1c2:	d0f5      	beq.n	9000a1b0 <dhcp_start+0x38>
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
9000a1c4:	62a0      	str	r0, [r4, #40]	; 0x28
  memset(dhcp, 0, sizeof(struct dhcp));
9000a1c6:	2234      	movs	r2, #52	; 0x34
9000a1c8:	2100      	movs	r1, #0
9000a1ca:	4628      	mov	r0, r5
9000a1cc:	f007 fc06 	bl	900119dc <memset>
  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
9000a1d0:	f7ff fa24 	bl	9000961c <dhcp_inc_pcb_refcount>
9000a1d4:	4602      	mov	r2, r0
9000a1d6:	2800      	cmp	r0, #0
9000a1d8:	d1ea      	bne.n	9000a1b0 <dhcp_start+0x38>
  dhcp->pcb_allocated = 1;
9000a1da:	2301      	movs	r3, #1
9000a1dc:	712b      	strb	r3, [r5, #4]
  if (!netif_is_link_up(netif)) {
9000a1de:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
9000a1e2:	075b      	lsls	r3, r3, #29
9000a1e4:	d40a      	bmi.n	9000a1fc <dhcp_start+0x84>
    dhcp_set_state(dhcp, DHCP_STATE_INIT);
9000a1e6:	2102      	movs	r1, #2
9000a1e8:	4628      	mov	r0, r5
9000a1ea:	f7fe ffce 	bl	9000918a <dhcp_set_state>
    return ERR_OK;
9000a1ee:	e7cf      	b.n	9000a190 <dhcp_start+0x18>
    if (dhcp->pcb_allocated != 0) {
9000a1f0:	792b      	ldrb	r3, [r5, #4]
9000a1f2:	2b00      	cmp	r3, #0
9000a1f4:	d0e7      	beq.n	9000a1c6 <dhcp_start+0x4e>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
9000a1f6:	f7ff fa4b 	bl	90009690 <dhcp_dec_pcb_refcount>
9000a1fa:	e7e4      	b.n	9000a1c6 <dhcp_start+0x4e>
  result = dhcp_discover(netif);
9000a1fc:	4620      	mov	r0, r4
9000a1fe:	f7ff f8f7 	bl	900093f0 <dhcp_discover>
  if (result != ERR_OK) {
9000a202:	4602      	mov	r2, r0
9000a204:	2800      	cmp	r0, #0
9000a206:	d0c3      	beq.n	9000a190 <dhcp_start+0x18>
    dhcp_release_and_stop(netif);
9000a208:	4620      	mov	r0, r4
9000a20a:	f7ff ff57 	bl	9000a0bc <dhcp_release_and_stop>
9000a20e:	e7cf      	b.n	9000a1b0 <dhcp_start+0x38>
9000a210:	90013361 	.word	0x90013361
9000a214:	90013511 	.word	0x90013511
9000a218:	90012aff 	.word	0x90012aff
9000a21c:	90013674 	.word	0x90013674

9000a220 <dhcp_coarse_tmr>:
  NETIF_FOREACH(netif) {
9000a220:	4b59      	ldr	r3, [pc, #356]	; (9000a388 <dhcp_coarse_tmr+0x168>)
{
9000a222:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  NETIF_FOREACH(netif) {
9000a226:	681d      	ldr	r5, [r3, #0]
{
9000a228:	b087      	sub	sp, #28
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
9000a22a:	f240 2619 	movw	r6, #537	; 0x219
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
9000a22e:	4f57      	ldr	r7, [pc, #348]	; (9000a38c <dhcp_coarse_tmr+0x16c>)
9000a230:	f8df 815c 	ldr.w	r8, [pc, #348]	; 9000a390 <dhcp_coarse_tmr+0x170>
  NETIF_FOREACH(netif) {
9000a234:	b915      	cbnz	r5, 9000a23c <dhcp_coarse_tmr+0x1c>
}
9000a236:	b007      	add	sp, #28
9000a238:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    struct dhcp *dhcp = netif_dhcp_data(netif);
9000a23c:	6aac      	ldr	r4, [r5, #40]	; 0x28
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
9000a23e:	b17c      	cbz	r4, 9000a260 <dhcp_coarse_tmr+0x40>
9000a240:	7963      	ldrb	r3, [r4, #5]
9000a242:	b16b      	cbz	r3, 9000a260 <dhcp_coarse_tmr+0x40>
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
9000a244:	8aa1      	ldrh	r1, [r4, #20]
9000a246:	b169      	cbz	r1, 9000a264 <dhcp_coarse_tmr+0x44>
9000a248:	8a62      	ldrh	r2, [r4, #18]
9000a24a:	3201      	adds	r2, #1
9000a24c:	b292      	uxth	r2, r2
9000a24e:	4291      	cmp	r1, r2
9000a250:	8262      	strh	r2, [r4, #18]
9000a252:	d107      	bne.n	9000a264 <dhcp_coarse_tmr+0x44>
        dhcp_release_and_stop(netif);
9000a254:	4628      	mov	r0, r5
9000a256:	f7ff ff31 	bl	9000a0bc <dhcp_release_and_stop>
        dhcp_start(netif);
9000a25a:	4628      	mov	r0, r5
9000a25c:	f7ff ff8c 	bl	9000a178 <dhcp_start>
  NETIF_FOREACH(netif) {
9000a260:	682d      	ldr	r5, [r5, #0]
9000a262:	e7e7      	b.n	9000a234 <dhcp_coarse_tmr+0x14>
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
9000a264:	8a22      	ldrh	r2, [r4, #16]
9000a266:	2a00      	cmp	r2, #0
9000a268:	d073      	beq.n	9000a352 <dhcp_coarse_tmr+0x132>
9000a26a:	1e51      	subs	r1, r2, #1
9000a26c:	2a01      	cmp	r2, #1
9000a26e:	8221      	strh	r1, [r4, #16]
9000a270:	d16f      	bne.n	9000a352 <dhcp_coarse_tmr+0x132>
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
9000a272:	3b01      	subs	r3, #1
9000a274:	b2db      	uxtb	r3, r3
9000a276:	2b09      	cmp	r3, #9
9000a278:	d8f2      	bhi.n	9000a260 <dhcp_coarse_tmr+0x40>
9000a27a:	fa26 f303 	lsr.w	r3, r6, r3
9000a27e:	07db      	lsls	r3, r3, #31
9000a280:	d5ee      	bpl.n	9000a260 <dhcp_coarse_tmr+0x40>
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
9000a282:	2104      	movs	r1, #4
9000a284:	4620      	mov	r0, r4
9000a286:	f7fe ff80 	bl	9000918a <dhcp_set_state>
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
9000a28a:	2203      	movs	r2, #3
9000a28c:	f10d 0316 	add.w	r3, sp, #22
9000a290:	4621      	mov	r1, r4
9000a292:	4628      	mov	r0, r5
9000a294:	f7fe fff8 	bl	90009288 <dhcp_create_msg>
  if (p_out != NULL) {
9000a298:	4681      	mov	r9, r0
9000a29a:	2800      	cmp	r0, #0
9000a29c:	d038      	beq.n	9000a310 <dhcp_coarse_tmr+0xf0>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
9000a29e:	6841      	ldr	r1, [r0, #4]
9000a2a0:	2302      	movs	r3, #2
9000a2a2:	2239      	movs	r2, #57	; 0x39
9000a2a4:	f8bd 0016 	ldrh.w	r0, [sp, #22]
9000a2a8:	31f0      	adds	r1, #240	; 0xf0
9000a2aa:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 9000a394 <dhcp_coarse_tmr+0x174>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000a2ae:	f04f 0a04 	mov.w	sl, #4
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
9000a2b2:	9103      	str	r1, [sp, #12]
9000a2b4:	f7fe ff8e 	bl	900091d4 <dhcp_option>
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
9000a2b8:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
9000a2ba:	9903      	ldr	r1, [sp, #12]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
9000a2bc:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
9000a2c0:	f7fe ff6c 	bl	9000919c <dhcp_option_short>
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000a2c4:	9903      	ldr	r1, [sp, #12]
9000a2c6:	2304      	movs	r3, #4
9000a2c8:	2237      	movs	r2, #55	; 0x37
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
9000a2ca:	f8ad 0016 	strh.w	r0, [sp, #22]
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
9000a2ce:	f7fe ff81 	bl	900091d4 <dhcp_option>
9000a2d2:	9903      	ldr	r1, [sp, #12]
9000a2d4:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a2d8:	f10a 3aff 	add.w	sl, sl, #4294967295
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000a2dc:	f81b 2b01 	ldrb.w	r2, [fp], #1
9000a2e0:	f8bd 0016 	ldrh.w	r0, [sp, #22]
9000a2e4:	9103      	str	r1, [sp, #12]
9000a2e6:	f7fe ff93 	bl	90009210 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a2ea:	f01a 0aff 	ands.w	sl, sl, #255	; 0xff
9000a2ee:	9903      	ldr	r1, [sp, #12]
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
9000a2f0:	f8ad 0016 	strh.w	r0, [sp, #22]
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
9000a2f4:	d1f0      	bne.n	9000a2d8 <dhcp_coarse_tmr+0xb8>
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
9000a2f6:	464a      	mov	r2, r9
9000a2f8:	f7ff f85a 	bl	900093b0 <dhcp_option_trailer>
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
9000a2fc:	2343      	movs	r3, #67	; 0x43
9000a2fe:	4642      	mov	r2, r8
9000a300:	4649      	mov	r1, r9
9000a302:	6838      	ldr	r0, [r7, #0]
9000a304:	9500      	str	r5, [sp, #0]
9000a306:	f007 fa0b 	bl	90011720 <udp_sendto_if>
    pbuf_free(p_out);
9000a30a:	4648      	mov	r0, r9
9000a30c:	f002 fcc8 	bl	9000cca0 <pbuf_free>
  if (dhcp->tries < 255) {
9000a310:	79a3      	ldrb	r3, [r4, #6]
9000a312:	2bff      	cmp	r3, #255	; 0xff
    dhcp->tries++;
9000a314:	bf1c      	itt	ne
9000a316:	3301      	addne	r3, #1
9000a318:	71a3      	strbne	r3, [r4, #6]
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
9000a31a:	79a3      	ldrb	r3, [r4, #6]
9000a31c:	2b09      	cmp	r3, #9
9000a31e:	bf96      	itet	ls
9000a320:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
9000a324:	f242 7310 	movwhi	r3, #10000	; 0x2710
9000a328:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000a32c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
9000a330:	bf9c      	itt	ls
9000a332:	00db      	lslls	r3, r3, #3
9000a334:	b29b      	uxthls	r3, r3
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000a336:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
9000a33a:	b29b      	uxth	r3, r3
9000a33c:	fbb3 f3f2 	udiv	r3, r3, r2
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
9000a340:	8a62      	ldrh	r2, [r4, #18]
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
9000a342:	8123      	strh	r3, [r4, #8]
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
9000a344:	8aa3      	ldrh	r3, [r4, #20]
9000a346:	1a9b      	subs	r3, r3, r2
9000a348:	2b01      	cmp	r3, #1
9000a34a:	dd89      	ble.n	9000a260 <dhcp_coarse_tmr+0x40>
      dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
9000a34c:	105b      	asrs	r3, r3, #1
9000a34e:	8223      	strh	r3, [r4, #16]
9000a350:	e786      	b.n	9000a260 <dhcp_coarse_tmr+0x40>
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
9000a352:	89e2      	ldrh	r2, [r4, #14]
9000a354:	2a00      	cmp	r2, #0
9000a356:	d083      	beq.n	9000a260 <dhcp_coarse_tmr+0x40>
9000a358:	1e51      	subs	r1, r2, #1
9000a35a:	2a01      	cmp	r2, #1
9000a35c:	81e1      	strh	r1, [r4, #14]
9000a35e:	f47f af7f 	bne.w	9000a260 <dhcp_coarse_tmr+0x40>
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
9000a362:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
9000a366:	2a01      	cmp	r2, #1
9000a368:	d002      	beq.n	9000a370 <dhcp_coarse_tmr+0x150>
9000a36a:	2b0a      	cmp	r3, #10
9000a36c:	f47f af78 	bne.w	9000a260 <dhcp_coarse_tmr+0x40>
    dhcp_renew(netif);
9000a370:	4628      	mov	r0, r5
9000a372:	f7ff fe21 	bl	90009fb8 <dhcp_renew>
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
9000a376:	89a3      	ldrh	r3, [r4, #12]
9000a378:	8a62      	ldrh	r2, [r4, #18]
9000a37a:	1a9b      	subs	r3, r3, r2
9000a37c:	2b01      	cmp	r3, #1
      dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
9000a37e:	bfc4      	itt	gt
9000a380:	105b      	asrgt	r3, r3, #1
9000a382:	81e3      	strhgt	r3, [r4, #14]
9000a384:	e76c      	b.n	9000a260 <dhcp_coarse_tmr+0x40>
9000a386:	bf00      	nop
9000a388:	2400d3a0 	.word	0x2400d3a0
9000a38c:	24009b30 	.word	0x24009b30
9000a390:	90013a6c 	.word	0x90013a6c
9000a394:	90013695 	.word	0x90013695

9000a398 <dhcp_fine_tmr>:
{
9000a398:	b538      	push	{r3, r4, r5, lr}
  NETIF_FOREACH(netif) {
9000a39a:	4b1e      	ldr	r3, [pc, #120]	; (9000a414 <dhcp_fine_tmr+0x7c>)
        dhcp->request_timeout--;
9000a39c:	2500      	movs	r5, #0
  NETIF_FOREACH(netif) {
9000a39e:	681c      	ldr	r4, [r3, #0]
9000a3a0:	b904      	cbnz	r4, 9000a3a4 <dhcp_fine_tmr+0xc>
}
9000a3a2:	bd38      	pop	{r3, r4, r5, pc}
    struct dhcp *dhcp = netif_dhcp_data(netif);
9000a3a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (dhcp != NULL) {
9000a3a6:	b123      	cbz	r3, 9000a3b2 <dhcp_fine_tmr+0x1a>
      if (dhcp->request_timeout > 1) {
9000a3a8:	891a      	ldrh	r2, [r3, #8]
9000a3aa:	2a01      	cmp	r2, #1
9000a3ac:	d903      	bls.n	9000a3b6 <dhcp_fine_tmr+0x1e>
        dhcp->request_timeout--;
9000a3ae:	3a01      	subs	r2, #1
9000a3b0:	811a      	strh	r2, [r3, #8]
  NETIF_FOREACH(netif) {
9000a3b2:	6824      	ldr	r4, [r4, #0]
9000a3b4:	e7f4      	b.n	9000a3a0 <dhcp_fine_tmr+0x8>
      } else if (dhcp->request_timeout == 1) {
9000a3b6:	d1fc      	bne.n	9000a3b2 <dhcp_fine_tmr+0x1a>
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
9000a3b8:	795a      	ldrb	r2, [r3, #5]
        dhcp->request_timeout--;
9000a3ba:	811d      	strh	r5, [r3, #8]
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
9000a3bc:	2a0c      	cmp	r2, #12
9000a3be:	d001      	beq.n	9000a3c4 <dhcp_fine_tmr+0x2c>
9000a3c0:	2a06      	cmp	r2, #6
9000a3c2:	d103      	bne.n	9000a3cc <dhcp_fine_tmr+0x34>
    dhcp_discover(netif);
9000a3c4:	4620      	mov	r0, r4
      dhcp_discover(netif);
9000a3c6:	f7ff f813 	bl	900093f0 <dhcp_discover>
9000a3ca:	e7f2      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
9000a3cc:	2a01      	cmp	r2, #1
9000a3ce:	d10c      	bne.n	9000a3ea <dhcp_fine_tmr+0x52>
    if (dhcp->tries <= 5) {
9000a3d0:	799b      	ldrb	r3, [r3, #6]
      dhcp_select(netif);
9000a3d2:	4620      	mov	r0, r4
    if (dhcp->tries <= 5) {
9000a3d4:	2b05      	cmp	r3, #5
9000a3d6:	d802      	bhi.n	9000a3de <dhcp_fine_tmr+0x46>
      dhcp_select(netif);
9000a3d8:	f7ff fa48 	bl	9000986c <dhcp_select.isra.0>
9000a3dc:	e7e9      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
      dhcp_release_and_stop(netif);
9000a3de:	f7ff fe6d 	bl	9000a0bc <dhcp_release_and_stop>
      dhcp_start(netif);
9000a3e2:	4620      	mov	r0, r4
9000a3e4:	f7ff fec8 	bl	9000a178 <dhcp_start>
9000a3e8:	e7e3      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
  } else if (dhcp->state == DHCP_STATE_CHECKING) {
9000a3ea:	2a08      	cmp	r2, #8
9000a3ec:	d109      	bne.n	9000a402 <dhcp_fine_tmr+0x6a>
    if (dhcp->tries <= 1) {
9000a3ee:	799b      	ldrb	r3, [r3, #6]
      dhcp_check(netif);
9000a3f0:	4620      	mov	r0, r4
    if (dhcp->tries <= 1) {
9000a3f2:	2b01      	cmp	r3, #1
9000a3f4:	d802      	bhi.n	9000a3fc <dhcp_fine_tmr+0x64>
      dhcp_check(netif);
9000a3f6:	f7ff f873 	bl	900094e0 <dhcp_check>
9000a3fa:	e7da      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
      dhcp_bind(netif);
9000a3fc:	f7ff f886 	bl	9000950c <dhcp_bind>
9000a400:	e7d7      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
9000a402:	2a03      	cmp	r2, #3
9000a404:	d1d5      	bne.n	9000a3b2 <dhcp_fine_tmr+0x1a>
    if (dhcp->tries < REBOOT_TRIES) {
9000a406:	799b      	ldrb	r3, [r3, #6]
      dhcp_reboot(netif);
9000a408:	4620      	mov	r0, r4
    if (dhcp->tries < REBOOT_TRIES) {
9000a40a:	2b01      	cmp	r3, #1
9000a40c:	d8db      	bhi.n	9000a3c6 <dhcp_fine_tmr+0x2e>
      dhcp_reboot(netif);
9000a40e:	f7ff f95f 	bl	900096d0 <dhcp_reboot.isra.0>
9000a412:	e7ce      	b.n	9000a3b2 <dhcp_fine_tmr+0x1a>
9000a414:	2400d3a0 	.word	0x2400d3a0

9000a418 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
9000a418:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
9000a41c:	4d23      	ldr	r5, [pc, #140]	; (9000a4ac <dns_call_found+0x94>)
9000a41e:	f44f 7788 	mov.w	r7, #272	; 0x110
9000a422:	4c23      	ldr	r4, [pc, #140]	; (9000a4b0 <dns_call_found+0x98>)
{
9000a424:	4606      	mov	r6, r0
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
9000a426:	fb07 5700 	mla	r7, r7, r0, r5
{
9000a42a:	468a      	mov	sl, r1
9000a42c:	f104 0830 	add.w	r8, r4, #48	; 0x30
      /* flush this entry */
      dns_requests[i].found = NULL;
9000a430:	f04f 0900 	mov.w	r9, #0
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
9000a434:	3710      	adds	r7, #16
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
9000a436:	6823      	ldr	r3, [r4, #0]
9000a438:	b143      	cbz	r3, 9000a44c <dns_call_found+0x34>
9000a43a:	7a22      	ldrb	r2, [r4, #8]
9000a43c:	42b2      	cmp	r2, r6
9000a43e:	d105      	bne.n	9000a44c <dns_call_found+0x34>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
9000a440:	6862      	ldr	r2, [r4, #4]
9000a442:	4651      	mov	r1, sl
9000a444:	4638      	mov	r0, r7
9000a446:	4798      	blx	r3
      dns_requests[i].found = NULL;
9000a448:	f8c4 9000 	str.w	r9, [r4]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
9000a44c:	340c      	adds	r4, #12
9000a44e:	4544      	cmp	r4, r8
9000a450:	d1f1      	bne.n	9000a436 <dns_call_found+0x1e>
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
    if (i == idx) {
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
9000a452:	f44f 7188 	mov.w	r1, #272	; 0x110
9000a456:	4a15      	ldr	r2, [pc, #84]	; (9000a4ac <dns_call_found+0x94>)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
9000a458:	2300      	movs	r3, #0
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
9000a45a:	fb01 5106 	mla	r1, r1, r6, r5
    if (i == idx) {
9000a45e:	b2d8      	uxtb	r0, r3
9000a460:	4286      	cmp	r6, r0
9000a462:	d01c      	beq.n	9000a49e <dns_call_found+0x86>
    if (dns_table[i].state == DNS_STATE_ASKING) {
9000a464:	7a90      	ldrb	r0, [r2, #10]
9000a466:	2802      	cmp	r0, #2
9000a468:	d119      	bne.n	9000a49e <dns_call_found+0x86>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
9000a46a:	7bd7      	ldrb	r7, [r2, #15]
9000a46c:	7bcc      	ldrb	r4, [r1, #15]
9000a46e:	42a7      	cmp	r7, r4
9000a470:	d115      	bne.n	9000a49e <dns_call_found+0x86>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
9000a472:	2304      	movs	r3, #4
9000a474:	73cb      	strb	r3, [r1, #15]
        break;
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
9000a476:	f44f 7088 	mov.w	r0, #272	; 0x110
9000a47a:	fb00 5506 	mla	r5, r0, r6, r5
9000a47e:	7beb      	ldrb	r3, [r5, #15]
9000a480:	2b03      	cmp	r3, #3
9000a482:	d80a      	bhi.n	9000a49a <dns_call_found+0x82>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
9000a484:	4c0b      	ldr	r4, [pc, #44]	; (9000a4b4 <dns_call_found+0x9c>)
9000a486:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
9000a48a:	f007 fa13 	bl	900118b4 <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
9000a48e:	7beb      	ldrb	r3, [r5, #15]
9000a490:	2200      	movs	r2, #0
9000a492:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
9000a496:	2304      	movs	r3, #4
9000a498:	73eb      	strb	r3, [r5, #15]
  }
#endif
}
9000a49a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
9000a49e:	3301      	adds	r3, #1
9000a4a0:	f502 7288 	add.w	r2, r2, #272	; 0x110
9000a4a4:	2b04      	cmp	r3, #4
9000a4a6:	d1da      	bne.n	9000a45e <dns_call_found+0x46>
9000a4a8:	e7e5      	b.n	9000a476 <dns_call_found+0x5e>
9000a4aa:	bf00      	nop
9000a4ac:	24009bb4 	.word	0x24009bb4
9000a4b0:	24009b7c 	.word	0x24009b7c
9000a4b4:	24009b6c 	.word	0x24009b6c

9000a4b8 <dns_send.isra.0>:
dns_send(u8_t idx)
9000a4b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
9000a4bc:	f44f 7388 	mov.w	r3, #272	; 0x110
9000a4c0:	4e49      	ldr	r6, [pc, #292]	; (9000a5e8 <dns_send.isra.0+0x130>)
dns_send(u8_t idx)
9000a4c2:	b087      	sub	sp, #28
9000a4c4:	4680      	mov	r8, r0
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
9000a4c6:	fb03 6300 	mla	r3, r3, r0, r6
9000a4ca:	7adb      	ldrb	r3, [r3, #11]
9000a4cc:	2b01      	cmp	r3, #1
9000a4ce:	d906      	bls.n	9000a4de <dns_send.isra.0+0x26>
9000a4d0:	4b46      	ldr	r3, [pc, #280]	; (9000a5ec <dns_send.isra.0+0x134>)
9000a4d2:	f240 22fa 	movw	r2, #762	; 0x2fa
9000a4d6:	4946      	ldr	r1, [pc, #280]	; (9000a5f0 <dns_send.isra.0+0x138>)
9000a4d8:	4846      	ldr	r0, [pc, #280]	; (9000a5f4 <dns_send.isra.0+0x13c>)
9000a4da:	f007 fb67 	bl	90011bac <iprintf>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
9000a4de:	f44f 7488 	mov.w	r4, #272	; 0x110
9000a4e2:	f8df a118 	ldr.w	sl, [pc, #280]	; 9000a5fc <dns_send.isra.0+0x144>
9000a4e6:	fb04 f408 	mul.w	r4, r4, r8
9000a4ea:	1937      	adds	r7, r6, r4
9000a4ec:	7afb      	ldrb	r3, [r7, #11]
9000a4ee:	f85a 5023 	ldr.w	r5, [sl, r3, lsl #2]
9000a4f2:	b93d      	cbnz	r5, 9000a504 <dns_send.isra.0+0x4c>
    dns_call_found(idx, NULL);
9000a4f4:	4629      	mov	r1, r5
9000a4f6:	4640      	mov	r0, r8
9000a4f8:	f7ff ff8e 	bl	9000a418 <dns_call_found>
    entry->state = DNS_STATE_UNUSED;
9000a4fc:	72bd      	strb	r5, [r7, #10]
}
9000a4fe:	b007      	add	sp, #28
9000a500:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
9000a504:	3410      	adds	r4, #16
9000a506:	4434      	add	r4, r6
9000a508:	4620      	mov	r0, r4
9000a50a:	f7f5 fee9 	bl	900002e0 <strlen>
9000a50e:	3012      	adds	r0, #18
9000a510:	f44f 7220 	mov.w	r2, #640	; 0x280
9000a514:	b281      	uxth	r1, r0
9000a516:	2036      	movs	r0, #54	; 0x36
9000a518:	f002 fc2a 	bl	9000cd70 <pbuf_alloc>
  if (p != NULL) {
9000a51c:	4605      	mov	r5, r0
9000a51e:	2800      	cmp	r0, #0
9000a520:	d0ed      	beq.n	9000a4fe <dns_send.isra.0+0x46>
    memset(&hdr, 0, SIZEOF_DNS_HDR);
9000a522:	2300      	movs	r3, #0
    hdr.id = lwip_htons(entry->txid);
9000a524:	8938      	ldrh	r0, [r7, #8]
    --hostname;
9000a526:	3c01      	subs	r4, #1
    memset(&hdr, 0, SIZEOF_DNS_HDR);
9000a528:	9305      	str	r3, [sp, #20]
9000a52a:	e9cd 3303 	strd	r3, r3, [sp, #12]
    hdr.id = lwip_htons(entry->txid);
9000a52e:	f7fe fe27 	bl	90009180 <lwip_htons>
    hdr.flags1 = DNS_FLAG1_RD;
9000a532:	2301      	movs	r3, #1
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
9000a534:	220c      	movs	r2, #12
    hdr.id = lwip_htons(entry->txid);
9000a536:	f8ad 000c 	strh.w	r0, [sp, #12]
    hdr.flags1 = DNS_FLAG1_RD;
9000a53a:	f88d 300e 	strb.w	r3, [sp, #14]
    hdr.numquestions = PP_HTONS(1);
9000a53e:	f44f 7380 	mov.w	r3, #256	; 0x100
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
9000a542:	eb0d 0102 	add.w	r1, sp, r2
9000a546:	4628      	mov	r0, r5
    hdr.numquestions = PP_HTONS(1);
9000a548:	f8ad 3010 	strh.w	r3, [sp, #16]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
9000a54c:	f002 fe2a 	bl	9000d1a4 <pbuf_take>
    query_idx = SIZEOF_DNS_HDR;
9000a550:	210c      	movs	r1, #12
      ++hostname;
9000a552:	3401      	adds	r4, #1
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
9000a554:	2300      	movs	r3, #0
      ++hostname;
9000a556:	46a3      	mov	fp, r4
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
9000a558:	7820      	ldrb	r0, [r4, #0]
9000a55a:	b2da      	uxtb	r2, r3
9000a55c:	282e      	cmp	r0, #46	; 0x2e
9000a55e:	d10c      	bne.n	9000a57a <dns_send.isra.0+0xc2>
      if (query_idx + n + 1 > 0xFFFF) {
9000a560:	1857      	adds	r7, r2, r1
9000a562:	f64f 73fe 	movw	r3, #65534	; 0xfffe
      copy_len = (u16_t)(hostname - hostname_part);
9000a566:	eba4 090b 	sub.w	r9, r4, fp
      if (query_idx + n + 1 > 0xFFFF) {
9000a56a:	429f      	cmp	r7, r3
      copy_len = (u16_t)(hostname - hostname_part);
9000a56c:	fa1f f989 	uxth.w	r9, r9
      if (query_idx + n + 1 > 0xFFFF) {
9000a570:	dd08      	ble.n	9000a584 <dns_send.isra.0+0xcc>
    pbuf_free(p);
9000a572:	4628      	mov	r0, r5
9000a574:	f002 fb94 	bl	9000cca0 <pbuf_free>
9000a578:	e7c1      	b.n	9000a4fe <dns_send.isra.0+0x46>
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
9000a57a:	3301      	adds	r3, #1
9000a57c:	2800      	cmp	r0, #0
9000a57e:	d0ef      	beq.n	9000a560 <dns_send.isra.0+0xa8>
9000a580:	3401      	adds	r4, #1
9000a582:	e7e9      	b.n	9000a558 <dns_send.isra.0+0xa0>
      pbuf_put_at(p, query_idx, n);
9000a584:	4628      	mov	r0, r5
9000a586:	9101      	str	r1, [sp, #4]
9000a588:	f002 fedc 	bl	9000d344 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
9000a58c:	9901      	ldr	r1, [sp, #4]
      query_idx = (u16_t)(query_idx + n + 1);
9000a58e:	b2bf      	uxth	r7, r7
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
9000a590:	464a      	mov	r2, r9
9000a592:	1c4b      	adds	r3, r1, #1
9000a594:	4628      	mov	r0, r5
9000a596:	4659      	mov	r1, fp
9000a598:	b29b      	uxth	r3, r3
9000a59a:	f002 fe61 	bl	9000d260 <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
9000a59e:	1c79      	adds	r1, r7, #1
    } while (*hostname != 0);
9000a5a0:	7822      	ldrb	r2, [r4, #0]
      query_idx = (u16_t)(query_idx + n + 1);
9000a5a2:	b289      	uxth	r1, r1
    } while (*hostname != 0);
9000a5a4:	2a00      	cmp	r2, #0
9000a5a6:	d1d4      	bne.n	9000a552 <dns_send.isra.0+0x9a>
    pbuf_put_at(p, query_idx, 0);
9000a5a8:	4628      	mov	r0, r5
    query_idx++;
9000a5aa:	3702      	adds	r7, #2
    pbuf_put_at(p, query_idx, 0);
9000a5ac:	f002 feca 	bl	9000d344 <pbuf_put_at>
      qry.type = PP_HTONS(DNS_RRTYPE_A);
9000a5b0:	f44f 7380 	mov.w	r3, #256	; 0x100
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
9000a5b4:	a902      	add	r1, sp, #8
9000a5b6:	2204      	movs	r2, #4
      qry.type = PP_HTONS(DNS_RRTYPE_A);
9000a5b8:	f8ad 3008 	strh.w	r3, [sp, #8]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
9000a5bc:	4628      	mov	r0, r5
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
9000a5be:	f8ad 300a 	strh.w	r3, [sp, #10]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
9000a5c2:	b2bb      	uxth	r3, r7
9000a5c4:	f002 fe4c 	bl	9000d260 <pbuf_take_at>
      dst = &dns_servers[entry->server_idx];
9000a5c8:	f44f 7088 	mov.w	r0, #272	; 0x110
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
9000a5cc:	2335      	movs	r3, #53	; 0x35
9000a5ce:	4629      	mov	r1, r5
      dst = &dns_servers[entry->server_idx];
9000a5d0:	fb00 6608 	mla	r6, r0, r8, r6
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
9000a5d4:	4808      	ldr	r0, [pc, #32]	; (9000a5f8 <dns_send.isra.0+0x140>)
      dst = &dns_servers[entry->server_idx];
9000a5d6:	7af2      	ldrb	r2, [r6, #11]
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
9000a5d8:	7bf4      	ldrb	r4, [r6, #15]
9000a5da:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
9000a5de:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
9000a5e2:	f007 f8dd 	bl	900117a0 <udp_sendto>
9000a5e6:	e7c4      	b.n	9000a572 <dns_send.isra.0+0xba>
9000a5e8:	24009bb4 	.word	0x24009bb4
9000a5ec:	90013699 	.word	0x90013699
9000a5f0:	900136cf 	.word	0x900136cf
9000a5f4:	90012aff 	.word	0x90012aff
9000a5f8:	24009b6c 	.word	0x24009b6c
9000a5fc:	24009bac 	.word	0x24009bac

9000a600 <dns_check_entry>:
dns_check_entry(u8_t i)
{
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
9000a600:	2803      	cmp	r0, #3
{
9000a602:	b570      	push	{r4, r5, r6, lr}
9000a604:	4604      	mov	r4, r0
  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
9000a606:	d906      	bls.n	9000a616 <dns_check_entry+0x16>
9000a608:	4b33      	ldr	r3, [pc, #204]	; (9000a6d8 <dns_check_entry+0xd8>)
9000a60a:	f240 421c 	movw	r2, #1052	; 0x41c
9000a60e:	4933      	ldr	r1, [pc, #204]	; (9000a6dc <dns_check_entry+0xdc>)
9000a610:	4833      	ldr	r0, [pc, #204]	; (9000a6e0 <dns_check_entry+0xe0>)
9000a612:	f007 facb 	bl	90011bac <iprintf>

  switch (entry->state) {
9000a616:	4d33      	ldr	r5, [pc, #204]	; (9000a6e4 <dns_check_entry+0xe4>)
9000a618:	f44f 7388 	mov.w	r3, #272	; 0x110
9000a61c:	fb03 5204 	mla	r2, r3, r4, r5
9000a620:	7a92      	ldrb	r2, [r2, #10]
9000a622:	2a03      	cmp	r2, #3
9000a624:	d84e      	bhi.n	9000a6c4 <dns_check_entry+0xc4>
9000a626:	e8df f002 	tbb	[pc, r2]
9000a62a:	0241      	.short	0x0241
9000a62c:	4421      	.short	0x4421
  txid = (u16_t)DNS_RAND_TXID();
9000a62e:	f007 fad5 	bl	90011bdc <rand>
9000a632:	4b2c      	ldr	r3, [pc, #176]	; (9000a6e4 <dns_check_entry+0xe4>)
9000a634:	b280      	uxth	r0, r0
9000a636:	2200      	movs	r2, #0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
9000a638:	7a99      	ldrb	r1, [r3, #10]
9000a63a:	2902      	cmp	r1, #2
9000a63c:	d102      	bne.n	9000a644 <dns_check_entry+0x44>
9000a63e:	8919      	ldrh	r1, [r3, #8]
9000a640:	4281      	cmp	r1, r0
9000a642:	d0f4      	beq.n	9000a62e <dns_check_entry+0x2e>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
9000a644:	3288      	adds	r2, #136	; 0x88
9000a646:	f503 7388 	add.w	r3, r3, #272	; 0x110
9000a64a:	f5b2 7f08 	cmp.w	r2, #544	; 0x220
9000a64e:	d1f3      	bne.n	9000a638 <dns_check_entry+0x38>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
9000a650:	f44f 7388 	mov.w	r3, #272	; 0x110
9000a654:	fb03 5504 	mla	r5, r3, r4, r5
      entry->state = DNS_STATE_ASKING;
9000a658:	2302      	movs	r3, #2
9000a65a:	816b      	strh	r3, [r5, #10]
      entry->server_idx = 0;
      entry->tmr = 1;
9000a65c:	2301      	movs	r3, #1
      entry->txid = dns_create_txid();
9000a65e:	8128      	strh	r0, [r5, #8]
      entry->tmr = 1;
9000a660:	81ab      	strh	r3, [r5, #12]
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
9000a662:	4620      	mov	r0, r4
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
  }
}
9000a664:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        err = dns_send(i);
9000a668:	f7ff bf26 	b.w	9000a4b8 <dns_send.isra.0>
      if (--entry->tmr == 0) {
9000a66c:	fb03 5304 	mla	r3, r3, r4, r5
9000a670:	7b1a      	ldrb	r2, [r3, #12]
9000a672:	3a01      	subs	r2, #1
9000a674:	b2d2      	uxtb	r2, r2
9000a676:	731a      	strb	r2, [r3, #12]
9000a678:	b9c2      	cbnz	r2, 9000a6ac <dns_check_entry+0xac>
        if (++entry->retries == DNS_MAX_RETRIES) {
9000a67a:	7b5a      	ldrb	r2, [r3, #13]
9000a67c:	3201      	adds	r2, #1
9000a67e:	b2d2      	uxtb	r2, r2
9000a680:	2a04      	cmp	r2, #4
9000a682:	735a      	strb	r2, [r3, #13]
9000a684:	d113      	bne.n	9000a6ae <dns_check_entry+0xae>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
9000a686:	7ada      	ldrb	r2, [r3, #11]
9000a688:	b932      	cbnz	r2, 9000a698 <dns_check_entry+0x98>
9000a68a:	4a17      	ldr	r2, [pc, #92]	; (9000a6e8 <dns_check_entry+0xe8>)
9000a68c:	6852      	ldr	r2, [r2, #4]
9000a68e:	b11a      	cbz	r2, 9000a698 <dns_check_entry+0x98>
            entry->server_idx++;
9000a690:	2201      	movs	r2, #1
9000a692:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
9000a694:	819a      	strh	r2, [r3, #12]
9000a696:	e7e4      	b.n	9000a662 <dns_check_entry+0x62>
            dns_call_found(i, NULL);
9000a698:	2100      	movs	r1, #0
9000a69a:	4620      	mov	r0, r4
9000a69c:	f7ff febc 	bl	9000a418 <dns_call_found>
        entry->state = DNS_STATE_UNUSED;
9000a6a0:	f44f 7088 	mov.w	r0, #272	; 0x110
9000a6a4:	2300      	movs	r3, #0
9000a6a6:	fb00 5404 	mla	r4, r0, r4, r5
9000a6aa:	72a3      	strb	r3, [r4, #10]
}
9000a6ac:	bd70      	pop	{r4, r5, r6, pc}
          entry->tmr = entry->retries;
9000a6ae:	731a      	strb	r2, [r3, #12]
9000a6b0:	e7d7      	b.n	9000a662 <dns_check_entry+0x62>
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
9000a6b2:	4363      	muls	r3, r4
9000a6b4:	58ea      	ldr	r2, [r5, r3]
9000a6b6:	2a00      	cmp	r2, #0
9000a6b8:	d0f2      	beq.n	9000a6a0 <dns_check_entry+0xa0>
9000a6ba:	3a01      	subs	r2, #1
9000a6bc:	50ea      	str	r2, [r5, r3]
9000a6be:	2a00      	cmp	r2, #0
9000a6c0:	d0ee      	beq.n	9000a6a0 <dns_check_entry+0xa0>
9000a6c2:	e7f3      	b.n	9000a6ac <dns_check_entry+0xac>
      LWIP_ASSERT("unknown dns_table entry state:", 0);
9000a6c4:	4b04      	ldr	r3, [pc, #16]	; (9000a6d8 <dns_check_entry+0xd8>)
9000a6c6:	f240 425b 	movw	r2, #1115	; 0x45b
9000a6ca:	4908      	ldr	r1, [pc, #32]	; (9000a6ec <dns_check_entry+0xec>)
9000a6cc:	4804      	ldr	r0, [pc, #16]	; (9000a6e0 <dns_check_entry+0xe0>)
}
9000a6ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LWIP_ASSERT("unknown dns_table entry state:", 0);
9000a6d2:	f007 ba6b 	b.w	90011bac <iprintf>
9000a6d6:	bf00      	nop
9000a6d8:	90013699 	.word	0x90013699
9000a6dc:	900136e7 	.word	0x900136e7
9000a6e0:	90012aff 	.word	0x90012aff
9000a6e4:	24009bb4 	.word	0x24009bb4
9000a6e8:	24009bac 	.word	0x24009bac
9000a6ec:	90013701 	.word	0x90013701

9000a6f0 <dns_init>:
}
9000a6f0:	4770      	bx	lr
	...

9000a6f4 <dns_setserver>:
  if (numdns < DNS_MAX_SERVERS) {
9000a6f4:	2801      	cmp	r0, #1
9000a6f6:	d804      	bhi.n	9000a702 <dns_setserver+0xe>
    if (dnsserver != NULL) {
9000a6f8:	4b04      	ldr	r3, [pc, #16]	; (9000a70c <dns_setserver+0x18>)
9000a6fa:	b119      	cbz	r1, 9000a704 <dns_setserver+0x10>
      dns_servers[numdns] = (*dnsserver);
9000a6fc:	680a      	ldr	r2, [r1, #0]
      dns_servers[numdns] = *IP_ADDR_ANY;
9000a6fe:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
9000a702:	4770      	bx	lr
      dns_servers[numdns] = *IP_ADDR_ANY;
9000a704:	4a02      	ldr	r2, [pc, #8]	; (9000a710 <dns_setserver+0x1c>)
9000a706:	6812      	ldr	r2, [r2, #0]
9000a708:	e7f9      	b.n	9000a6fe <dns_setserver+0xa>
9000a70a:	bf00      	nop
9000a70c:	24009bac 	.word	0x24009bac
9000a710:	90013a68 	.word	0x90013a68

9000a714 <dns_tmr>:
{
9000a714:	b508      	push	{r3, lr}
dns_check_entries(void)
{
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    dns_check_entry(i);
9000a716:	2000      	movs	r0, #0
9000a718:	f7ff ff72 	bl	9000a600 <dns_check_entry>
9000a71c:	2001      	movs	r0, #1
9000a71e:	f7ff ff6f 	bl	9000a600 <dns_check_entry>
9000a722:	2002      	movs	r0, #2
9000a724:	f7ff ff6c 	bl	9000a600 <dns_check_entry>
9000a728:	2003      	movs	r0, #3
}
9000a72a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    dns_check_entry(i);
9000a72e:	f7ff bf67 	b.w	9000a600 <dns_check_entry>
	...

9000a734 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
9000a734:	b570      	push	{r4, r5, r6, lr}
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
9000a736:	2618      	movs	r6, #24
9000a738:	4c07      	ldr	r4, [pc, #28]	; (9000a758 <etharp_free_entry+0x24>)
{
9000a73a:	4605      	mov	r5, r0
  if (arp_table[i].q != NULL) {
9000a73c:	4346      	muls	r6, r0
9000a73e:	59a0      	ldr	r0, [r4, r6]
9000a740:	b118      	cbz	r0, 9000a74a <etharp_free_entry+0x16>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
9000a742:	f002 faad 	bl	9000cca0 <pbuf_free>
    arp_table[i].q = NULL;
9000a746:	2300      	movs	r3, #0
9000a748:	51a3      	str	r3, [r4, r6]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
9000a74a:	2018      	movs	r0, #24
9000a74c:	2300      	movs	r3, #0
9000a74e:	fb00 4405 	mla	r4, r0, r5, r4
9000a752:	7523      	strb	r3, [r4, #20]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
9000a754:	bd70      	pop	{r4, r5, r6, pc}
9000a756:	bf00      	nop
9000a758:	24009ff4 	.word	0x24009ff4

9000a75c <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s16_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
{
9000a75c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000a760:	2300      	movs	r3, #0
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s16_t empty = ARP_TABLE_SIZE;
  s16_t i = 0;
  /* oldest entry with packets on queue */
  s16_t old_queue = ARP_TABLE_SIZE;
9000a762:	f04f 0e0a 	mov.w	lr, #10
{
9000a766:	4606      	mov	r6, r0
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
9000a768:	4699      	mov	r9, r3
9000a76a:	469b      	mov	fp, r3
9000a76c:	469c      	mov	ip, r3
  s16_t empty = ARP_TABLE_SIZE;
9000a76e:	4674      	mov	r4, lr
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
9000a770:	4675      	mov	r5, lr
9000a772:	46f0      	mov	r8, lr
{
9000a774:	e9cd 2100 	strd	r2, r1, [sp]
9000a778:	4a3a      	ldr	r2, [pc, #232]	; (9000a864 <etharp_find_entry+0x108>)
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
9000a77a:	2c0a      	cmp	r4, #10
9000a77c:	b218      	sxth	r0, r3
    u8_t state = arp_table[i].state;
9000a77e:	f892 a014 	ldrb.w	sl, [r2, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
9000a782:	d11a      	bne.n	9000a7ba <etharp_find_entry+0x5e>
9000a784:	f1ba 0f00 	cmp.w	sl, #0
9000a788:	d05d      	beq.n	9000a846 <etharp_find_entry+0xea>
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
                  state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
9000a78a:	b156      	cbz	r6, 9000a7a2 <etharp_find_entry+0x46>
9000a78c:	6831      	ldr	r1, [r6, #0]
9000a78e:	6857      	ldr	r7, [r2, #4]
9000a790:	42b9      	cmp	r1, r7
9000a792:	d106      	bne.n	9000a7a2 <etharp_find_entry+0x46>
#if ETHARP_TABLE_MATCH_NETIF
          && ((netif == NULL) || (netif == arp_table[i].netif))
9000a794:	9900      	ldr	r1, [sp, #0]
9000a796:	2900      	cmp	r1, #0
9000a798:	d048      	beq.n	9000a82c <etharp_find_entry+0xd0>
9000a79a:	6891      	ldr	r1, [r2, #8]
9000a79c:	9f00      	ldr	r7, [sp, #0]
9000a79e:	42b9      	cmp	r1, r7
9000a7a0:	d044      	beq.n	9000a82c <etharp_find_entry+0xd0>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n", (int)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
9000a7a2:	f1ba 0f01 	cmp.w	sl, #1
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
          if (arp_table[i].ctime >= age_queue) {
9000a7a6:	8a51      	ldrh	r1, [r2, #18]
      if (state == ETHARP_STATE_PENDING) {
9000a7a8:	d148      	bne.n	9000a83c <etharp_find_entry+0xe0>
        if (arp_table[i].q != NULL) {
9000a7aa:	6817      	ldr	r7, [r2, #0]
9000a7ac:	2f00      	cmp	r7, #0
9000a7ae:	d040      	beq.n	9000a832 <etharp_find_entry+0xd6>
          if (arp_table[i].ctime >= age_queue) {
9000a7b0:	4561      	cmp	r1, ip
9000a7b2:	d305      	bcc.n	9000a7c0 <etharp_find_entry+0x64>
9000a7b4:	468c      	mov	ip, r1
9000a7b6:	4686      	mov	lr, r0
9000a7b8:	e002      	b.n	9000a7c0 <etharp_find_entry+0x64>
    } else if (state != ETHARP_STATE_EMPTY) {
9000a7ba:	f1ba 0f00 	cmp.w	sl, #0
9000a7be:	d1e4      	bne.n	9000a78a <etharp_find_entry+0x2e>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
9000a7c0:	3301      	adds	r3, #1
9000a7c2:	3218      	adds	r2, #24
9000a7c4:	2b0a      	cmp	r3, #10
9000a7c6:	d1d8      	bne.n	9000a77a <etharp_find_entry+0x1e>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
9000a7c8:	9b01      	ldr	r3, [sp, #4]
9000a7ca:	2b01      	cmp	r3, #1
9000a7cc:	d143      	bne.n	9000a856 <etharp_find_entry+0xfa>
9000a7ce:	2c0a      	cmp	r4, #10
9000a7d0:	d111      	bne.n	9000a7f6 <etharp_find_entry+0x9a>
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (int)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
9000a7d2:	2d0a      	cmp	r5, #10
9000a7d4:	d039      	beq.n	9000a84a <etharp_find_entry+0xee>
      /* recycle oldest stable*/
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %d\n", (int)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
9000a7d6:	2318      	movs	r3, #24
9000a7d8:	4a22      	ldr	r2, [pc, #136]	; (9000a864 <etharp_find_entry+0x108>)
9000a7da:	436b      	muls	r3, r5
9000a7dc:	58d3      	ldr	r3, [r2, r3]
9000a7de:	b133      	cbz	r3, 9000a7ee <etharp_find_entry+0x92>
9000a7e0:	4b21      	ldr	r3, [pc, #132]	; (9000a868 <etharp_find_entry+0x10c>)
9000a7e2:	f240 126d 	movw	r2, #365	; 0x16d
9000a7e6:	4921      	ldr	r1, [pc, #132]	; (9000a86c <etharp_find_entry+0x110>)
9000a7e8:	4821      	ldr	r0, [pc, #132]	; (9000a870 <etharp_find_entry+0x114>)
9000a7ea:	f007 f9df 	bl	90011bac <iprintf>
      return (s16_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
9000a7ee:	462c      	mov	r4, r5
9000a7f0:	4628      	mov	r0, r5
9000a7f2:	f7ff ff9f 	bl	9000a734 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
9000a7f6:	4d1b      	ldr	r5, [pc, #108]	; (9000a864 <etharp_find_entry+0x108>)
9000a7f8:	2318      	movs	r3, #24
9000a7fa:	fb03 5304 	mla	r3, r3, r4, r5
9000a7fe:	7d1b      	ldrb	r3, [r3, #20]
9000a800:	b133      	cbz	r3, 9000a810 <etharp_find_entry+0xb4>
9000a802:	4b19      	ldr	r3, [pc, #100]	; (9000a868 <etharp_find_entry+0x10c>)
9000a804:	f44f 72c2 	mov.w	r2, #388	; 0x184
9000a808:	491a      	ldr	r1, [pc, #104]	; (9000a874 <etharp_find_entry+0x118>)
9000a80a:	4819      	ldr	r0, [pc, #100]	; (9000a870 <etharp_find_entry+0x114>)
9000a80c:	f007 f9ce 	bl	90011bac <iprintf>
              arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
9000a810:	b126      	cbz	r6, 9000a81c <etharp_find_entry+0xc0>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
9000a812:	2318      	movs	r3, #24
9000a814:	6832      	ldr	r2, [r6, #0]
9000a816:	fb03 5304 	mla	r3, r3, r4, r5
9000a81a:	605a      	str	r2, [r3, #4]
  }
  arp_table[i].ctime = 0;
9000a81c:	2318      	movs	r3, #24
9000a81e:	2200      	movs	r2, #0
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
#endif /* ETHARP_TABLE_MATCH_NETIF */
  return (s16_t)i;
9000a820:	4620      	mov	r0, r4
  arp_table[i].ctime = 0;
9000a822:	fb03 5304 	mla	r3, r3, r4, r5
9000a826:	825a      	strh	r2, [r3, #18]
  arp_table[i].netif = netif;
9000a828:	9a00      	ldr	r2, [sp, #0]
9000a82a:	609a      	str	r2, [r3, #8]
}
9000a82c:	b003      	add	sp, #12
9000a82e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if (arp_table[i].ctime >= age_pending) {
9000a832:	4559      	cmp	r1, fp
9000a834:	d3c4      	bcc.n	9000a7c0 <etharp_find_entry+0x64>
9000a836:	468b      	mov	fp, r1
9000a838:	4680      	mov	r8, r0
9000a83a:	e7c1      	b.n	9000a7c0 <etharp_find_entry+0x64>
          if (arp_table[i].ctime >= age_stable) {
9000a83c:	4549      	cmp	r1, r9
9000a83e:	d3bf      	bcc.n	9000a7c0 <etharp_find_entry+0x64>
9000a840:	4689      	mov	r9, r1
9000a842:	4605      	mov	r5, r0
9000a844:	e7bc      	b.n	9000a7c0 <etharp_find_entry+0x64>
9000a846:	4604      	mov	r4, r0
9000a848:	e7ba      	b.n	9000a7c0 <etharp_find_entry+0x64>
    } else if (old_pending < ARP_TABLE_SIZE) {
9000a84a:	f1b8 0f0a 	cmp.w	r8, #10
9000a84e:	d105      	bne.n	9000a85c <etharp_find_entry+0x100>
    } else if (old_queue < ARP_TABLE_SIZE) {
9000a850:	f1be 0f0a 	cmp.w	lr, #10
9000a854:	d104      	bne.n	9000a860 <etharp_find_entry+0x104>
    return (s16_t)ERR_MEM;
9000a856:	f04f 30ff 	mov.w	r0, #4294967295
9000a85a:	e7e7      	b.n	9000a82c <etharp_find_entry+0xd0>
9000a85c:	4645      	mov	r5, r8
9000a85e:	e7c6      	b.n	9000a7ee <etharp_find_entry+0x92>
9000a860:	4675      	mov	r5, lr
9000a862:	e7c4      	b.n	9000a7ee <etharp_find_entry+0x92>
9000a864:	24009ff4 	.word	0x24009ff4
9000a868:	90013720 	.word	0x90013720
9000a86c:	9001375e 	.word	0x9001375e
9000a870:	90012aff 	.word	0x90012aff
9000a874:	90013775 	.word	0x90013775

9000a878 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
9000a878:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
9000a87c:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
9000a880:	4688      	mov	r8, r1
9000a882:	4691      	mov	r9, r2
9000a884:	461e      	mov	r6, r3
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
9000a886:	4607      	mov	r7, r0
9000a888:	b930      	cbnz	r0, 9000a898 <etharp_raw+0x20>
9000a88a:	4b2d      	ldr	r3, [pc, #180]	; (9000a940 <etharp_raw+0xc8>)
9000a88c:	f240 4257 	movw	r2, #1111	; 0x457
9000a890:	492c      	ldr	r1, [pc, #176]	; (9000a944 <etharp_raw+0xcc>)
9000a892:	482d      	ldr	r0, [pc, #180]	; (9000a948 <etharp_raw+0xd0>)
9000a894:	f007 f98a 	bl	90011bac <iprintf>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
9000a898:	f44f 7220 	mov.w	r2, #640	; 0x280
9000a89c:	211c      	movs	r1, #28
9000a89e:	200e      	movs	r0, #14
9000a8a0:	f002 fa66 	bl	9000cd70 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
9000a8a4:	4605      	mov	r5, r0
9000a8a6:	2800      	cmp	r0, #0
9000a8a8:	d047      	beq.n	9000a93a <etharp_raw+0xc2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
9000a8aa:	8943      	ldrh	r3, [r0, #10]
9000a8ac:	2b1b      	cmp	r3, #27
9000a8ae:	d806      	bhi.n	9000a8be <etharp_raw+0x46>
9000a8b0:	4b23      	ldr	r3, [pc, #140]	; (9000a940 <etharp_raw+0xc8>)
9000a8b2:	f240 4262 	movw	r2, #1122	; 0x462
9000a8b6:	4925      	ldr	r1, [pc, #148]	; (9000a94c <etharp_raw+0xd4>)
9000a8b8:	4823      	ldr	r0, [pc, #140]	; (9000a948 <etharp_raw+0xd0>)
9000a8ba:	f007 f977 	bl	90011bac <iprintf>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
9000a8be:	686c      	ldr	r4, [r5, #4]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
9000a8c0:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
9000a8c4:	f7fe fc5c 	bl	90009180 <lwip_htons>
9000a8c8:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
9000a8ca:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
9000a8ce:	2b06      	cmp	r3, #6
9000a8d0:	d006      	beq.n	9000a8e0 <etharp_raw+0x68>
9000a8d2:	4b1b      	ldr	r3, [pc, #108]	; (9000a940 <etharp_raw+0xc8>)
9000a8d4:	f240 4269 	movw	r2, #1129	; 0x469
9000a8d8:	491d      	ldr	r1, [pc, #116]	; (9000a950 <etharp_raw+0xd8>)
9000a8da:	481b      	ldr	r0, [pc, #108]	; (9000a948 <etharp_raw+0xd0>)
9000a8dc:	f007 f966 	bl	90011bac <iprintf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
9000a8e0:	6833      	ldr	r3, [r6, #0]
  if (ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
9000a8e2:	4642      	mov	r2, r8
9000a8e4:	4629      	mov	r1, r5
9000a8e6:	4638      	mov	r0, r7
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
9000a8e8:	60a3      	str	r3, [r4, #8]
9000a8ea:	88b3      	ldrh	r3, [r6, #4]
  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
9000a8ec:	2600      	movs	r6, #0
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
9000a8ee:	81a3      	strh	r3, [r4, #12]
  SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
9000a8f0:	f8da 3000 	ldr.w	r3, [sl]
9000a8f4:	f8c4 3012 	str.w	r3, [r4, #18]
9000a8f8:	f8ba 3004 	ldrh.w	r3, [sl, #4]
9000a8fc:	82e3      	strh	r3, [r4, #22]
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
9000a8fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9000a900:	681b      	ldr	r3, [r3, #0]
9000a902:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
9000a906:	9b0c      	ldr	r3, [sp, #48]	; 0x30
9000a908:	681b      	ldr	r3, [r3, #0]
  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
9000a90a:	7026      	strb	r6, [r4, #0]
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
9000a90c:	61a3      	str	r3, [r4, #24]
  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
9000a90e:	2301      	movs	r3, #1
  hdr->proto = PP_HTONS(ETHTYPE_IP);
9000a910:	70e6      	strb	r6, [r4, #3]
  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
9000a912:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
9000a914:	2308      	movs	r3, #8
9000a916:	70a3      	strb	r3, [r4, #2]
  hdr->hwlen = ETH_HWADDR_LEN;
9000a918:	2306      	movs	r3, #6
9000a91a:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
9000a91c:	2304      	movs	r3, #4
9000a91e:	7163      	strb	r3, [r4, #5]
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
9000a920:	f640 0306 	movw	r3, #2054	; 0x806
9000a924:	9300      	str	r3, [sp, #0]
9000a926:	464b      	mov	r3, r9
9000a928:	f000 faf6 	bl	9000af18 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
9000a92c:	4628      	mov	r0, r5
9000a92e:	f002 f9b7 	bl	9000cca0 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
9000a932:	4630      	mov	r0, r6
}
9000a934:	b002      	add	sp, #8
9000a936:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return ERR_MEM;
9000a93a:	f04f 30ff 	mov.w	r0, #4294967295
9000a93e:	e7f9      	b.n	9000a934 <etharp_raw+0xbc>
9000a940:	90013720 	.word	0x90013720
9000a944:	90013511 	.word	0x90013511
9000a948:	90012aff 	.word	0x90012aff
9000a94c:	9001379e 	.word	0x9001379e
9000a950:	900137cf 	.word	0x900137cf

9000a954 <etharp_cleanup_netif>:
{
9000a954:	b570      	push	{r4, r5, r6, lr}
9000a956:	4606      	mov	r6, r0
9000a958:	4d07      	ldr	r5, [pc, #28]	; (9000a978 <etharp_cleanup_netif+0x24>)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
9000a95a:	2400      	movs	r4, #0
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
9000a95c:	7d2b      	ldrb	r3, [r5, #20]
9000a95e:	b12b      	cbz	r3, 9000a96c <etharp_cleanup_netif+0x18>
9000a960:	68ab      	ldr	r3, [r5, #8]
9000a962:	42b3      	cmp	r3, r6
9000a964:	d102      	bne.n	9000a96c <etharp_cleanup_netif+0x18>
      etharp_free_entry(i);
9000a966:	4620      	mov	r0, r4
9000a968:	f7ff fee4 	bl	9000a734 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
9000a96c:	3401      	adds	r4, #1
9000a96e:	3518      	adds	r5, #24
9000a970:	2c0a      	cmp	r4, #10
9000a972:	d1f3      	bne.n	9000a95c <etharp_cleanup_netif+0x8>
}
9000a974:	bd70      	pop	{r4, r5, r6, pc}
9000a976:	bf00      	nop
9000a978:	24009ff4 	.word	0x24009ff4

9000a97c <etharp_input>:
{
9000a97c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000a980:	4607      	mov	r7, r0
9000a982:	b088      	sub	sp, #32
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
9000a984:	460c      	mov	r4, r1
9000a986:	b949      	cbnz	r1, 9000a99c <etharp_input+0x20>
9000a988:	4b4f      	ldr	r3, [pc, #316]	; (9000aac8 <etharp_input+0x14c>)
9000a98a:	f240 228a 	movw	r2, #650	; 0x28a
9000a98e:	494f      	ldr	r1, [pc, #316]	; (9000aacc <etharp_input+0x150>)
9000a990:	484f      	ldr	r0, [pc, #316]	; (9000aad0 <etharp_input+0x154>)
}
9000a992:	b008      	add	sp, #32
9000a994:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
9000a998:	f007 b908 	b.w	90011bac <iprintf>
  hdr = (struct etharp_hdr *)p->payload;
9000a99c:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
9000a99e:	882b      	ldrh	r3, [r5, #0]
9000a9a0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9000a9a4:	d108      	bne.n	9000a9b8 <etharp_input+0x3c>
9000a9a6:	792b      	ldrb	r3, [r5, #4]
9000a9a8:	2b06      	cmp	r3, #6
9000a9aa:	d105      	bne.n	9000a9b8 <etharp_input+0x3c>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
9000a9ac:	796b      	ldrb	r3, [r5, #5]
9000a9ae:	2b04      	cmp	r3, #4
9000a9b0:	d102      	bne.n	9000a9b8 <etharp_input+0x3c>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
9000a9b2:	886b      	ldrh	r3, [r5, #2]
9000a9b4:	2b08      	cmp	r3, #8
9000a9b6:	d005      	beq.n	9000a9c4 <etharp_input+0x48>
    pbuf_free(p);
9000a9b8:	4638      	mov	r0, r7
}
9000a9ba:	b008      	add	sp, #32
9000a9bc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pbuf_free(p);
9000a9c0:	f002 b96e 	b.w	9000cca0 <pbuf_free>
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
9000a9c4:	f8d5 300e 	ldr.w	r3, [r5, #14]
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
9000a9c8:	f105 0808 	add.w	r8, r5, #8
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
9000a9cc:	684e      	ldr	r6, [r1, #4]
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
9000a9ce:	9307      	str	r3, [sp, #28]
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
9000a9d0:	69ab      	ldr	r3, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
9000a9d2:	2e00      	cmp	r6, #0
9000a9d4:	d05e      	beq.n	9000aa94 <etharp_input+0x118>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
9000a9d6:	1af3      	subs	r3, r6, r3
9000a9d8:	425e      	negs	r6, r3
9000a9da:	415e      	adcs	r6, r3
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
9000a9dc:	f1c6 0a02 	rsb	sl, r6, #2
9000a9e0:	fa5f fa8a 	uxtb.w	sl, sl
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
9000a9e4:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
9000a9e8:	2b06      	cmp	r3, #6
9000a9ea:	d006      	beq.n	9000a9fa <etharp_input+0x7e>
9000a9ec:	4b36      	ldr	r3, [pc, #216]	; (9000aac8 <etharp_input+0x14c>)
9000a9ee:	f240 12a9 	movw	r2, #425	; 0x1a9
9000a9f2:	4938      	ldr	r1, [pc, #224]	; (9000aad4 <etharp_input+0x158>)
9000a9f4:	4836      	ldr	r0, [pc, #216]	; (9000aad0 <etharp_input+0x154>)
9000a9f6:	f007 f8d9 	bl	90011bac <iprintf>
  if (ip4_addr_isany(ipaddr) ||
9000a9fa:	9807      	ldr	r0, [sp, #28]
9000a9fc:	2800      	cmp	r0, #0
9000a9fe:	d03c      	beq.n	9000aa7a <etharp_input+0xfe>
      ip4_addr_isbroadcast(ipaddr, netif) ||
9000aa00:	4621      	mov	r1, r4
9000aa02:	f000 fdcc 	bl	9000b59e <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
9000aa06:	4681      	mov	r9, r0
9000aa08:	bbb8      	cbnz	r0, 9000aa7a <etharp_input+0xfe>
      ip4_addr_ismulticast(ipaddr)) {
9000aa0a:	9b07      	ldr	r3, [sp, #28]
9000aa0c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
9000aa10:	2be0      	cmp	r3, #224	; 0xe0
9000aa12:	d032      	beq.n	9000aa7a <etharp_input+0xfe>
  i = etharp_find_entry(ipaddr, flags, netif);
9000aa14:	4622      	mov	r2, r4
9000aa16:	4651      	mov	r1, sl
9000aa18:	a807      	add	r0, sp, #28
9000aa1a:	f7ff fe9f 	bl	9000a75c <etharp_find_entry>
  if (i < 0) {
9000aa1e:	1e03      	subs	r3, r0, #0
9000aa20:	db2b      	blt.n	9000aa7a <etharp_input+0xfe>
    arp_table[i].state = ETHARP_STATE_STABLE;
9000aa22:	2018      	movs	r0, #24
9000aa24:	4a2c      	ldr	r2, [pc, #176]	; (9000aad8 <etharp_input+0x15c>)
9000aa26:	f04f 0e02 	mov.w	lr, #2
9000aa2a:	fb00 fc03 	mul.w	ip, r0, r3
9000aa2e:	eb02 010c 	add.w	r1, r2, ip
9000aa32:	f881 e014 	strb.w	lr, [r1, #20]
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
9000aa36:	f04f 0e0c 	mov.w	lr, #12
  arp_table[i].netif = netif;
9000aa3a:	608c      	str	r4, [r1, #8]
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
9000aa3c:	fb13 e300 	smlabb	r3, r3, r0, lr
9000aa40:	68a8      	ldr	r0, [r5, #8]
9000aa42:	eb02 0e03 	add.w	lr, r2, r3
9000aa46:	50d0      	str	r0, [r2, r3]
9000aa48:	f8b8 3004 	ldrh.w	r3, [r8, #4]
9000aa4c:	f8ae 3004 	strh.w	r3, [lr, #4]
  arp_table[i].ctime = 0;
9000aa50:	f8a1 9012 	strh.w	r9, [r1, #18]
  if (arp_table[i].q != NULL) {
9000aa54:	f852 100c 	ldr.w	r1, [r2, ip]
9000aa58:	b179      	cbz	r1, 9000aa7a <etharp_input+0xfe>
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
9000aa5a:	f44f 6300 	mov.w	r3, #2048	; 0x800
    arp_table[i].q = NULL;
9000aa5e:	f842 900c 	str.w	r9, [r2, ip]
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
9000aa62:	4620      	mov	r0, r4
9000aa64:	f104 022e 	add.w	r2, r4, #46	; 0x2e
9000aa68:	9300      	str	r3, [sp, #0]
9000aa6a:	4643      	mov	r3, r8
9000aa6c:	9105      	str	r1, [sp, #20]
9000aa6e:	f000 fa53 	bl	9000af18 <ethernet_output>
    pbuf_free(p);
9000aa72:	9905      	ldr	r1, [sp, #20]
9000aa74:	4608      	mov	r0, r1
9000aa76:	f002 f913 	bl	9000cca0 <pbuf_free>
  switch (hdr->opcode) {
9000aa7a:	88eb      	ldrh	r3, [r5, #6]
9000aa7c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9000aa80:	d00b      	beq.n	9000aa9a <etharp_input+0x11e>
9000aa82:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
9000aa86:	d019      	beq.n	9000aabc <etharp_input+0x140>
  pbuf_free(p);
9000aa88:	4638      	mov	r0, r7
9000aa8a:	f002 f909 	bl	9000cca0 <pbuf_free>
}
9000aa8e:	b008      	add	sp, #32
9000aa90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
9000aa94:	f04f 0a02 	mov.w	sl, #2
9000aa98:	e7a4      	b.n	9000a9e4 <etharp_input+0x68>
      if (for_us) {
9000aa9a:	2e00      	cmp	r6, #0
9000aa9c:	d0f4      	beq.n	9000aa88 <etharp_input+0x10c>
        etharp_raw(netif,
9000aa9e:	2202      	movs	r2, #2
                   (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
9000aaa0:	f104 032e 	add.w	r3, r4, #46	; 0x2e
        etharp_raw(netif,
9000aaa4:	4620      	mov	r0, r4
9000aaa6:	9203      	str	r2, [sp, #12]
9000aaa8:	aa07      	add	r2, sp, #28
9000aaaa:	4619      	mov	r1, r3
9000aaac:	e9cd 8201 	strd	r8, r2, [sp, #4]
                   (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
9000aab0:	1d22      	adds	r2, r4, #4
        etharp_raw(netif,
9000aab2:	9200      	str	r2, [sp, #0]
9000aab4:	4642      	mov	r2, r8
9000aab6:	f7ff fedf 	bl	9000a878 <etharp_raw>
9000aaba:	e7e5      	b.n	9000aa88 <etharp_input+0x10c>
      dhcp_arp_reply(netif, &sipaddr);
9000aabc:	a907      	add	r1, sp, #28
9000aabe:	4620      	mov	r0, r4
9000aac0:	f7ff fa18 	bl	90009ef4 <dhcp_arp_reply>
      break;
9000aac4:	e7e0      	b.n	9000aa88 <etharp_input+0x10c>
9000aac6:	bf00      	nop
9000aac8:	90013720 	.word	0x90013720
9000aacc:	90013511 	.word	0x90013511
9000aad0:	90012aff 	.word	0x90012aff
9000aad4:	9001382f 	.word	0x9001382f
9000aad8:	24009ff4 	.word	0x24009ff4

9000aadc <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
9000aadc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
9000aade:	4602      	mov	r2, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000aae0:	2401      	movs	r4, #1
9000aae2:	f100 032e 	add.w	r3, r0, #46	; 0x2e
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
9000aae6:	3204      	adds	r2, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000aae8:	e9cd 1402 	strd	r1, r4, [sp, #8]
9000aaec:	4904      	ldr	r1, [pc, #16]	; (9000ab00 <etharp_request+0x24>)
9000aaee:	9200      	str	r2, [sp, #0]
9000aaf0:	9101      	str	r1, [sp, #4]
9000aaf2:	4619      	mov	r1, r3
9000aaf4:	4a03      	ldr	r2, [pc, #12]	; (9000ab04 <etharp_request+0x28>)
9000aaf6:	f7ff febf 	bl	9000a878 <etharp_raw>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
}
9000aafa:	b004      	add	sp, #16
9000aafc:	bd10      	pop	{r4, pc}
9000aafe:	bf00      	nop
9000ab00:	9001391e 	.word	0x9001391e
9000ab04:	90013918 	.word	0x90013918

9000ab08 <etharp_tmr>:
{
9000ab08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000ab0a:	4c13      	ldr	r4, [pc, #76]	; (9000ab58 <etharp_tmr+0x50>)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
9000ab0c:	2500      	movs	r5, #0
        arp_table[i].state = ETHARP_STATE_STABLE;
9000ab0e:	2602      	movs	r6, #2
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
9000ab10:	2704      	movs	r7, #4
    u8_t state = arp_table[i].state;
9000ab12:	7d22      	ldrb	r2, [r4, #20]
    if (state != ETHARP_STATE_EMPTY
9000ab14:	b16a      	cbz	r2, 9000ab32 <etharp_tmr+0x2a>
      arp_table[i].ctime++;
9000ab16:	8a63      	ldrh	r3, [r4, #18]
9000ab18:	3301      	adds	r3, #1
9000ab1a:	b29b      	uxth	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
9000ab1c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
      arp_table[i].ctime++;
9000ab20:	8263      	strh	r3, [r4, #18]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
9000ab22:	d203      	bcs.n	9000ab2c <etharp_tmr+0x24>
9000ab24:	2a01      	cmp	r2, #1
9000ab26:	d109      	bne.n	9000ab3c <etharp_tmr+0x34>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
9000ab28:	2b04      	cmp	r3, #4
9000ab2a:	d90f      	bls.n	9000ab4c <etharp_tmr+0x44>
        etharp_free_entry(i);
9000ab2c:	4628      	mov	r0, r5
9000ab2e:	f7ff fe01 	bl	9000a734 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
9000ab32:	3501      	adds	r5, #1
9000ab34:	3418      	adds	r4, #24
9000ab36:	2d0a      	cmp	r5, #10
9000ab38:	d1eb      	bne.n	9000ab12 <etharp_tmr+0xa>
}
9000ab3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
9000ab3c:	2a03      	cmp	r2, #3
9000ab3e:	d101      	bne.n	9000ab44 <etharp_tmr+0x3c>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
9000ab40:	7527      	strb	r7, [r4, #20]
9000ab42:	e7f6      	b.n	9000ab32 <etharp_tmr+0x2a>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
9000ab44:	2a04      	cmp	r2, #4
9000ab46:	d1f4      	bne.n	9000ab32 <etharp_tmr+0x2a>
        arp_table[i].state = ETHARP_STATE_STABLE;
9000ab48:	7526      	strb	r6, [r4, #20]
9000ab4a:	e7f2      	b.n	9000ab32 <etharp_tmr+0x2a>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
9000ab4c:	1d21      	adds	r1, r4, #4
9000ab4e:	68a0      	ldr	r0, [r4, #8]
9000ab50:	f7ff ffc4 	bl	9000aadc <etharp_request>
9000ab54:	e7ed      	b.n	9000ab32 <etharp_tmr+0x2a>
9000ab56:	bf00      	nop
9000ab58:	24009ff4 	.word	0x24009ff4

9000ab5c <etharp_output_to_arp_index>:
{
9000ab5c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
9000ab60:	4f24      	ldr	r7, [pc, #144]	; (9000abf4 <etharp_output_to_arp_index+0x98>)
9000ab62:	2318      	movs	r3, #24
{
9000ab64:	4606      	mov	r6, r0
9000ab66:	4688      	mov	r8, r1
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
9000ab68:	fb03 7302 	mla	r3, r3, r2, r7
{
9000ab6c:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
9000ab6e:	7d1b      	ldrb	r3, [r3, #20]
9000ab70:	2b01      	cmp	r3, #1
9000ab72:	d806      	bhi.n	9000ab82 <etharp_output_to_arp_index+0x26>
9000ab74:	4b20      	ldr	r3, [pc, #128]	; (9000abf8 <etharp_output_to_arp_index+0x9c>)
9000ab76:	f240 22ee 	movw	r2, #750	; 0x2ee
9000ab7a:	4920      	ldr	r1, [pc, #128]	; (9000abfc <etharp_output_to_arp_index+0xa0>)
9000ab7c:	4820      	ldr	r0, [pc, #128]	; (9000ac00 <etharp_output_to_arp_index+0xa4>)
9000ab7e:	f007 f815 	bl	90011bac <iprintf>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
9000ab82:	2218      	movs	r2, #24
9000ab84:	eb04 0544 	add.w	r5, r4, r4, lsl #1
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000ab88:	f106 092e 	add.w	r9, r6, #46	; 0x2e
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
9000ab8c:	fb02 7404 	mla	r4, r2, r4, r7
9000ab90:	00ed      	lsls	r5, r5, #3
9000ab92:	7d23      	ldrb	r3, [r4, #20]
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
9000ab94:	f105 0a0c 	add.w	sl, r5, #12
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
9000ab98:	2b02      	cmp	r3, #2
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
9000ab9a:	44ba      	add	sl, r7
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
9000ab9c:	d10b      	bne.n	9000abb6 <etharp_output_to_arp_index+0x5a>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
9000ab9e:	8a63      	ldrh	r3, [r4, #18]
9000aba0:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
9000aba4:	d913      	bls.n	9000abce <etharp_output_to_arp_index+0x72>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
9000aba6:	3504      	adds	r5, #4
9000aba8:	4630      	mov	r0, r6
9000abaa:	1979      	adds	r1, r7, r5
9000abac:	f7ff ff96 	bl	9000aadc <etharp_request>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
9000abb0:	b908      	cbnz	r0, 9000abb6 <etharp_output_to_arp_index+0x5a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
9000abb2:	2303      	movs	r3, #3
9000abb4:	7523      	strb	r3, [r4, #20]
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
9000abb6:	f44f 6300 	mov.w	r3, #2048	; 0x800
9000abba:	464a      	mov	r2, r9
9000abbc:	4641      	mov	r1, r8
9000abbe:	4630      	mov	r0, r6
9000abc0:	9300      	str	r3, [sp, #0]
9000abc2:	4653      	mov	r3, sl
9000abc4:	f000 f9a8 	bl	9000af18 <ethernet_output>
}
9000abc8:	b004      	add	sp, #16
9000abca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
9000abce:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
9000abd2:	d3f0      	bcc.n	9000abb6 <etharp_output_to_arp_index+0x5a>
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000abd4:	2301      	movs	r3, #1
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
9000abd6:	3504      	adds	r5, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000abd8:	4652      	mov	r2, sl
9000abda:	4649      	mov	r1, r9
9000abdc:	9303      	str	r3, [sp, #12]
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
9000abde:	443d      	add	r5, r7
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000abe0:	4b08      	ldr	r3, [pc, #32]	; (9000ac04 <etharp_output_to_arp_index+0xa8>)
9000abe2:	4630      	mov	r0, r6
9000abe4:	9502      	str	r5, [sp, #8]
9000abe6:	9301      	str	r3, [sp, #4]
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
9000abe8:	1d33      	adds	r3, r6, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
9000abea:	9300      	str	r3, [sp, #0]
9000abec:	464b      	mov	r3, r9
9000abee:	f7ff fe43 	bl	9000a878 <etharp_raw>
9000abf2:	e7dd      	b.n	9000abb0 <etharp_output_to_arp_index+0x54>
9000abf4:	24009ff4 	.word	0x24009ff4
9000abf8:	90013720 	.word	0x90013720
9000abfc:	90013853 	.word	0x90013853
9000ac00:	90012aff 	.word	0x90012aff
9000ac04:	9001391e 	.word	0x9001391e

9000ac08 <etharp_query>:
{
9000ac08:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
9000ac0c:	460f      	mov	r7, r1
9000ac0e:	4606      	mov	r6, r0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
9000ac10:	4601      	mov	r1, r0
{
9000ac12:	4615      	mov	r5, r2
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
9000ac14:	6838      	ldr	r0, [r7, #0]
9000ac16:	f000 fcc2 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000ac1a:	2800      	cmp	r0, #0
9000ac1c:	d16b      	bne.n	9000acf6 <etharp_query+0xee>
      ip4_addr_ismulticast(ipaddr) ||
9000ac1e:	683b      	ldr	r3, [r7, #0]
9000ac20:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
9000ac24:	2ae0      	cmp	r2, #224	; 0xe0
9000ac26:	d066      	beq.n	9000acf6 <etharp_query+0xee>
      ip4_addr_isany(ipaddr)) {
9000ac28:	2b00      	cmp	r3, #0
9000ac2a:	d064      	beq.n	9000acf6 <etharp_query+0xee>
  i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
9000ac2c:	4632      	mov	r2, r6
9000ac2e:	2101      	movs	r1, #1
9000ac30:	4638      	mov	r0, r7
9000ac32:	f7ff fd93 	bl	9000a75c <etharp_find_entry>
  if (i_err < 0) {
9000ac36:	1e04      	subs	r4, r0, #0
9000ac38:	da03      	bge.n	9000ac42 <etharp_query+0x3a>
    return (err_t)i_err;
9000ac3a:	b260      	sxtb	r0, r4
}
9000ac3c:	b002      	add	sp, #8
9000ac3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
9000ac42:	2c7e      	cmp	r4, #126	; 0x7e
9000ac44:	dd06      	ble.n	9000ac54 <etharp_query+0x4c>
9000ac46:	4b36      	ldr	r3, [pc, #216]	; (9000ad20 <etharp_query+0x118>)
9000ac48:	f240 32c1 	movw	r2, #961	; 0x3c1
9000ac4c:	4935      	ldr	r1, [pc, #212]	; (9000ad24 <etharp_query+0x11c>)
9000ac4e:	4836      	ldr	r0, [pc, #216]	; (9000ad28 <etharp_query+0x120>)
9000ac50:	f006 ffac 	bl	90011bac <iprintf>
  i = (netif_addr_idx_t)i_err;
9000ac54:	b2e4      	uxtb	r4, r4
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
9000ac56:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 9000ad30 <etharp_query+0x128>
9000ac5a:	2318      	movs	r3, #24
9000ac5c:	fb03 8304 	mla	r3, r3, r4, r8
9000ac60:	7d1a      	ldrb	r2, [r3, #20]
9000ac62:	2a00      	cmp	r2, #0
9000ac64:	d156      	bne.n	9000ad14 <etharp_query+0x10c>
    arp_table[i].state = ETHARP_STATE_PENDING;
9000ac66:	2201      	movs	r2, #1
    arp_table[i].netif = netif;
9000ac68:	609e      	str	r6, [r3, #8]
    arp_table[i].state = ETHARP_STATE_PENDING;
9000ac6a:	751a      	strb	r2, [r3, #20]
    result = etharp_request(netif, ipaddr);
9000ac6c:	4639      	mov	r1, r7
9000ac6e:	4630      	mov	r0, r6
9000ac70:	f7ff ff34 	bl	9000aadc <etharp_request>
    if (q == NULL) {
9000ac74:	2d00      	cmp	r5, #0
9000ac76:	d0e1      	beq.n	9000ac3c <etharp_query+0x34>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
9000ac78:	2318      	movs	r3, #24
9000ac7a:	fb03 8204 	mla	r2, r3, r4, r8
9000ac7e:	7d12      	ldrb	r2, [r2, #20]
9000ac80:	2a01      	cmp	r2, #1
9000ac82:	d90e      	bls.n	9000aca2 <etharp_query+0x9a>
    ETHARP_SET_ADDRHINT(netif, i);
9000ac84:	4a29      	ldr	r2, [pc, #164]	; (9000ad2c <etharp_query+0x124>)
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
9000ac86:	fb03 8304 	mla	r3, r3, r4, r8
9000ac8a:	4629      	mov	r1, r5
9000ac8c:	4630      	mov	r0, r6
    ETHARP_SET_ADDRHINT(netif, i);
9000ac8e:	7014      	strb	r4, [r2, #0]
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
9000ac90:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000ac94:	330c      	adds	r3, #12
9000ac96:	9200      	str	r2, [sp, #0]
9000ac98:	f106 022e 	add.w	r2, r6, #46	; 0x2e
9000ac9c:	f000 f93c 	bl	9000af18 <ethernet_output>
9000aca0:	e7cc      	b.n	9000ac3c <etharp_query+0x34>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
9000aca2:	d1cb      	bne.n	9000ac3c <etharp_query+0x34>
9000aca4:	462e      	mov	r6, r5
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
9000aca6:	4f1e      	ldr	r7, [pc, #120]	; (9000ad20 <etharp_query+0x118>)
9000aca8:	f8df 9088 	ldr.w	r9, [pc, #136]	; 9000ad34 <etharp_query+0x12c>
9000acac:	f8df a078 	ldr.w	sl, [pc, #120]	; 9000ad28 <etharp_query+0x120>
9000acb0:	8972      	ldrh	r2, [r6, #10]
9000acb2:	8933      	ldrh	r3, [r6, #8]
9000acb4:	429a      	cmp	r2, r3
9000acb6:	d108      	bne.n	9000acca <etharp_query+0xc2>
9000acb8:	6833      	ldr	r3, [r6, #0]
9000acba:	b133      	cbz	r3, 9000acca <etharp_query+0xc2>
9000acbc:	463b      	mov	r3, r7
9000acbe:	f240 32f1 	movw	r2, #1009	; 0x3f1
9000acc2:	4649      	mov	r1, r9
9000acc4:	4650      	mov	r0, sl
9000acc6:	f006 ff71 	bl	90011bac <iprintf>
      if (PBUF_NEEDS_COPY(p)) {
9000acca:	7b33      	ldrb	r3, [r6, #12]
9000accc:	065b      	lsls	r3, r3, #25
9000acce:	d415      	bmi.n	9000acfc <etharp_query+0xf4>
      p = p->next;
9000acd0:	6836      	ldr	r6, [r6, #0]
    while (p) {
9000acd2:	2e00      	cmp	r6, #0
9000acd4:	d1ec      	bne.n	9000acb0 <etharp_query+0xa8>
      pbuf_ref(p);
9000acd6:	4628      	mov	r0, r5
9000acd8:	f002 f93c 	bl	9000cf54 <pbuf_ref>
      if (arp_table[i].q != NULL) {
9000acdc:	2618      	movs	r6, #24
9000acde:	fb06 f304 	mul.w	r3, r6, r4
9000ace2:	f858 0003 	ldr.w	r0, [r8, r3]
9000ace6:	b108      	cbz	r0, 9000acec <etharp_query+0xe4>
        pbuf_free(arp_table[i].q);
9000ace8:	f001 ffda 	bl	9000cca0 <pbuf_free>
      arp_table[i].q = p;
9000acec:	4374      	muls	r4, r6
      result = ERR_OK;
9000acee:	2000      	movs	r0, #0
      arp_table[i].q = p;
9000acf0:	f848 5004 	str.w	r5, [r8, r4]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
9000acf4:	e7a2      	b.n	9000ac3c <etharp_query+0x34>
    return ERR_ARG;
9000acf6:	f06f 000f 	mvn.w	r0, #15
9000acfa:	e79f      	b.n	9000ac3c <etharp_query+0x34>
      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
9000acfc:	462a      	mov	r2, r5
9000acfe:	f44f 7120 	mov.w	r1, #640	; 0x280
9000ad02:	200e      	movs	r0, #14
9000ad04:	f002 fae8 	bl	9000d2d8 <pbuf_clone>
    if (p != NULL) {
9000ad08:	4605      	mov	r5, r0
9000ad0a:	2800      	cmp	r0, #0
9000ad0c:	d1e6      	bne.n	9000acdc <etharp_query+0xd4>
      result = ERR_MEM;
9000ad0e:	f04f 30ff 	mov.w	r0, #4294967295
9000ad12:	e793      	b.n	9000ac3c <etharp_query+0x34>
  if (is_new_entry || (q == NULL)) {
9000ad14:	2d00      	cmp	r5, #0
9000ad16:	d0a9      	beq.n	9000ac6c <etharp_query+0x64>
  err_t result = ERR_MEM;
9000ad18:	f04f 30ff 	mov.w	r0, #4294967295
9000ad1c:	e7ac      	b.n	9000ac78 <etharp_query+0x70>
9000ad1e:	bf00      	nop
9000ad20:	90013720 	.word	0x90013720
9000ad24:	90013883 	.word	0x90013883
9000ad28:	90012aff 	.word	0x90012aff
9000ad2c:	2400a0e4 	.word	0x2400a0e4
9000ad30:	24009ff4 	.word	0x24009ff4
9000ad34:	90013891 	.word	0x90013891

9000ad38 <etharp_output>:
{
9000ad38:	b5f0      	push	{r4, r5, r6, r7, lr}
9000ad3a:	460e      	mov	r6, r1
9000ad3c:	b085      	sub	sp, #20
9000ad3e:	4615      	mov	r5, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
9000ad40:	4604      	mov	r4, r0
9000ad42:	b930      	cbnz	r0, 9000ad52 <etharp_output+0x1a>
9000ad44:	4b44      	ldr	r3, [pc, #272]	; (9000ae58 <etharp_output+0x120>)
9000ad46:	f240 321e 	movw	r2, #798	; 0x31e
9000ad4a:	4944      	ldr	r1, [pc, #272]	; (9000ae5c <etharp_output+0x124>)
9000ad4c:	4844      	ldr	r0, [pc, #272]	; (9000ae60 <etharp_output+0x128>)
9000ad4e:	f006 ff2d 	bl	90011bac <iprintf>
  LWIP_ASSERT("q != NULL", q != NULL);
9000ad52:	b936      	cbnz	r6, 9000ad62 <etharp_output+0x2a>
9000ad54:	4b40      	ldr	r3, [pc, #256]	; (9000ae58 <etharp_output+0x120>)
9000ad56:	f240 321f 	movw	r2, #799	; 0x31f
9000ad5a:	4942      	ldr	r1, [pc, #264]	; (9000ae64 <etharp_output+0x12c>)
9000ad5c:	4840      	ldr	r0, [pc, #256]	; (9000ae60 <etharp_output+0x128>)
9000ad5e:	f006 ff25 	bl	90011bac <iprintf>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
9000ad62:	b935      	cbnz	r5, 9000ad72 <etharp_output+0x3a>
9000ad64:	4b3c      	ldr	r3, [pc, #240]	; (9000ae58 <etharp_output+0x120>)
9000ad66:	f44f 7248 	mov.w	r2, #800	; 0x320
9000ad6a:	493f      	ldr	r1, [pc, #252]	; (9000ae68 <etharp_output+0x130>)
9000ad6c:	483c      	ldr	r0, [pc, #240]	; (9000ae60 <etharp_output+0x128>)
9000ad6e:	f006 ff1d 	bl	90011bac <iprintf>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
9000ad72:	4621      	mov	r1, r4
9000ad74:	6828      	ldr	r0, [r5, #0]
9000ad76:	f000 fc12 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000ad7a:	2800      	cmp	r0, #0
9000ad7c:	d167      	bne.n	9000ae4e <etharp_output+0x116>
  } else if (ip4_addr_ismulticast(ipaddr)) {
9000ad7e:	682b      	ldr	r3, [r5, #0]
9000ad80:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
9000ad84:	2ae0      	cmp	r2, #224	; 0xe0
9000ad86:	d11e      	bne.n	9000adc6 <etharp_output+0x8e>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
9000ad88:	2301      	movs	r3, #1
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
9000ad8a:	f88d 0009 	strb.w	r0, [sp, #9]
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
9000ad8e:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
9000ad92:	235e      	movs	r3, #94	; 0x5e
9000ad94:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
9000ad98:	786b      	ldrb	r3, [r5, #1]
9000ad9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9000ad9e:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
9000ada2:	78ab      	ldrb	r3, [r5, #2]
9000ada4:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
9000ada8:	78eb      	ldrb	r3, [r5, #3]
9000adaa:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
9000adae:	ab02      	add	r3, sp, #8
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
9000adb0:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000adb4:	4631      	mov	r1, r6
9000adb6:	4620      	mov	r0, r4
9000adb8:	9200      	str	r2, [sp, #0]
9000adba:	f104 022e 	add.w	r2, r4, #46	; 0x2e
9000adbe:	f000 f8ab 	bl	9000af18 <ethernet_output>
}
9000adc2:	b005      	add	sp, #20
9000adc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
9000adc6:	6862      	ldr	r2, [r4, #4]
9000adc8:	68a1      	ldr	r1, [r4, #8]
9000adca:	405a      	eors	r2, r3
9000adcc:	420a      	tst	r2, r1
9000adce:	d009      	beq.n	9000ade4 <etharp_output+0xac>
        !ip4_addr_islinklocal(ipaddr)) {
9000add0:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
9000add2:	f64f 62a9 	movw	r2, #65193	; 0xfea9
9000add6:	4293      	cmp	r3, r2
9000add8:	d004      	beq.n	9000ade4 <etharp_output+0xac>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
9000adda:	68e3      	ldr	r3, [r4, #12]
9000addc:	2b00      	cmp	r3, #0
9000adde:	d038      	beq.n	9000ae52 <etharp_output+0x11a>
            dst_addr = netif_ip4_gw(netif);
9000ade0:	f104 050c 	add.w	r5, r4, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
9000ade4:	f8df c08c 	ldr.w	ip, [pc, #140]	; 9000ae74 <etharp_output+0x13c>
9000ade8:	2118      	movs	r1, #24
9000adea:	4b20      	ldr	r3, [pc, #128]	; (9000ae6c <etharp_output+0x134>)
9000adec:	f89c 2000 	ldrb.w	r2, [ip]
9000adf0:	fb01 3302 	mla	r3, r1, r2, r3
9000adf4:	7d19      	ldrb	r1, [r3, #20]
9000adf6:	2901      	cmp	r1, #1
9000adf8:	d90d      	bls.n	9000ae16 <etharp_output+0xde>
9000adfa:	6899      	ldr	r1, [r3, #8]
9000adfc:	42a1      	cmp	r1, r4
9000adfe:	d10a      	bne.n	9000ae16 <etharp_output+0xde>
            (arp_table[etharp_cached_entry].netif == netif) &&
9000ae00:	6829      	ldr	r1, [r5, #0]
9000ae02:	685b      	ldr	r3, [r3, #4]
9000ae04:	4299      	cmp	r1, r3
9000ae06:	d106      	bne.n	9000ae16 <etharp_output+0xde>
        return etharp_output_to_arp_index(netif, q, i);
9000ae08:	4631      	mov	r1, r6
9000ae0a:	4620      	mov	r0, r4
}
9000ae0c:	b005      	add	sp, #20
9000ae0e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        return etharp_output_to_arp_index(netif, q, i);
9000ae12:	f7ff bea3 	b.w	9000ab5c <etharp_output_to_arp_index>
9000ae16:	4b15      	ldr	r3, [pc, #84]	; (9000ae6c <etharp_output+0x134>)
{
9000ae18:	2100      	movs	r1, #0
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
9000ae1a:	7d1f      	ldrb	r7, [r3, #20]
9000ae1c:	b2ca      	uxtb	r2, r1
9000ae1e:	2f01      	cmp	r7, #1
9000ae20:	d909      	bls.n	9000ae36 <etharp_output+0xfe>
9000ae22:	689f      	ldr	r7, [r3, #8]
9000ae24:	42a7      	cmp	r7, r4
9000ae26:	d106      	bne.n	9000ae36 <etharp_output+0xfe>
          (arp_table[i].netif == netif) &&
9000ae28:	685f      	ldr	r7, [r3, #4]
9000ae2a:	6828      	ldr	r0, [r5, #0]
9000ae2c:	42b8      	cmp	r0, r7
9000ae2e:	d102      	bne.n	9000ae36 <etharp_output+0xfe>
        ETHARP_SET_ADDRHINT(netif, i);
9000ae30:	f88c 2000 	strb.w	r2, [ip]
9000ae34:	e7e8      	b.n	9000ae08 <etharp_output+0xd0>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
9000ae36:	3101      	adds	r1, #1
9000ae38:	3318      	adds	r3, #24
9000ae3a:	290a      	cmp	r1, #10
9000ae3c:	d1ed      	bne.n	9000ae1a <etharp_output+0xe2>
    return etharp_query(netif, dst_addr, q);
9000ae3e:	4632      	mov	r2, r6
9000ae40:	4629      	mov	r1, r5
9000ae42:	4620      	mov	r0, r4
}
9000ae44:	b005      	add	sp, #20
9000ae46:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return etharp_query(netif, dst_addr, q);
9000ae4a:	f7ff bedd 	b.w	9000ac08 <etharp_query>
    dest = (const struct eth_addr *)&ethbroadcast;
9000ae4e:	4b08      	ldr	r3, [pc, #32]	; (9000ae70 <etharp_output+0x138>)
9000ae50:	e7ae      	b.n	9000adb0 <etharp_output+0x78>
            return ERR_RTE;
9000ae52:	f06f 0003 	mvn.w	r0, #3
9000ae56:	e7b4      	b.n	9000adc2 <etharp_output+0x8a>
9000ae58:	90013720 	.word	0x90013720
9000ae5c:	90013511 	.word	0x90013511
9000ae60:	90012aff 	.word	0x90012aff
9000ae64:	90014386 	.word	0x90014386
9000ae68:	90013810 	.word	0x90013810
9000ae6c:	24009ff4 	.word	0x24009ff4
9000ae70:	90013918 	.word	0x90013918
9000ae74:	2400a0e4 	.word	0x2400a0e4

9000ae78 <ethernet_input>:
  u16_t next_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  LWIP_ASSERT_CORE_LOCKED();

  if (p->len <= SIZEOF_ETH_HDR) {
9000ae78:	8943      	ldrh	r3, [r0, #10]
9000ae7a:	2b0e      	cmp	r3, #14
{
9000ae7c:	b570      	push	{r4, r5, r6, lr}
9000ae7e:	4604      	mov	r4, r0
9000ae80:	460d      	mov	r5, r1
  if (p->len <= SIZEOF_ETH_HDR) {
9000ae82:	d91a      	bls.n	9000aeba <ethernet_input+0x42>
    ETHARP_STATS_INC(etharp.drop);
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  if (p->if_idx == NETIF_NO_INDEX) {
9000ae84:	7bc3      	ldrb	r3, [r0, #15]
9000ae86:	b91b      	cbnz	r3, 9000ae90 <ethernet_input+0x18>
    p->if_idx = netif_get_index(netif);
9000ae88:	f891 3038 	ldrb.w	r3, [r1, #56]	; 0x38
9000ae8c:	3301      	adds	r3, #1
9000ae8e:	73c3      	strb	r3, [r0, #15]
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
9000ae90:	6860      	ldr	r0, [r4, #4]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
9000ae92:	7803      	ldrb	r3, [r0, #0]
  type = ethhdr->type;
9000ae94:	8986      	ldrh	r6, [r0, #12]
  if (ethhdr->dest.addr[0] & 1) {
9000ae96:	07d9      	lsls	r1, r3, #31
9000ae98:	d50a      	bpl.n	9000aeb0 <ethernet_input+0x38>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
9000ae9a:	2b01      	cmp	r3, #1
9000ae9c:	d111      	bne.n	9000aec2 <ethernet_input+0x4a>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
9000ae9e:	7843      	ldrb	r3, [r0, #1]
9000aea0:	b933      	cbnz	r3, 9000aeb0 <ethernet_input+0x38>
9000aea2:	7883      	ldrb	r3, [r0, #2]
9000aea4:	2b5e      	cmp	r3, #94	; 0x5e
9000aea6:	d103      	bne.n	9000aeb0 <ethernet_input+0x38>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
9000aea8:	7b63      	ldrb	r3, [r4, #13]
9000aeaa:	f043 0310 	orr.w	r3, r3, #16
      p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
9000aeae:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
9000aeb0:	2e08      	cmp	r6, #8
9000aeb2:	d010      	beq.n	9000aed6 <ethernet_input+0x5e>
9000aeb4:	f5b6 6fc1 	cmp.w	r6, #1544	; 0x608
9000aeb8:	d01d      	beq.n	9000aef6 <ethernet_input+0x7e>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
9000aeba:	4620      	mov	r0, r4
9000aebc:	f001 fef0 	bl	9000cca0 <pbuf_free>
  return ERR_OK;
9000aec0:	e017      	b.n	9000aef2 <ethernet_input+0x7a>
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
9000aec2:	2206      	movs	r2, #6
9000aec4:	4913      	ldr	r1, [pc, #76]	; (9000af14 <ethernet_input+0x9c>)
9000aec6:	f006 fd6b 	bl	900119a0 <memcmp>
9000aeca:	2800      	cmp	r0, #0
9000aecc:	d1f0      	bne.n	9000aeb0 <ethernet_input+0x38>
      p->flags |= PBUF_FLAG_LLBCAST;
9000aece:	7b63      	ldrb	r3, [r4, #13]
9000aed0:	f043 0308 	orr.w	r3, r3, #8
9000aed4:	e7eb      	b.n	9000aeae <ethernet_input+0x36>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
9000aed6:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
9000aeda:	071a      	lsls	r2, r3, #28
9000aedc:	d5ed      	bpl.n	9000aeba <ethernet_input+0x42>
      if (pbuf_remove_header(p, next_hdr_offset)) {
9000aede:	210e      	movs	r1, #14
9000aee0:	4620      	mov	r0, r4
9000aee2:	f001 fea9 	bl	9000cc38 <pbuf_remove_header>
9000aee6:	2800      	cmp	r0, #0
9000aee8:	d1e7      	bne.n	9000aeba <ethernet_input+0x42>
        ip4_input(p, netif);
9000aeea:	4629      	mov	r1, r5
9000aeec:	4620      	mov	r0, r4
9000aeee:	f000 f9fb 	bl	9000b2e8 <ip4_input>
}
9000aef2:	2000      	movs	r0, #0
9000aef4:	bd70      	pop	{r4, r5, r6, pc}
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
9000aef6:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
9000aefa:	071b      	lsls	r3, r3, #28
9000aefc:	d5dd      	bpl.n	9000aeba <ethernet_input+0x42>
      if (pbuf_remove_header(p, next_hdr_offset)) {
9000aefe:	210e      	movs	r1, #14
9000af00:	4620      	mov	r0, r4
9000af02:	f001 fe99 	bl	9000cc38 <pbuf_remove_header>
9000af06:	2800      	cmp	r0, #0
9000af08:	d1d7      	bne.n	9000aeba <ethernet_input+0x42>
        etharp_input(p, netif);
9000af0a:	4629      	mov	r1, r5
9000af0c:	4620      	mov	r0, r4
9000af0e:	f7ff fd35 	bl	9000a97c <etharp_input>
      break;
9000af12:	e7ee      	b.n	9000aef2 <ethernet_input+0x7a>
9000af14:	90013918 	.word	0x90013918

9000af18 <ethernet_output>:
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
err_t
ethernet_output(struct netif * netif, struct pbuf * p,
                const struct eth_addr * src, const struct eth_addr * dst,
                u16_t eth_type) {
9000af18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9000af1c:	460d      	mov	r5, r1
9000af1e:	4604      	mov	r4, r0
  struct eth_hdr *ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
9000af20:	f8bd 0018 	ldrh.w	r0, [sp, #24]
                u16_t eth_type) {
9000af24:	4616      	mov	r6, r2
9000af26:	461f      	mov	r7, r3
  u16_t eth_type_be = lwip_htons(eth_type);
9000af28:	f7fe f92a 	bl	90009180 <lwip_htons>

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
9000af2c:	210e      	movs	r1, #14
  u16_t eth_type_be = lwip_htons(eth_type);
9000af2e:	4680      	mov	r8, r0
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
9000af30:	4628      	mov	r0, r5
9000af32:	f001 fe7d 	bl	9000cc30 <pbuf_add_header>
9000af36:	b9e0      	cbnz	r0, 9000af72 <ethernet_output+0x5a>
    }
  }

  LWIP_ASSERT_CORE_LOCKED();

  ethhdr = (struct eth_hdr *)p->payload;
9000af38:	6869      	ldr	r1, [r5, #4]
  ethhdr->type = eth_type_be;
9000af3a:	f8a1 800c 	strh.w	r8, [r1, #12]
  SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
9000af3e:	683b      	ldr	r3, [r7, #0]
9000af40:	600b      	str	r3, [r1, #0]
9000af42:	88bb      	ldrh	r3, [r7, #4]
9000af44:	808b      	strh	r3, [r1, #4]
  SMEMCPY(&ethhdr->src,  src, ETH_HWADDR_LEN);
9000af46:	6833      	ldr	r3, [r6, #0]
9000af48:	f8c1 3006 	str.w	r3, [r1, #6]
9000af4c:	88b3      	ldrh	r3, [r6, #4]
9000af4e:	814b      	strh	r3, [r1, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
9000af50:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
9000af54:	2b06      	cmp	r3, #6
9000af56:	d006      	beq.n	9000af66 <ethernet_output+0x4e>
9000af58:	4b08      	ldr	r3, [pc, #32]	; (9000af7c <ethernet_output+0x64>)
9000af5a:	f44f 7299 	mov.w	r2, #306	; 0x132
9000af5e:	4908      	ldr	r1, [pc, #32]	; (9000af80 <ethernet_output+0x68>)
9000af60:	4808      	ldr	r0, [pc, #32]	; (9000af84 <ethernet_output+0x6c>)
9000af62:	f006 fe23 	bl	90011bac <iprintf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
              ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
9000af66:	69a3      	ldr	r3, [r4, #24]
9000af68:	4629      	mov	r1, r5
9000af6a:	4620      	mov	r0, r4
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
              ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
9000af6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return netif->linkoutput(netif, p);
9000af70:	4718      	bx	r3
}
9000af72:	f06f 0001 	mvn.w	r0, #1
9000af76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9000af7a:	bf00      	nop
9000af7c:	900138ab 	.word	0x900138ab
9000af80:	900138e7 	.word	0x900138e7
9000af84:	90012aff 	.word	0x90012aff

9000af88 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
9000af88:	b5f0      	push	{r4, r5, r6, r7, lr}
9000af8a:	4604      	mov	r4, r0
9000af8c:	b087      	sub	sp, #28
9000af8e:	460f      	mov	r7, r1
9000af90:	4616      	mov	r6, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
9000af92:	2124      	movs	r1, #36	; 0x24
9000af94:	f44f 7220 	mov.w	r2, #640	; 0x280
9000af98:	2022      	movs	r0, #34	; 0x22
9000af9a:	f001 fee9 	bl	9000cd70 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
9000af9e:	4605      	mov	r5, r0
9000afa0:	2800      	cmp	r0, #0
9000afa2:	d039      	beq.n	9000b018 <icmp_send_response+0x90>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
9000afa4:	8943      	ldrh	r3, [r0, #10]
9000afa6:	2b23      	cmp	r3, #35	; 0x23
9000afa8:	d806      	bhi.n	9000afb8 <icmp_send_response+0x30>
9000afaa:	4b1c      	ldr	r3, [pc, #112]	; (9000b01c <icmp_send_response+0x94>)
9000afac:	f44f 72b4 	mov.w	r2, #360	; 0x168
9000afb0:	491b      	ldr	r1, [pc, #108]	; (9000b020 <icmp_send_response+0x98>)
9000afb2:	481c      	ldr	r0, [pc, #112]	; (9000b024 <icmp_send_response+0x9c>)
9000afb4:	f006 fdfa 	bl	90011bac <iprintf>
              (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
9000afb8:	6860      	ldr	r0, [r4, #4]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
9000afba:	2300      	movs	r3, #0
  icmphdr = (struct icmp_echo_hdr *)q->payload;
9000afbc:	686c      	ldr	r4, [r5, #4]
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
9000afbe:	f100 011c 	add.w	r1, r0, #28
  icmphdr->id = 0;
9000afc2:	7123      	strb	r3, [r4, #4]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
9000afc4:	f104 0208 	add.w	r2, r4, #8
  icmphdr->id = 0;
9000afc8:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
9000afca:	71a3      	strb	r3, [r4, #6]
9000afcc:	71e3      	strb	r3, [r4, #7]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
9000afce:	4603      	mov	r3, r0
  icmphdr->type = type;
9000afd0:	7027      	strb	r7, [r4, #0]
  icmphdr->code = code;
9000afd2:	7066      	strb	r6, [r4, #1]
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
9000afd4:	f853 6b04 	ldr.w	r6, [r3], #4
9000afd8:	428b      	cmp	r3, r1
9000afda:	f842 6b04 	str.w	r6, [r2], #4
9000afde:	d1f9      	bne.n	9000afd4 <icmp_send_response+0x4c>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
9000afe0:	68c3      	ldr	r3, [r0, #12]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
9000afe2:	a805      	add	r0, sp, #20
  ip4_addr_copy(iphdr_src, iphdr->src);
9000afe4:	9305      	str	r3, [sp, #20]
  netif = ip4_route(&iphdr_src);
9000afe6:	f000 f951 	bl	9000b28c <ip4_route>
#endif
  if (netif != NULL) {
9000afea:	4607      	mov	r7, r0
9000afec:	b188      	cbz	r0, 9000b012 <icmp_send_response+0x8a>
    /* calculate checksum */
    icmphdr->chksum = 0;
9000afee:	2600      	movs	r6, #0
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
9000aff0:	8969      	ldrh	r1, [r5, #10]
9000aff2:	4620      	mov	r0, r4
    icmphdr->chksum = 0;
9000aff4:	70a6      	strb	r6, [r4, #2]
9000aff6:	70e6      	strb	r6, [r4, #3]
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
9000aff8:	f000 f8f3 	bl	9000b1e2 <inet_chksum>
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
9000affc:	2301      	movs	r3, #1
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
9000affe:	8060      	strh	r0, [r4, #2]
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
9000b000:	aa05      	add	r2, sp, #20
9000b002:	4631      	mov	r1, r6
9000b004:	4628      	mov	r0, r5
9000b006:	9702      	str	r7, [sp, #8]
9000b008:	e9cd 6300 	strd	r6, r3, [sp]
9000b00c:	23ff      	movs	r3, #255	; 0xff
9000b00e:	f000 fab5 	bl	9000b57c <ip4_output_if>
  }
  pbuf_free(q);
9000b012:	4628      	mov	r0, r5
9000b014:	f001 fe44 	bl	9000cca0 <pbuf_free>
}
9000b018:	b007      	add	sp, #28
9000b01a:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000b01c:	90013924 	.word	0x90013924
9000b020:	90013960 	.word	0x90013960
9000b024:	90012aff 	.word	0x90012aff

9000b028 <icmp_input>:
{
9000b028:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  iphdr_in = ip4_current_header();
9000b02c:	f8df 8144 	ldr.w	r8, [pc, #324]	; 9000b174 <icmp_input+0x14c>
{
9000b030:	b087      	sub	sp, #28
9000b032:	4604      	mov	r4, r0
9000b034:	460f      	mov	r7, r1
  iphdr_in = ip4_current_header();
9000b036:	f8d8 9008 	ldr.w	r9, [r8, #8]
  hlen = IPH_HL_BYTES(iphdr_in);
9000b03a:	f899 5000 	ldrb.w	r5, [r9]
9000b03e:	f005 050f 	and.w	r5, r5, #15
9000b042:	00ad      	lsls	r5, r5, #2
  if (hlen < IP_HLEN) {
9000b044:	2d13      	cmp	r5, #19
9000b046:	d918      	bls.n	9000b07a <icmp_input+0x52>
  if (p->len < sizeof(u16_t) * 2) {
9000b048:	8943      	ldrh	r3, [r0, #10]
9000b04a:	2b03      	cmp	r3, #3
9000b04c:	d915      	bls.n	9000b07a <icmp_input+0x52>
  type = *((u8_t *)p->payload);
9000b04e:	6843      	ldr	r3, [r0, #4]
  switch (type) {
9000b050:	781b      	ldrb	r3, [r3, #0]
9000b052:	2b08      	cmp	r3, #8
9000b054:	d111      	bne.n	9000b07a <icmp_input+0x52>
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
9000b056:	f8d8 0014 	ldr.w	r0, [r8, #20]
9000b05a:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
9000b05e:	2be0      	cmp	r3, #224	; 0xe0
9000b060:	d00b      	beq.n	9000b07a <icmp_input+0x52>
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
9000b062:	f8d8 1000 	ldr.w	r1, [r8]
9000b066:	f000 fa9a 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000b06a:	b930      	cbnz	r0, 9000b07a <icmp_input+0x52>
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
9000b06c:	8923      	ldrh	r3, [r4, #8]
9000b06e:	2b07      	cmp	r3, #7
9000b070:	d903      	bls.n	9000b07a <icmp_input+0x52>
        if (inet_chksum_pbuf(p) != 0) {
9000b072:	4620      	mov	r0, r4
9000b074:	f000 f8bb 	bl	9000b1ee <inet_chksum_pbuf>
9000b078:	b128      	cbz	r0, 9000b086 <icmp_input+0x5e>
  pbuf_free(p);
9000b07a:	4620      	mov	r0, r4
}
9000b07c:	b007      	add	sp, #28
9000b07e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  pbuf_free(p);
9000b082:	f001 be0d 	b.w	9000cca0 <pbuf_free>
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
9000b086:	f105 010e 	add.w	r1, r5, #14
9000b08a:	4620      	mov	r0, r4
9000b08c:	9105      	str	r1, [sp, #20]
9000b08e:	f001 fdcf 	bl	9000cc30 <pbuf_add_header>
9000b092:	9905      	ldr	r1, [sp, #20]
9000b094:	2800      	cmp	r0, #0
9000b096:	d057      	beq.n	9000b148 <icmp_input+0x120>
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
9000b098:	8923      	ldrh	r3, [r4, #8]
9000b09a:	1959      	adds	r1, r3, r5
9000b09c:	b289      	uxth	r1, r1
        if (alloc_len < p->tot_len) {
9000b09e:	428b      	cmp	r3, r1
9000b0a0:	d8eb      	bhi.n	9000b07a <icmp_input+0x52>
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
9000b0a2:	f44f 7220 	mov.w	r2, #640	; 0x280
9000b0a6:	200e      	movs	r0, #14
9000b0a8:	f001 fe62 	bl	9000cd70 <pbuf_alloc>
        if (r == NULL) {
9000b0ac:	4606      	mov	r6, r0
9000b0ae:	2800      	cmp	r0, #0
9000b0b0:	d0e3      	beq.n	9000b07a <icmp_input+0x52>
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
9000b0b2:	8942      	ldrh	r2, [r0, #10]
9000b0b4:	f105 0308 	add.w	r3, r5, #8
9000b0b8:	429a      	cmp	r2, r3
9000b0ba:	d203      	bcs.n	9000b0c4 <icmp_input+0x9c>
          pbuf_free(r);
9000b0bc:	4630      	mov	r0, r6
9000b0be:	f001 fdef 	bl	9000cca0 <pbuf_free>
          goto icmperr;
9000b0c2:	e7da      	b.n	9000b07a <icmp_input+0x52>
        MEMCPY(r->payload, iphdr_in, hlen);
9000b0c4:	4649      	mov	r1, r9
9000b0c6:	462a      	mov	r2, r5
9000b0c8:	6840      	ldr	r0, [r0, #4]
9000b0ca:	f006 fc79 	bl	900119c0 <memcpy>
        if (pbuf_remove_header(r, hlen)) {
9000b0ce:	4629      	mov	r1, r5
9000b0d0:	4630      	mov	r0, r6
9000b0d2:	f001 fdb1 	bl	9000cc38 <pbuf_remove_header>
9000b0d6:	b130      	cbz	r0, 9000b0e6 <icmp_input+0xbe>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
9000b0d8:	4b21      	ldr	r3, [pc, #132]	; (9000b160 <icmp_input+0x138>)
9000b0da:	22b6      	movs	r2, #182	; 0xb6
9000b0dc:	4921      	ldr	r1, [pc, #132]	; (9000b164 <icmp_input+0x13c>)
9000b0de:	4822      	ldr	r0, [pc, #136]	; (9000b168 <icmp_input+0x140>)
9000b0e0:	f006 fd64 	bl	90011bac <iprintf>
          pbuf_free(r);
9000b0e4:	e7ea      	b.n	9000b0bc <icmp_input+0x94>
        if (pbuf_copy(r, p) != ERR_OK) {
9000b0e6:	4621      	mov	r1, r4
9000b0e8:	4630      	mov	r0, r6
9000b0ea:	f001 ff93 	bl	9000d014 <pbuf_copy>
9000b0ee:	2800      	cmp	r0, #0
9000b0f0:	d1e4      	bne.n	9000b0bc <icmp_input+0x94>
        pbuf_free(p);
9000b0f2:	4620      	mov	r0, r4
9000b0f4:	4634      	mov	r4, r6
9000b0f6:	f001 fdd3 	bl	9000cca0 <pbuf_free>
      if (pbuf_add_header(p, hlen)) {
9000b0fa:	4629      	mov	r1, r5
9000b0fc:	4620      	mov	r0, r4
      iecho = (struct icmp_echo_hdr *)p->payload;
9000b0fe:	6866      	ldr	r6, [r4, #4]
      if (pbuf_add_header(p, hlen)) {
9000b100:	f001 fd96 	bl	9000cc30 <pbuf_add_header>
9000b104:	2800      	cmp	r0, #0
9000b106:	d1b8      	bne.n	9000b07a <icmp_input+0x52>
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
9000b108:	6861      	ldr	r1, [r4, #4]
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
9000b10a:	f64f 72f7 	movw	r2, #65527	; 0xfff7
        ip4_addr_copy(iphdr->src, *src);
9000b10e:	f8d8 3014 	ldr.w	r3, [r8, #20]
9000b112:	60cb      	str	r3, [r1, #12]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
9000b114:	f8d8 3010 	ldr.w	r3, [r8, #16]
9000b118:	610b      	str	r3, [r1, #16]
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
9000b11a:	8873      	ldrh	r3, [r6, #2]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
9000b11c:	7030      	strb	r0, [r6, #0]
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
9000b11e:	4620      	mov	r0, r4
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
9000b120:	4293      	cmp	r3, r2
        IPH_CHKSUM_SET(iphdr, 0);
9000b122:	f04f 0200 	mov.w	r2, #0
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
9000b126:	bf8c      	ite	hi
9000b128:	3309      	addhi	r3, #9
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
9000b12a:	3308      	addls	r3, #8
9000b12c:	b29b      	uxth	r3, r3
9000b12e:	8073      	strh	r3, [r6, #2]
        IPH_TTL_SET(iphdr, ICMP_TTL);
9000b130:	23ff      	movs	r3, #255	; 0xff
        IPH_CHKSUM_SET(iphdr, 0);
9000b132:	728a      	strb	r2, [r1, #10]
        IPH_TTL_SET(iphdr, ICMP_TTL);
9000b134:	720b      	strb	r3, [r1, #8]
        IPH_CHKSUM_SET(iphdr, 0);
9000b136:	72ca      	strb	r2, [r1, #11]
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
9000b138:	2101      	movs	r1, #1
9000b13a:	9702      	str	r7, [sp, #8]
9000b13c:	e9cd 2100 	strd	r2, r1, [sp]
9000b140:	490a      	ldr	r1, [pc, #40]	; (9000b16c <icmp_input+0x144>)
9000b142:	f000 fa1b 	bl	9000b57c <ip4_output_if>
  pbuf_free(p);
9000b146:	e798      	b.n	9000b07a <icmp_input+0x52>
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
9000b148:	4620      	mov	r0, r4
9000b14a:	f001 fd75 	bl	9000cc38 <pbuf_remove_header>
9000b14e:	2800      	cmp	r0, #0
9000b150:	d0d3      	beq.n	9000b0fa <icmp_input+0xd2>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
9000b152:	4b03      	ldr	r3, [pc, #12]	; (9000b160 <icmp_input+0x138>)
9000b154:	22c7      	movs	r2, #199	; 0xc7
9000b156:	4906      	ldr	r1, [pc, #24]	; (9000b170 <icmp_input+0x148>)
9000b158:	4803      	ldr	r0, [pc, #12]	; (9000b168 <icmp_input+0x140>)
9000b15a:	f006 fd27 	bl	90011bac <iprintf>
          goto icmperr;
9000b15e:	e78c      	b.n	9000b07a <icmp_input+0x52>
9000b160:	90013924 	.word	0x90013924
9000b164:	9001398c 	.word	0x9001398c
9000b168:	90012aff 	.word	0x90012aff
9000b16c:	2400a0fc 	.word	0x2400a0fc
9000b170:	900139c1 	.word	0x900139c1
9000b174:	2400a0e8 	.word	0x2400a0e8

9000b178 <icmp_dest_unreach>:
{
9000b178:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_DUR, t);
9000b17a:	2103      	movs	r1, #3
9000b17c:	f7ff bf04 	b.w	9000af88 <icmp_send_response>

9000b180 <icmp_time_exceeded>:
{
9000b180:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_TE, t);
9000b182:	210b      	movs	r1, #11
9000b184:	f7ff bf00 	b.w	9000af88 <icmp_send_response>

9000b188 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
9000b188:	b513      	push	{r0, r1, r4, lr}
  const u8_t *pb = (const u8_t *)dataptr;
  const u16_t *ps;
  u16_t t = 0;
9000b18a:	2300      	movs	r3, #0
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
9000b18c:	f010 0401 	ands.w	r4, r0, #1
  u16_t t = 0;
9000b190:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (odd && len > 0) {
9000b194:	d007      	beq.n	9000b1a6 <lwip_standard_chksum+0x1e>
9000b196:	4299      	cmp	r1, r3
    ((u8_t *)&t)[1] = *pb++;
9000b198:	bfc2      	ittt	gt
9000b19a:	f810 3b01 	ldrbgt.w	r3, [r0], #1
    len--;
9000b19e:	f101 31ff 	addgt.w	r1, r1, #4294967295
    ((u8_t *)&t)[1] = *pb++;
9000b1a2:	f88d 3007 	strbgt.w	r3, [sp, #7]
  u32_t sum = 0;
9000b1a6:	2200      	movs	r2, #0
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
  while (len > 1) {
9000b1a8:	2901      	cmp	r1, #1
9000b1aa:	dc15      	bgt.n	9000b1d8 <lwip_standard_chksum+0x50>
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
9000b1ac:	bf04      	itt	eq
9000b1ae:	7803      	ldrbeq	r3, [r0, #0]
9000b1b0:	f88d 3006 	strbeq.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
9000b1b4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
9000b1b8:	4413      	add	r3, r2

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
9000b1ba:	b298      	uxth	r0, r3
9000b1bc:	eb00 4313 	add.w	r3, r0, r3, lsr #16
  sum = FOLD_U32T(sum);
9000b1c0:	b298      	uxth	r0, r3
9000b1c2:	eb00 4013 	add.w	r0, r0, r3, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
9000b1c6:	b124      	cbz	r4, 9000b1d2 <lwip_standard_chksum+0x4a>
    sum = SWAP_BYTES_IN_WORD(sum);
9000b1c8:	0203      	lsls	r3, r0, #8
9000b1ca:	f3c0 2007 	ubfx	r0, r0, #8, #8
9000b1ce:	b29b      	uxth	r3, r3
9000b1d0:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
}
9000b1d2:	b280      	uxth	r0, r0
9000b1d4:	b002      	add	sp, #8
9000b1d6:	bd10      	pop	{r4, pc}
    sum += *ps++;
9000b1d8:	f830 3b02 	ldrh.w	r3, [r0], #2
    len -= 2;
9000b1dc:	3902      	subs	r1, #2
    sum += *ps++;
9000b1de:	441a      	add	r2, r3
    len -= 2;
9000b1e0:	e7e2      	b.n	9000b1a8 <lwip_standard_chksum+0x20>

9000b1e2 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
9000b1e2:	b508      	push	{r3, lr}
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
9000b1e4:	f7ff ffd0 	bl	9000b188 <lwip_standard_chksum>
9000b1e8:	43c0      	mvns	r0, r0
}
9000b1ea:	b280      	uxth	r0, r0
9000b1ec:	bd08      	pop	{r3, pc}

9000b1ee <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
9000b1ee:	b570      	push	{r4, r5, r6, lr}
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
9000b1f0:	2600      	movs	r6, #0
{
9000b1f2:	4605      	mov	r5, r0

  acc = 0;
9000b1f4:	4634      	mov	r4, r6
  for (q = p; q != NULL; q = q->next) {
9000b1f6:	b945      	cbnz	r5, 9000b20a <inet_chksum_pbuf+0x1c>
      swapped = !swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
9000b1f8:	b126      	cbz	r6, 9000b204 <inet_chksum_pbuf+0x16>
    acc = SWAP_BYTES_IN_WORD(acc);
9000b1fa:	0223      	lsls	r3, r4, #8
9000b1fc:	f3c4 2407 	ubfx	r4, r4, #8, #8
9000b200:	b29b      	uxth	r3, r3
9000b202:	431c      	orrs	r4, r3
  }
  return (u16_t)~(acc & 0xffffUL);
9000b204:	43e0      	mvns	r0, r4
}
9000b206:	b280      	uxth	r0, r0
9000b208:	bd70      	pop	{r4, r5, r6, pc}
    acc += LWIP_CHKSUM(q->payload, q->len);
9000b20a:	8969      	ldrh	r1, [r5, #10]
9000b20c:	6868      	ldr	r0, [r5, #4]
9000b20e:	f7ff ffbb 	bl	9000b188 <lwip_standard_chksum>
    if (q->len % 2 != 0) {
9000b212:	896b      	ldrh	r3, [r5, #10]
    acc += LWIP_CHKSUM(q->payload, q->len);
9000b214:	4404      	add	r4, r0
    if (q->len % 2 != 0) {
9000b216:	07db      	lsls	r3, r3, #31
    acc = FOLD_U32T(acc);
9000b218:	b2a0      	uxth	r0, r4
9000b21a:	eb00 4414 	add.w	r4, r0, r4, lsr #16
    if (q->len % 2 != 0) {
9000b21e:	d506      	bpl.n	9000b22e <inet_chksum_pbuf+0x40>
      acc = SWAP_BYTES_IN_WORD(acc);
9000b220:	0223      	lsls	r3, r4, #8
9000b222:	f3c4 2407 	ubfx	r4, r4, #8, #8
9000b226:	f086 0601 	eor.w	r6, r6, #1
9000b22a:	b29b      	uxth	r3, r3
9000b22c:	431c      	orrs	r4, r3
  for (q = p; q != NULL; q = q->next) {
9000b22e:	682d      	ldr	r5, [r5, #0]
9000b230:	e7e1      	b.n	9000b1f6 <inet_chksum_pbuf+0x8>

9000b232 <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
9000b232:	b508      	push	{r3, lr}
#endif

  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
9000b234:	f002 f904 	bl	9000d440 <sys_init>
#endif /* !NO_SYS */
  mem_init();
9000b238:	f000 fdfa 	bl	9000be30 <mem_init>
  memp_init();
9000b23c:	f001 f8c2 	bl	9000c3c4 <memp_init>
  pbuf_init();
  netif_init();
9000b240:	f001 fc16 	bl	9000ca70 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
9000b244:	f006 f88a 	bl	9001135c <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
9000b248:	f002 f99a 	bl	9000d580 <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
9000b24c:	f7ff fa50 	bl	9000a6f0 <dns_init>
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
9000b250:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  sys_timeouts_init();
9000b254:	f006 b83c 	b.w	900112d0 <sys_timeouts_init>

9000b258 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
9000b258:	b508      	push	{r3, lr}
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
9000b25a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
{
9000b25e:	4601      	mov	r1, r0
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
9000b260:	f013 0301 	ands.w	r3, r3, #1
9000b264:	d00b      	beq.n	9000b27e <ip4_input_accept+0x26>
9000b266:	6843      	ldr	r3, [r0, #4]
9000b268:	b14b      	cbz	r3, 9000b27e <ip4_input_accept+0x26>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
9000b26a:	4a07      	ldr	r2, [pc, #28]	; (9000b288 <ip4_input_accept+0x30>)
9000b26c:	6950      	ldr	r0, [r2, #20]
9000b26e:	4283      	cmp	r3, r0
9000b270:	d007      	beq.n	9000b282 <ip4_input_accept+0x2a>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
9000b272:	f000 f994 	bl	9000b59e <ip4_addr_isbroadcast_u32>
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
9000b276:	3800      	subs	r0, #0
9000b278:	bf18      	it	ne
9000b27a:	2001      	movne	r0, #1
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
}
9000b27c:	bd08      	pop	{r3, pc}
  return 0;
9000b27e:	4618      	mov	r0, r3
9000b280:	e7fc      	b.n	9000b27c <ip4_input_accept+0x24>
      return 1;
9000b282:	2001      	movs	r0, #1
9000b284:	e7fa      	b.n	9000b27c <ip4_input_accept+0x24>
9000b286:	bf00      	nop
9000b288:	2400a0e8 	.word	0x2400a0e8

9000b28c <ip4_route>:
  NETIF_FOREACH(netif) {
9000b28c:	4b14      	ldr	r3, [pc, #80]	; (9000b2e0 <ip4_route+0x54>)
{
9000b28e:	4602      	mov	r2, r0
  NETIF_FOREACH(netif) {
9000b290:	6818      	ldr	r0, [r3, #0]
{
9000b292:	b530      	push	{r4, r5, lr}
  NETIF_FOREACH(netif) {
9000b294:	b978      	cbnz	r0, 9000b2b6 <ip4_route+0x2a>
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
9000b296:	4b13      	ldr	r3, [pc, #76]	; (9000b2e4 <ip4_route+0x58>)
9000b298:	681b      	ldr	r3, [r3, #0]
9000b29a:	b15b      	cbz	r3, 9000b2b4 <ip4_route+0x28>
9000b29c:	f893 1035 	ldrb.w	r1, [r3, #53]	; 0x35
9000b2a0:	f001 0105 	and.w	r1, r1, #5
9000b2a4:	2905      	cmp	r1, #5
9000b2a6:	d105      	bne.n	9000b2b4 <ip4_route+0x28>
9000b2a8:	6859      	ldr	r1, [r3, #4]
9000b2aa:	b119      	cbz	r1, 9000b2b4 <ip4_route+0x28>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
9000b2ac:	7812      	ldrb	r2, [r2, #0]
9000b2ae:	2a7f      	cmp	r2, #127	; 0x7f
9000b2b0:	bf18      	it	ne
9000b2b2:	4618      	movne	r0, r3
}
9000b2b4:	bd30      	pop	{r4, r5, pc}
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
9000b2b6:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
9000b2ba:	07cd      	lsls	r5, r1, #31
9000b2bc:	d50d      	bpl.n	9000b2da <ip4_route+0x4e>
9000b2be:	074c      	lsls	r4, r1, #29
9000b2c0:	d50b      	bpl.n	9000b2da <ip4_route+0x4e>
9000b2c2:	6843      	ldr	r3, [r0, #4]
9000b2c4:	b14b      	cbz	r3, 9000b2da <ip4_route+0x4e>
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
9000b2c6:	6814      	ldr	r4, [r2, #0]
9000b2c8:	6885      	ldr	r5, [r0, #8]
9000b2ca:	4063      	eors	r3, r4
9000b2cc:	422b      	tst	r3, r5
9000b2ce:	d0f1      	beq.n	9000b2b4 <ip4_route+0x28>
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
9000b2d0:	078b      	lsls	r3, r1, #30
9000b2d2:	d402      	bmi.n	9000b2da <ip4_route+0x4e>
9000b2d4:	68c3      	ldr	r3, [r0, #12]
9000b2d6:	429c      	cmp	r4, r3
9000b2d8:	d0ec      	beq.n	9000b2b4 <ip4_route+0x28>
  NETIF_FOREACH(netif) {
9000b2da:	6800      	ldr	r0, [r0, #0]
9000b2dc:	e7da      	b.n	9000b294 <ip4_route+0x8>
9000b2de:	bf00      	nop
9000b2e0:	2400d3a0 	.word	0x2400d3a0
9000b2e4:	2400d39c 	.word	0x2400d39c

9000b2e8 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
9000b2e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
9000b2ec:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
9000b2f0:	4604      	mov	r4, r0
9000b2f2:	460e      	mov	r6, r1
  if (IPH_V(iphdr) != 4) {
9000b2f4:	f898 5000 	ldrb.w	r5, [r8]
9000b2f8:	092b      	lsrs	r3, r5, #4
9000b2fa:	2b04      	cmp	r3, #4
9000b2fc:	d005      	beq.n	9000b30a <ip4_input+0x22>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
9000b2fe:	4620      	mov	r0, r4
9000b300:	f001 fcce 	bl	9000cca0 <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
9000b304:	2000      	movs	r0, #0
9000b306:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
9000b30a:	f8b8 0002 	ldrh.w	r0, [r8, #2]
  iphdr_hlen = IPH_HL_BYTES(iphdr);
9000b30e:	f005 050f 	and.w	r5, r5, #15
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
9000b312:	f7fd ff35 	bl	90009180 <lwip_htons>
  if (iphdr_len < p->tot_len) {
9000b316:	8923      	ldrh	r3, [r4, #8]
  iphdr_hlen = IPH_HL_BYTES(iphdr);
9000b318:	ea4f 0985 	mov.w	r9, r5, lsl #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
9000b31c:	4607      	mov	r7, r0
  if (iphdr_len < p->tot_len) {
9000b31e:	4283      	cmp	r3, r0
  iphdr_hlen = IPH_HL_BYTES(iphdr);
9000b320:	464d      	mov	r5, r9
  if (iphdr_len < p->tot_len) {
9000b322:	d903      	bls.n	9000b32c <ip4_input+0x44>
    pbuf_realloc(p, iphdr_len);
9000b324:	4601      	mov	r1, r0
9000b326:	4620      	mov	r0, r4
9000b328:	f001 fdb4 	bl	9000ce94 <pbuf_realloc>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
9000b32c:	8963      	ldrh	r3, [r4, #10]
9000b32e:	42ab      	cmp	r3, r5
9000b330:	d3e5      	bcc.n	9000b2fe <ip4_input+0x16>
9000b332:	8923      	ldrh	r3, [r4, #8]
9000b334:	42bb      	cmp	r3, r7
9000b336:	d3e2      	bcc.n	9000b2fe <ip4_input+0x16>
9000b338:	2d13      	cmp	r5, #19
9000b33a:	d9e0      	bls.n	9000b2fe <ip4_input+0x16>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
9000b33c:	f8d8 3010 	ldr.w	r3, [r8, #16]
9000b340:	4d49      	ldr	r5, [pc, #292]	; (9000b468 <ip4_input+0x180>)
9000b342:	616b      	str	r3, [r5, #20]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
9000b344:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
9000b348:	f8d8 200c 	ldr.w	r2, [r8, #12]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
9000b34c:	2be0      	cmp	r3, #224	; 0xe0
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
9000b34e:	612a      	str	r2, [r5, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
9000b350:	d143      	bne.n	9000b3da <ip4_input+0xf2>
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
9000b352:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
9000b356:	07db      	lsls	r3, r3, #31
9000b358:	d405      	bmi.n	9000b366 <ip4_input+0x7e>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
9000b35a:	f898 3009 	ldrb.w	r3, [r8, #9]
9000b35e:	2b11      	cmp	r3, #17
9000b360:	d053      	beq.n	9000b40a <ip4_input+0x122>
9000b362:	2700      	movs	r7, #0
9000b364:	e003      	b.n	9000b36e <ip4_input+0x86>
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
9000b366:	6873      	ldr	r3, [r6, #4]
9000b368:	2b00      	cmp	r3, #0
9000b36a:	d0f6      	beq.n	9000b35a <ip4_input+0x72>
9000b36c:	4637      	mov	r7, r6
      && !ip4_addr_isany_val(*ip4_current_src_addr())
9000b36e:	6928      	ldr	r0, [r5, #16]
9000b370:	b148      	cbz	r0, 9000b386 <ip4_input+0x9e>
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
9000b372:	4631      	mov	r1, r6
9000b374:	f000 f913 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000b378:	2800      	cmp	r0, #0
9000b37a:	d1c0      	bne.n	9000b2fe <ip4_input+0x16>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
9000b37c:	692b      	ldr	r3, [r5, #16]
9000b37e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
9000b382:	2be0      	cmp	r3, #224	; 0xe0
9000b384:	d0bb      	beq.n	9000b2fe <ip4_input+0x16>
  if (netif == NULL) {
9000b386:	2f00      	cmp	r7, #0
9000b388:	d0b9      	beq.n	9000b2fe <ip4_input+0x16>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
9000b38a:	f8b8 3006 	ldrh.w	r3, [r8, #6]
9000b38e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
9000b392:	b13b      	cbz	r3, 9000b3a4 <ip4_input+0xbc>
    p = ip4_reass(p);
9000b394:	4620      	mov	r0, r4
9000b396:	f000 fa85 	bl	9000b8a4 <ip4_reass>
    if (p == NULL) {
9000b39a:	4604      	mov	r4, r0
9000b39c:	2800      	cmp	r0, #0
9000b39e:	d0b1      	beq.n	9000b304 <ip4_input+0x1c>
    iphdr = (const struct ip_hdr *)p->payload;
9000b3a0:	f8d0 8004 	ldr.w	r8, [r0, #4]
  ip_data.current_ip4_header = iphdr;
9000b3a4:	f8c5 8008 	str.w	r8, [r5, #8]
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
9000b3a8:	4649      	mov	r1, r9
9000b3aa:	4620      	mov	r0, r4
  ip_data.current_input_netif = inp;
9000b3ac:	e9c5 7600 	strd	r7, r6, [r5]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
9000b3b0:	f898 3000 	ldrb.w	r3, [r8]
9000b3b4:	f003 030f 	and.w	r3, r3, #15
9000b3b8:	009b      	lsls	r3, r3, #2
9000b3ba:	81ab      	strh	r3, [r5, #12]
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
9000b3bc:	f001 fc3c 	bl	9000cc38 <pbuf_remove_header>
    switch (IPH_PROTO(iphdr)) {
9000b3c0:	f898 3009 	ldrb.w	r3, [r8, #9]
9000b3c4:	2b06      	cmp	r3, #6
9000b3c6:	d034      	beq.n	9000b432 <ip4_input+0x14a>
9000b3c8:	2b11      	cmp	r3, #17
9000b3ca:	d026      	beq.n	9000b41a <ip4_input+0x132>
9000b3cc:	2b01      	cmp	r3, #1
9000b3ce:	d135      	bne.n	9000b43c <ip4_input+0x154>
        icmp_input(p, inp);
9000b3d0:	4631      	mov	r1, r6
9000b3d2:	4620      	mov	r0, r4
9000b3d4:	f7ff fe28 	bl	9000b028 <icmp_input>
        break;
9000b3d8:	e023      	b.n	9000b422 <ip4_input+0x13a>
    if (ip4_input_accept(inp)) {
9000b3da:	4630      	mov	r0, r6
9000b3dc:	f7ff ff3c 	bl	9000b258 <ip4_input_accept>
9000b3e0:	b980      	cbnz	r0, 9000b404 <ip4_input+0x11c>
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
9000b3e2:	7d2b      	ldrb	r3, [r5, #20]
9000b3e4:	2b7f      	cmp	r3, #127	; 0x7f
9000b3e6:	d0b8      	beq.n	9000b35a <ip4_input+0x72>
        NETIF_FOREACH(netif) {
9000b3e8:	4b20      	ldr	r3, [pc, #128]	; (9000b46c <ip4_input+0x184>)
9000b3ea:	681f      	ldr	r7, [r3, #0]
9000b3ec:	2f00      	cmp	r7, #0
9000b3ee:	d0b4      	beq.n	9000b35a <ip4_input+0x72>
          if (netif == inp) {
9000b3f0:	42b7      	cmp	r7, r6
9000b3f2:	d101      	bne.n	9000b3f8 <ip4_input+0x110>
        NETIF_FOREACH(netif) {
9000b3f4:	683f      	ldr	r7, [r7, #0]
9000b3f6:	e7f9      	b.n	9000b3ec <ip4_input+0x104>
          if (ip4_input_accept(netif)) {
9000b3f8:	4638      	mov	r0, r7
9000b3fa:	f7ff ff2d 	bl	9000b258 <ip4_input_accept>
9000b3fe:	2800      	cmp	r0, #0
9000b400:	d0f8      	beq.n	9000b3f4 <ip4_input+0x10c>
9000b402:	e7b4      	b.n	9000b36e <ip4_input+0x86>
  if (netif == NULL) {
9000b404:	2e00      	cmp	r6, #0
9000b406:	d1b1      	bne.n	9000b36c <ip4_input+0x84>
9000b408:	e7a7      	b.n	9000b35a <ip4_input+0x72>
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
9000b40a:	eb08 0309 	add.w	r3, r8, r9
9000b40e:	885b      	ldrh	r3, [r3, #2]
9000b410:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
9000b414:	d1a5      	bne.n	9000b362 <ip4_input+0x7a>
9000b416:	4637      	mov	r7, r6
9000b418:	e7b5      	b.n	9000b386 <ip4_input+0x9e>
        udp_input(p, inp);
9000b41a:	4631      	mov	r1, r6
9000b41c:	4620      	mov	r0, r4
9000b41e:	f005 ffa9 	bl	90011374 <udp_input>
  ip_data.current_netif = NULL;
9000b422:	2300      	movs	r3, #0
  ip_data.current_input_netif = NULL;
9000b424:	e9c5 3300 	strd	r3, r3, [r5]
  ip_data.current_ip4_header = NULL;
9000b428:	60ab      	str	r3, [r5, #8]
  ip_data.current_ip_header_tot_len = 0;
9000b42a:	81ab      	strh	r3, [r5, #12]
  ip4_addr_set_any(ip4_current_dest_addr());
9000b42c:	e9c5 3304 	strd	r3, r3, [r5, #16]
  return ERR_OK;
9000b430:	e768      	b.n	9000b304 <ip4_input+0x1c>
        tcp_input(p, inp);
9000b432:	4631      	mov	r1, r6
9000b434:	4620      	mov	r0, r4
9000b436:	f003 fec9 	bl	9000f1cc <tcp_input>
        break;
9000b43a:	e7f2      	b.n	9000b422 <ip4_input+0x13a>
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
9000b43c:	4639      	mov	r1, r7
9000b43e:	6968      	ldr	r0, [r5, #20]
9000b440:	f000 f8ad 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000b444:	b960      	cbnz	r0, 9000b460 <ip4_input+0x178>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
9000b446:	696b      	ldr	r3, [r5, #20]
9000b448:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
9000b44c:	2be0      	cmp	r3, #224	; 0xe0
9000b44e:	d007      	beq.n	9000b460 <ip4_input+0x178>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
9000b450:	4649      	mov	r1, r9
9000b452:	4620      	mov	r0, r4
9000b454:	f001 fc1c 	bl	9000cc90 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
9000b458:	2102      	movs	r1, #2
9000b45a:	4620      	mov	r0, r4
9000b45c:	f7ff fe8c 	bl	9000b178 <icmp_dest_unreach>
        pbuf_free(p);
9000b460:	4620      	mov	r0, r4
9000b462:	f001 fc1d 	bl	9000cca0 <pbuf_free>
        break;
9000b466:	e7dc      	b.n	9000b422 <ip4_input+0x13a>
9000b468:	2400a0e8 	.word	0x2400a0e8
9000b46c:	2400d3a0 	.word	0x2400d3a0

9000b470 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
9000b470:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
9000b474:	4698      	mov	r8, r3
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
9000b476:	7b83      	ldrb	r3, [r0, #14]
{
9000b478:	4604      	mov	r4, r0
9000b47a:	4689      	mov	r9, r1
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
9000b47c:	2b01      	cmp	r3, #1
{
9000b47e:	4616      	mov	r6, r2
9000b480:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
9000b482:	d006      	beq.n	9000b492 <ip4_output_if_src+0x22>
9000b484:	4b37      	ldr	r3, [pc, #220]	; (9000b564 <ip4_output_if_src+0xf4>)
9000b486:	f44f 7255 	mov.w	r2, #852	; 0x354
9000b48a:	4937      	ldr	r1, [pc, #220]	; (9000b568 <ip4_output_if_src+0xf8>)
9000b48c:	4837      	ldr	r0, [pc, #220]	; (9000b56c <ip4_output_if_src+0xfc>)
9000b48e:	f006 fb8d 	bl	90011bac <iprintf>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
9000b492:	2e00      	cmp	r6, #0
9000b494:	d04c      	beq.n	9000b530 <ip4_output_if_src+0xc0>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
9000b496:	2114      	movs	r1, #20
9000b498:	4620      	mov	r0, r4
9000b49a:	f001 fbc9 	bl	9000cc30 <pbuf_add_header>
9000b49e:	b120      	cbz	r0, 9000b4aa <ip4_output_if_src+0x3a>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
9000b4a0:	f06f 0001 	mvn.w	r0, #1
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
}
9000b4a4:	b002      	add	sp, #8
9000b4a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
9000b4aa:	8963      	ldrh	r3, [r4, #10]
    iphdr = (struct ip_hdr *)p->payload;
9000b4ac:	6865      	ldr	r5, [r4, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
9000b4ae:	2b13      	cmp	r3, #19
9000b4b0:	d806      	bhi.n	9000b4c0 <ip4_output_if_src+0x50>
9000b4b2:	4b2c      	ldr	r3, [pc, #176]	; (9000b564 <ip4_output_if_src+0xf4>)
9000b4b4:	f44f 7262 	mov.w	r2, #904	; 0x388
9000b4b8:	492d      	ldr	r1, [pc, #180]	; (9000b570 <ip4_output_if_src+0x100>)
9000b4ba:	482c      	ldr	r0, [pc, #176]	; (9000b56c <ip4_output_if_src+0xfc>)
9000b4bc:	f006 fb76 	bl	90011bac <iprintf>
    IPH_PROTO_SET(iphdr, proto);
9000b4c0:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    IPH_TTL_SET(iphdr, ttl);
9000b4c4:	f885 8008 	strb.w	r8, [r5, #8]
    IPH_OFFSET_SET(iphdr, 0);
9000b4c8:	f04f 0800 	mov.w	r8, #0
    IPH_PROTO_SET(iphdr, proto);
9000b4cc:	726b      	strb	r3, [r5, #9]
    ip4_addr_copy(iphdr->dest, *dest);
9000b4ce:	6833      	ldr	r3, [r6, #0]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
9000b4d0:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 9000b578 <ip4_output_if_src+0x108>
    ip4_addr_copy(iphdr->dest, *dest);
9000b4d4:	612b      	str	r3, [r5, #16]
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
9000b4d6:	2345      	movs	r3, #69	; 0x45
9000b4d8:	702b      	strb	r3, [r5, #0]
    IPH_TOS_SET(iphdr, tos);
9000b4da:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
9000b4de:	706b      	strb	r3, [r5, #1]
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
9000b4e0:	8920      	ldrh	r0, [r4, #8]
9000b4e2:	f7fd fe4d 	bl	90009180 <lwip_htons>
    IPH_OFFSET_SET(iphdr, 0);
9000b4e6:	f885 8006 	strb.w	r8, [r5, #6]
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
9000b4ea:	8068      	strh	r0, [r5, #2]
    IPH_OFFSET_SET(iphdr, 0);
9000b4ec:	f885 8007 	strb.w	r8, [r5, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
9000b4f0:	f8ba 0000 	ldrh.w	r0, [sl]
9000b4f4:	f7fd fe44 	bl	90009180 <lwip_htons>
    ++ip_id;
9000b4f8:	f8ba 3000 	ldrh.w	r3, [sl]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
9000b4fc:	80a8      	strh	r0, [r5, #4]
    ++ip_id;
9000b4fe:	3301      	adds	r3, #1
9000b500:	f8aa 3000 	strh.w	r3, [sl]
    if (src == NULL) {
9000b504:	f1b9 0f00 	cmp.w	r9, #0
9000b508:	d10f      	bne.n	9000b52a <ip4_output_if_src+0xba>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
9000b50a:	4b1a      	ldr	r3, [pc, #104]	; (9000b574 <ip4_output_if_src+0x104>)
9000b50c:	681b      	ldr	r3, [r3, #0]
9000b50e:	60eb      	str	r3, [r5, #12]
    IPH_CHKSUM_SET(iphdr, 0);
9000b510:	f885 800a 	strb.w	r8, [r5, #10]
9000b514:	f885 800b 	strb.w	r8, [r5, #11]
  if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
9000b518:	6832      	ldr	r2, [r6, #0]
9000b51a:	687b      	ldr	r3, [r7, #4]
9000b51c:	429a      	cmp	r2, r3
9000b51e:	d10f      	bne.n	9000b540 <ip4_output_if_src+0xd0>
    return netif_loop_output(netif, p);
9000b520:	4621      	mov	r1, r4
9000b522:	4638      	mov	r0, r7
9000b524:	f001 f88e 	bl	9000c644 <netif_loop_output>
9000b528:	e7bc      	b.n	9000b4a4 <ip4_output_if_src+0x34>
      ip4_addr_copy(iphdr->src, *src);
9000b52a:	f8d9 3000 	ldr.w	r3, [r9]
9000b52e:	e7ee      	b.n	9000b50e <ip4_output_if_src+0x9e>
    if (p->len < IP_HLEN) {
9000b530:	8963      	ldrh	r3, [r4, #10]
9000b532:	2b13      	cmp	r3, #19
9000b534:	d9b4      	bls.n	9000b4a0 <ip4_output_if_src+0x30>
    ip4_addr_copy(dest_addr, iphdr->dest);
9000b536:	6863      	ldr	r3, [r4, #4]
    dest = &dest_addr;
9000b538:	ae01      	add	r6, sp, #4
    ip4_addr_copy(dest_addr, iphdr->dest);
9000b53a:	691b      	ldr	r3, [r3, #16]
9000b53c:	9301      	str	r3, [sp, #4]
    dest = &dest_addr;
9000b53e:	e7eb      	b.n	9000b518 <ip4_output_if_src+0xa8>
  if (netif->mtu && (p->tot_len > netif->mtu)) {
9000b540:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
9000b542:	b143      	cbz	r3, 9000b556 <ip4_output_if_src+0xe6>
9000b544:	8922      	ldrh	r2, [r4, #8]
9000b546:	429a      	cmp	r2, r3
9000b548:	d905      	bls.n	9000b556 <ip4_output_if_src+0xe6>
    return ip4_frag(p, netif, dest);
9000b54a:	4632      	mov	r2, r6
9000b54c:	4639      	mov	r1, r7
9000b54e:	4620      	mov	r0, r4
9000b550:	f000 fb82 	bl	9000bc58 <ip4_frag>
9000b554:	e7a6      	b.n	9000b4a4 <ip4_output_if_src+0x34>
  return netif->output(netif, p, dest);
9000b556:	697b      	ldr	r3, [r7, #20]
9000b558:	4632      	mov	r2, r6
9000b55a:	4621      	mov	r1, r4
9000b55c:	4638      	mov	r0, r7
9000b55e:	4798      	blx	r3
9000b560:	e7a0      	b.n	9000b4a4 <ip4_output_if_src+0x34>
9000b562:	bf00      	nop
9000b564:	900139f3 	.word	0x900139f3
9000b568:	90013a2e 	.word	0x90013a2e
9000b56c:	90012aff 	.word	0x90012aff
9000b570:	90013a3a 	.word	0x90013a3a
9000b574:	90013a68 	.word	0x90013a68
9000b578:	2400a100 	.word	0x2400a100

9000b57c <ip4_output_if>:
{
9000b57c:	b4f0      	push	{r4, r5, r6, r7}
9000b57e:	9c06      	ldr	r4, [sp, #24]
9000b580:	f89d 5010 	ldrb.w	r5, [sp, #16]
9000b584:	f89d 6014 	ldrb.w	r6, [sp, #20]
  if (dest != LWIP_IP_HDRINCL) {
9000b588:	b11a      	cbz	r2, 9000b592 <ip4_output_if+0x16>
    if (ip4_addr_isany(src)) {
9000b58a:	b109      	cbz	r1, 9000b590 <ip4_output_if+0x14>
9000b58c:	680f      	ldr	r7, [r1, #0]
9000b58e:	b907      	cbnz	r7, 9000b592 <ip4_output_if+0x16>
      src_used = netif_ip4_addr(netif);
9000b590:	1d21      	adds	r1, r4, #4
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
9000b592:	9504      	str	r5, [sp, #16]
9000b594:	e9cd 6405 	strd	r6, r4, [sp, #20]
}
9000b598:	bcf0      	pop	{r4, r5, r6, r7}
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
9000b59a:	f7ff bf69 	b.w	9000b470 <ip4_output_if_src>

9000b59e <ip4_addr_isbroadcast_u32>:
{
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
9000b59e:	1e43      	subs	r3, r0, #1
{
9000b5a0:	4602      	mov	r2, r0
  if ((~addr == IPADDR_ANY) ||
9000b5a2:	3303      	adds	r3, #3
9000b5a4:	d812      	bhi.n	9000b5cc <ip4_addr_isbroadcast_u32+0x2e>
      (addr == IPADDR_ANY)) {
    return 1;
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
9000b5a6:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
9000b5aa:	f013 0002 	ands.w	r0, r3, #2
9000b5ae:	d010      	beq.n	9000b5d2 <ip4_addr_isbroadcast_u32+0x34>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
9000b5b0:	684b      	ldr	r3, [r1, #4]
9000b5b2:	4293      	cmp	r3, r2
9000b5b4:	d00c      	beq.n	9000b5d0 <ip4_addr_isbroadcast_u32+0x32>
    return 0;
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
9000b5b6:	6888      	ldr	r0, [r1, #8]
9000b5b8:	4053      	eors	r3, r2
9000b5ba:	4203      	tst	r3, r0
9000b5bc:	d108      	bne.n	9000b5d0 <ip4_addr_isbroadcast_u32+0x32>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
9000b5be:	43c3      	mvns	r3, r0
9000b5c0:	ea22 0000 	bic.w	r0, r2, r0
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
9000b5c4:	1ac3      	subs	r3, r0, r3
9000b5c6:	4258      	negs	r0, r3
9000b5c8:	4158      	adcs	r0, r3
9000b5ca:	4770      	bx	lr
    return 1;
9000b5cc:	2001      	movs	r0, #1
9000b5ce:	4770      	bx	lr
    return 0;
9000b5d0:	2000      	movs	r0, #0
  }
}
9000b5d2:	4770      	bx	lr

9000b5d4 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
9000b5d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
9000b5d8:	6803      	ldr	r3, [r0, #0]
9000b5da:	f10d 0c04 	add.w	ip, sp, #4

  rp = buf;
9000b5de:	460d      	mov	r5, r1
  s_addr = ip4_addr_get_u32(addr);
9000b5e0:	2004      	movs	r0, #4
  int len = 0;
9000b5e2:	2600      	movs	r6, #0
  ap = (u8_t *)&s_addr;
  for (n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
9000b5e4:	f04f 0e0a 	mov.w	lr, #10
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
9000b5e8:	f04f 082e 	mov.w	r8, #46	; 0x2e
  s_addr = ip4_addr_get_u32(addr);
9000b5ec:	9301      	str	r3, [sp, #4]
  for (n = 0; n < 4; n++) {
9000b5ee:	f81c 4b01 	ldrb.w	r4, [ip], #1
    i = 0;
9000b5f2:	2700      	movs	r7, #0
      rem = *ap % (u8_t)10;
9000b5f4:	46a2      	mov	sl, r4
9000b5f6:	fbb4 f3fe 	udiv	r3, r4, lr
9000b5fa:	fb0e 4913 	mls	r9, lr, r3, r4
      *ap /= (u8_t)10;
9000b5fe:	b2dc      	uxtb	r4, r3
      inv[i++] = (char)('0' + rem);
9000b600:	463b      	mov	r3, r7
    } while (*ap);
9000b602:	f1ba 0f09 	cmp.w	sl, #9
      inv[i++] = (char)('0' + rem);
9000b606:	f107 0701 	add.w	r7, r7, #1
9000b60a:	f109 0930 	add.w	r9, r9, #48	; 0x30
9000b60e:	f103 0b08 	add.w	fp, r3, #8
9000b612:	b2ff      	uxtb	r7, r7
9000b614:	44eb      	add	fp, sp
9000b616:	f80b 9c08 	strb.w	r9, [fp, #-8]
    } while (*ap);
9000b61a:	d8eb      	bhi.n	9000b5f4 <ip4addr_ntoa_r+0x20>
9000b61c:	f80c 4c01 	strb.w	r4, [ip, #-1]
9000b620:	4637      	mov	r7, r6
9000b622:	462c      	mov	r4, r5
    while (i--) {
9000b624:	2bff      	cmp	r3, #255	; 0xff
      if (len++ >= buflen) {
9000b626:	f106 0601 	add.w	r6, r6, #1
    while (i--) {
9000b62a:	d10d      	bne.n	9000b648 <ip4addr_ntoa_r+0x74>
    if (len++ >= buflen) {
9000b62c:	4297      	cmp	r7, r2
9000b62e:	da18      	bge.n	9000b662 <ip4addr_ntoa_r+0x8e>
  for (n = 0; n < 4; n++) {
9000b630:	3801      	subs	r0, #1
    *rp++ = '.';
9000b632:	4625      	mov	r5, r4
  for (n = 0; n < 4; n++) {
9000b634:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
    *rp++ = '.';
9000b638:	f805 8b01 	strb.w	r8, [r5], #1
  for (n = 0; n < 4; n++) {
9000b63c:	d1d7      	bne.n	9000b5ee <ip4addr_ntoa_r+0x1a>
    ap++;
  }
  *--rp = 0;
9000b63e:	7020      	strb	r0, [r4, #0]
  return buf;
9000b640:	4608      	mov	r0, r1
}
9000b642:	b003      	add	sp, #12
9000b644:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (len++ >= buflen) {
9000b648:	1e5d      	subs	r5, r3, #1
9000b64a:	4297      	cmp	r7, r2
9000b64c:	b2ed      	uxtb	r5, r5
9000b64e:	da08      	bge.n	9000b662 <ip4addr_ntoa_r+0x8e>
      *rp++ = inv[i];
9000b650:	3308      	adds	r3, #8
      if (len++ >= buflen) {
9000b652:	4637      	mov	r7, r6
      *rp++ = inv[i];
9000b654:	446b      	add	r3, sp
9000b656:	f813 3c08 	ldrb.w	r3, [r3, #-8]
9000b65a:	f804 3b01 	strb.w	r3, [r4], #1
9000b65e:	462b      	mov	r3, r5
9000b660:	e7e0      	b.n	9000b624 <ip4addr_ntoa_r+0x50>
        return NULL;
9000b662:	2000      	movs	r0, #0
9000b664:	e7ed      	b.n	9000b642 <ip4addr_ntoa_r+0x6e>
	...

9000b668 <ip4addr_ntoa>:
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
9000b668:	2210      	movs	r2, #16
9000b66a:	4901      	ldr	r1, [pc, #4]	; (9000b670 <ip4addr_ntoa+0x8>)
9000b66c:	f7ff bfb2 	b.w	9000b5d4 <ip4addr_ntoa_r>
9000b670:	2400a102 	.word	0x2400a102

9000b674 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
9000b674:	b538      	push	{r3, r4, r5, lr}
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
9000b676:	4b0c      	ldr	r3, [pc, #48]	; (9000b6a8 <ip_reass_dequeue_datagram+0x34>)
{
9000b678:	4604      	mov	r4, r0
9000b67a:	460d      	mov	r5, r1
  if (reassdatagrams == ipr) {
9000b67c:	681a      	ldr	r2, [r3, #0]
9000b67e:	4282      	cmp	r2, r0
9000b680:	d107      	bne.n	9000b692 <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
9000b682:	6802      	ldr	r2, [r0, #0]
9000b684:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
9000b686:	4621      	mov	r1, r4
9000b688:	2004      	movs	r0, #4
}
9000b68a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  memp_free(MEMP_REASSDATA, ipr);
9000b68e:	f000 beed 	b.w	9000c46c <memp_free>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
9000b692:	b931      	cbnz	r1, 9000b6a2 <ip_reass_dequeue_datagram+0x2e>
9000b694:	4b05      	ldr	r3, [pc, #20]	; (9000b6ac <ip_reass_dequeue_datagram+0x38>)
9000b696:	f240 1245 	movw	r2, #325	; 0x145
9000b69a:	4905      	ldr	r1, [pc, #20]	; (9000b6b0 <ip_reass_dequeue_datagram+0x3c>)
9000b69c:	4805      	ldr	r0, [pc, #20]	; (9000b6b4 <ip_reass_dequeue_datagram+0x40>)
9000b69e:	f006 fa85 	bl	90011bac <iprintf>
    prev->next = ipr->next;
9000b6a2:	6823      	ldr	r3, [r4, #0]
9000b6a4:	602b      	str	r3, [r5, #0]
9000b6a6:	e7ee      	b.n	9000b686 <ip_reass_dequeue_datagram+0x12>
9000b6a8:	2400a114 	.word	0x2400a114
9000b6ac:	90013a70 	.word	0x90013a70
9000b6b0:	90013ab0 	.word	0x90013ab0
9000b6b4:	90012aff 	.word	0x90012aff

9000b6b8 <ip_reass_free_complete_datagram>:
  LWIP_ASSERT("prev != ipr", prev != ipr);
9000b6b8:	4281      	cmp	r1, r0
{
9000b6ba:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000b6be:	4604      	mov	r4, r0
9000b6c0:	460e      	mov	r6, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
9000b6c2:	d105      	bne.n	9000b6d0 <ip_reass_free_complete_datagram+0x18>
9000b6c4:	4b2f      	ldr	r3, [pc, #188]	; (9000b784 <ip_reass_free_complete_datagram+0xcc>)
9000b6c6:	22ab      	movs	r2, #171	; 0xab
9000b6c8:	492f      	ldr	r1, [pc, #188]	; (9000b788 <ip_reass_free_complete_datagram+0xd0>)
9000b6ca:	4830      	ldr	r0, [pc, #192]	; (9000b78c <ip_reass_free_complete_datagram+0xd4>)
9000b6cc:	f006 fa6e 	bl	90011bac <iprintf>
  if (prev != NULL) {
9000b6d0:	b146      	cbz	r6, 9000b6e4 <ip_reass_free_complete_datagram+0x2c>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
9000b6d2:	6833      	ldr	r3, [r6, #0]
9000b6d4:	42a3      	cmp	r3, r4
9000b6d6:	d005      	beq.n	9000b6e4 <ip_reass_free_complete_datagram+0x2c>
9000b6d8:	4b2a      	ldr	r3, [pc, #168]	; (9000b784 <ip_reass_free_complete_datagram+0xcc>)
9000b6da:	22ad      	movs	r2, #173	; 0xad
9000b6dc:	492c      	ldr	r1, [pc, #176]	; (9000b790 <ip_reass_free_complete_datagram+0xd8>)
9000b6de:	482b      	ldr	r0, [pc, #172]	; (9000b78c <ip_reass_free_complete_datagram+0xd4>)
9000b6e0:	f006 fa64 	bl	90011bac <iprintf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
9000b6e4:	6867      	ldr	r7, [r4, #4]
9000b6e6:	687b      	ldr	r3, [r7, #4]
  if (iprh->start == 0) {
9000b6e8:	889a      	ldrh	r2, [r3, #4]
9000b6ea:	bb92      	cbnz	r2, 9000b752 <ip_reass_free_complete_datagram+0x9a>
    ipr->p = iprh->next_pbuf;
9000b6ec:	681a      	ldr	r2, [r3, #0]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
9000b6ee:	f104 011c 	add.w	r1, r4, #28
    ipr->p = iprh->next_pbuf;
9000b6f2:	6062      	str	r2, [r4, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
9000b6f4:	f104 0208 	add.w	r2, r4, #8
9000b6f8:	f852 0b04 	ldr.w	r0, [r2], #4
9000b6fc:	428a      	cmp	r2, r1
9000b6fe:	f843 0b04 	str.w	r0, [r3], #4
9000b702:	d1f9      	bne.n	9000b6f8 <ip_reass_free_complete_datagram+0x40>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
9000b704:	2101      	movs	r1, #1
9000b706:	4638      	mov	r0, r7
9000b708:	f7ff fd3a 	bl	9000b180 <icmp_time_exceeded>
    clen = pbuf_clen(p);
9000b70c:	4638      	mov	r0, r7
9000b70e:	f001 fc19 	bl	9000cf44 <pbuf_clen>
9000b712:	4605      	mov	r5, r0
    pbuf_free(p);
9000b714:	4638      	mov	r0, r7
9000b716:	f001 fac3 	bl	9000cca0 <pbuf_free>
  p = ipr->p;
9000b71a:	6867      	ldr	r7, [r4, #4]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
9000b71c:	f8df 8064 	ldr.w	r8, [pc, #100]	; 9000b784 <ip_reass_free_complete_datagram+0xcc>
9000b720:	f8df 9078 	ldr.w	r9, [pc, #120]	; 9000b79c <ip_reass_free_complete_datagram+0xe4>
9000b724:	f8df a064 	ldr.w	sl, [pc, #100]	; 9000b78c <ip_reass_free_complete_datagram+0xd4>
  while (p != NULL) {
9000b728:	b9af      	cbnz	r7, 9000b756 <ip_reass_free_complete_datagram+0x9e>
  ip_reass_dequeue_datagram(ipr, prev);
9000b72a:	4620      	mov	r0, r4
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
9000b72c:	4c19      	ldr	r4, [pc, #100]	; (9000b794 <ip_reass_free_complete_datagram+0xdc>)
  ip_reass_dequeue_datagram(ipr, prev);
9000b72e:	4631      	mov	r1, r6
9000b730:	f7ff ffa0 	bl	9000b674 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
9000b734:	8823      	ldrh	r3, [r4, #0]
9000b736:	42ab      	cmp	r3, r5
9000b738:	d205      	bcs.n	9000b746 <ip_reass_free_complete_datagram+0x8e>
9000b73a:	4b12      	ldr	r3, [pc, #72]	; (9000b784 <ip_reass_free_complete_datagram+0xcc>)
9000b73c:	22d2      	movs	r2, #210	; 0xd2
9000b73e:	4916      	ldr	r1, [pc, #88]	; (9000b798 <ip_reass_free_complete_datagram+0xe0>)
9000b740:	4812      	ldr	r0, [pc, #72]	; (9000b78c <ip_reass_free_complete_datagram+0xd4>)
9000b742:	f006 fa33 	bl	90011bac <iprintf>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
9000b746:	8823      	ldrh	r3, [r4, #0]
}
9000b748:	4628      	mov	r0, r5
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
9000b74a:	1b5b      	subs	r3, r3, r5
9000b74c:	8023      	strh	r3, [r4, #0]
}
9000b74e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  u16_t pbufs_freed = 0;
9000b752:	2500      	movs	r5, #0
9000b754:	e7e1      	b.n	9000b71a <ip_reass_free_complete_datagram+0x62>
    iprh = (struct ip_reass_helper *)p->payload;
9000b756:	687b      	ldr	r3, [r7, #4]
    clen = pbuf_clen(pcur);
9000b758:	4638      	mov	r0, r7
    p = iprh->next_pbuf;
9000b75a:	f8d3 b000 	ldr.w	fp, [r3]
    clen = pbuf_clen(pcur);
9000b75e:	f001 fbf1 	bl	9000cf44 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
9000b762:	4405      	add	r5, r0
9000b764:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
9000b768:	db05      	blt.n	9000b776 <ip_reass_free_complete_datagram+0xbe>
9000b76a:	4643      	mov	r3, r8
9000b76c:	22cc      	movs	r2, #204	; 0xcc
9000b76e:	4649      	mov	r1, r9
9000b770:	4650      	mov	r0, sl
9000b772:	f006 fa1b 	bl	90011bac <iprintf>
    pbuf_free(pcur);
9000b776:	4638      	mov	r0, r7
    pbufs_freed = (u16_t)(pbufs_freed + clen);
9000b778:	b2ad      	uxth	r5, r5
    p = iprh->next_pbuf;
9000b77a:	465f      	mov	r7, fp
    pbuf_free(pcur);
9000b77c:	f001 fa90 	bl	9000cca0 <pbuf_free>
9000b780:	e7d2      	b.n	9000b728 <ip_reass_free_complete_datagram+0x70>
9000b782:	bf00      	nop
9000b784:	90013a70 	.word	0x90013a70
9000b788:	90013ac9 	.word	0x90013ac9
9000b78c:	90012aff 	.word	0x90012aff
9000b790:	90013ad5 	.word	0x90013ad5
9000b794:	2400a112 	.word	0x2400a112
9000b798:	90013b04 	.word	0x90013b04
9000b79c:	90013ae7 	.word	0x90013ae7

9000b7a0 <ip_reass_remove_oldest_datagram>:
{
9000b7a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9000b7a4:	4605      	mov	r5, r0
9000b7a6:	460f      	mov	r7, r1
  int pbufs_freed = 0, pbufs_freed_current;
9000b7a8:	2600      	movs	r6, #0
    r = reassdatagrams;
9000b7aa:	f8df 8068 	ldr.w	r8, [pc, #104]	; 9000b814 <ip_reass_remove_oldest_datagram+0x74>
    other_datagrams = 0;
9000b7ae:	2400      	movs	r4, #0
    r = reassdatagrams;
9000b7b0:	f8d8 3000 	ldr.w	r3, [r8]
    oldest_prev = NULL;
9000b7b4:	4621      	mov	r1, r4
    prev = NULL;
9000b7b6:	46a4      	mov	ip, r4
    oldest = NULL;
9000b7b8:	4620      	mov	r0, r4
    while (r != NULL) {
9000b7ba:	b953      	cbnz	r3, 9000b7d2 <ip_reass_remove_oldest_datagram+0x32>
    if (oldest != NULL) {
9000b7bc:	b110      	cbz	r0, 9000b7c4 <ip_reass_remove_oldest_datagram+0x24>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
9000b7be:	f7ff ff7b 	bl	9000b6b8 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
9000b7c2:	4406      	add	r6, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
9000b7c4:	42be      	cmp	r6, r7
9000b7c6:	da01      	bge.n	9000b7cc <ip_reass_remove_oldest_datagram+0x2c>
9000b7c8:	2c01      	cmp	r4, #1
9000b7ca:	dcf0      	bgt.n	9000b7ae <ip_reass_remove_oldest_datagram+0xe>
}
9000b7cc:	4630      	mov	r0, r6
9000b7ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
9000b7d2:	f8d5 e00c 	ldr.w	lr, [r5, #12]
9000b7d6:	695a      	ldr	r2, [r3, #20]
9000b7d8:	4572      	cmp	r2, lr
9000b7da:	d109      	bne.n	9000b7f0 <ip_reass_remove_oldest_datagram+0x50>
9000b7dc:	f8d5 e010 	ldr.w	lr, [r5, #16]
9000b7e0:	699a      	ldr	r2, [r3, #24]
9000b7e2:	4572      	cmp	r2, lr
9000b7e4:	d104      	bne.n	9000b7f0 <ip_reass_remove_oldest_datagram+0x50>
9000b7e6:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
9000b7ea:	88aa      	ldrh	r2, [r5, #4]
9000b7ec:	4596      	cmp	lr, r2
9000b7ee:	d008      	beq.n	9000b802 <ip_reass_remove_oldest_datagram+0x62>
        other_datagrams++;
9000b7f0:	3401      	adds	r4, #1
        if (oldest == NULL) {
9000b7f2:	b160      	cbz	r0, 9000b80e <ip_reass_remove_oldest_datagram+0x6e>
        } else if (r->timer <= oldest->timer) {
9000b7f4:	7fc2      	ldrb	r2, [r0, #31]
9000b7f6:	f893 e01f 	ldrb.w	lr, [r3, #31]
          oldest_prev = prev;
9000b7fa:	4596      	cmp	lr, r2
9000b7fc:	bf9c      	itt	ls
9000b7fe:	4661      	movls	r1, ip
9000b800:	4618      	movls	r0, r3
      if (r->next != NULL) {
9000b802:	681a      	ldr	r2, [r3, #0]
9000b804:	2a00      	cmp	r2, #0
9000b806:	bf18      	it	ne
9000b808:	469c      	movne	ip, r3
9000b80a:	4613      	mov	r3, r2
9000b80c:	e7d5      	b.n	9000b7ba <ip_reass_remove_oldest_datagram+0x1a>
          oldest_prev = prev;
9000b80e:	4661      	mov	r1, ip
9000b810:	4618      	mov	r0, r3
9000b812:	e7f6      	b.n	9000b802 <ip_reass_remove_oldest_datagram+0x62>
9000b814:	2400a114 	.word	0x2400a114

9000b818 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
{
9000b818:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
9000b81a:	4604      	mov	r4, r0
9000b81c:	b930      	cbnz	r0, 9000b82c <ip_frag_free_pbuf_custom_ref+0x14>
9000b81e:	4b06      	ldr	r3, [pc, #24]	; (9000b838 <ip_frag_free_pbuf_custom_ref+0x20>)
9000b820:	f44f 7231 	mov.w	r2, #708	; 0x2c4
9000b824:	4905      	ldr	r1, [pc, #20]	; (9000b83c <ip_frag_free_pbuf_custom_ref+0x24>)
9000b826:	4806      	ldr	r0, [pc, #24]	; (9000b840 <ip_frag_free_pbuf_custom_ref+0x28>)
9000b828:	f006 f9c0 	bl	90011bac <iprintf>
  memp_free(MEMP_FRAG_PBUF, p);
9000b82c:	4621      	mov	r1, r4
9000b82e:	2005      	movs	r0, #5
}
9000b830:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  memp_free(MEMP_FRAG_PBUF, p);
9000b834:	f000 be1a 	b.w	9000c46c <memp_free>
9000b838:	90013a70 	.word	0x90013a70
9000b83c:	9001436e 	.word	0x9001436e
9000b840:	90012aff 	.word	0x90012aff

9000b844 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
9000b844:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
9000b846:	4604      	mov	r4, r0
9000b848:	b930      	cbnz	r0, 9000b858 <ipfrag_free_pbuf_custom+0x14>
9000b84a:	4b08      	ldr	r3, [pc, #32]	; (9000b86c <ipfrag_free_pbuf_custom+0x28>)
9000b84c:	f240 22ce 	movw	r2, #718	; 0x2ce
9000b850:	4907      	ldr	r1, [pc, #28]	; (9000b870 <ipfrag_free_pbuf_custom+0x2c>)
9000b852:	4808      	ldr	r0, [pc, #32]	; (9000b874 <ipfrag_free_pbuf_custom+0x30>)
9000b854:	f006 f9aa 	bl	90011bac <iprintf>
  LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  if (pcr->original != NULL) {
9000b858:	6960      	ldr	r0, [r4, #20]
9000b85a:	b108      	cbz	r0, 9000b860 <ipfrag_free_pbuf_custom+0x1c>
    pbuf_free(pcr->original);
9000b85c:	f001 fa20 	bl	9000cca0 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
9000b860:	4620      	mov	r0, r4
}
9000b862:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  ip_frag_free_pbuf_custom_ref(pcr);
9000b866:	f7ff bfd7 	b.w	9000b818 <ip_frag_free_pbuf_custom_ref>
9000b86a:	bf00      	nop
9000b86c:	90013a70 	.word	0x90013a70
9000b870:	90013b26 	.word	0x90013b26
9000b874:	90012aff 	.word	0x90012aff

9000b878 <ip_reass_tmr>:
{
9000b878:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
9000b87a:	4b09      	ldr	r3, [pc, #36]	; (9000b8a0 <ip_reass_tmr+0x28>)
  struct ip_reassdata *r, *prev = NULL;
9000b87c:	2400      	movs	r4, #0
  r = reassdatagrams;
9000b87e:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
9000b880:	b900      	cbnz	r0, 9000b884 <ip_reass_tmr+0xc>
}
9000b882:	bd38      	pop	{r3, r4, r5, pc}
    if (r->timer > 0) {
9000b884:	7fc3      	ldrb	r3, [r0, #31]
      r = r->next;
9000b886:	6805      	ldr	r5, [r0, #0]
    if (r->timer > 0) {
9000b888:	b123      	cbz	r3, 9000b894 <ip_reass_tmr+0x1c>
      r->timer--;
9000b88a:	3b01      	subs	r3, #1
9000b88c:	77c3      	strb	r3, [r0, #31]
      ip_reass_free_complete_datagram(tmp, prev);
9000b88e:	4604      	mov	r4, r0
9000b890:	4628      	mov	r0, r5
9000b892:	e7f5      	b.n	9000b880 <ip_reass_tmr+0x8>
9000b894:	4621      	mov	r1, r4
9000b896:	f7ff ff0f 	bl	9000b6b8 <ip_reass_free_complete_datagram>
9000b89a:	4620      	mov	r0, r4
9000b89c:	e7f7      	b.n	9000b88e <ip_reass_tmr+0x16>
9000b89e:	bf00      	nop
9000b8a0:	2400a114 	.word	0x2400a114

9000b8a4 <ip4_reass>:
{
9000b8a4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  fraghdr = (struct ip_hdr *)p->payload;
9000b8a8:	6845      	ldr	r5, [r0, #4]
{
9000b8aa:	4680      	mov	r8, r0
  if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
9000b8ac:	782b      	ldrb	r3, [r5, #0]
9000b8ae:	f003 030f 	and.w	r3, r3, #15
9000b8b2:	2b05      	cmp	r3, #5
9000b8b4:	f040 80a1 	bne.w	9000b9fa <ip4_reass+0x156>
  offset = IPH_OFFSET_BYTES(fraghdr);
9000b8b8:	88e8      	ldrh	r0, [r5, #6]
9000b8ba:	f7fd fc61 	bl	90009180 <lwip_htons>
9000b8be:	4607      	mov	r7, r0
  len = lwip_ntohs(IPH_LEN(fraghdr));
9000b8c0:	8868      	ldrh	r0, [r5, #2]
9000b8c2:	f7fd fc5d 	bl	90009180 <lwip_htons>
  hlen = IPH_HL_BYTES(fraghdr);
9000b8c6:	782a      	ldrb	r2, [r5, #0]
9000b8c8:	f002 020f 	and.w	r2, r2, #15
  if (hlen > len) {
9000b8cc:	ebb0 0f82 	cmp.w	r0, r2, lsl #2
9000b8d0:	ea4f 0382 	mov.w	r3, r2, lsl #2
9000b8d4:	f0c0 8091 	bcc.w	9000b9fa <ip4_reass+0x156>
  len = (u16_t)(len - hlen);
9000b8d8:	1ac3      	subs	r3, r0, r3
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
9000b8da:	4cb6      	ldr	r4, [pc, #728]	; (9000bbb4 <ip4_reass+0x310>)
  clen = pbuf_clen(p);
9000b8dc:	4640      	mov	r0, r8
  len = (u16_t)(len - hlen);
9000b8de:	b29b      	uxth	r3, r3
9000b8e0:	9301      	str	r3, [sp, #4]
  clen = pbuf_clen(p);
9000b8e2:	f001 fb2f 	bl	9000cf44 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
9000b8e6:	8823      	ldrh	r3, [r4, #0]
  clen = pbuf_clen(p);
9000b8e8:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
9000b8ea:	4403      	add	r3, r0
9000b8ec:	2b0a      	cmp	r3, #10
9000b8ee:	dc7a      	bgt.n	9000b9e6 <ip4_reass+0x142>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
9000b8f0:	4eb1      	ldr	r6, [pc, #708]	; (9000bbb8 <ip4_reass+0x314>)
9000b8f2:	6834      	ldr	r4, [r6, #0]
9000b8f4:	2c00      	cmp	r4, #0
9000b8f6:	f040 8085 	bne.w	9000ba04 <ip4_reass+0x160>
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
9000b8fa:	2004      	movs	r0, #4
9000b8fc:	f000 fd86 	bl	9000c40c <memp_malloc>
  if (ipr == NULL) {
9000b900:	4604      	mov	r4, r0
9000b902:	b958      	cbnz	r0, 9000b91c <ip4_reass+0x78>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
9000b904:	4649      	mov	r1, r9
9000b906:	4628      	mov	r0, r5
9000b908:	f7ff ff4a 	bl	9000b7a0 <ip_reass_remove_oldest_datagram>
9000b90c:	4581      	cmp	r9, r0
9000b90e:	dc74      	bgt.n	9000b9fa <ip4_reass+0x156>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
9000b910:	2004      	movs	r0, #4
9000b912:	f000 fd7b 	bl	9000c40c <memp_malloc>
    if (ipr == NULL)
9000b916:	4604      	mov	r4, r0
9000b918:	2800      	cmp	r0, #0
9000b91a:	d06e      	beq.n	9000b9fa <ip4_reass+0x156>
  memset(ipr, 0, sizeof(struct ip_reassdata));
9000b91c:	221c      	movs	r2, #28
9000b91e:	2100      	movs	r1, #0
9000b920:	1d20      	adds	r0, r4, #4
9000b922:	f006 f85b 	bl	900119dc <memset>
  ipr->timer = IP_REASS_MAXAGE;
9000b926:	230f      	movs	r3, #15
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
9000b928:	f104 0208 	add.w	r2, r4, #8
9000b92c:	f105 0114 	add.w	r1, r5, #20
  ipr->timer = IP_REASS_MAXAGE;
9000b930:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
9000b932:	6833      	ldr	r3, [r6, #0]
  reassdatagrams = ipr;
9000b934:	6034      	str	r4, [r6, #0]
  ipr->next = reassdatagrams;
9000b936:	6023      	str	r3, [r4, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
9000b938:	462b      	mov	r3, r5
9000b93a:	f853 0b04 	ldr.w	r0, [r3], #4
9000b93e:	428b      	cmp	r3, r1
9000b940:	f842 0b04 	str.w	r0, [r2], #4
9000b944:	d1f9      	bne.n	9000b93a <ip4_reass+0x96>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
9000b946:	f8b5 b006 	ldrh.w	fp, [r5, #6]
  offset = IPH_OFFSET_BYTES(fraghdr);
9000b94a:	f3c7 070c 	ubfx	r7, r7, #0, #13
  if (is_last) {
9000b94e:	f01b 0b20 	ands.w	fp, fp, #32
  offset = IPH_OFFSET_BYTES(fraghdr);
9000b952:	ea4f 07c7 	mov.w	r7, r7, lsl #3
  if (is_last) {
9000b956:	d10a      	bne.n	9000b96e <ip4_reass+0xca>
    u16_t datagram_len = (u16_t)(offset + len);
9000b958:	9b01      	ldr	r3, [sp, #4]
9000b95a:	18fb      	adds	r3, r7, r3
9000b95c:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
9000b95e:	429f      	cmp	r7, r3
9000b960:	f200 813a 	bhi.w	9000bbd8 <ip4_reass+0x334>
9000b964:	f64f 72eb 	movw	r2, #65515	; 0xffeb
9000b968:	4293      	cmp	r3, r2
9000b96a:	f200 8135 	bhi.w	9000bbd8 <ip4_reass+0x334>
  fraghdr = (struct ip_hdr *)new_p->payload;
9000b96e:	f8d8 5004 	ldr.w	r5, [r8, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr));
9000b972:	8868      	ldrh	r0, [r5, #2]
9000b974:	f7fd fc04 	bl	90009180 <lwip_htons>
  hlen = IPH_HL_BYTES(fraghdr);
9000b978:	782b      	ldrb	r3, [r5, #0]
9000b97a:	f003 030f 	and.w	r3, r3, #15
  if (hlen > len) {
9000b97e:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
9000b982:	ea4f 0283 	mov.w	r2, r3, lsl #2
9000b986:	f0c0 8127 	bcc.w	9000bbd8 <ip4_reass+0x334>
  len = (u16_t)(len - hlen);
9000b98a:	1a80      	subs	r0, r0, r2
9000b98c:	fa1f fa80 	uxth.w	sl, r0
  offset = IPH_OFFSET_BYTES(fraghdr);
9000b990:	88e8      	ldrh	r0, [r5, #6]
9000b992:	f7fd fbf5 	bl	90009180 <lwip_htons>
9000b996:	f3c0 000c 	ubfx	r0, r0, #0, #13
  iprh = (struct ip_reass_helper *)new_p->payload;
9000b99a:	f8d8 6004 	ldr.w	r6, [r8, #4]
  iprh->next_pbuf = NULL;
9000b99e:	2500      	movs	r5, #0
  offset = IPH_OFFSET_BYTES(fraghdr);
9000b9a0:	00c0      	lsls	r0, r0, #3
  iprh->next_pbuf = NULL;
9000b9a2:	7035      	strb	r5, [r6, #0]
  iprh->end = (u16_t)(offset + len);
9000b9a4:	eb0a 0300 	add.w	r3, sl, r0
  iprh->next_pbuf = NULL;
9000b9a8:	7075      	strb	r5, [r6, #1]
9000b9aa:	70b5      	strb	r5, [r6, #2]
  iprh->end = (u16_t)(offset + len);
9000b9ac:	fa1f fc83 	uxth.w	ip, r3
  iprh->next_pbuf = NULL;
9000b9b0:	70f5      	strb	r5, [r6, #3]
  iprh->start = offset;
9000b9b2:	80b0      	strh	r0, [r6, #4]
  if (iprh->end < offset) {
9000b9b4:	4560      	cmp	r0, ip
  iprh->end = (u16_t)(offset + len);
9000b9b6:	80f3      	strh	r3, [r6, #6]
  if (iprh->end < offset) {
9000b9b8:	f200 810e 	bhi.w	9000bbd8 <ip4_reass+0x334>
  for (q = ipr->p; q != NULL;) {
9000b9bc:	f8d4 e004 	ldr.w	lr, [r4, #4]
  int valid = 1;
9000b9c0:	f04f 0a01 	mov.w	sl, #1
  for (q = ipr->p; q != NULL;) {
9000b9c4:	4671      	mov	r1, lr
9000b9c6:	bb61      	cbnz	r1, 9000ba22 <ip4_reass+0x17e>
    if (iprh_prev != NULL) {
9000b9c8:	2d00      	cmp	r5, #0
9000b9ca:	f040 80aa 	bne.w	9000bb22 <ip4_reass+0x27e>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
9000b9ce:	f1be 0f00 	cmp.w	lr, #0
9000b9d2:	f000 8096 	beq.w	9000bb02 <ip4_reass+0x25e>
9000b9d6:	4b79      	ldr	r3, [pc, #484]	; (9000bbbc <ip4_reass+0x318>)
9000b9d8:	f44f 72df 	mov.w	r2, #446	; 0x1be
9000b9dc:	4978      	ldr	r1, [pc, #480]	; (9000bbc0 <ip4_reass+0x31c>)
9000b9de:	4879      	ldr	r0, [pc, #484]	; (9000bbc4 <ip4_reass+0x320>)
9000b9e0:	f006 f8e4 	bl	90011bac <iprintf>
9000b9e4:	e08d      	b.n	9000bb02 <ip4_reass+0x25e>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
9000b9e6:	4601      	mov	r1, r0
9000b9e8:	4628      	mov	r0, r5
9000b9ea:	f7ff fed9 	bl	9000b7a0 <ip_reass_remove_oldest_datagram>
9000b9ee:	b120      	cbz	r0, 9000b9fa <ip4_reass+0x156>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
9000b9f0:	8823      	ldrh	r3, [r4, #0]
9000b9f2:	444b      	add	r3, r9
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
9000b9f4:	2b0a      	cmp	r3, #10
9000b9f6:	f77f af7b 	ble.w	9000b8f0 <ip4_reass+0x4c>
  pbuf_free(p);
9000b9fa:	4640      	mov	r0, r8
9000b9fc:	f001 f950 	bl	9000cca0 <pbuf_free>
  return NULL;
9000ba00:	2700      	movs	r7, #0
9000ba02:	e078      	b.n	9000baf6 <ip4_reass+0x252>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
9000ba04:	68eb      	ldr	r3, [r5, #12]
9000ba06:	6962      	ldr	r2, [r4, #20]
9000ba08:	429a      	cmp	r2, r3
9000ba0a:	d108      	bne.n	9000ba1e <ip4_reass+0x17a>
9000ba0c:	692b      	ldr	r3, [r5, #16]
9000ba0e:	69a2      	ldr	r2, [r4, #24]
9000ba10:	429a      	cmp	r2, r3
9000ba12:	d104      	bne.n	9000ba1e <ip4_reass+0x17a>
9000ba14:	89a2      	ldrh	r2, [r4, #12]
9000ba16:	88ab      	ldrh	r3, [r5, #4]
9000ba18:	429a      	cmp	r2, r3
9000ba1a:	f000 80f1 	beq.w	9000bc00 <ip4_reass+0x35c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
9000ba1e:	6824      	ldr	r4, [r4, #0]
9000ba20:	e768      	b.n	9000b8f4 <ip4_reass+0x50>
    iprh_tmp = (struct ip_reass_helper *)q->payload;
9000ba22:	684b      	ldr	r3, [r1, #4]
    if (iprh->start < iprh_tmp->start) {
9000ba24:	889a      	ldrh	r2, [r3, #4]
9000ba26:	4290      	cmp	r0, r2
9000ba28:	d26e      	bcs.n	9000bb08 <ip4_reass+0x264>
      iprh->next_pbuf = q;
9000ba2a:	6031      	str	r1, [r6, #0]
      if (iprh_prev != NULL) {
9000ba2c:	2d00      	cmp	r5, #0
9000ba2e:	d066      	beq.n	9000bafe <ip4_reass+0x25a>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
9000ba30:	88eb      	ldrh	r3, [r5, #6]
9000ba32:	4298      	cmp	r0, r3
9000ba34:	f0c0 80d0 	bcc.w	9000bbd8 <ip4_reass+0x334>
9000ba38:	4594      	cmp	ip, r2
9000ba3a:	f200 80cd 	bhi.w	9000bbd8 <ip4_reass+0x334>
        if (iprh_prev->end != iprh->start) {
9000ba3e:	4298      	cmp	r0, r3
        iprh_prev->next_pbuf = new_p;
9000ba40:	f8c5 8000 	str.w	r8, [r5]
      if (iprh_prev->end != iprh->start) {
9000ba44:	f040 80f8 	bne.w	9000bc38 <ip4_reass+0x394>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
9000ba48:	f1bb 0f00 	cmp.w	fp, #0
9000ba4c:	d004      	beq.n	9000ba58 <ip4_reass+0x1b4>
9000ba4e:	7fa3      	ldrb	r3, [r4, #30]
9000ba50:	f013 0301 	ands.w	r3, r3, #1
9000ba54:	f000 809c 	beq.w	9000bb90 <ip4_reass+0x2ec>
    if (valid) {
9000ba58:	f1ba 0f00 	cmp.w	sl, #0
9000ba5c:	d171      	bne.n	9000bb42 <ip4_reass+0x29e>
          q = iprh->next_pbuf;
9000ba5e:	f04f 0a00 	mov.w	sl, #0
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
9000ba62:	4e54      	ldr	r6, [pc, #336]	; (9000bbb4 <ip4_reass+0x310>)
9000ba64:	8830      	ldrh	r0, [r6, #0]
9000ba66:	4481      	add	r9, r0
9000ba68:	f8a6 9000 	strh.w	r9, [r6]
  if (is_last) {
9000ba6c:	f1bb 0f00 	cmp.w	fp, #0
9000ba70:	d106      	bne.n	9000ba80 <ip4_reass+0x1dc>
    u16_t datagram_len = (u16_t)(offset + len);
9000ba72:	9b01      	ldr	r3, [sp, #4]
9000ba74:	441f      	add	r7, r3
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
9000ba76:	7fa3      	ldrb	r3, [r4, #30]
9000ba78:	f043 0301 	orr.w	r3, r3, #1
    ipr->datagram_len = datagram_len;
9000ba7c:	83a7      	strh	r7, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
9000ba7e:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
9000ba80:	f1ba 0f01 	cmp.w	sl, #1
9000ba84:	d1bc      	bne.n	9000ba00 <ip4_reass+0x15c>
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
9000ba86:	6863      	ldr	r3, [r4, #4]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
9000ba88:	f104 011c 	add.w	r1, r4, #28
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
9000ba8c:	8ba0      	ldrh	r0, [r4, #28]
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
9000ba8e:	685f      	ldr	r7, [r3, #4]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
9000ba90:	f104 0308 	add.w	r3, r4, #8
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
9000ba94:	3014      	adds	r0, #20
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
9000ba96:	683d      	ldr	r5, [r7, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
9000ba98:	463a      	mov	r2, r7
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
9000ba9a:	b280      	uxth	r0, r0
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
9000ba9c:	f853 cb04 	ldr.w	ip, [r3], #4
9000baa0:	428b      	cmp	r3, r1
9000baa2:	f842 cb04 	str.w	ip, [r2], #4
9000baa6:	d1f9      	bne.n	9000ba9c <ip4_reass+0x1f8>
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
9000baa8:	f7fd fb6a 	bl	90009180 <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
9000baac:	2300      	movs	r3, #0
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
9000baae:	8078      	strh	r0, [r7, #2]
    IPH_OFFSET_SET(fraghdr, 0);
9000bab0:	71bb      	strb	r3, [r7, #6]
9000bab2:	71fb      	strb	r3, [r7, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
9000bab4:	72bb      	strb	r3, [r7, #10]
9000bab6:	72fb      	strb	r3, [r7, #11]
    p = ipr->p;
9000bab8:	6867      	ldr	r7, [r4, #4]
    while (r != NULL) {
9000baba:	2d00      	cmp	r5, #0
9000babc:	d16a      	bne.n	9000bb94 <ip4_reass+0x2f0>
    if (ipr == reassdatagrams) {
9000babe:	4b3e      	ldr	r3, [pc, #248]	; (9000bbb8 <ip4_reass+0x314>)
9000bac0:	681b      	ldr	r3, [r3, #0]
        if (ipr_prev->next == ipr) {
9000bac2:	42a3      	cmp	r3, r4
9000bac4:	d002      	beq.n	9000bacc <ip4_reass+0x228>
9000bac6:	461d      	mov	r5, r3
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
9000bac8:	2b00      	cmp	r3, #0
9000baca:	d170      	bne.n	9000bbae <ip4_reass+0x30a>
    ip_reass_dequeue_datagram(ipr, ipr_prev);
9000bacc:	4620      	mov	r0, r4
9000bace:	4629      	mov	r1, r5
9000bad0:	f7ff fdd0 	bl	9000b674 <ip_reass_dequeue_datagram>
    clen = pbuf_clen(p);
9000bad4:	4638      	mov	r0, r7
9000bad6:	f001 fa35 	bl	9000cf44 <pbuf_clen>
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
9000bada:	8833      	ldrh	r3, [r6, #0]
    clen = pbuf_clen(p);
9000badc:	4604      	mov	r4, r0
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
9000bade:	4283      	cmp	r3, r0
9000bae0:	d206      	bcs.n	9000baf0 <ip4_reass+0x24c>
9000bae2:	4b36      	ldr	r3, [pc, #216]	; (9000bbbc <ip4_reass+0x318>)
9000bae4:	f240 229b 	movw	r2, #667	; 0x29b
9000bae8:	4937      	ldr	r1, [pc, #220]	; (9000bbc8 <ip4_reass+0x324>)
9000baea:	4836      	ldr	r0, [pc, #216]	; (9000bbc4 <ip4_reass+0x320>)
9000baec:	f006 f85e 	bl	90011bac <iprintf>
    ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
9000baf0:	8830      	ldrh	r0, [r6, #0]
9000baf2:	1b04      	subs	r4, r0, r4
9000baf4:	8034      	strh	r4, [r6, #0]
}
9000baf6:	4638      	mov	r0, r7
9000baf8:	b003      	add	sp, #12
9000bafa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (iprh->end > iprh_tmp->start) {
9000bafe:	4594      	cmp	ip, r2
9000bb00:	d86a      	bhi.n	9000bbd8 <ip4_reass+0x334>
      ipr->p = new_p;
9000bb02:	f8c4 8004 	str.w	r8, [r4, #4]
9000bb06:	e79f      	b.n	9000ba48 <ip4_reass+0x1a4>
    } else if (iprh->start == iprh_tmp->start) {
9000bb08:	d066      	beq.n	9000bbd8 <ip4_reass+0x334>
    } else if (iprh->start < iprh_tmp->end) {
9000bb0a:	88d9      	ldrh	r1, [r3, #6]
9000bb0c:	4281      	cmp	r1, r0
9000bb0e:	d863      	bhi.n	9000bbd8 <ip4_reass+0x334>
      if (iprh_prev != NULL) {
9000bb10:	b125      	cbz	r5, 9000bb1c <ip4_reass+0x278>
        if (iprh_prev->end != iprh_tmp->start) {
9000bb12:	88e9      	ldrh	r1, [r5, #6]
          valid = 0;
9000bb14:	4291      	cmp	r1, r2
9000bb16:	bf18      	it	ne
9000bb18:	f04f 0a00 	movne.w	sl, #0
    q = iprh_tmp->next_pbuf;
9000bb1c:	6819      	ldr	r1, [r3, #0]
9000bb1e:	461d      	mov	r5, r3
9000bb20:	e751      	b.n	9000b9c6 <ip4_reass+0x122>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
9000bb22:	88eb      	ldrh	r3, [r5, #6]
9000bb24:	4283      	cmp	r3, r0
9000bb26:	d906      	bls.n	9000bb36 <ip4_reass+0x292>
9000bb28:	4b24      	ldr	r3, [pc, #144]	; (9000bbbc <ip4_reass+0x318>)
9000bb2a:	f44f 72db 	mov.w	r2, #438	; 0x1b6
9000bb2e:	4927      	ldr	r1, [pc, #156]	; (9000bbcc <ip4_reass+0x328>)
9000bb30:	4824      	ldr	r0, [pc, #144]	; (9000bbc4 <ip4_reass+0x320>)
9000bb32:	f006 f83b 	bl	90011bac <iprintf>
      if (iprh_prev->end != iprh->start) {
9000bb36:	88ea      	ldrh	r2, [r5, #6]
      iprh_prev->next_pbuf = new_p;
9000bb38:	f8c5 8000 	str.w	r8, [r5]
      if (iprh_prev->end != iprh->start) {
9000bb3c:	88b3      	ldrh	r3, [r6, #4]
9000bb3e:	429a      	cmp	r2, r3
9000bb40:	e780      	b.n	9000ba44 <ip4_reass+0x1a0>
      if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
9000bb42:	6863      	ldr	r3, [r4, #4]
9000bb44:	2b00      	cmp	r3, #0
9000bb46:	d08a      	beq.n	9000ba5e <ip4_reass+0x1ba>
9000bb48:	6859      	ldr	r1, [r3, #4]
9000bb4a:	888b      	ldrh	r3, [r1, #4]
9000bb4c:	2b00      	cmp	r3, #0
9000bb4e:	d186      	bne.n	9000ba5e <ip4_reass+0x1ba>
        q = iprh->next_pbuf;
9000bb50:	6833      	ldr	r3, [r6, #0]
        while (q != NULL) {
9000bb52:	b9a3      	cbnz	r3, 9000bb7e <ip4_reass+0x2da>
          LWIP_ASSERT("sanity check",
9000bb54:	42b1      	cmp	r1, r6
9000bb56:	d106      	bne.n	9000bb66 <ip4_reass+0x2c2>
9000bb58:	4b18      	ldr	r3, [pc, #96]	; (9000bbbc <ip4_reass+0x318>)
9000bb5a:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
9000bb5e:	491c      	ldr	r1, [pc, #112]	; (9000bbd0 <ip4_reass+0x32c>)
9000bb60:	4818      	ldr	r0, [pc, #96]	; (9000bbc4 <ip4_reass+0x320>)
9000bb62:	f006 f823 	bl	90011bac <iprintf>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
9000bb66:	6833      	ldr	r3, [r6, #0]
9000bb68:	2b00      	cmp	r3, #0
9000bb6a:	f43f af7a 	beq.w	9000ba62 <ip4_reass+0x1be>
9000bb6e:	4b13      	ldr	r3, [pc, #76]	; (9000bbbc <ip4_reass+0x318>)
9000bb70:	f44f 72f1 	mov.w	r2, #482	; 0x1e2
9000bb74:	4917      	ldr	r1, [pc, #92]	; (9000bbd4 <ip4_reass+0x330>)
9000bb76:	4813      	ldr	r0, [pc, #76]	; (9000bbc4 <ip4_reass+0x320>)
9000bb78:	f006 f818 	bl	90011bac <iprintf>
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
9000bb7c:	e771      	b.n	9000ba62 <ip4_reass+0x1be>
          iprh = (struct ip_reass_helper *)q->payload;
9000bb7e:	685a      	ldr	r2, [r3, #4]
          if (iprh_prev->end != iprh->start) {
9000bb80:	88f0      	ldrh	r0, [r6, #6]
9000bb82:	8893      	ldrh	r3, [r2, #4]
9000bb84:	4298      	cmp	r0, r3
9000bb86:	f47f af6a 	bne.w	9000ba5e <ip4_reass+0x1ba>
          q = iprh->next_pbuf;
9000bb8a:	6813      	ldr	r3, [r2, #0]
9000bb8c:	4616      	mov	r6, r2
9000bb8e:	e7e0      	b.n	9000bb52 <ip4_reass+0x2ae>
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
9000bb90:	469a      	mov	sl, r3
9000bb92:	e766      	b.n	9000ba62 <ip4_reass+0x1be>
      iprh = (struct ip_reass_helper *)r->payload;
9000bb94:	f8d5 8004 	ldr.w	r8, [r5, #4]
      pbuf_remove_header(r, IP_HLEN);
9000bb98:	2114      	movs	r1, #20
9000bb9a:	4628      	mov	r0, r5
9000bb9c:	f001 f84c 	bl	9000cc38 <pbuf_remove_header>
      pbuf_cat(p, r);
9000bba0:	4629      	mov	r1, r5
9000bba2:	4638      	mov	r0, r7
9000bba4:	f001 f9f2 	bl	9000cf8c <pbuf_cat>
      r = iprh->next_pbuf;
9000bba8:	f8d8 5000 	ldr.w	r5, [r8]
9000bbac:	e785      	b.n	9000baba <ip4_reass+0x216>
        if (ipr_prev->next == ipr) {
9000bbae:	682b      	ldr	r3, [r5, #0]
9000bbb0:	e787      	b.n	9000bac2 <ip4_reass+0x21e>
9000bbb2:	bf00      	nop
9000bbb4:	2400a112 	.word	0x2400a112
9000bbb8:	2400a114 	.word	0x2400a114
9000bbbc:	90013a70 	.word	0x90013a70
9000bbc0:	90013b50 	.word	0x90013b50
9000bbc4:	90012aff 	.word	0x90012aff
9000bbc8:	90013bb6 	.word	0x90013bb6
9000bbcc:	90013b32 	.word	0x90013b32
9000bbd0:	90013b87 	.word	0x90013b87
9000bbd4:	90013b94 	.word	0x90013b94
  if (ipr->p == NULL) {
9000bbd8:	6863      	ldr	r3, [r4, #4]
9000bbda:	2b00      	cmp	r3, #0
9000bbdc:	f47f af0d 	bne.w	9000b9fa <ip4_reass+0x156>
    LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
9000bbe0:	4b19      	ldr	r3, [pc, #100]	; (9000bc48 <ip4_reass+0x3a4>)
9000bbe2:	681b      	ldr	r3, [r3, #0]
9000bbe4:	42a3      	cmp	r3, r4
9000bbe6:	d006      	beq.n	9000bbf6 <ip4_reass+0x352>
9000bbe8:	4b18      	ldr	r3, [pc, #96]	; (9000bc4c <ip4_reass+0x3a8>)
9000bbea:	f240 22ab 	movw	r2, #683	; 0x2ab
9000bbee:	4918      	ldr	r1, [pc, #96]	; (9000bc50 <ip4_reass+0x3ac>)
9000bbf0:	4818      	ldr	r0, [pc, #96]	; (9000bc54 <ip4_reass+0x3b0>)
9000bbf2:	f005 ffdb 	bl	90011bac <iprintf>
    ip_reass_dequeue_datagram(ipr, NULL);
9000bbf6:	2100      	movs	r1, #0
9000bbf8:	4620      	mov	r0, r4
9000bbfa:	f7ff fd3b 	bl	9000b674 <ip_reass_dequeue_datagram>
9000bbfe:	e6fc      	b.n	9000b9fa <ip4_reass+0x156>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
9000bc00:	88e8      	ldrh	r0, [r5, #6]
9000bc02:	f7fd fabd 	bl	90009180 <lwip_htons>
9000bc06:	f3c0 000c 	ubfx	r0, r0, #0, #13
9000bc0a:	2800      	cmp	r0, #0
9000bc0c:	f47f ae9b 	bne.w	9000b946 <ip4_reass+0xa2>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
9000bc10:	89e0      	ldrh	r0, [r4, #14]
9000bc12:	f7fd fab5 	bl	90009180 <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
9000bc16:	f3c0 000c 	ubfx	r0, r0, #0, #13
9000bc1a:	2800      	cmp	r0, #0
9000bc1c:	f43f ae93 	beq.w	9000b946 <ip4_reass+0xa2>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
9000bc20:	462b      	mov	r3, r5
9000bc22:	f104 0208 	add.w	r2, r4, #8
9000bc26:	f105 0114 	add.w	r1, r5, #20
9000bc2a:	f853 0b04 	ldr.w	r0, [r3], #4
9000bc2e:	428b      	cmp	r3, r1
9000bc30:	f842 0b04 	str.w	r0, [r2], #4
9000bc34:	d1f9      	bne.n	9000bc2a <ip4_reass+0x386>
9000bc36:	e686      	b.n	9000b946 <ip4_reass+0xa2>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
9000bc38:	f1bb 0f00 	cmp.w	fp, #0
9000bc3c:	f43f af0f 	beq.w	9000ba5e <ip4_reass+0x1ba>
9000bc40:	f04f 0a00 	mov.w	sl, #0
9000bc44:	e703      	b.n	9000ba4e <ip4_reass+0x1aa>
9000bc46:	bf00      	nop
9000bc48:	2400a114 	.word	0x2400a114
9000bc4c:	90013a70 	.word	0x90013a70
9000bc50:	90013bd1 	.word	0x90013bd1
9000bc54:	90012aff 	.word	0x90012aff

9000bc58 <ip4_frag>:
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
9000bc58:	8d8b      	ldrh	r3, [r1, #44]	; 0x2c
{
9000bc5a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000bc5e:	ed2d 8b02 	vpush	{d8}
9000bc62:	ee08 2a10 	vmov	s16, r2
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
9000bc66:	f1b3 0214 	subs.w	r2, r3, #20
{
9000bc6a:	b08b      	sub	sp, #44	; 0x2c
9000bc6c:	4605      	mov	r5, r0
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
9000bc6e:	bf48      	it	mi
9000bc70:	f1a3 020d 	submi.w	r2, r3, #13
{
9000bc74:	468a      	mov	sl, r1
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
9000bc76:	f3c2 03cf 	ubfx	r3, r2, #3, #16
9000bc7a:	9305      	str	r3, [sp, #20]
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;
  int mf_set;

  original_iphdr = (struct ip_hdr *)p->payload;
9000bc7c:	6843      	ldr	r3, [r0, #4]
9000bc7e:	9302      	str	r3, [sp, #8]
  iphdr = original_iphdr;
  if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
9000bc80:	781b      	ldrb	r3, [r3, #0]
9000bc82:	f003 030f 	and.w	r3, r3, #15
9000bc86:	2b05      	cmp	r3, #5
9000bc88:	ea4f 0783 	mov.w	r7, r3, lsl #2
9000bc8c:	d109      	bne.n	9000bca2 <ip4_frag+0x4a>
    /* ip4_frag() does not support IP options */
    return ERR_VAL;
  }
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
9000bc8e:	8943      	ldrh	r3, [r0, #10]
9000bc90:	2b13      	cmp	r3, #19
9000bc92:	d809      	bhi.n	9000bca8 <ip4_frag+0x50>
9000bc94:	4b60      	ldr	r3, [pc, #384]	; (9000be18 <ip4_frag+0x1c0>)
9000bc96:	f44f 723f 	mov.w	r2, #764	; 0x2fc
9000bc9a:	4960      	ldr	r1, [pc, #384]	; (9000be1c <ip4_frag+0x1c4>)
9000bc9c:	4860      	ldr	r0, [pc, #384]	; (9000be20 <ip4_frag+0x1c8>)
9000bc9e:	f005 ff85 	bl	90011bac <iprintf>
    return ERR_VAL;
9000bca2:	f06f 0005 	mvn.w	r0, #5
9000bca6:	e013      	b.n	9000bcd0 <ip4_frag+0x78>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
9000bca8:	9b02      	ldr	r3, [sp, #8]
  u16_t newpbuflen = 0;
9000bcaa:	2600      	movs	r6, #0
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
9000bcac:	88d8      	ldrh	r0, [r3, #6]
9000bcae:	f7fd fa67 	bl	90009180 <lwip_htons>
  ofo = tmp & IP_OFFMASK;
9000bcb2:	f3c0 030c 	ubfx	r3, r0, #0, #13
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;

  left = (u16_t)(p->tot_len - IP_HLEN);
9000bcb6:	892c      	ldrh	r4, [r5, #8]
  ofo = tmp & IP_OFFMASK;
9000bcb8:	9303      	str	r3, [sp, #12]
  mf_set = tmp & IP_MF;
9000bcba:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
  left = (u16_t)(p->tot_len - IP_HLEN);
9000bcbe:	3c14      	subs	r4, #20
9000bcc0:	9307      	str	r3, [sp, #28]

  while (left) {
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
9000bcc2:	9b05      	ldr	r3, [sp, #20]
  left = (u16_t)(p->tot_len - IP_HLEN);
9000bcc4:	b2a4      	uxth	r4, r4
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
9000bcc6:	00db      	lsls	r3, r3, #3
9000bcc8:	b29b      	uxth	r3, r3
9000bcca:	9306      	str	r3, [sp, #24]
  while (left) {
9000bccc:	b92c      	cbnz	r4, 9000bcda <ip4_frag+0x82>
    pbuf_free(rambuf);
    left = (u16_t)(left - fragsize);
    ofo = (u16_t)(ofo + nfb);
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
9000bcce:	4620      	mov	r0, r4
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
}
9000bcd0:	b00b      	add	sp, #44	; 0x2c
9000bcd2:	ecbd 8b02 	vpop	{d8}
9000bcd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
9000bcda:	9b06      	ldr	r3, [sp, #24]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
9000bcdc:	f44f 7220 	mov.w	r2, #640	; 0x280
9000bce0:	2114      	movs	r1, #20
9000bce2:	200e      	movs	r0, #14
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
9000bce4:	42a3      	cmp	r3, r4
9000bce6:	bf28      	it	cs
9000bce8:	4623      	movcs	r3, r4
9000bcea:	9304      	str	r3, [sp, #16]
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
9000bcec:	f001 f840 	bl	9000cd70 <pbuf_alloc>
    if (rambuf == NULL) {
9000bcf0:	4680      	mov	r8, r0
9000bcf2:	2800      	cmp	r0, #0
9000bcf4:	d036      	beq.n	9000bd64 <ip4_frag+0x10c>
    LWIP_ASSERT("this needs a pbuf in one piece!",
9000bcf6:	8943      	ldrh	r3, [r0, #10]
9000bcf8:	2b13      	cmp	r3, #19
9000bcfa:	d806      	bhi.n	9000bd0a <ip4_frag+0xb2>
9000bcfc:	4b46      	ldr	r3, [pc, #280]	; (9000be18 <ip4_frag+0x1c0>)
9000bcfe:	f44f 7249 	mov.w	r2, #804	; 0x324
9000bd02:	4948      	ldr	r1, [pc, #288]	; (9000be24 <ip4_frag+0x1cc>)
9000bd04:	4846      	ldr	r0, [pc, #280]	; (9000be20 <ip4_frag+0x1c8>)
9000bd06:	f005 ff51 	bl	90011bac <iprintf>
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
9000bd0a:	9b02      	ldr	r3, [sp, #8]
9000bd0c:	f8d8 2004 	ldr.w	r2, [r8, #4]
9000bd10:	4619      	mov	r1, r3
9000bd12:	3114      	adds	r1, #20
9000bd14:	f853 0b04 	ldr.w	r0, [r3], #4
9000bd18:	428b      	cmp	r3, r1
9000bd1a:	f842 0b04 	str.w	r0, [r2], #4
9000bd1e:	d1f9      	bne.n	9000bd14 <ip4_frag+0xbc>
    iphdr = (struct ip_hdr *)rambuf->payload;
9000bd20:	f8d8 b004 	ldr.w	fp, [r8, #4]
    left_to_copy = fragsize;
9000bd24:	f8dd 9010 	ldr.w	r9, [sp, #16]
    while (left_to_copy) {
9000bd28:	f1b9 0f00 	cmp.w	r9, #0
9000bd2c:	d041      	beq.n	9000bdb2 <ip4_frag+0x15a>
      u16_t plen = (u16_t)(p->len - poff);
9000bd2e:	896b      	ldrh	r3, [r5, #10]
9000bd30:	1bde      	subs	r6, r3, r7
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
9000bd32:	42bb      	cmp	r3, r7
      u16_t plen = (u16_t)(p->len - poff);
9000bd34:	b2b6      	uxth	r6, r6
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
9000bd36:	d206      	bcs.n	9000bd46 <ip4_frag+0xee>
9000bd38:	4b37      	ldr	r3, [pc, #220]	; (9000be18 <ip4_frag+0x1c0>)
9000bd3a:	f240 322d 	movw	r2, #813	; 0x32d
9000bd3e:	493a      	ldr	r1, [pc, #232]	; (9000be28 <ip4_frag+0x1d0>)
9000bd40:	4837      	ldr	r0, [pc, #220]	; (9000be20 <ip4_frag+0x1c8>)
9000bd42:	f005 ff33 	bl	90011bac <iprintf>
      newpbuflen = LWIP_MIN(left_to_copy, plen);
9000bd46:	454e      	cmp	r6, r9
9000bd48:	bf28      	it	cs
9000bd4a:	464e      	movcs	r6, r9
      if (!newpbuflen) {
9000bd4c:	b916      	cbnz	r6, 9000bd54 <ip4_frag+0xfc>
        p = p->next;
9000bd4e:	682d      	ldr	r5, [r5, #0]
        poff = 0;
9000bd50:	2700      	movs	r7, #0
9000bd52:	e7e9      	b.n	9000bd28 <ip4_frag+0xd0>
  return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
9000bd54:	2005      	movs	r0, #5
9000bd56:	f000 fb59 	bl	9000c40c <memp_malloc>
      if (pcr == NULL) {
9000bd5a:	4603      	mov	r3, r0
9000bd5c:	b928      	cbnz	r0, 9000bd6a <ip4_frag+0x112>
        pbuf_free(rambuf);
9000bd5e:	4640      	mov	r0, r8
9000bd60:	f000 ff9e 	bl	9000cca0 <pbuf_free>
  return ERR_MEM;
9000bd64:	f04f 30ff 	mov.w	r0, #4294967295
9000bd68:	e7b2      	b.n	9000bcd0 <ip4_frag+0x78>
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
9000bd6a:	9601      	str	r6, [sp, #4]
9000bd6c:	4631      	mov	r1, r6
9000bd6e:	686a      	ldr	r2, [r5, #4]
9000bd70:	9008      	str	r0, [sp, #32]
9000bd72:	2000      	movs	r0, #0
9000bd74:	443a      	add	r2, r7
9000bd76:	9200      	str	r2, [sp, #0]
9000bd78:	2241      	movs	r2, #65	; 0x41
9000bd7a:	f000 ff3f 	bl	9000cbfc <pbuf_alloced_custom>
      if (newpbuf == NULL) {
9000bd7e:	9b08      	ldr	r3, [sp, #32]
9000bd80:	b918      	cbnz	r0, 9000bd8a <ip4_frag+0x132>
        ip_frag_free_pbuf_custom_ref(pcr);
9000bd82:	4618      	mov	r0, r3
9000bd84:	f7ff fd48 	bl	9000b818 <ip_frag_free_pbuf_custom_ref>
9000bd88:	e7e9      	b.n	9000bd5e <ip4_frag+0x106>
9000bd8a:	e9cd 0308 	strd	r0, r3, [sp, #32]
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
9000bd8e:	eba9 0906 	sub.w	r9, r9, r6
      pbuf_ref(p);
9000bd92:	4628      	mov	r0, r5
9000bd94:	f001 f8de 	bl	9000cf54 <pbuf_ref>
      pcr->original = p;
9000bd98:	9b09      	ldr	r3, [sp, #36]	; 0x24
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
9000bd9a:	4a24      	ldr	r2, [pc, #144]	; (9000be2c <ip4_frag+0x1d4>)
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
9000bd9c:	fa1f f989 	uxth.w	r9, r9
      pbuf_cat(rambuf, newpbuf);
9000bda0:	9908      	ldr	r1, [sp, #32]
9000bda2:	4640      	mov	r0, r8
      pcr->original = p;
9000bda4:	615d      	str	r5, [r3, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
9000bda6:	611a      	str	r2, [r3, #16]
      pbuf_cat(rambuf, newpbuf);
9000bda8:	f001 f8f0 	bl	9000cf8c <pbuf_cat>
      if (left_to_copy) {
9000bdac:	f1b9 0f00 	cmp.w	r9, #0
9000bdb0:	d1cd      	bne.n	9000bd4e <ip4_frag+0xf6>
    tmp = (IP_OFFMASK & (ofo));
9000bdb2:	9b03      	ldr	r3, [sp, #12]
    poff = (u16_t)(poff + newpbuflen);
9000bdb4:	4437      	add	r7, r6
    tmp = (IP_OFFMASK & (ofo));
9000bdb6:	f3c3 000c 	ubfx	r0, r3, #0, #13
    last = (left <= netif->mtu - IP_HLEN);
9000bdba:	f8ba 302c 	ldrh.w	r3, [sl, #44]	; 0x2c
    poff = (u16_t)(poff + newpbuflen);
9000bdbe:	b2bf      	uxth	r7, r7
    last = (left <= netif->mtu - IP_HLEN);
9000bdc0:	3b13      	subs	r3, #19
    if (!last || mf_set) {
9000bdc2:	42a3      	cmp	r3, r4
9000bdc4:	dd01      	ble.n	9000bdca <ip4_frag+0x172>
9000bdc6:	9b07      	ldr	r3, [sp, #28]
9000bdc8:	b10b      	cbz	r3, 9000bdce <ip4_frag+0x176>
      tmp = tmp | IP_MF;
9000bdca:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
9000bdce:	f7fd f9d7 	bl	90009180 <lwip_htons>
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
9000bdd2:	9b04      	ldr	r3, [sp, #16]
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
9000bdd4:	f8ab 0006 	strh.w	r0, [fp, #6]
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
9000bdd8:	f103 0014 	add.w	r0, r3, #20
9000bddc:	b280      	uxth	r0, r0
9000bdde:	f7fd f9cf 	bl	90009180 <lwip_htons>
    IPH_CHKSUM_SET(iphdr, 0);
9000bde2:	2300      	movs	r3, #0
    netif->output(netif, rambuf, dest);
9000bde4:	ee18 2a10 	vmov	r2, s16
9000bde8:	4641      	mov	r1, r8
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
9000bdea:	f8ab 0002 	strh.w	r0, [fp, #2]
    netif->output(netif, rambuf, dest);
9000bdee:	4650      	mov	r0, sl
    IPH_CHKSUM_SET(iphdr, 0);
9000bdf0:	f88b 300a 	strb.w	r3, [fp, #10]
9000bdf4:	f88b 300b 	strb.w	r3, [fp, #11]
    netif->output(netif, rambuf, dest);
9000bdf8:	f8da 3014 	ldr.w	r3, [sl, #20]
9000bdfc:	4798      	blx	r3
    pbuf_free(rambuf);
9000bdfe:	4640      	mov	r0, r8
9000be00:	f000 ff4e 	bl	9000cca0 <pbuf_free>
    left = (u16_t)(left - fragsize);
9000be04:	9b04      	ldr	r3, [sp, #16]
    ofo = (u16_t)(ofo + nfb);
9000be06:	9a05      	ldr	r2, [sp, #20]
    left = (u16_t)(left - fragsize);
9000be08:	1ae4      	subs	r4, r4, r3
    ofo = (u16_t)(ofo + nfb);
9000be0a:	9b03      	ldr	r3, [sp, #12]
9000be0c:	4413      	add	r3, r2
    left = (u16_t)(left - fragsize);
9000be0e:	b2a4      	uxth	r4, r4
    ofo = (u16_t)(ofo + nfb);
9000be10:	b29b      	uxth	r3, r3
9000be12:	9303      	str	r3, [sp, #12]
9000be14:	e75a      	b.n	9000bccc <ip4_frag+0x74>
9000be16:	bf00      	nop
9000be18:	90013a70 	.word	0x90013a70
9000be1c:	90013bf1 	.word	0x90013bf1
9000be20:	90012aff 	.word	0x90012aff
9000be24:	90013c0c 	.word	0x90013c0c
9000be28:	90013c2c 	.word	0x90013c2c
9000be2c:	9000b845 	.word	0x9000b845

9000be30 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
9000be30:	4b11      	ldr	r3, [pc, #68]	; (9000be78 <mem_init+0x48>)
9000be32:	4a12      	ldr	r2, [pc, #72]	; (9000be7c <mem_init+0x4c>)
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
9000be34:	4912      	ldr	r1, [pc, #72]	; (9000be80 <mem_init+0x50>)
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
9000be36:	4813      	ldr	r0, [pc, #76]	; (9000be84 <mem_init+0x54>)
{
9000be38:	b510      	push	{r4, lr}
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
9000be3a:	6013      	str	r3, [r2, #0]
  mem->next = MEM_SIZE_ALIGNED;
9000be3c:	f44f 62c8 	mov.w	r2, #1600	; 0x640
9000be40:	601a      	str	r2, [r3, #0]
  mem->used = 0;
9000be42:	2200      	movs	r2, #0
9000be44:	711a      	strb	r2, [r3, #4]
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
9000be46:	4a10      	ldr	r2, [pc, #64]	; (9000be88 <mem_init+0x58>)
9000be48:	6011      	str	r1, [r2, #0]
  ram_end->used = 1;
9000be4a:	2101      	movs	r1, #1
  ram_end->next = MEM_SIZE_ALIGNED;
9000be4c:	4a0f      	ldr	r2, [pc, #60]	; (9000be8c <mem_init+0x5c>)
9000be4e:	f8c3 2640 	str.w	r2, [r3, #1600]	; 0x640
  ram_end->used = 1;
9000be52:	4a0f      	ldr	r2, [pc, #60]	; (9000be90 <mem_init+0x60>)
9000be54:	f882 1044 	strb.w	r1, [r2, #68]	; 0x44
  lfree = (struct mem *)(void *)ram;
9000be58:	4a0e      	ldr	r2, [pc, #56]	; (9000be94 <mem_init+0x64>)
9000be5a:	6013      	str	r3, [r2, #0]
  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
9000be5c:	f001 fafa 	bl	9000d454 <sys_mutex_new>
9000be60:	b140      	cbz	r0, 9000be74 <mem_init+0x44>
    LWIP_ASSERT("failed to create mem_mutex", 0);
9000be62:	4b0d      	ldr	r3, [pc, #52]	; (9000be98 <mem_init+0x68>)
9000be64:	f240 221f 	movw	r2, #543	; 0x21f
9000be68:	490c      	ldr	r1, [pc, #48]	; (9000be9c <mem_init+0x6c>)
9000be6a:	480d      	ldr	r0, [pc, #52]	; (9000bea0 <mem_init+0x70>)
  }
}
9000be6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LWIP_ASSERT("failed to create mem_mutex", 0);
9000be70:	f005 be9c 	b.w	90011bac <iprintf>
}
9000be74:	bd10      	pop	{r4, pc}
9000be76:	bf00      	nop
9000be78:	30044000 	.word	0x30044000
9000be7c:	2400a120 	.word	0x2400a120
9000be80:	30044640 	.word	0x30044640
9000be84:	2400a11c 	.word	0x2400a11c
9000be88:	2400a124 	.word	0x2400a124
9000be8c:	06400640 	.word	0x06400640
9000be90:	30044600 	.word	0x30044600
9000be94:	2400a118 	.word	0x2400a118
9000be98:	90013c3b 	.word	0x90013c3b
9000be9c:	90013c71 	.word	0x90013c71
9000bea0:	90012aff 	.word	0x90012aff

9000bea4 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
9000bea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
9000bea8:	4604      	mov	r4, r0
9000beaa:	2800      	cmp	r0, #0
9000beac:	f000 80b7 	beq.w	9000c01e <mem_free+0x17a>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
9000beb0:	0783      	lsls	r3, r0, #30
9000beb2:	d00c      	beq.n	9000bece <mem_free+0x2a>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
9000beb4:	4b5b      	ldr	r3, [pc, #364]	; (9000c024 <mem_free+0x180>)
9000beb6:	f240 2273 	movw	r2, #627	; 0x273
9000beba:	495b      	ldr	r1, [pc, #364]	; (9000c028 <mem_free+0x184>)
  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
9000bebc:	485b      	ldr	r0, [pc, #364]	; (9000c02c <mem_free+0x188>)
9000bebe:	f005 fe75 	bl	90011bac <iprintf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
9000bec2:	f001 faf1 	bl	9000d4a8 <sys_arch_protect>
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
9000bec6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MEM_STATS_INC_LOCKED(illegal);
9000beca:	f001 baf9 	b.w	9000d4c0 <sys_arch_unprotect>
  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
9000bece:	f8df 8188 	ldr.w	r8, [pc, #392]	; 9000c058 <mem_free+0x1b4>
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
9000bed2:	f1a0 0508 	sub.w	r5, r0, #8
  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
9000bed6:	f8d8 3000 	ldr.w	r3, [r8]
9000beda:	42ab      	cmp	r3, r5
9000bedc:	d805      	bhi.n	9000beea <mem_free+0x46>
9000bede:	4f54      	ldr	r7, [pc, #336]	; (9000c030 <mem_free+0x18c>)
9000bee0:	f100 030c 	add.w	r3, r0, #12
9000bee4:	683a      	ldr	r2, [r7, #0]
9000bee6:	429a      	cmp	r2, r3
9000bee8:	d204      	bcs.n	9000bef4 <mem_free+0x50>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
9000beea:	4b4e      	ldr	r3, [pc, #312]	; (9000c024 <mem_free+0x180>)
9000beec:	f240 227f 	movw	r2, #639	; 0x27f
9000bef0:	4950      	ldr	r1, [pc, #320]	; (9000c034 <mem_free+0x190>)
9000bef2:	e7e3      	b.n	9000bebc <mem_free+0x18>
  LWIP_MEM_FREE_PROTECT();
9000bef4:	4850      	ldr	r0, [pc, #320]	; (9000c038 <mem_free+0x194>)
9000bef6:	f001 fab8 	bl	9000d46a <sys_mutex_lock>
  if (!mem->used) {
9000befa:	f814 3c04 	ldrb.w	r3, [r4, #-4]
9000befe:	b953      	cbnz	r3, 9000bf16 <mem_free+0x72>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
9000bf00:	4b48      	ldr	r3, [pc, #288]	; (9000c024 <mem_free+0x180>)
9000bf02:	f44f 7223 	mov.w	r2, #652	; 0x28c
9000bf06:	494d      	ldr	r1, [pc, #308]	; (9000c03c <mem_free+0x198>)
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
9000bf08:	4848      	ldr	r0, [pc, #288]	; (9000c02c <mem_free+0x188>)
9000bf0a:	f005 fe4f 	bl	90011bac <iprintf>
    LWIP_MEM_FREE_UNPROTECT();
9000bf0e:	484a      	ldr	r0, [pc, #296]	; (9000c038 <mem_free+0x194>)
9000bf10:	f001 fab0 	bl	9000d474 <sys_mutex_unlock>
    MEM_STATS_INC_LOCKED(illegal);
9000bf14:	e7d5      	b.n	9000bec2 <mem_free+0x1e>
  nmem = ptr_to_mem(mem->next);
9000bf16:	f834 2c08 	ldrh.w	r2, [r4, #-8]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
9000bf1a:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
9000bf1e:	d814      	bhi.n	9000bf4a <mem_free+0xa6>
  pmem = ptr_to_mem(mem->prev);
9000bf20:	f834 0c06 	ldrh.w	r0, [r4, #-6]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
9000bf24:	f5b0 6fc8 	cmp.w	r0, #1600	; 0x640
9000bf28:	d80f      	bhi.n	9000bf4a <mem_free+0xa6>
  return (mem_size_t)((u8_t *)mem - ram);
9000bf2a:	f8d8 1000 	ldr.w	r1, [r8]
9000bf2e:	1a6b      	subs	r3, r5, r1
9000bf30:	b29b      	uxth	r3, r3
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
9000bf32:	4283      	cmp	r3, r0
9000bf34:	d002      	beq.n	9000bf3c <mem_free+0x98>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
9000bf36:	5a08      	ldrh	r0, [r1, r0]
9000bf38:	4298      	cmp	r0, r3
9000bf3a:	d106      	bne.n	9000bf4a <mem_free+0xa6>
  return (struct mem *)(void *)&ram[ptr];
9000bf3c:	440a      	add	r2, r1
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
9000bf3e:	6838      	ldr	r0, [r7, #0]
9000bf40:	4282      	cmp	r2, r0
9000bf42:	d007      	beq.n	9000bf54 <mem_free+0xb0>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
9000bf44:	8852      	ldrh	r2, [r2, #2]
9000bf46:	429a      	cmp	r2, r3
9000bf48:	d004      	beq.n	9000bf54 <mem_free+0xb0>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
9000bf4a:	4b36      	ldr	r3, [pc, #216]	; (9000c024 <mem_free+0x180>)
9000bf4c:	f240 2295 	movw	r2, #661	; 0x295
9000bf50:	493b      	ldr	r1, [pc, #236]	; (9000c040 <mem_free+0x19c>)
9000bf52:	e7d9      	b.n	9000bf08 <mem_free+0x64>
  mem->used = 0;
9000bf54:	2300      	movs	r3, #0
  if (mem < lfree) {
9000bf56:	4e3b      	ldr	r6, [pc, #236]	; (9000c044 <mem_free+0x1a0>)
  mem->used = 0;
9000bf58:	f804 3c04 	strb.w	r3, [r4, #-4]
  if (mem < lfree) {
9000bf5c:	6833      	ldr	r3, [r6, #0]
9000bf5e:	42ab      	cmp	r3, r5
    lfree = mem;
9000bf60:	bf88      	it	hi
9000bf62:	6035      	strhi	r5, [r6, #0]
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
9000bf64:	428d      	cmp	r5, r1
9000bf66:	d206      	bcs.n	9000bf76 <mem_free+0xd2>
9000bf68:	4b2e      	ldr	r3, [pc, #184]	; (9000c024 <mem_free+0x180>)
9000bf6a:	f240 12df 	movw	r2, #479	; 0x1df
9000bf6e:	4936      	ldr	r1, [pc, #216]	; (9000c048 <mem_free+0x1a4>)
9000bf70:	482e      	ldr	r0, [pc, #184]	; (9000c02c <mem_free+0x188>)
9000bf72:	f005 fe1b 	bl	90011bac <iprintf>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
9000bf76:	683b      	ldr	r3, [r7, #0]
9000bf78:	429d      	cmp	r5, r3
9000bf7a:	d306      	bcc.n	9000bf8a <mem_free+0xe6>
9000bf7c:	4b29      	ldr	r3, [pc, #164]	; (9000c024 <mem_free+0x180>)
9000bf7e:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
9000bf82:	4932      	ldr	r1, [pc, #200]	; (9000c04c <mem_free+0x1a8>)
9000bf84:	4829      	ldr	r0, [pc, #164]	; (9000c02c <mem_free+0x188>)
9000bf86:	f005 fe11 	bl	90011bac <iprintf>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
9000bf8a:	f814 3c04 	ldrb.w	r3, [r4, #-4]
9000bf8e:	b133      	cbz	r3, 9000bf9e <mem_free+0xfa>
9000bf90:	4b24      	ldr	r3, [pc, #144]	; (9000c024 <mem_free+0x180>)
9000bf92:	f240 12e1 	movw	r2, #481	; 0x1e1
9000bf96:	492e      	ldr	r1, [pc, #184]	; (9000c050 <mem_free+0x1ac>)
9000bf98:	4824      	ldr	r0, [pc, #144]	; (9000c02c <mem_free+0x188>)
9000bf9a:	f005 fe07 	bl	90011bac <iprintf>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
9000bf9e:	f834 3c08 	ldrh.w	r3, [r4, #-8]
9000bfa2:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
9000bfa6:	d906      	bls.n	9000bfb6 <mem_free+0x112>
9000bfa8:	4b1e      	ldr	r3, [pc, #120]	; (9000c024 <mem_free+0x180>)
9000bfaa:	f44f 72f2 	mov.w	r2, #484	; 0x1e4
9000bfae:	4929      	ldr	r1, [pc, #164]	; (9000c054 <mem_free+0x1b0>)
9000bfb0:	481e      	ldr	r0, [pc, #120]	; (9000c02c <mem_free+0x188>)
9000bfb2:	f005 fdfb 	bl	90011bac <iprintf>
  return (struct mem *)(void *)&ram[ptr];
9000bfb6:	f8d8 3000 	ldr.w	r3, [r8]
9000bfba:	f834 1c08 	ldrh.w	r1, [r4, #-8]
9000bfbe:	185a      	adds	r2, r3, r1
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
9000bfc0:	4295      	cmp	r5, r2
9000bfc2:	d012      	beq.n	9000bfea <mem_free+0x146>
9000bfc4:	7910      	ldrb	r0, [r2, #4]
9000bfc6:	b980      	cbnz	r0, 9000bfea <mem_free+0x146>
9000bfc8:	6838      	ldr	r0, [r7, #0]
9000bfca:	4282      	cmp	r2, r0
9000bfcc:	d00d      	beq.n	9000bfea <mem_free+0x146>
    if (lfree == nmem) {
9000bfce:	6830      	ldr	r0, [r6, #0]
9000bfd0:	4282      	cmp	r2, r0
    mem->next = nmem->next;
9000bfd2:	5a5a      	ldrh	r2, [r3, r1]
9000bfd4:	f824 2c08 	strh.w	r2, [r4, #-8]
    if (nmem->next != MEM_SIZE_ALIGNED) {
9000bfd8:	5a5a      	ldrh	r2, [r3, r1]
      lfree = mem;
9000bfda:	bf08      	it	eq
9000bfdc:	6035      	streq	r5, [r6, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
9000bfde:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
9000bfe2:	bf1e      	ittt	ne
9000bfe4:	18d2      	addne	r2, r2, r3
  return (mem_size_t)((u8_t *)mem - ram);
9000bfe6:	1ae9      	subne	r1, r5, r3
9000bfe8:	8051      	strhne	r1, [r2, #2]
  pmem = ptr_to_mem(mem->prev);
9000bfea:	f834 2c06 	ldrh.w	r2, [r4, #-6]
  return (struct mem *)(void *)&ram[ptr];
9000bfee:	1899      	adds	r1, r3, r2
  if (pmem != mem && pmem->used == 0) {
9000bff0:	428d      	cmp	r5, r1
9000bff2:	d00f      	beq.n	9000c014 <mem_free+0x170>
9000bff4:	7908      	ldrb	r0, [r1, #4]
9000bff6:	b968      	cbnz	r0, 9000c014 <mem_free+0x170>
    if (lfree == mem) {
9000bff8:	6830      	ldr	r0, [r6, #0]
9000bffa:	4285      	cmp	r5, r0
      lfree = pmem;
9000bffc:	bf08      	it	eq
9000bffe:	6031      	streq	r1, [r6, #0]
    pmem->next = mem->next;
9000c000:	f834 1c08 	ldrh.w	r1, [r4, #-8]
9000c004:	5299      	strh	r1, [r3, r2]
    if (mem->next != MEM_SIZE_ALIGNED) {
9000c006:	f834 1c08 	ldrh.w	r1, [r4, #-8]
9000c00a:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
9000c00e:	bf1c      	itt	ne
9000c010:	185b      	addne	r3, r3, r1
9000c012:	805a      	strhne	r2, [r3, #2]
  LWIP_MEM_FREE_UNPROTECT();
9000c014:	4808      	ldr	r0, [pc, #32]	; (9000c038 <mem_free+0x194>)
}
9000c016:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  LWIP_MEM_FREE_UNPROTECT();
9000c01a:	f001 ba2b 	b.w	9000d474 <sys_mutex_unlock>
}
9000c01e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9000c022:	bf00      	nop
9000c024:	90013c3b 	.word	0x90013c3b
9000c028:	90013c8c 	.word	0x90013c8c
9000c02c:	90012aff 	.word	0x90012aff
9000c030:	2400a124 	.word	0x2400a124
9000c034:	90013cad 	.word	0x90013cad
9000c038:	2400a11c 	.word	0x2400a11c
9000c03c:	90013cc6 	.word	0x90013cc6
9000c040:	90013cec 	.word	0x90013cec
9000c044:	2400a118 	.word	0x2400a118
9000c048:	90013d1e 	.word	0x90013d1e
9000c04c:	90013d35 	.word	0x90013d35
9000c050:	90013d4f 	.word	0x90013d4f
9000c054:	90013d6a 	.word	0x90013d6a
9000c058:	2400a120 	.word	0x2400a120

9000c05c <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
9000c05c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
9000c060:	1ccc      	adds	r4, r1, #3
{
9000c062:	4605      	mov	r5, r0
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
9000c064:	f024 0403 	bic.w	r4, r4, #3
9000c068:	b2a4      	uxth	r4, r4
  if (newsize < MIN_SIZE_ALIGNED) {
9000c06a:	2c0b      	cmp	r4, #11
9000c06c:	d904      	bls.n	9000c078 <mem_trim+0x1c>
    newsize = MIN_SIZE_ALIGNED;
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
9000c06e:	f5b4 6fc8 	cmp.w	r4, #1600	; 0x640
9000c072:	d902      	bls.n	9000c07a <mem_trim+0x1e>
    return NULL;
9000c074:	2500      	movs	r5, #0
9000c076:	e01f      	b.n	9000c0b8 <mem_trim+0x5c>
    newsize = MIN_SIZE_ALIGNED;
9000c078:	240c      	movs	r4, #12
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
9000c07a:	42a1      	cmp	r1, r4
9000c07c:	d8fa      	bhi.n	9000c074 <mem_trim+0x18>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
9000c07e:	f8df 8144 	ldr.w	r8, [pc, #324]	; 9000c1c4 <mem_trim+0x168>
9000c082:	f8d8 3000 	ldr.w	r3, [r8]
9000c086:	42ab      	cmp	r3, r5
9000c088:	d803      	bhi.n	9000c092 <mem_trim+0x36>
9000c08a:	4b46      	ldr	r3, [pc, #280]	; (9000c1a4 <mem_trim+0x148>)
9000c08c:	681b      	ldr	r3, [r3, #0]
9000c08e:	42ab      	cmp	r3, r5
9000c090:	d806      	bhi.n	9000c0a0 <mem_trim+0x44>
9000c092:	4b45      	ldr	r3, [pc, #276]	; (9000c1a8 <mem_trim+0x14c>)
9000c094:	f240 22d1 	movw	r2, #721	; 0x2d1
9000c098:	4944      	ldr	r1, [pc, #272]	; (9000c1ac <mem_trim+0x150>)
9000c09a:	4845      	ldr	r0, [pc, #276]	; (9000c1b0 <mem_trim+0x154>)
9000c09c:	f005 fd86 	bl	90011bac <iprintf>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
9000c0a0:	f8d8 3000 	ldr.w	r3, [r8]
9000c0a4:	42ab      	cmp	r3, r5
9000c0a6:	d803      	bhi.n	9000c0b0 <mem_trim+0x54>
9000c0a8:	4a3e      	ldr	r2, [pc, #248]	; (9000c1a4 <mem_trim+0x148>)
9000c0aa:	6812      	ldr	r2, [r2, #0]
9000c0ac:	42aa      	cmp	r2, r5
9000c0ae:	d806      	bhi.n	9000c0be <mem_trim+0x62>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
9000c0b0:	f001 f9fa 	bl	9000d4a8 <sys_arch_protect>
9000c0b4:	f001 fa04 	bl	9000d4c0 <sys_arch_unprotect>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
9000c0b8:	4628      	mov	r0, r5
9000c0ba:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
9000c0be:	f1a5 0608 	sub.w	r6, r5, #8
  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
9000c0c2:	f835 7c08 	ldrh.w	r7, [r5, #-8]
  return (mem_size_t)((u8_t *)mem - ram);
9000c0c6:	1af6      	subs	r6, r6, r3
  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
9000c0c8:	3f08      	subs	r7, #8
  return (mem_size_t)((u8_t *)mem - ram);
9000c0ca:	b2b6      	uxth	r6, r6
  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
9000c0cc:	1bbf      	subs	r7, r7, r6
9000c0ce:	b2bf      	uxth	r7, r7
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
9000c0d0:	42a7      	cmp	r7, r4
9000c0d2:	d207      	bcs.n	9000c0e4 <mem_trim+0x88>
9000c0d4:	4b34      	ldr	r3, [pc, #208]	; (9000c1a8 <mem_trim+0x14c>)
9000c0d6:	f44f 7239 	mov.w	r2, #740	; 0x2e4
9000c0da:	4936      	ldr	r1, [pc, #216]	; (9000c1b4 <mem_trim+0x158>)
9000c0dc:	4834      	ldr	r0, [pc, #208]	; (9000c1b0 <mem_trim+0x154>)
9000c0de:	f005 fd65 	bl	90011bac <iprintf>
  if (newsize > size) {
9000c0e2:	e7c7      	b.n	9000c074 <mem_trim+0x18>
  if (newsize == size) {
9000c0e4:	d0e8      	beq.n	9000c0b8 <mem_trim+0x5c>
  LWIP_MEM_FREE_PROTECT();
9000c0e6:	4834      	ldr	r0, [pc, #208]	; (9000c1b8 <mem_trim+0x15c>)
9000c0e8:	f001 f9bf 	bl	9000d46a <sys_mutex_lock>
  mem2 = ptr_to_mem(mem->next);
9000c0ec:	f835 9c08 	ldrh.w	r9, [r5, #-8]
  return (struct mem *)(void *)&ram[ptr];
9000c0f0:	f8d8 b000 	ldr.w	fp, [r8]
9000c0f4:	eb0b 0a09 	add.w	sl, fp, r9
  if (mem2->used == 0) {
9000c0f8:	f89a 3004 	ldrb.w	r3, [sl, #4]
9000c0fc:	bb43      	cbnz	r3, 9000c150 <mem_trim+0xf4>
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
9000c0fe:	f5b9 6fc8 	cmp.w	r9, #1600	; 0x640
9000c102:	d106      	bne.n	9000c112 <mem_trim+0xb6>
9000c104:	4b28      	ldr	r3, [pc, #160]	; (9000c1a8 <mem_trim+0x14c>)
9000c106:	f240 22f5 	movw	r2, #757	; 0x2f5
9000c10a:	492c      	ldr	r1, [pc, #176]	; (9000c1bc <mem_trim+0x160>)
9000c10c:	4828      	ldr	r0, [pc, #160]	; (9000c1b0 <mem_trim+0x154>)
9000c10e:	f005 fd4d 	bl	90011bac <iprintf>
    if (lfree == mem2) {
9000c112:	492b      	ldr	r1, [pc, #172]	; (9000c1c0 <mem_trim+0x164>)
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
9000c114:	f106 0308 	add.w	r3, r6, #8
    next = mem2->next;
9000c118:	f83b 7009 	ldrh.w	r7, [fp, r9]
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
9000c11c:	441c      	add	r4, r3
    if (lfree == mem2) {
9000c11e:	6808      	ldr	r0, [r1, #0]
  return (struct mem *)(void *)&ram[ptr];
9000c120:	f8d8 3000 	ldr.w	r3, [r8]
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
9000c124:	b2a2      	uxth	r2, r4
    if (lfree == mem2) {
9000c126:	4550      	cmp	r0, sl
  return (struct mem *)(void *)&ram[ptr];
9000c128:	fa13 f484 	uxtah	r4, r3, r4
      lfree = ptr_to_mem(ptr2);
9000c12c:	bf08      	it	eq
9000c12e:	600c      	streq	r4, [r1, #0]
    mem2->used = 0;
9000c130:	2100      	movs	r1, #0
9000c132:	7121      	strb	r1, [r4, #4]
    mem2->next = next;
9000c134:	529f      	strh	r7, [r3, r2]
    mem2->prev = ptr;
9000c136:	8066      	strh	r6, [r4, #2]
    mem->next = ptr2;
9000c138:	f825 2c08 	strh.w	r2, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
9000c13c:	5a99      	ldrh	r1, [r3, r2]
9000c13e:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
9000c142:	d001      	beq.n	9000c148 <mem_trim+0xec>
      ptr_to_mem(mem2->next)->prev = ptr2;
9000c144:	440b      	add	r3, r1
9000c146:	805a      	strh	r2, [r3, #2]
  LWIP_MEM_FREE_UNPROTECT();
9000c148:	481b      	ldr	r0, [pc, #108]	; (9000c1b8 <mem_trim+0x15c>)
9000c14a:	f001 f993 	bl	9000d474 <sys_mutex_unlock>
  return rmem;
9000c14e:	e7b3      	b.n	9000c0b8 <mem_trim+0x5c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
9000c150:	f104 0314 	add.w	r3, r4, #20
9000c154:	b29b      	uxth	r3, r3
9000c156:	429f      	cmp	r7, r3
9000c158:	d3f6      	bcc.n	9000c148 <mem_trim+0xec>
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
9000c15a:	f106 0308 	add.w	r3, r6, #8
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
9000c15e:	f5b9 6fc8 	cmp.w	r9, #1600	; 0x640
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
9000c162:	441c      	add	r4, r3
9000c164:	b2a4      	uxth	r4, r4
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
9000c166:	d106      	bne.n	9000c176 <mem_trim+0x11a>
9000c168:	4b0f      	ldr	r3, [pc, #60]	; (9000c1a8 <mem_trim+0x14c>)
9000c16a:	f240 3216 	movw	r2, #790	; 0x316
9000c16e:	4913      	ldr	r1, [pc, #76]	; (9000c1bc <mem_trim+0x160>)
9000c170:	480f      	ldr	r0, [pc, #60]	; (9000c1b0 <mem_trim+0x154>)
9000c172:	f005 fd1b 	bl	90011bac <iprintf>
  return (struct mem *)(void *)&ram[ptr];
9000c176:	f8d8 3000 	ldr.w	r3, [r8]
    if (mem2 < lfree) {
9000c17a:	4911      	ldr	r1, [pc, #68]	; (9000c1c0 <mem_trim+0x164>)
  return (struct mem *)(void *)&ram[ptr];
9000c17c:	191a      	adds	r2, r3, r4
    if (mem2 < lfree) {
9000c17e:	6808      	ldr	r0, [r1, #0]
9000c180:	4290      	cmp	r0, r2
      lfree = mem2;
9000c182:	bf88      	it	hi
9000c184:	600a      	strhi	r2, [r1, #0]
    mem2->used = 0;
9000c186:	2100      	movs	r1, #0
9000c188:	7111      	strb	r1, [r2, #4]
    mem2->next = mem->next;
9000c18a:	f835 1c08 	ldrh.w	r1, [r5, #-8]
9000c18e:	5319      	strh	r1, [r3, r4]
    mem2->prev = ptr;
9000c190:	8056      	strh	r6, [r2, #2]
    mem->next = ptr2;
9000c192:	f825 4c08 	strh.w	r4, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
9000c196:	5b1a      	ldrh	r2, [r3, r4]
9000c198:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
      ptr_to_mem(mem2->next)->prev = ptr2;
9000c19c:	bf1c      	itt	ne
9000c19e:	189b      	addne	r3, r3, r2
9000c1a0:	805c      	strhne	r4, [r3, #2]
9000c1a2:	e7d1      	b.n	9000c148 <mem_trim+0xec>
9000c1a4:	2400a124 	.word	0x2400a124
9000c1a8:	90013c3b 	.word	0x90013c3b
9000c1ac:	90013d94 	.word	0x90013d94
9000c1b0:	90012aff 	.word	0x90012aff
9000c1b4:	90013dab 	.word	0x90013dab
9000c1b8:	2400a11c 	.word	0x2400a11c
9000c1bc:	90013dcb 	.word	0x90013dcb
9000c1c0:	2400a118 	.word	0x2400a118
9000c1c4:	2400a120 	.word	0x2400a120

9000c1c8 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
9000c1c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
9000c1cc:	2800      	cmp	r0, #0
9000c1ce:	f000 808a 	beq.w	9000c2e6 <mem_malloc+0x11e>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
9000c1d2:	1cc5      	adds	r5, r0, #3
9000c1d4:	f025 0503 	bic.w	r5, r5, #3
9000c1d8:	b2ad      	uxth	r5, r5
  if (size < MIN_SIZE_ALIGNED) {
9000c1da:	2d0b      	cmp	r5, #11
9000c1dc:	d904      	bls.n	9000c1e8 <mem_malloc+0x20>
    size = MIN_SIZE_ALIGNED;
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
9000c1de:	f5b5 6fc8 	cmp.w	r5, #1600	; 0x640
9000c1e2:	d902      	bls.n	9000c1ea <mem_malloc+0x22>
    return NULL;
9000c1e4:	2000      	movs	r0, #0
9000c1e6:	e07e      	b.n	9000c2e6 <mem_malloc+0x11e>
    size = MIN_SIZE_ALIGNED;
9000c1e8:	250c      	movs	r5, #12
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
9000c1ea:	42a8      	cmp	r0, r5
9000c1ec:	d8fa      	bhi.n	9000c1e4 <mem_malloc+0x1c>
  return (mem_size_t)((u8_t *)mem - ram);
9000c1ee:	f8df 9130 	ldr.w	r9, [pc, #304]	; 9000c320 <mem_malloc+0x158>
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
9000c1f2:	f06f 0707 	mvn.w	r7, #7
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
9000c1f6:	f8df 812c 	ldr.w	r8, [pc, #300]	; 9000c324 <mem_malloc+0x15c>
  sys_mutex_lock(&mem_mutex);
9000c1fa:	4840      	ldr	r0, [pc, #256]	; (9000c2fc <mem_malloc+0x134>)
9000c1fc:	f001 f935 	bl	9000d46a <sys_mutex_lock>
  return (mem_size_t)((u8_t *)mem - ram);
9000c200:	f8d9 2000 	ldr.w	r2, [r9]
9000c204:	f8d8 6000 	ldr.w	r6, [r8]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
9000c208:	f5c5 60c8 	rsb	r0, r5, #1600	; 0x640
  return (mem_size_t)((u8_t *)mem - ram);
9000c20c:	1ab6      	subs	r6, r6, r2
9000c20e:	b2b6      	uxth	r6, r6
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
9000c210:	4286      	cmp	r6, r0
9000c212:	d303      	bcc.n	9000c21c <mem_malloc+0x54>
    /* if we got interrupted by a mem_free, try again */
  } while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
9000c214:	4839      	ldr	r0, [pc, #228]	; (9000c2fc <mem_malloc+0x134>)
9000c216:	f001 f92d 	bl	9000d474 <sys_mutex_unlock>
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
9000c21a:	e7e3      	b.n	9000c1e4 <mem_malloc+0x1c>
  return (struct mem *)(void *)&ram[ptr];
9000c21c:	1994      	adds	r4, r2, r6
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
9000c21e:	5b91      	ldrh	r1, [r2, r6]
      if ((!mem->used) &&
9000c220:	7923      	ldrb	r3, [r4, #4]
9000c222:	2b00      	cmp	r3, #0
9000c224:	d167      	bne.n	9000c2f6 <mem_malloc+0x12e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
9000c226:	1bbb      	subs	r3, r7, r6
9000c228:	440b      	add	r3, r1
      if ((!mem->used) &&
9000c22a:	42ab      	cmp	r3, r5
9000c22c:	d363      	bcc.n	9000c2f6 <mem_malloc+0x12e>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
9000c22e:	f105 0708 	add.w	r7, r5, #8
9000c232:	3514      	adds	r5, #20
9000c234:	b2ad      	uxth	r5, r5
9000c236:	b2bf      	uxth	r7, r7
9000c238:	42ab      	cmp	r3, r5
9000c23a:	d356      	bcc.n	9000c2ea <mem_malloc+0x122>
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
9000c23c:	19bd      	adds	r5, r7, r6
9000c23e:	b2ad      	uxth	r5, r5
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
9000c240:	f5b5 6fc8 	cmp.w	r5, #1600	; 0x640
9000c244:	d106      	bne.n	9000c254 <mem_malloc+0x8c>
9000c246:	4b2e      	ldr	r3, [pc, #184]	; (9000c300 <mem_malloc+0x138>)
9000c248:	f240 3287 	movw	r2, #903	; 0x387
9000c24c:	492d      	ldr	r1, [pc, #180]	; (9000c304 <mem_malloc+0x13c>)
9000c24e:	482e      	ldr	r0, [pc, #184]	; (9000c308 <mem_malloc+0x140>)
9000c250:	f005 fcac 	bl	90011bac <iprintf>
  return (struct mem *)(void *)&ram[ptr];
9000c254:	f8d9 3000 	ldr.w	r3, [r9]
          mem2->used = 0;
9000c258:	2100      	movs	r1, #0
  return (struct mem *)(void *)&ram[ptr];
9000c25a:	195a      	adds	r2, r3, r5
          mem2->used = 0;
9000c25c:	7111      	strb	r1, [r2, #4]
          mem2->next = mem->next;
9000c25e:	8821      	ldrh	r1, [r4, #0]
9000c260:	5359      	strh	r1, [r3, r5]
          mem2->prev = ptr;
9000c262:	8056      	strh	r6, [r2, #2]
          mem->used = 1;
9000c264:	2201      	movs	r2, #1
          mem->next = ptr2;
9000c266:	8025      	strh	r5, [r4, #0]
          mem->used = 1;
9000c268:	7122      	strb	r2, [r4, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
9000c26a:	5b5a      	ldrh	r2, [r3, r5]
9000c26c:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
9000c270:	d001      	beq.n	9000c276 <mem_malloc+0xae>
            ptr_to_mem(mem2->next)->prev = ptr2;
9000c272:	4413      	add	r3, r2
9000c274:	805d      	strh	r5, [r3, #2]
        if (mem == lfree) {
9000c276:	f8d8 3000 	ldr.w	r3, [r8]
9000c27a:	4d24      	ldr	r5, [pc, #144]	; (9000c30c <mem_malloc+0x144>)
9000c27c:	42a3      	cmp	r3, r4
9000c27e:	d112      	bne.n	9000c2a6 <mem_malloc+0xde>
          while (cur->used && cur != ram_end) {
9000c280:	6829      	ldr	r1, [r5, #0]
  return (struct mem *)(void *)&ram[ptr];
9000c282:	f8d9 0000 	ldr.w	r0, [r9]
          while (cur->used && cur != ram_end) {
9000c286:	791a      	ldrb	r2, [r3, #4]
9000c288:	b10a      	cbz	r2, 9000c28e <mem_malloc+0xc6>
9000c28a:	4299      	cmp	r1, r3
9000c28c:	d130      	bne.n	9000c2f0 <mem_malloc+0x128>
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
9000c28e:	4299      	cmp	r1, r3
          lfree = cur;
9000c290:	f8c8 3000 	str.w	r3, [r8]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
9000c294:	d007      	beq.n	9000c2a6 <mem_malloc+0xde>
9000c296:	b132      	cbz	r2, 9000c2a6 <mem_malloc+0xde>
9000c298:	4b19      	ldr	r3, [pc, #100]	; (9000c300 <mem_malloc+0x138>)
9000c29a:	f240 32b5 	movw	r2, #949	; 0x3b5
9000c29e:	491c      	ldr	r1, [pc, #112]	; (9000c310 <mem_malloc+0x148>)
9000c2a0:	4819      	ldr	r0, [pc, #100]	; (9000c308 <mem_malloc+0x140>)
9000c2a2:	f005 fc83 	bl	90011bac <iprintf>
        sys_mutex_unlock(&mem_mutex);
9000c2a6:	4815      	ldr	r0, [pc, #84]	; (9000c2fc <mem_malloc+0x134>)
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
9000c2a8:	4427      	add	r7, r4
        sys_mutex_unlock(&mem_mutex);
9000c2aa:	f001 f8e3 	bl	9000d474 <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
9000c2ae:	682b      	ldr	r3, [r5, #0]
9000c2b0:	42bb      	cmp	r3, r7
9000c2b2:	d206      	bcs.n	9000c2c2 <mem_malloc+0xfa>
9000c2b4:	4b12      	ldr	r3, [pc, #72]	; (9000c300 <mem_malloc+0x138>)
9000c2b6:	f240 32b9 	movw	r2, #953	; 0x3b9
9000c2ba:	4916      	ldr	r1, [pc, #88]	; (9000c314 <mem_malloc+0x14c>)
9000c2bc:	4812      	ldr	r0, [pc, #72]	; (9000c308 <mem_malloc+0x140>)
9000c2be:	f005 fc75 	bl	90011bac <iprintf>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
9000c2c2:	07a3      	lsls	r3, r4, #30
9000c2c4:	d00d      	beq.n	9000c2e2 <mem_malloc+0x11a>
9000c2c6:	4b0e      	ldr	r3, [pc, #56]	; (9000c300 <mem_malloc+0x138>)
9000c2c8:	f240 32bb 	movw	r2, #955	; 0x3bb
9000c2cc:	4912      	ldr	r1, [pc, #72]	; (9000c318 <mem_malloc+0x150>)
9000c2ce:	480e      	ldr	r0, [pc, #56]	; (9000c308 <mem_malloc+0x140>)
9000c2d0:	f005 fc6c 	bl	90011bac <iprintf>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
9000c2d4:	4b0a      	ldr	r3, [pc, #40]	; (9000c300 <mem_malloc+0x138>)
9000c2d6:	f240 32bd 	movw	r2, #957	; 0x3bd
9000c2da:	4910      	ldr	r1, [pc, #64]	; (9000c31c <mem_malloc+0x154>)
9000c2dc:	480a      	ldr	r0, [pc, #40]	; (9000c308 <mem_malloc+0x140>)
9000c2de:	f005 fc65 	bl	90011bac <iprintf>
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
9000c2e2:	f104 0008 	add.w	r0, r4, #8
}
9000c2e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          mem->used = 1;
9000c2ea:	2301      	movs	r3, #1
9000c2ec:	7123      	strb	r3, [r4, #4]
9000c2ee:	e7c2      	b.n	9000c276 <mem_malloc+0xae>
  return (struct mem *)(void *)&ram[ptr];
9000c2f0:	881b      	ldrh	r3, [r3, #0]
9000c2f2:	4403      	add	r3, r0
9000c2f4:	e7c7      	b.n	9000c286 <mem_malloc+0xbe>
9000c2f6:	460e      	mov	r6, r1
9000c2f8:	e78a      	b.n	9000c210 <mem_malloc+0x48>
9000c2fa:	bf00      	nop
9000c2fc:	2400a11c 	.word	0x2400a11c
9000c300:	90013c3b 	.word	0x90013c3b
9000c304:	90013dcb 	.word	0x90013dcb
9000c308:	90012aff 	.word	0x90012aff
9000c30c:	2400a124 	.word	0x2400a124
9000c310:	90013ddc 	.word	0x90013ddc
9000c314:	90013df5 	.word	0x90013df5
9000c318:	90013e25 	.word	0x90013e25
9000c31c:	90013e54 	.word	0x90013e54
9000c320:	2400a120 	.word	0x2400a120
9000c324:	2400a118 	.word	0x2400a118

9000c328 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
9000c328:	b538      	push	{r3, r4, r5, lr}
9000c32a:	4604      	mov	r4, r0

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
9000c32c:	f001 f8bc 	bl	9000d4a8 <sys_arch_protect>
9000c330:	4605      	mov	r5, r0

  memp = *desc->tab;
9000c332:	68a3      	ldr	r3, [r4, #8]
9000c334:	681c      	ldr	r4, [r3, #0]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
9000c336:	b15c      	cbz	r4, 9000c350 <do_memp_malloc_pool+0x28>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
9000c338:	6822      	ldr	r2, [r4, #0]
9000c33a:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
9000c33c:	07a3      	lsls	r3, r4, #30
9000c33e:	d006      	beq.n	9000c34e <do_memp_malloc_pool+0x26>
9000c340:	4b05      	ldr	r3, [pc, #20]	; (9000c358 <do_memp_malloc_pool+0x30>)
9000c342:	f44f 728c 	mov.w	r2, #280	; 0x118
9000c346:	4905      	ldr	r1, [pc, #20]	; (9000c35c <do_memp_malloc_pool+0x34>)
9000c348:	4805      	ldr	r0, [pc, #20]	; (9000c360 <do_memp_malloc_pool+0x38>)
9000c34a:	f005 fc2f 	bl	90011bac <iprintf>
    desc->stats->used++;
    if (desc->stats->used > desc->stats->max) {
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
9000c34e:	4628      	mov	r0, r5
    return ((u8_t *)memp + MEMP_SIZE);
  } else {
#if MEMP_STATS
    desc->stats->err++;
#endif
    SYS_ARCH_UNPROTECT(old_level);
9000c350:	f001 f8b6 	bl	9000d4c0 <sys_arch_unprotect>
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
}
9000c354:	4620      	mov	r0, r4
9000c356:	bd38      	pop	{r3, r4, r5, pc}
9000c358:	90013e77 	.word	0x90013e77
9000c35c:	90013eae 	.word	0x90013eae
9000c360:	90012aff 	.word	0x90012aff

9000c364 <do_memp_free_pool>:
  return memp;
}

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
9000c364:	b538      	push	{r3, r4, r5, lr}
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
9000c366:	078b      	lsls	r3, r1, #30
{
9000c368:	4605      	mov	r5, r0
9000c36a:	460c      	mov	r4, r1
  LWIP_ASSERT("memp_free: mem properly aligned",
9000c36c:	d006      	beq.n	9000c37c <do_memp_free_pool+0x18>
9000c36e:	4b08      	ldr	r3, [pc, #32]	; (9000c390 <do_memp_free_pool+0x2c>)
9000c370:	f44f 72b6 	mov.w	r2, #364	; 0x16c
9000c374:	4907      	ldr	r1, [pc, #28]	; (9000c394 <do_memp_free_pool+0x30>)
9000c376:	4808      	ldr	r0, [pc, #32]	; (9000c398 <do_memp_free_pool+0x34>)
9000c378:	f005 fc18 	bl	90011bac <iprintf>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
9000c37c:	f001 f894 	bl	9000d4a8 <sys_arch_protect>
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
9000c380:	68ab      	ldr	r3, [r5, #8]
9000c382:	681a      	ldr	r2, [r3, #0]
9000c384:	6022      	str	r2, [r4, #0]
  *desc->tab = memp;
9000c386:	601c      	str	r4, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
9000c388:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  SYS_ARCH_UNPROTECT(old_level);
9000c38c:	f001 b898 	b.w	9000d4c0 <sys_arch_unprotect>
9000c390:	90013e77 	.word	0x90013e77
9000c394:	90013ed1 	.word	0x90013ed1
9000c398:	90012aff 	.word	0x90012aff

9000c39c <memp_init_pool>:
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
9000c39c:	6843      	ldr	r3, [r0, #4]
  *desc->tab = NULL;
9000c39e:	2200      	movs	r2, #0
9000c3a0:	6881      	ldr	r1, [r0, #8]
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
9000c3a2:	3303      	adds	r3, #3
{
9000c3a4:	b530      	push	{r4, r5, lr}
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
9000c3a6:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
9000c3aa:	8844      	ldrh	r4, [r0, #2]
  *desc->tab = NULL;
9000c3ac:	600a      	str	r2, [r1, #0]
  for (i = 0; i < desc->num; ++i) {
9000c3ae:	4294      	cmp	r4, r2
9000c3b0:	dc00      	bgt.n	9000c3b4 <memp_init_pool+0x18>
}
9000c3b2:	bd30      	pop	{r4, r5, pc}
    memp->next = *desc->tab;
9000c3b4:	680d      	ldr	r5, [r1, #0]
  for (i = 0; i < desc->num; ++i) {
9000c3b6:	3201      	adds	r2, #1
    memp->next = *desc->tab;
9000c3b8:	601d      	str	r5, [r3, #0]
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
9000c3ba:	8805      	ldrh	r5, [r0, #0]
    *desc->tab = memp;
9000c3bc:	600b      	str	r3, [r1, #0]
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
9000c3be:	442b      	add	r3, r5
  for (i = 0; i < desc->num; ++i) {
9000c3c0:	e7f5      	b.n	9000c3ae <memp_init_pool+0x12>
	...

9000c3c4 <memp_init>:
{
9000c3c4:	b538      	push	{r3, r4, r5, lr}
9000c3c6:	4d05      	ldr	r5, [pc, #20]	; (9000c3dc <memp_init+0x18>)
9000c3c8:	240e      	movs	r4, #14
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
9000c3ca:	3c01      	subs	r4, #1
    memp_init_pool(memp_pools[i]);
9000c3cc:	f855 0b04 	ldr.w	r0, [r5], #4
9000c3d0:	f7ff ffe4 	bl	9000c39c <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
9000c3d4:	b2a4      	uxth	r4, r4
9000c3d6:	2c00      	cmp	r4, #0
9000c3d8:	d1f7      	bne.n	9000c3ca <memp_init+0x6>
}
9000c3da:	bd38      	pop	{r3, r4, r5, pc}
9000c3dc:	90013fe4 	.word	0x90013fe4

9000c3e0 <memp_malloc_pool>:
{
9000c3e0:	b510      	push	{r4, lr}
  LWIP_ASSERT("invalid pool desc", desc != NULL);
9000c3e2:	4604      	mov	r4, r0
9000c3e4:	b118      	cbz	r0, 9000c3ee <memp_malloc_pool+0xe>
}
9000c3e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return do_memp_malloc_pool(desc);
9000c3ea:	f7ff bf9d 	b.w	9000c328 <do_memp_malloc_pool>
  LWIP_ASSERT("invalid pool desc", desc != NULL);
9000c3ee:	4b04      	ldr	r3, [pc, #16]	; (9000c400 <memp_malloc_pool+0x20>)
9000c3f0:	f44f 729e 	mov.w	r2, #316	; 0x13c
9000c3f4:	4903      	ldr	r1, [pc, #12]	; (9000c404 <memp_malloc_pool+0x24>)
9000c3f6:	4804      	ldr	r0, [pc, #16]	; (9000c408 <memp_malloc_pool+0x28>)
9000c3f8:	f005 fbd8 	bl	90011bac <iprintf>
}
9000c3fc:	4620      	mov	r0, r4
9000c3fe:	bd10      	pop	{r4, pc}
9000c400:	90013e77 	.word	0x90013e77
9000c404:	90013ef1 	.word	0x90013ef1
9000c408:	90012aff 	.word	0x90012aff

9000c40c <memp_malloc>:
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
9000c40c:	280d      	cmp	r0, #13
{
9000c40e:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
9000c410:	d806      	bhi.n	9000c420 <memp_malloc+0x14>
  memp = do_memp_malloc_pool(memp_pools[type]);
9000c412:	4b08      	ldr	r3, [pc, #32]	; (9000c434 <memp_malloc+0x28>)
9000c414:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
9000c418:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  memp = do_memp_malloc_pool(memp_pools[type]);
9000c41c:	f7ff bf84 	b.w	9000c328 <do_memp_malloc_pool>
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
9000c420:	4b05      	ldr	r3, [pc, #20]	; (9000c438 <memp_malloc+0x2c>)
9000c422:	f240 1257 	movw	r2, #343	; 0x157
9000c426:	4905      	ldr	r1, [pc, #20]	; (9000c43c <memp_malloc+0x30>)
9000c428:	4805      	ldr	r0, [pc, #20]	; (9000c440 <memp_malloc+0x34>)
9000c42a:	f005 fbbf 	bl	90011bac <iprintf>
}
9000c42e:	2000      	movs	r0, #0
9000c430:	bd08      	pop	{r3, pc}
9000c432:	bf00      	nop
9000c434:	90013fe4 	.word	0x90013fe4
9000c438:	90013e77 	.word	0x90013e77
9000c43c:	90013f03 	.word	0x90013f03
9000c440:	90012aff 	.word	0x90012aff

9000c444 <memp_free_pool>:
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
  LWIP_ASSERT("invalid pool desc", desc != NULL);
9000c444:	b940      	cbnz	r0, 9000c458 <memp_free_pool+0x14>
9000c446:	4b06      	ldr	r3, [pc, #24]	; (9000c460 <memp_free_pool+0x1c>)
9000c448:	f240 1295 	movw	r2, #405	; 0x195
9000c44c:	4905      	ldr	r1, [pc, #20]	; (9000c464 <memp_free_pool+0x20>)
9000c44e:	4806      	ldr	r0, [pc, #24]	; (9000c468 <memp_free_pool+0x24>)
9000c450:	f005 bbac 	b.w	90011bac <iprintf>
  if ((desc == NULL) || (mem == NULL)) {
    return;
  }

  do_memp_free_pool(desc, mem);
9000c454:	f7ff bf86 	b.w	9000c364 <do_memp_free_pool>
  if ((desc == NULL) || (mem == NULL)) {
9000c458:	2900      	cmp	r1, #0
9000c45a:	d1fb      	bne.n	9000c454 <memp_free_pool+0x10>
}
9000c45c:	4770      	bx	lr
9000c45e:	bf00      	nop
9000c460:	90013e77 	.word	0x90013e77
9000c464:	90013ef1 	.word	0x90013ef1
9000c468:	90012aff 	.word	0x90012aff

9000c46c <memp_free>:
{
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
9000c46c:	280d      	cmp	r0, #13
9000c46e:	d906      	bls.n	9000c47e <memp_free+0x12>
9000c470:	4b06      	ldr	r3, [pc, #24]	; (9000c48c <memp_free+0x20>)
9000c472:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
9000c476:	4906      	ldr	r1, [pc, #24]	; (9000c490 <memp_free+0x24>)
9000c478:	4806      	ldr	r0, [pc, #24]	; (9000c494 <memp_free+0x28>)
9000c47a:	f005 bb97 	b.w	90011bac <iprintf>

  if (mem == NULL) {
9000c47e:	b121      	cbz	r1, 9000c48a <memp_free+0x1e>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
9000c480:	4b05      	ldr	r3, [pc, #20]	; (9000c498 <memp_free+0x2c>)
9000c482:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
9000c486:	f7ff bf6d 	b.w	9000c364 <do_memp_free_pool>
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
9000c48a:	4770      	bx	lr
9000c48c:	90013e77 	.word	0x90013e77
9000c490:	90013f20 	.word	0x90013f20
9000c494:	90012aff 	.word	0x90012aff
9000c498:	90013fe4 	.word	0x90013fe4

9000c49c <netif_null_output_ip4>:
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
}
9000c49c:	f06f 000b 	mvn.w	r0, #11
9000c4a0:	4770      	bx	lr
	...

9000c4a4 <netif_loopif_init>:
{
9000c4a4:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif_loopif_init: invalid netif", netif != NULL);
9000c4a6:	4604      	mov	r4, r0
9000c4a8:	b928      	cbnz	r0, 9000c4b6 <netif_loopif_init+0x12>
9000c4aa:	4b06      	ldr	r3, [pc, #24]	; (9000c4c4 <netif_loopif_init+0x20>)
9000c4ac:	2299      	movs	r2, #153	; 0x99
9000c4ae:	4906      	ldr	r1, [pc, #24]	; (9000c4c8 <netif_loopif_init+0x24>)
9000c4b0:	4806      	ldr	r0, [pc, #24]	; (9000c4cc <netif_loopif_init+0x28>)
9000c4b2:	f005 fb7b 	bl	90011bac <iprintf>
  netif->name[0] = 'l';
9000c4b6:	f646 736c 	movw	r3, #28524	; 0x6f6c
}
9000c4ba:	2000      	movs	r0, #0
  netif->name[0] = 'l';
9000c4bc:	86e3      	strh	r3, [r4, #54]	; 0x36
  netif->output = netif_loop_output_ipv4;
9000c4be:	4b04      	ldr	r3, [pc, #16]	; (9000c4d0 <netif_loopif_init+0x2c>)
9000c4c0:	6163      	str	r3, [r4, #20]
}
9000c4c2:	bd10      	pop	{r4, pc}
9000c4c4:	9001401c 	.word	0x9001401c
9000c4c8:	90014054 	.word	0x90014054
9000c4cc:	90012aff 	.word	0x90012aff
9000c4d0:	9000c6fd 	.word	0x9000c6fd

9000c4d4 <netif_issue_reports>:
{
9000c4d4:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
9000c4d6:	4604      	mov	r4, r0
9000c4d8:	b930      	cbnz	r0, 9000c4e8 <netif_issue_reports+0x14>
9000c4da:	4b0c      	ldr	r3, [pc, #48]	; (9000c50c <netif_issue_reports+0x38>)
9000c4dc:	f240 326d 	movw	r2, #877	; 0x36d
9000c4e0:	490b      	ldr	r1, [pc, #44]	; (9000c510 <netif_issue_reports+0x3c>)
9000c4e2:	480c      	ldr	r0, [pc, #48]	; (9000c514 <netif_issue_reports+0x40>)
9000c4e4:	f005 fb62 	bl	90011bac <iprintf>
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
9000c4e8:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
9000c4ec:	f003 0205 	and.w	r2, r3, #5
9000c4f0:	2a05      	cmp	r2, #5
9000c4f2:	d109      	bne.n	9000c508 <netif_issue_reports+0x34>
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
9000c4f4:	6862      	ldr	r2, [r4, #4]
9000c4f6:	b13a      	cbz	r2, 9000c508 <netif_issue_reports+0x34>
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
9000c4f8:	071b      	lsls	r3, r3, #28
9000c4fa:	d505      	bpl.n	9000c508 <netif_issue_reports+0x34>
      etharp_gratuitous(netif);
9000c4fc:	1d21      	adds	r1, r4, #4
9000c4fe:	4620      	mov	r0, r4
}
9000c500:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      etharp_gratuitous(netif);
9000c504:	f7fe baea 	b.w	9000aadc <etharp_request>
}
9000c508:	bd10      	pop	{r4, pc}
9000c50a:	bf00      	nop
9000c50c:	9001401c 	.word	0x9001401c
9000c510:	90014075 	.word	0x90014075
9000c514:	90012aff 	.word	0x90012aff

9000c518 <netif_poll>:
{
9000c518:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ASSERT("netif_poll: invalid netif", netif != NULL);
9000c51c:	4604      	mov	r4, r0
9000c51e:	b930      	cbnz	r0, 9000c52e <netif_poll+0x16>
9000c520:	4b26      	ldr	r3, [pc, #152]	; (9000c5bc <netif_poll+0xa4>)
9000c522:	f240 42bb 	movw	r2, #1211	; 0x4bb
9000c526:	4926      	ldr	r1, [pc, #152]	; (9000c5c0 <netif_poll+0xa8>)
9000c528:	4826      	ldr	r0, [pc, #152]	; (9000c5c4 <netif_poll+0xac>)
9000c52a:	f005 fb3f 	bl	90011bac <iprintf>
  SYS_ARCH_PROTECT(lev);
9000c52e:	f000 ffbb 	bl	9000d4a8 <sys_arch_protect>
      LWIP_ASSERT("bogus pbuf: len != tot_len but next == NULL!", in_end->next != NULL);
9000c532:	f8df 8088 	ldr.w	r8, [pc, #136]	; 9000c5bc <netif_poll+0xa4>
  SYS_ARCH_PROTECT(lev);
9000c536:	4606      	mov	r6, r0
      LWIP_ASSERT("bogus pbuf: len != tot_len but next == NULL!", in_end->next != NULL);
9000c538:	f8df a090 	ldr.w	sl, [pc, #144]	; 9000c5cc <netif_poll+0xb4>
9000c53c:	f8df 9084 	ldr.w	r9, [pc, #132]	; 9000c5c4 <netif_poll+0xac>
  while (netif->loop_first != NULL) {
9000c540:	6be7      	ldr	r7, [r4, #60]	; 0x3c
9000c542:	bb6f      	cbnz	r7, 9000c5a0 <netif_poll+0x88>
  SYS_ARCH_UNPROTECT(lev);
9000c544:	4630      	mov	r0, r6
}
9000c546:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  SYS_ARCH_UNPROTECT(lev);
9000c54a:	f000 bfb9 	b.w	9000d4c0 <sys_arch_unprotect>
      LWIP_ASSERT("bogus pbuf: len != tot_len but next == NULL!", in_end->next != NULL);
9000c54e:	682b      	ldr	r3, [r5, #0]
9000c550:	b933      	cbnz	r3, 9000c560 <netif_poll+0x48>
9000c552:	4643      	mov	r3, r8
9000c554:	f240 42c7 	movw	r2, #1223	; 0x4c7
9000c558:	4651      	mov	r1, sl
9000c55a:	4648      	mov	r0, r9
9000c55c:	f005 fb26 	bl	90011bac <iprintf>
      in_end = in_end->next;
9000c560:	682d      	ldr	r5, [r5, #0]
    while (in_end->len != in_end->tot_len) {
9000c562:	896a      	ldrh	r2, [r5, #10]
9000c564:	892b      	ldrh	r3, [r5, #8]
9000c566:	429a      	cmp	r2, r3
9000c568:	d1f1      	bne.n	9000c54e <netif_poll+0x36>
    if (in_end == netif->loop_last) {
9000c56a:	6c23      	ldr	r3, [r4, #64]	; 0x40
9000c56c:	42ab      	cmp	r3, r5
9000c56e:	d119      	bne.n	9000c5a4 <netif_poll+0x8c>
      netif->loop_first = netif->loop_last = NULL;
9000c570:	2300      	movs	r3, #0
9000c572:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
    in_end->next = NULL;
9000c576:	2300      	movs	r3, #0
    SYS_ARCH_UNPROTECT(lev);
9000c578:	4630      	mov	r0, r6
    in_end->next = NULL;
9000c57a:	602b      	str	r3, [r5, #0]
    SYS_ARCH_UNPROTECT(lev);
9000c57c:	f000 ffa0 	bl	9000d4c0 <sys_arch_unprotect>
    in->if_idx = netif_get_index(netif);
9000c580:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    if (ip_input(in, netif) != ERR_OK) {
9000c584:	4621      	mov	r1, r4
9000c586:	4638      	mov	r0, r7
    in->if_idx = netif_get_index(netif);
9000c588:	3301      	adds	r3, #1
9000c58a:	73fb      	strb	r3, [r7, #15]
    if (ip_input(in, netif) != ERR_OK) {
9000c58c:	f7fe feac 	bl	9000b2e8 <ip4_input>
9000c590:	b110      	cbz	r0, 9000c598 <netif_poll+0x80>
      pbuf_free(in);
9000c592:	4638      	mov	r0, r7
9000c594:	f000 fb84 	bl	9000cca0 <pbuf_free>
    SYS_ARCH_PROTECT(lev);
9000c598:	f000 ff86 	bl	9000d4a8 <sys_arch_protect>
9000c59c:	4606      	mov	r6, r0
9000c59e:	e7cf      	b.n	9000c540 <netif_poll+0x28>
9000c5a0:	463d      	mov	r5, r7
9000c5a2:	e7de      	b.n	9000c562 <netif_poll+0x4a>
      netif->loop_first = in_end->next;
9000c5a4:	682b      	ldr	r3, [r5, #0]
9000c5a6:	63e3      	str	r3, [r4, #60]	; 0x3c
      LWIP_ASSERT("should not be null since first != last!", netif->loop_first != NULL);
9000c5a8:	2b00      	cmp	r3, #0
9000c5aa:	d1e4      	bne.n	9000c576 <netif_poll+0x5e>
9000c5ac:	4643      	mov	r3, r8
9000c5ae:	f240 42db 	movw	r2, #1243	; 0x4db
9000c5b2:	4905      	ldr	r1, [pc, #20]	; (9000c5c8 <netif_poll+0xb0>)
9000c5b4:	4648      	mov	r0, r9
9000c5b6:	f005 faf9 	bl	90011bac <iprintf>
9000c5ba:	e7dc      	b.n	9000c576 <netif_poll+0x5e>
9000c5bc:	9001401c 	.word	0x9001401c
9000c5c0:	90014098 	.word	0x90014098
9000c5c4:	90012aff 	.word	0x90012aff
9000c5c8:	900140df 	.word	0x900140df
9000c5cc:	900140b2 	.word	0x900140b2

9000c5d0 <netif_do_set_ipaddr>:
{
9000c5d0:	b573      	push	{r0, r1, r4, r5, r6, lr}
9000c5d2:	4604      	mov	r4, r0
9000c5d4:	4616      	mov	r6, r2
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
9000c5d6:	460d      	mov	r5, r1
9000c5d8:	b931      	cbnz	r1, 9000c5e8 <netif_do_set_ipaddr+0x18>
9000c5da:	4b12      	ldr	r3, [pc, #72]	; (9000c624 <netif_do_set_ipaddr+0x54>)
9000c5dc:	f240 12cb 	movw	r2, #459	; 0x1cb
9000c5e0:	4911      	ldr	r1, [pc, #68]	; (9000c628 <netif_do_set_ipaddr+0x58>)
9000c5e2:	4812      	ldr	r0, [pc, #72]	; (9000c62c <netif_do_set_ipaddr+0x5c>)
9000c5e4:	f005 fae2 	bl	90011bac <iprintf>
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
9000c5e8:	6863      	ldr	r3, [r4, #4]
9000c5ea:	682a      	ldr	r2, [r5, #0]
9000c5ec:	429a      	cmp	r2, r3
9000c5ee:	d101      	bne.n	9000c5f4 <netif_do_set_ipaddr+0x24>
  return 0; /* address unchanged */
9000c5f0:	2000      	movs	r0, #0
9000c5f2:	e014      	b.n	9000c61e <netif_do_set_ipaddr+0x4e>
    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
9000c5f4:	6033      	str	r3, [r6, #0]
  tcp_netif_ip_addr_changed(old_addr, new_addr);
9000c5f6:	a901      	add	r1, sp, #4
9000c5f8:	4630      	mov	r0, r6
    *ip_2_ip4(&new_addr) = *ipaddr;
9000c5fa:	9201      	str	r2, [sp, #4]
  tcp_netif_ip_addr_changed(old_addr, new_addr);
9000c5fc:	f001 fbf4 	bl	9000dde8 <tcp_netif_ip_addr_changed>
  udp_netif_ip_addr_changed(old_addr, new_addr);
9000c600:	a901      	add	r1, sp, #4
9000c602:	4630      	mov	r0, r6
9000c604:	f005 f98a 	bl	9001191c <udp_netif_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
9000c608:	682b      	ldr	r3, [r5, #0]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
9000c60a:	2101      	movs	r1, #1
9000c60c:	4620      	mov	r0, r4
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
9000c60e:	6063      	str	r3, [r4, #4]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
9000c610:	f7ff ff60 	bl	9000c4d4 <netif_issue_reports>
    NETIF_STATUS_CALLBACK(netif);
9000c614:	69e3      	ldr	r3, [r4, #28]
9000c616:	b10b      	cbz	r3, 9000c61c <netif_do_set_ipaddr+0x4c>
9000c618:	4620      	mov	r0, r4
9000c61a:	4798      	blx	r3
    return 1; /* address changed */
9000c61c:	2001      	movs	r0, #1
}
9000c61e:	b002      	add	sp, #8
9000c620:	bd70      	pop	{r4, r5, r6, pc}
9000c622:	bf00      	nop
9000c624:	9001401c 	.word	0x9001401c
9000c628:	90014107 	.word	0x90014107
9000c62c:	90012aff 	.word	0x90012aff

9000c630 <netif_set_default>:
  netif_default = netif;
9000c630:	4b01      	ldr	r3, [pc, #4]	; (9000c638 <netif_set_default+0x8>)
9000c632:	6018      	str	r0, [r3, #0]
}
9000c634:	4770      	bx	lr
9000c636:	bf00      	nop
9000c638:	2400d39c 	.word	0x2400d39c

9000c63c <netif_set_link_callback>:
  if (netif) {
9000c63c:	b100      	cbz	r0, 9000c640 <netif_set_link_callback+0x4>
    netif->link_callback = link_callback;
9000c63e:	6201      	str	r1, [r0, #32]
}
9000c640:	4770      	bx	lr
	...

9000c644 <netif_loop_output>:
{
9000c644:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9000c648:	460e      	mov	r6, r1
  LWIP_ASSERT("netif_loop_output: invalid netif", netif != NULL);
9000c64a:	4604      	mov	r4, r0
9000c64c:	b930      	cbnz	r0, 9000c65c <netif_loop_output+0x18>
9000c64e:	4b25      	ldr	r3, [pc, #148]	; (9000c6e4 <netif_loop_output+0xa0>)
9000c650:	f240 424b 	movw	r2, #1099	; 0x44b
9000c654:	4924      	ldr	r1, [pc, #144]	; (9000c6e8 <netif_loop_output+0xa4>)
9000c656:	4825      	ldr	r0, [pc, #148]	; (9000c6ec <netif_loop_output+0xa8>)
9000c658:	f005 faa8 	bl	90011bac <iprintf>
  LWIP_ASSERT("netif_loop_output: invalid pbuf", p != NULL);
9000c65c:	b936      	cbnz	r6, 9000c66c <netif_loop_output+0x28>
9000c65e:	4b21      	ldr	r3, [pc, #132]	; (9000c6e4 <netif_loop_output+0xa0>)
9000c660:	f240 424c 	movw	r2, #1100	; 0x44c
9000c664:	4922      	ldr	r1, [pc, #136]	; (9000c6f0 <netif_loop_output+0xac>)
9000c666:	4821      	ldr	r0, [pc, #132]	; (9000c6ec <netif_loop_output+0xa8>)
9000c668:	f005 faa0 	bl	90011bac <iprintf>
  r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
9000c66c:	f44f 7220 	mov.w	r2, #640	; 0x280
9000c670:	8931      	ldrh	r1, [r6, #8]
9000c672:	200e      	movs	r0, #14
9000c674:	f000 fb7c 	bl	9000cd70 <pbuf_alloc>
  if (r == NULL) {
9000c678:	4605      	mov	r5, r0
9000c67a:	b380      	cbz	r0, 9000c6de <netif_loop_output+0x9a>
  if ((err = pbuf_copy(r, p)) != ERR_OK) {
9000c67c:	4631      	mov	r1, r6
9000c67e:	f000 fcc9 	bl	9000d014 <pbuf_copy>
9000c682:	4606      	mov	r6, r0
9000c684:	b128      	cbz	r0, 9000c692 <netif_loop_output+0x4e>
    pbuf_free(r);
9000c686:	4628      	mov	r0, r5
9000c688:	f000 fb0a 	bl	9000cca0 <pbuf_free>
}
9000c68c:	4630      	mov	r0, r6
9000c68e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9000c692:	462b      	mov	r3, r5
  for (last = r; last->next != NULL; last = last->next) {
9000c694:	4698      	mov	r8, r3
9000c696:	681b      	ldr	r3, [r3, #0]
9000c698:	2b00      	cmp	r3, #0
9000c69a:	d1fb      	bne.n	9000c694 <netif_loop_output+0x50>
  SYS_ARCH_PROTECT(lev);
9000c69c:	f000 ff04 	bl	9000d4a8 <sys_arch_protect>
  if (netif->loop_first != NULL) {
9000c6a0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  SYS_ARCH_PROTECT(lev);
9000c6a2:	4607      	mov	r7, r0
  if (netif->loop_first != NULL) {
9000c6a4:	b1bb      	cbz	r3, 9000c6d6 <netif_loop_output+0x92>
    LWIP_ASSERT("if first != NULL, last must also be != NULL", netif->loop_last != NULL);
9000c6a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
9000c6a8:	b933      	cbnz	r3, 9000c6b8 <netif_loop_output+0x74>
9000c6aa:	4b0e      	ldr	r3, [pc, #56]	; (9000c6e4 <netif_loop_output+0xa0>)
9000c6ac:	f240 4277 	movw	r2, #1143	; 0x477
9000c6b0:	4910      	ldr	r1, [pc, #64]	; (9000c6f4 <netif_loop_output+0xb0>)
9000c6b2:	480e      	ldr	r0, [pc, #56]	; (9000c6ec <netif_loop_output+0xa8>)
9000c6b4:	f005 fa7a 	bl	90011bac <iprintf>
    netif->loop_last->next = r;
9000c6b8:	6c23      	ldr	r3, [r4, #64]	; 0x40
9000c6ba:	601d      	str	r5, [r3, #0]
  u8_t schedule_poll = 0;
9000c6bc:	2500      	movs	r5, #0
    netif->loop_last = last;
9000c6be:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
  SYS_ARCH_UNPROTECT(lev);
9000c6c2:	4638      	mov	r0, r7
9000c6c4:	f000 fefc 	bl	9000d4c0 <sys_arch_unprotect>
  if (schedule_poll) {
9000c6c8:	2d00      	cmp	r5, #0
9000c6ca:	d0df      	beq.n	9000c68c <netif_loop_output+0x48>
    tcpip_try_callback((tcpip_callback_fn)netif_poll, netif);
9000c6cc:	4621      	mov	r1, r4
9000c6ce:	480a      	ldr	r0, [pc, #40]	; (9000c6f8 <netif_loop_output+0xb4>)
9000c6d0:	f004 fcf2 	bl	900110b8 <tcpip_try_callback>
9000c6d4:	e7da      	b.n	9000c68c <netif_loop_output+0x48>
    netif->loop_last = last;
9000c6d6:	e9c4 580f 	strd	r5, r8, [r4, #60]	; 0x3c
    schedule_poll = 1;
9000c6da:	2501      	movs	r5, #1
9000c6dc:	e7f1      	b.n	9000c6c2 <netif_loop_output+0x7e>
    return ERR_MEM;
9000c6de:	f04f 36ff 	mov.w	r6, #4294967295
9000c6e2:	e7d3      	b.n	9000c68c <netif_loop_output+0x48>
9000c6e4:	9001401c 	.word	0x9001401c
9000c6e8:	90014117 	.word	0x90014117
9000c6ec:	90012aff 	.word	0x90012aff
9000c6f0:	90014138 	.word	0x90014138
9000c6f4:	90014158 	.word	0x90014158
9000c6f8:	9000c519 	.word	0x9000c519

9000c6fc <netif_loop_output_ipv4>:
  return netif_loop_output(netif, p);
9000c6fc:	f7ff bfa2 	b.w	9000c644 <netif_loop_output>

9000c700 <netif_get_by_index>:
{
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
9000c700:	4603      	mov	r3, r0
9000c702:	b158      	cbz	r0, 9000c71c <netif_get_by_index+0x1c>
    NETIF_FOREACH(netif) {
9000c704:	4a06      	ldr	r2, [pc, #24]	; (9000c720 <netif_get_by_index+0x20>)
9000c706:	6810      	ldr	r0, [r2, #0]
9000c708:	b900      	cbnz	r0, 9000c70c <netif_get_by_index+0xc>
9000c70a:	4770      	bx	lr
      if (idx == netif_get_index(netif)) {
9000c70c:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
9000c710:	3201      	adds	r2, #1
9000c712:	b2d2      	uxtb	r2, r2
9000c714:	429a      	cmp	r2, r3
9000c716:	d001      	beq.n	9000c71c <netif_get_by_index+0x1c>
    NETIF_FOREACH(netif) {
9000c718:	6800      	ldr	r0, [r0, #0]
9000c71a:	e7f5      	b.n	9000c708 <netif_get_by_index+0x8>
      }
    }
  }

  return NULL;
}
9000c71c:	4770      	bx	lr
9000c71e:	bf00      	nop
9000c720:	2400d3a0 	.word	0x2400d3a0

9000c724 <netif_invoke_ext_callback>:
 * @param reason change reason
 * @param args depends on reason, see reason description
 */
void
netif_invoke_ext_callback(struct netif *netif, netif_nsc_reason_t reason, const netif_ext_callback_args_t *args)
{
9000c724:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  netif_ext_callback_t *callback = ext_callback;
9000c726:	4b0b      	ldr	r3, [pc, #44]	; (9000c754 <netif_invoke_ext_callback+0x30>)
{
9000c728:	460e      	mov	r6, r1
9000c72a:	4617      	mov	r7, r2

  LWIP_ASSERT("netif must be != NULL", netif != NULL);
9000c72c:	4605      	mov	r5, r0
  netif_ext_callback_t *callback = ext_callback;
9000c72e:	681c      	ldr	r4, [r3, #0]
  LWIP_ASSERT("netif must be != NULL", netif != NULL);
9000c730:	b930      	cbnz	r0, 9000c740 <netif_invoke_ext_callback+0x1c>
9000c732:	4b09      	ldr	r3, [pc, #36]	; (9000c758 <netif_invoke_ext_callback+0x34>)
9000c734:	f240 62fc 	movw	r2, #1788	; 0x6fc
9000c738:	4908      	ldr	r1, [pc, #32]	; (9000c75c <netif_invoke_ext_callback+0x38>)
9000c73a:	4809      	ldr	r0, [pc, #36]	; (9000c760 <netif_invoke_ext_callback+0x3c>)
9000c73c:	f005 fa36 	bl	90011bac <iprintf>

  while (callback != NULL) {
9000c740:	b904      	cbnz	r4, 9000c744 <netif_invoke_ext_callback+0x20>
    callback->callback_fn(netif, reason, args);
    callback = callback->next;
  }
}
9000c742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    callback->callback_fn(netif, reason, args);
9000c744:	6823      	ldr	r3, [r4, #0]
9000c746:	463a      	mov	r2, r7
9000c748:	4631      	mov	r1, r6
9000c74a:	4628      	mov	r0, r5
9000c74c:	4798      	blx	r3
    callback = callback->next;
9000c74e:	6864      	ldr	r4, [r4, #4]
9000c750:	e7f6      	b.n	9000c740 <netif_invoke_ext_callback+0x1c>
9000c752:	bf00      	nop
9000c754:	2400d354 	.word	0x2400d354
9000c758:	9001401c 	.word	0x9001401c
9000c75c:	90014184 	.word	0x90014184
9000c760:	90012aff 	.word	0x90012aff

9000c764 <netif_set_addr>:
{
9000c764:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ipaddr = IP4_ADDR_ANY4;
9000c768:	4e28      	ldr	r6, [pc, #160]	; (9000c80c <netif_set_addr+0xa8>)
{
9000c76a:	b087      	sub	sp, #28
9000c76c:	4605      	mov	r5, r0
    ipaddr = IP4_ADDR_ANY4;
9000c76e:	2900      	cmp	r1, #0
9000c770:	bf14      	ite	ne
9000c772:	460f      	movne	r7, r1
9000c774:	4637      	moveq	r7, r6
    netmask = IP4_ADDR_ANY4;
9000c776:	2a00      	cmp	r2, #0
9000c778:	bf14      	ite	ne
9000c77a:	4690      	movne	r8, r2
9000c77c:	46b0      	moveq	r8, r6
    gw = IP4_ADDR_ANY4;
9000c77e:	2b00      	cmp	r3, #0
9000c780:	bf18      	it	ne
9000c782:	461e      	movne	r6, r3
  remove = ip4_addr_isany(ipaddr);
9000c784:	683b      	ldr	r3, [r7, #0]
9000c786:	2b00      	cmp	r3, #0
9000c788:	d13c      	bne.n	9000c804 <netif_set_addr+0xa0>
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
9000c78a:	f10d 0908 	add.w	r9, sp, #8
9000c78e:	4639      	mov	r1, r7
9000c790:	464a      	mov	r2, r9
9000c792:	f7ff ff1d 	bl	9000c5d0 <netif_do_set_ipaddr>
9000c796:	4604      	mov	r4, r0
9000c798:	b308      	cbz	r0, 9000c7de <netif_set_addr+0x7a>
      cb_args.ipv4_changed.old_address = &old_addr;
9000c79a:	2301      	movs	r3, #1
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
9000c79c:	2410      	movs	r4, #16
      cb_args.ipv4_changed.old_address = &old_addr;
9000c79e:	f8cd 900c 	str.w	r9, [sp, #12]
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
9000c7a2:	68a9      	ldr	r1, [r5, #8]
9000c7a4:	f8d8 2000 	ldr.w	r2, [r8]
9000c7a8:	428a      	cmp	r2, r1
    ip_addr_copy(*old_nm, *netif_ip_netmask4(netif));
9000c7aa:	bf1e      	ittt	ne
9000c7ac:	9100      	strne	r1, [sp, #0]
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
9000c7ae:	f044 0440 	orrne.w	r4, r4, #64	; 0x40
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
9000c7b2:	60aa      	strne	r2, [r5, #8]
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
9000c7b4:	68e9      	ldr	r1, [r5, #12]
9000c7b6:	6832      	ldr	r2, [r6, #0]
    cb_args.ipv4_changed.old_netmask = old_nm;
9000c7b8:	bf18      	it	ne
9000c7ba:	f8cd d010 	strne.w	sp, [sp, #16]
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
9000c7be:	428a      	cmp	r2, r1
9000c7c0:	d00f      	beq.n	9000c7e2 <netif_set_addr+0x7e>
    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
9000c7c2:	60ea      	str	r2, [r5, #12]
    cb_args.ipv4_changed.old_gw = old_gw;
9000c7c4:	aa01      	add	r2, sp, #4
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
9000c7c6:	f044 0420 	orr.w	r4, r4, #32
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
9000c7ca:	9101      	str	r1, [sp, #4]
    cb_args.ipv4_changed.old_gw = old_gw;
9000c7cc:	9205      	str	r2, [sp, #20]
  if (!remove) {
9000c7ce:	b14b      	cbz	r3, 9000c7e4 <netif_set_addr+0x80>
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
9000c7d0:	aa03      	add	r2, sp, #12
9000c7d2:	f044 0180 	orr.w	r1, r4, #128	; 0x80
9000c7d6:	4628      	mov	r0, r5
9000c7d8:	f7ff ffa4 	bl	9000c724 <netif_invoke_ext_callback>
}
9000c7dc:	e00f      	b.n	9000c7fe <netif_set_addr+0x9a>
9000c7de:	2301      	movs	r3, #1
9000c7e0:	e7df      	b.n	9000c7a2 <netif_set_addr+0x3e>
  if (!remove) {
9000c7e2:	b953      	cbnz	r3, 9000c7fa <netif_set_addr+0x96>
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
9000c7e4:	ae02      	add	r6, sp, #8
9000c7e6:	4639      	mov	r1, r7
9000c7e8:	4628      	mov	r0, r5
9000c7ea:	4632      	mov	r2, r6
9000c7ec:	f7ff fef0 	bl	9000c5d0 <netif_do_set_ipaddr>
9000c7f0:	b118      	cbz	r0, 9000c7fa <netif_set_addr+0x96>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
9000c7f2:	f044 0410 	orr.w	r4, r4, #16
      cb_args.ipv4_changed.old_address = &old_addr;
9000c7f6:	9603      	str	r6, [sp, #12]
  if (change_reason != LWIP_NSC_NONE) {
9000c7f8:	e7ea      	b.n	9000c7d0 <netif_set_addr+0x6c>
9000c7fa:	2c00      	cmp	r4, #0
9000c7fc:	d1e8      	bne.n	9000c7d0 <netif_set_addr+0x6c>
}
9000c7fe:	b007      	add	sp, #28
9000c800:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  remove = ip4_addr_isany(ipaddr);
9000c804:	2300      	movs	r3, #0
  netif_nsc_reason_t change_reason = LWIP_NSC_NONE;
9000c806:	461c      	mov	r4, r3
9000c808:	e7cb      	b.n	9000c7a2 <netif_set_addr+0x3e>
9000c80a:	bf00      	nop
9000c80c:	90013a68 	.word	0x90013a68

9000c810 <netif_add>:
{
9000c810:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000c814:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
9000c818:	4604      	mov	r4, r0
9000c81a:	b948      	cbnz	r0, 9000c830 <netif_add+0x20>
9000c81c:	4b41      	ldr	r3, [pc, #260]	; (9000c924 <netif_add+0x114>)
9000c81e:	f240 1227 	movw	r2, #295	; 0x127
9000c822:	4941      	ldr	r1, [pc, #260]	; (9000c928 <netif_add+0x118>)
9000c824:	4841      	ldr	r0, [pc, #260]	; (9000c92c <netif_add+0x11c>)
9000c826:	f005 f9c1 	bl	90011bac <iprintf>
}
9000c82a:	4620      	mov	r0, r4
9000c82c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
9000c830:	f1b8 0f00 	cmp.w	r8, #0
9000c834:	d108      	bne.n	9000c848 <netif_add+0x38>
9000c836:	4b3b      	ldr	r3, [pc, #236]	; (9000c924 <netif_add+0x114>)
9000c838:	f44f 7294 	mov.w	r2, #296	; 0x128
9000c83c:	493c      	ldr	r1, [pc, #240]	; (9000c930 <netif_add+0x120>)
9000c83e:	4644      	mov	r4, r8
9000c840:	483a      	ldr	r0, [pc, #232]	; (9000c92c <netif_add+0x11c>)
9000c842:	f005 f9b3 	bl	90011bac <iprintf>
9000c846:	e7f0      	b.n	9000c82a <netif_add+0x1a>
  netif->output = netif_null_output_ip4;
9000c848:	4e3a      	ldr	r6, [pc, #232]	; (9000c934 <netif_add+0x124>)
  ip_addr_set_zero_ip4(&netif->ip_addr);
9000c84a:	2500      	movs	r5, #0
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
9000c84c:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 9000c944 <netif_add+0x134>
  netif->output = netif_null_output_ip4;
9000c850:	6146      	str	r6, [r0, #20]
  netif->state = state;
9000c852:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  netif_set_addr(netif, ipaddr, netmask, gw);
9000c854:	42ab      	cmp	r3, r5
9000c856:	bf08      	it	eq
9000c858:	4663      	moveq	r3, ip
  ip_addr_set_zero_ip4(&netif->gw);
9000c85a:	60c5      	str	r5, [r0, #12]
  netif_set_addr(netif, ipaddr, netmask, gw);
9000c85c:	42aa      	cmp	r2, r5
9000c85e:	bf08      	it	eq
9000c860:	4662      	moveq	r2, ip
  netif->state = state;
9000c862:	6246      	str	r6, [r0, #36]	; 0x24
  netif_set_addr(netif, ipaddr, netmask, gw);
9000c864:	42a9      	cmp	r1, r5
9000c866:	bf08      	it	eq
9000c868:	4661      	moveq	r1, ip
  netif->num = netif_num;
9000c86a:	4e33      	ldr	r6, [pc, #204]	; (9000c938 <netif_add+0x128>)
  netif->mtu = 0;
9000c86c:	8585      	strh	r5, [r0, #44]	; 0x2c
  netif->num = netif_num;
9000c86e:	7837      	ldrb	r7, [r6, #0]
  netif->flags = 0;
9000c870:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
  netif->num = netif_num;
9000c874:	f880 7038 	strb.w	r7, [r0, #56]	; 0x38
  netif->input = input;
9000c878:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  memset(netif->client_data, 0, sizeof(netif->client_data));
9000c87a:	6285      	str	r5, [r0, #40]	; 0x28
  netif->input = input;
9000c87c:	6107      	str	r7, [r0, #16]
  ip_addr_set_zero_ip4(&netif->netmask);
9000c87e:	e9c0 5501 	strd	r5, r5, [r0, #4]
  netif->link_callback = NULL;
9000c882:	e9c0 5507 	strd	r5, r5, [r0, #28]
  netif->loop_last = NULL;
9000c886:	e9c0 550f 	strd	r5, r5, [r0, #60]	; 0x3c
  netif_set_addr(netif, ipaddr, netmask, gw);
9000c88a:	f7ff ff6b 	bl	9000c764 <netif_set_addr>
  if (init(netif) != ERR_OK) {
9000c88e:	4620      	mov	r0, r4
9000c890:	47c0      	blx	r8
9000c892:	2800      	cmp	r0, #0
9000c894:	d144      	bne.n	9000c920 <netif_add+0x110>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
9000c896:	4f29      	ldr	r7, [pc, #164]	; (9000c93c <netif_add+0x12c>)
        LWIP_ASSERT("netif already added", netif2 != netif);
9000c898:	f8df b088 	ldr.w	fp, [pc, #136]	; 9000c924 <netif_add+0x114>
      if (netif->num == 255) {
9000c89c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
      num_netifs = 0;
9000c8a0:	f04f 0800 	mov.w	r8, #0
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
9000c8a4:	683d      	ldr	r5, [r7, #0]
      if (netif->num == 255) {
9000c8a6:	2bff      	cmp	r3, #255	; 0xff
        LWIP_ASSERT("netif already added", netif2 != netif);
9000c8a8:	f8df a09c 	ldr.w	sl, [pc, #156]	; 9000c948 <netif_add+0x138>
9000c8ac:	f8df 907c 	ldr.w	r9, [pc, #124]	; 9000c92c <netif_add+0x11c>
        netif->num = 0;
9000c8b0:	bf04      	itt	eq
9000c8b2:	2300      	moveq	r3, #0
9000c8b4:	f884 3038 	strbeq.w	r3, [r4, #56]	; 0x38
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
9000c8b8:	b92d      	cbnz	r5, 9000c8c6 <netif_add+0xb6>
  if (netif->num == 254) {
9000c8ba:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
9000c8be:	2bfe      	cmp	r3, #254	; 0xfe
9000c8c0:	d122      	bne.n	9000c908 <netif_add+0xf8>
    netif_num = 0;
9000c8c2:	462b      	mov	r3, r5
9000c8c4:	e022      	b.n	9000c90c <netif_add+0xfc>
        LWIP_ASSERT("netif already added", netif2 != netif);
9000c8c6:	42a5      	cmp	r5, r4
9000c8c8:	d106      	bne.n	9000c8d8 <netif_add+0xc8>
9000c8ca:	465b      	mov	r3, fp
9000c8cc:	f240 128b 	movw	r2, #395	; 0x18b
9000c8d0:	4651      	mov	r1, sl
9000c8d2:	4648      	mov	r0, r9
9000c8d4:	f005 f96a 	bl	90011bac <iprintf>
        num_netifs++;
9000c8d8:	f108 0801 	add.w	r8, r8, #1
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
9000c8dc:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
9000c8e0:	dd06      	ble.n	9000c8f0 <netif_add+0xe0>
9000c8e2:	465b      	mov	r3, fp
9000c8e4:	f240 128d 	movw	r2, #397	; 0x18d
9000c8e8:	4915      	ldr	r1, [pc, #84]	; (9000c940 <netif_add+0x130>)
9000c8ea:	4648      	mov	r0, r9
9000c8ec:	f005 f95e 	bl	90011bac <iprintf>
        if (netif2->num == netif->num) {
9000c8f0:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
9000c8f4:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
9000c8f8:	429a      	cmp	r2, r3
9000c8fa:	d103      	bne.n	9000c904 <netif_add+0xf4>
          netif->num++;
9000c8fc:	3201      	adds	r2, #1
9000c8fe:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    } while (netif2 != NULL);
9000c902:	e7cb      	b.n	9000c89c <netif_add+0x8c>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
9000c904:	682d      	ldr	r5, [r5, #0]
9000c906:	e7d7      	b.n	9000c8b8 <netif_add+0xa8>
    netif_num = (u8_t)(netif->num + 1);
9000c908:	3301      	adds	r3, #1
9000c90a:	b2db      	uxtb	r3, r3
9000c90c:	7033      	strb	r3, [r6, #0]
  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);
9000c90e:	2200      	movs	r2, #0
  netif->next = netif_list;
9000c910:	683b      	ldr	r3, [r7, #0]
  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);
9000c912:	2101      	movs	r1, #1
9000c914:	4620      	mov	r0, r4
  netif->next = netif_list;
9000c916:	6023      	str	r3, [r4, #0]
  netif_list = netif;
9000c918:	603c      	str	r4, [r7, #0]
  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);
9000c91a:	f7ff ff03 	bl	9000c724 <netif_invoke_ext_callback>
  return netif;
9000c91e:	e784      	b.n	9000c82a <netif_add+0x1a>
    return NULL;
9000c920:	462c      	mov	r4, r5
9000c922:	e782      	b.n	9000c82a <netif_add+0x1a>
9000c924:	9001401c 	.word	0x9001401c
9000c928:	9001419a 	.word	0x9001419a
9000c92c:	90012aff 	.word	0x90012aff
9000c930:	900141b3 	.word	0x900141b3
9000c934:	9000c49d 	.word	0x9000c49d
9000c938:	2400d3a4 	.word	0x2400d3a4
9000c93c:	2400d3a0 	.word	0x2400d3a0
9000c940:	900141e9 	.word	0x900141e9
9000c944:	90013a68 	.word	0x90013a68
9000c948:	900141d5 	.word	0x900141d5

9000c94c <netif_set_up>:
{
9000c94c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
9000c94e:	4604      	mov	r4, r0
9000c950:	b948      	cbnz	r0, 9000c966 <netif_set_up+0x1a>
9000c952:	4b13      	ldr	r3, [pc, #76]	; (9000c9a0 <netif_set_up+0x54>)
9000c954:	f44f 7254 	mov.w	r2, #848	; 0x350
9000c958:	4912      	ldr	r1, [pc, #72]	; (9000c9a4 <netif_set_up+0x58>)
9000c95a:	4813      	ldr	r0, [pc, #76]	; (9000c9a8 <netif_set_up+0x5c>)
}
9000c95c:	b004      	add	sp, #16
9000c95e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
9000c962:	f005 b923 	b.w	90011bac <iprintf>
  if (!(netif->flags & NETIF_FLAG_UP)) {
9000c966:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
9000c96a:	07da      	lsls	r2, r3, #31
9000c96c:	d415      	bmi.n	9000c99a <netif_set_up+0x4e>
    netif_set_flags(netif, NETIF_FLAG_UP);
9000c96e:	f043 0301 	orr.w	r3, r3, #1
9000c972:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    NETIF_STATUS_CALLBACK(netif);
9000c976:	69c3      	ldr	r3, [r0, #28]
9000c978:	b103      	cbz	r3, 9000c97c <netif_set_up+0x30>
9000c97a:	4798      	blx	r3
      args.status_changed.state = 1;
9000c97c:	2301      	movs	r3, #1
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
9000c97e:	4620      	mov	r0, r4
9000c980:	aa01      	add	r2, sp, #4
9000c982:	2108      	movs	r1, #8
      args.status_changed.state = 1;
9000c984:	f88d 3004 	strb.w	r3, [sp, #4]
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
9000c988:	f7ff fecc 	bl	9000c724 <netif_invoke_ext_callback>
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
9000c98c:	2103      	movs	r1, #3
9000c98e:	4620      	mov	r0, r4
}
9000c990:	b004      	add	sp, #16
9000c992:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
9000c996:	f7ff bd9d 	b.w	9000c4d4 <netif_issue_reports>
}
9000c99a:	b004      	add	sp, #16
9000c99c:	bd10      	pop	{r4, pc}
9000c99e:	bf00      	nop
9000c9a0:	9001401c 	.word	0x9001401c
9000c9a4:	90014217 	.word	0x90014217
9000c9a8:	90012aff 	.word	0x90012aff

9000c9ac <netif_set_down>:
{
9000c9ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
9000c9ae:	4604      	mov	r4, r0
9000c9b0:	b948      	cbnz	r0, 9000c9c6 <netif_set_down+0x1a>
9000c9b2:	4b14      	ldr	r3, [pc, #80]	; (9000ca04 <netif_set_down+0x58>)
9000c9b4:	f240 329b 	movw	r2, #923	; 0x39b
9000c9b8:	4913      	ldr	r1, [pc, #76]	; (9000ca08 <netif_set_down+0x5c>)
9000c9ba:	4814      	ldr	r0, [pc, #80]	; (9000ca0c <netif_set_down+0x60>)
}
9000c9bc:	b004      	add	sp, #16
9000c9be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
9000c9c2:	f005 b8f3 	b.w	90011bac <iprintf>
  if (netif->flags & NETIF_FLAG_UP) {
9000c9c6:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
9000c9ca:	07da      	lsls	r2, r3, #31
9000c9cc:	d518      	bpl.n	9000ca00 <netif_set_down+0x54>
      args.status_changed.state = 0;
9000c9ce:	2300      	movs	r3, #0
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
9000c9d0:	aa01      	add	r2, sp, #4
9000c9d2:	2108      	movs	r1, #8
      args.status_changed.state = 0;
9000c9d4:	f88d 3004 	strb.w	r3, [sp, #4]
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
9000c9d8:	f7ff fea4 	bl	9000c724 <netif_invoke_ext_callback>
    netif_clear_flags(netif, NETIF_FLAG_UP);
9000c9dc:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
9000c9e0:	f023 0201 	bic.w	r2, r3, #1
    if (netif->flags & NETIF_FLAG_ETHARP) {
9000c9e4:	071b      	lsls	r3, r3, #28
    netif_clear_flags(netif, NETIF_FLAG_UP);
9000c9e6:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
    if (netif->flags & NETIF_FLAG_ETHARP) {
9000c9ea:	d502      	bpl.n	9000c9f2 <netif_set_down+0x46>
      etharp_cleanup_netif(netif);
9000c9ec:	4620      	mov	r0, r4
9000c9ee:	f7fd ffb1 	bl	9000a954 <etharp_cleanup_netif>
    NETIF_STATUS_CALLBACK(netif);
9000c9f2:	69e3      	ldr	r3, [r4, #28]
9000c9f4:	b123      	cbz	r3, 9000ca00 <netif_set_down+0x54>
9000c9f6:	4620      	mov	r0, r4
}
9000c9f8:	b004      	add	sp, #16
9000c9fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NETIF_STATUS_CALLBACK(netif);
9000c9fe:	4718      	bx	r3
}
9000ca00:	b004      	add	sp, #16
9000ca02:	bd10      	pop	{r4, pc}
9000ca04:	9001401c 	.word	0x9001401c
9000ca08:	90014233 	.word	0x90014233
9000ca0c:	90012aff 	.word	0x90012aff

9000ca10 <netif_set_link_up>:
{
9000ca10:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
9000ca12:	4604      	mov	r4, r0
9000ca14:	b948      	cbnz	r0, 9000ca2a <netif_set_link_up+0x1a>
9000ca16:	4b13      	ldr	r3, [pc, #76]	; (9000ca64 <netif_set_link_up+0x54>)
9000ca18:	f44f 7278 	mov.w	r2, #992	; 0x3e0
9000ca1c:	4912      	ldr	r1, [pc, #72]	; (9000ca68 <netif_set_link_up+0x58>)
9000ca1e:	4813      	ldr	r0, [pc, #76]	; (9000ca6c <netif_set_link_up+0x5c>)
}
9000ca20:	b004      	add	sp, #16
9000ca22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
9000ca26:	f005 b8c1 	b.w	90011bac <iprintf>
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
9000ca2a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
9000ca2e:	075a      	lsls	r2, r3, #29
9000ca30:	d415      	bmi.n	9000ca5e <netif_set_link_up+0x4e>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
9000ca32:	f043 0304 	orr.w	r3, r3, #4
9000ca36:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    dhcp_network_changed(netif);
9000ca3a:	f7fd fa2f 	bl	90009e9c <dhcp_network_changed>
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
9000ca3e:	2103      	movs	r1, #3
9000ca40:	4620      	mov	r0, r4
9000ca42:	f7ff fd47 	bl	9000c4d4 <netif_issue_reports>
    NETIF_LINK_CALLBACK(netif);
9000ca46:	6a23      	ldr	r3, [r4, #32]
9000ca48:	b10b      	cbz	r3, 9000ca4e <netif_set_link_up+0x3e>
9000ca4a:	4620      	mov	r0, r4
9000ca4c:	4798      	blx	r3
      args.link_changed.state = 1;
9000ca4e:	2301      	movs	r3, #1
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
9000ca50:	aa01      	add	r2, sp, #4
9000ca52:	2104      	movs	r1, #4
9000ca54:	4620      	mov	r0, r4
      args.link_changed.state = 1;
9000ca56:	f88d 3004 	strb.w	r3, [sp, #4]
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
9000ca5a:	f7ff fe63 	bl	9000c724 <netif_invoke_ext_callback>
}
9000ca5e:	b004      	add	sp, #16
9000ca60:	bd10      	pop	{r4, pc}
9000ca62:	bf00      	nop
9000ca64:	9001401c 	.word	0x9001401c
9000ca68:	90014251 	.word	0x90014251
9000ca6c:	90012aff 	.word	0x90012aff

9000ca70 <netif_init>:
{
9000ca70:	b510      	push	{r4, lr}
  IP4_ADDR(&loop_gw, 127, 0, 0, 1);
9000ca72:	4b0d      	ldr	r3, [pc, #52]	; (9000caa8 <netif_init+0x38>)
{
9000ca74:	b088      	sub	sp, #32
  netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, tcpip_input);
9000ca76:	4c0d      	ldr	r4, [pc, #52]	; (9000caac <netif_init+0x3c>)
  IP4_ADDR(&loop_gw, 127, 0, 0, 1);
9000ca78:	9307      	str	r3, [sp, #28]
  netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, tcpip_input);
9000ca7a:	aa06      	add	r2, sp, #24
  IP4_ADDR(&loop_ipaddr, 127, 0, 0, 1);
9000ca7c:	9305      	str	r3, [sp, #20]
  IP4_ADDR(&loop_netmask, 255, 0, 0, 0);
9000ca7e:	23ff      	movs	r3, #255	; 0xff
  netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, tcpip_input);
9000ca80:	a905      	add	r1, sp, #20
9000ca82:	4620      	mov	r0, r4
  IP4_ADDR(&loop_netmask, 255, 0, 0, 0);
9000ca84:	9306      	str	r3, [sp, #24]
  netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, tcpip_input);
9000ca86:	4b0a      	ldr	r3, [pc, #40]	; (9000cab0 <netif_init+0x40>)
9000ca88:	9302      	str	r3, [sp, #8]
9000ca8a:	4b0a      	ldr	r3, [pc, #40]	; (9000cab4 <netif_init+0x44>)
9000ca8c:	9301      	str	r3, [sp, #4]
9000ca8e:	2300      	movs	r3, #0
9000ca90:	9300      	str	r3, [sp, #0]
9000ca92:	ab07      	add	r3, sp, #28
9000ca94:	f7ff febc 	bl	9000c810 <netif_add>
  netif_set_link_up(&loop_netif);
9000ca98:	4620      	mov	r0, r4
9000ca9a:	f7ff ffb9 	bl	9000ca10 <netif_set_link_up>
  netif_set_up(&loop_netif);
9000ca9e:	4620      	mov	r0, r4
9000caa0:	f7ff ff54 	bl	9000c94c <netif_set_up>
}
9000caa4:	b008      	add	sp, #32
9000caa6:	bd10      	pop	{r4, pc}
9000caa8:	0100007f 	.word	0x0100007f
9000caac:	2400d358 	.word	0x2400d358
9000cab0:	9001109d 	.word	0x9001109d
9000cab4:	9000c4a5 	.word	0x9000c4a5

9000cab8 <netif_set_link_down>:
{
9000cab8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
9000caba:	4604      	mov	r4, r0
9000cabc:	b948      	cbnz	r0, 9000cad2 <netif_set_link_down+0x1a>
9000cabe:	4b0f      	ldr	r3, [pc, #60]	; (9000cafc <netif_set_link_down+0x44>)
9000cac0:	f240 4206 	movw	r2, #1030	; 0x406
9000cac4:	490e      	ldr	r1, [pc, #56]	; (9000cb00 <netif_set_link_down+0x48>)
9000cac6:	480f      	ldr	r0, [pc, #60]	; (9000cb04 <netif_set_link_down+0x4c>)
}
9000cac8:	b004      	add	sp, #16
9000caca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
9000cace:	f005 b86d 	b.w	90011bac <iprintf>
  if (netif->flags & NETIF_FLAG_LINK_UP) {
9000cad2:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
9000cad6:	075a      	lsls	r2, r3, #29
9000cad8:	d50e      	bpl.n	9000caf8 <netif_set_link_down+0x40>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
9000cada:	f023 0304 	bic.w	r3, r3, #4
9000cade:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    NETIF_LINK_CALLBACK(netif);
9000cae2:	6a03      	ldr	r3, [r0, #32]
9000cae4:	b103      	cbz	r3, 9000cae8 <netif_set_link_down+0x30>
9000cae6:	4798      	blx	r3
      args.link_changed.state = 0;
9000cae8:	2300      	movs	r3, #0
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
9000caea:	aa01      	add	r2, sp, #4
9000caec:	2104      	movs	r1, #4
9000caee:	4620      	mov	r0, r4
      args.link_changed.state = 0;
9000caf0:	f88d 3004 	strb.w	r3, [sp, #4]
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
9000caf4:	f7ff fe16 	bl	9000c724 <netif_invoke_ext_callback>
}
9000caf8:	b004      	add	sp, #16
9000cafa:	bd10      	pop	{r4, pc}
9000cafc:	9001401c 	.word	0x9001401c
9000cb00:	90014272 	.word	0x90014272
9000cb04:	90012aff 	.word	0x90012aff

9000cb08 <pbuf_skip_const>:
{
  u16_t offset_left = in_offset;
  const struct pbuf *q = in;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
9000cb08:	b110      	cbz	r0, 9000cb10 <pbuf_skip_const+0x8>
9000cb0a:	8943      	ldrh	r3, [r0, #10]
9000cb0c:	428b      	cmp	r3, r1
9000cb0e:	d902      	bls.n	9000cb16 <pbuf_skip_const+0xe>
    offset_left = (u16_t)(offset_left - q->len);
    q = q->next;
  }
  if (out_offset != NULL) {
9000cb10:	b102      	cbz	r2, 9000cb14 <pbuf_skip_const+0xc>
    *out_offset = offset_left;
9000cb12:	8011      	strh	r1, [r2, #0]
  }
  return q;
}
9000cb14:	4770      	bx	lr
    offset_left = (u16_t)(offset_left - q->len);
9000cb16:	1ac9      	subs	r1, r1, r3
    q = q->next;
9000cb18:	6800      	ldr	r0, [r0, #0]
    offset_left = (u16_t)(offset_left - q->len);
9000cb1a:	b289      	uxth	r1, r1
    q = q->next;
9000cb1c:	e7f4      	b.n	9000cb08 <pbuf_skip_const>
	...

9000cb20 <pbuf_free_ooseq_callback>:
{
9000cb20:	b508      	push	{r3, lr}
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
9000cb22:	f000 fcc1 	bl	9000d4a8 <sys_arch_protect>
9000cb26:	4b08      	ldr	r3, [pc, #32]	; (9000cb48 <pbuf_free_ooseq_callback+0x28>)
9000cb28:	2200      	movs	r2, #0
9000cb2a:	701a      	strb	r2, [r3, #0]
9000cb2c:	f000 fcc8 	bl	9000d4c0 <sys_arch_unprotect>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
9000cb30:	4b06      	ldr	r3, [pc, #24]	; (9000cb4c <pbuf_free_ooseq_callback+0x2c>)
9000cb32:	6818      	ldr	r0, [r3, #0]
9000cb34:	b900      	cbnz	r0, 9000cb38 <pbuf_free_ooseq_callback+0x18>
}
9000cb36:	bd08      	pop	{r3, pc}
    if (pcb->ooseq != NULL) {
9000cb38:	6f43      	ldr	r3, [r0, #116]	; 0x74
9000cb3a:	b11b      	cbz	r3, 9000cb44 <pbuf_free_ooseq_callback+0x24>
}
9000cb3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      tcp_free_ooseq(pcb);
9000cb40:	f000 bff6 	b.w	9000db30 <tcp_free_ooseq>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
9000cb44:	68c0      	ldr	r0, [r0, #12]
9000cb46:	e7f5      	b.n	9000cb34 <pbuf_free_ooseq_callback+0x14>
9000cb48:	2400d3a5 	.word	0x2400d3a5
9000cb4c:	2400d3b0 	.word	0x2400d3b0

9000cb50 <pbuf_add_header_impl>:
{
9000cb50:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
9000cb52:	b968      	cbnz	r0, 9000cb70 <pbuf_add_header_impl+0x20>
9000cb54:	4b14      	ldr	r3, [pc, #80]	; (9000cba8 <pbuf_add_header_impl+0x58>)
9000cb56:	f240 12df 	movw	r2, #479	; 0x1df
9000cb5a:	4914      	ldr	r1, [pc, #80]	; (9000cbac <pbuf_add_header_impl+0x5c>)
9000cb5c:	4814      	ldr	r0, [pc, #80]	; (9000cbb0 <pbuf_add_header_impl+0x60>)
9000cb5e:	f005 f825 	bl	90011bac <iprintf>
    return 1;
9000cb62:	2001      	movs	r0, #1
9000cb64:	e01f      	b.n	9000cba6 <pbuf_add_header_impl+0x56>
    if (force) {
9000cb66:	2a00      	cmp	r2, #0
9000cb68:	d0fb      	beq.n	9000cb62 <pbuf_add_header_impl+0x12>
      payload = (u8_t *)p->payload - header_size_increment;
9000cb6a:	6842      	ldr	r2, [r0, #4]
9000cb6c:	1a51      	subs	r1, r2, r1
9000cb6e:	e014      	b.n	9000cb9a <pbuf_add_header_impl+0x4a>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
9000cb70:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
9000cb74:	d2f5      	bcs.n	9000cb62 <pbuf_add_header_impl+0x12>
  if (header_size_increment == 0) {
9000cb76:	b1a9      	cbz	r1, 9000cba4 <pbuf_add_header_impl+0x54>
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
9000cb78:	8903      	ldrh	r3, [r0, #8]
  increment_magnitude = (u16_t)header_size_increment;
9000cb7a:	b28c      	uxth	r4, r1
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
9000cb7c:	fa13 f381 	uxtah	r3, r3, r1
9000cb80:	b29b      	uxth	r3, r3
9000cb82:	429c      	cmp	r4, r3
9000cb84:	d8ed      	bhi.n	9000cb62 <pbuf_add_header_impl+0x12>
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
9000cb86:	f990 500c 	ldrsb.w	r5, [r0, #12]
9000cb8a:	2d00      	cmp	r5, #0
9000cb8c:	daeb      	bge.n	9000cb66 <pbuf_add_header_impl+0x16>
    payload = (u8_t *)p->payload - header_size_increment;
9000cb8e:	6842      	ldr	r2, [r0, #4]
9000cb90:	1a51      	subs	r1, r2, r1
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
9000cb92:	f100 0210 	add.w	r2, r0, #16
9000cb96:	4291      	cmp	r1, r2
9000cb98:	d3e3      	bcc.n	9000cb62 <pbuf_add_header_impl+0x12>
  p->len = (u16_t)(p->len + increment_magnitude);
9000cb9a:	8942      	ldrh	r2, [r0, #10]
  p->payload = payload;
9000cb9c:	6041      	str	r1, [r0, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
9000cb9e:	4414      	add	r4, r2
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
9000cba0:	8103      	strh	r3, [r0, #8]
  p->len = (u16_t)(p->len + increment_magnitude);
9000cba2:	8144      	strh	r4, [r0, #10]
  return 0;
9000cba4:	2000      	movs	r0, #0
}
9000cba6:	bd38      	pop	{r3, r4, r5, pc}
9000cba8:	90014295 	.word	0x90014295
9000cbac:	9001436e 	.word	0x9001436e
9000cbb0:	90012aff 	.word	0x90012aff

9000cbb4 <pbuf_alloc_reference>:
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
9000cbb4:	f022 0340 	bic.w	r3, r2, #64	; 0x40
9000cbb8:	2b01      	cmp	r3, #1
{
9000cbba:	b570      	push	{r4, r5, r6, lr}
9000cbbc:	4606      	mov	r6, r0
9000cbbe:	460d      	mov	r5, r1
9000cbc0:	4614      	mov	r4, r2
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
9000cbc2:	d006      	beq.n	9000cbd2 <pbuf_alloc_reference+0x1e>
9000cbc4:	4b0a      	ldr	r3, [pc, #40]	; (9000cbf0 <pbuf_alloc_reference+0x3c>)
9000cbc6:	f44f 72a5 	mov.w	r2, #330	; 0x14a
9000cbca:	490a      	ldr	r1, [pc, #40]	; (9000cbf4 <pbuf_alloc_reference+0x40>)
9000cbcc:	480a      	ldr	r0, [pc, #40]	; (9000cbf8 <pbuf_alloc_reference+0x44>)
9000cbce:	f004 ffed 	bl	90011bac <iprintf>
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
9000cbd2:	200c      	movs	r0, #12
9000cbd4:	f7ff fc1a 	bl	9000c40c <memp_malloc>
  if (p == NULL) {
9000cbd8:	b140      	cbz	r0, 9000cbec <pbuf_alloc_reference+0x38>
  p->next = NULL;
9000cbda:	2300      	movs	r3, #0
  p->tot_len = tot_len;
9000cbdc:	8105      	strh	r5, [r0, #8]
  p->len = len;
9000cbde:	8145      	strh	r5, [r0, #10]
  p->flags = flags;
9000cbe0:	7343      	strb	r3, [r0, #13]
  p->type_internal = (u8_t)type;
9000cbe2:	7304      	strb	r4, [r0, #12]
  p->payload = payload;
9000cbe4:	e9c0 3600 	strd	r3, r6, [r0]
  p->ref = 1;
9000cbe8:	2301      	movs	r3, #1
9000cbea:	81c3      	strh	r3, [r0, #14]
}
9000cbec:	bd70      	pop	{r4, r5, r6, pc}
9000cbee:	bf00      	nop
9000cbf0:	90014295 	.word	0x90014295
9000cbf4:	900142cc 	.word	0x900142cc
9000cbf8:	90012aff 	.word	0x90012aff

9000cbfc <pbuf_alloced_custom>:
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
9000cbfc:	3003      	adds	r0, #3
9000cbfe:	f020 0003 	bic.w	r0, r0, #3
{
9000cc02:	b570      	push	{r4, r5, r6, lr}
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
9000cc04:	180e      	adds	r6, r1, r0
9000cc06:	f8bd 5014 	ldrh.w	r5, [sp, #20]
{
9000cc0a:	9c04      	ldr	r4, [sp, #16]
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
9000cc0c:	42ae      	cmp	r6, r5
9000cc0e:	d80d      	bhi.n	9000cc2c <pbuf_alloced_custom+0x30>
  if (payload_mem != NULL) {
9000cc10:	b104      	cbz	r4, 9000cc14 <pbuf_alloced_custom+0x18>
    payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
9000cc12:	4404      	add	r4, r0
  pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
9000cc14:	4618      	mov	r0, r3
  p->next = NULL;
9000cc16:	2300      	movs	r3, #0
  p->payload = payload;
9000cc18:	e9c0 3400 	strd	r3, r4, [r0]
  p->flags = flags;
9000cc1c:	2302      	movs	r3, #2
  p->tot_len = tot_len;
9000cc1e:	8101      	strh	r1, [r0, #8]
  p->len = len;
9000cc20:	8141      	strh	r1, [r0, #10]
  p->flags = flags;
9000cc22:	7343      	strb	r3, [r0, #13]
  p->ref = 1;
9000cc24:	2301      	movs	r3, #1
  p->type_internal = (u8_t)type;
9000cc26:	7302      	strb	r2, [r0, #12]
  p->ref = 1;
9000cc28:	81c3      	strh	r3, [r0, #14]
}
9000cc2a:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
9000cc2c:	2000      	movs	r0, #0
9000cc2e:	e7fc      	b.n	9000cc2a <pbuf_alloced_custom+0x2e>

9000cc30 <pbuf_add_header>:
  return pbuf_add_header_impl(p, header_size_increment, 0);
9000cc30:	2200      	movs	r2, #0
9000cc32:	f7ff bf8d 	b.w	9000cb50 <pbuf_add_header_impl>
	...

9000cc38 <pbuf_remove_header>:
{
9000cc38:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
9000cc3a:	b990      	cbnz	r0, 9000cc62 <pbuf_remove_header+0x2a>
9000cc3c:	4b10      	ldr	r3, [pc, #64]	; (9000cc80 <pbuf_remove_header+0x48>)
9000cc3e:	f240 224b 	movw	r2, #587	; 0x24b
9000cc42:	4910      	ldr	r1, [pc, #64]	; (9000cc84 <pbuf_remove_header+0x4c>)
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
9000cc44:	4810      	ldr	r0, [pc, #64]	; (9000cc88 <pbuf_remove_header+0x50>)
9000cc46:	f004 ffb1 	bl	90011bac <iprintf>
    return 1;
9000cc4a:	2001      	movs	r0, #1
9000cc4c:	e008      	b.n	9000cc60 <pbuf_remove_header+0x28>
  p->len = (u16_t)(p->len - increment_magnitude);
9000cc4e:	1a9b      	subs	r3, r3, r2
  p->payload = (u8_t *)p->payload + header_size_decrement;
9000cc50:	6844      	ldr	r4, [r0, #4]
  p->len = (u16_t)(p->len - increment_magnitude);
9000cc52:	8143      	strh	r3, [r0, #10]
  p->payload = (u8_t *)p->payload + header_size_decrement;
9000cc54:	4421      	add	r1, r4
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
9000cc56:	8903      	ldrh	r3, [r0, #8]
  p->payload = (u8_t *)p->payload + header_size_decrement;
9000cc58:	6041      	str	r1, [r0, #4]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
9000cc5a:	1a9b      	subs	r3, r3, r2
9000cc5c:	8103      	strh	r3, [r0, #8]
  return 0;
9000cc5e:	2000      	movs	r0, #0
}
9000cc60:	bd10      	pop	{r4, pc}
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
9000cc62:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
9000cc66:	d2f0      	bcs.n	9000cc4a <pbuf_remove_header+0x12>
  if (header_size_decrement == 0) {
9000cc68:	2900      	cmp	r1, #0
9000cc6a:	d0f8      	beq.n	9000cc5e <pbuf_remove_header+0x26>
  increment_magnitude = (u16_t)header_size_decrement;
9000cc6c:	b28a      	uxth	r2, r1
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
9000cc6e:	8943      	ldrh	r3, [r0, #10]
9000cc70:	429a      	cmp	r2, r3
9000cc72:	d9ec      	bls.n	9000cc4e <pbuf_remove_header+0x16>
9000cc74:	4b02      	ldr	r3, [pc, #8]	; (9000cc80 <pbuf_remove_header+0x48>)
9000cc76:	f240 2255 	movw	r2, #597	; 0x255
9000cc7a:	4904      	ldr	r1, [pc, #16]	; (9000cc8c <pbuf_remove_header+0x54>)
9000cc7c:	e7e2      	b.n	9000cc44 <pbuf_remove_header+0xc>
9000cc7e:	bf00      	nop
9000cc80:	90014295 	.word	0x90014295
9000cc84:	9001436e 	.word	0x9001436e
9000cc88:	90012aff 	.word	0x90012aff
9000cc8c:	900142de 	.word	0x900142de

9000cc90 <pbuf_header_force>:
  if (header_size_increment < 0) {
9000cc90:	1e0b      	subs	r3, r1, #0
9000cc92:	da02      	bge.n	9000cc9a <pbuf_header_force+0xa>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
9000cc94:	4259      	negs	r1, r3
9000cc96:	f7ff bfcf 	b.w	9000cc38 <pbuf_remove_header>
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
9000cc9a:	2201      	movs	r2, #1
9000cc9c:	f7ff bf58 	b.w	9000cb50 <pbuf_add_header_impl>

9000cca0 <pbuf_free>:
{
9000cca0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (p == NULL) {
9000cca4:	4604      	mov	r4, r0
9000cca6:	b950      	cbnz	r0, 9000ccbe <pbuf_free+0x1e>
    return 0;
9000cca8:	4625      	mov	r5, r4
    LWIP_ASSERT("p != NULL", p != NULL);
9000ccaa:	4b2b      	ldr	r3, [pc, #172]	; (9000cd58 <pbuf_free+0xb8>)
9000ccac:	f44f 7237 	mov.w	r2, #732	; 0x2dc
9000ccb0:	492a      	ldr	r1, [pc, #168]	; (9000cd5c <pbuf_free+0xbc>)
9000ccb2:	482b      	ldr	r0, [pc, #172]	; (9000cd60 <pbuf_free+0xc0>)
9000ccb4:	f004 ff7a 	bl	90011bac <iprintf>
}
9000ccb8:	4628      	mov	r0, r5
9000ccba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  count = 0;
9000ccbe:	2500      	movs	r5, #0
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
9000ccc0:	4f25      	ldr	r7, [pc, #148]	; (9000cd58 <pbuf_free+0xb8>)
9000ccc2:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 9000cd6c <pbuf_free+0xcc>
9000ccc6:	f8df 8098 	ldr.w	r8, [pc, #152]	; 9000cd60 <pbuf_free+0xc0>
    SYS_ARCH_PROTECT(old_level);
9000ccca:	f000 fbed 	bl	9000d4a8 <sys_arch_protect>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
9000ccce:	7ba3      	ldrb	r3, [r4, #14]
    SYS_ARCH_PROTECT(old_level);
9000ccd0:	4681      	mov	r9, r0
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
9000ccd2:	b933      	cbnz	r3, 9000cce2 <pbuf_free+0x42>
9000ccd4:	463b      	mov	r3, r7
9000ccd6:	f240 22f1 	movw	r2, #753	; 0x2f1
9000ccda:	4651      	mov	r1, sl
9000ccdc:	4640      	mov	r0, r8
9000ccde:	f004 ff65 	bl	90011bac <iprintf>
    ref = --(p->ref);
9000cce2:	7ba6      	ldrb	r6, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
9000cce4:	4648      	mov	r0, r9
    ref = --(p->ref);
9000cce6:	3e01      	subs	r6, #1
9000cce8:	b2f6      	uxtb	r6, r6
9000ccea:	73a6      	strb	r6, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
9000ccec:	f000 fbe8 	bl	9000d4c0 <sys_arch_unprotect>
    if (ref == 0) {
9000ccf0:	2e00      	cmp	r6, #0
9000ccf2:	d1e1      	bne.n	9000ccb8 <pbuf_free+0x18>
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
9000ccf4:	7b63      	ldrb	r3, [r4, #13]
      q = p->next;
9000ccf6:	6826      	ldr	r6, [r4, #0]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
9000ccf8:	079b      	lsls	r3, r3, #30
9000ccfa:	d511      	bpl.n	9000cd20 <pbuf_free+0x80>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
9000ccfc:	6923      	ldr	r3, [r4, #16]
9000ccfe:	b933      	cbnz	r3, 9000cd0e <pbuf_free+0x6e>
9000cd00:	463b      	mov	r3, r7
9000cd02:	f240 22ff 	movw	r2, #767	; 0x2ff
9000cd06:	4917      	ldr	r1, [pc, #92]	; (9000cd64 <pbuf_free+0xc4>)
9000cd08:	4640      	mov	r0, r8
9000cd0a:	f004 ff4f 	bl	90011bac <iprintf>
        pc->custom_free_function(p);
9000cd0e:	6923      	ldr	r3, [r4, #16]
9000cd10:	4620      	mov	r0, r4
9000cd12:	4798      	blx	r3
      count++;
9000cd14:	3501      	adds	r5, #1
9000cd16:	b2ed      	uxtb	r5, r5
  while (p != NULL) {
9000cd18:	2e00      	cmp	r6, #0
9000cd1a:	d0cd      	beq.n	9000ccb8 <pbuf_free+0x18>
9000cd1c:	4634      	mov	r4, r6
9000cd1e:	e7d4      	b.n	9000ccca <pbuf_free+0x2a>
      alloc_src = pbuf_get_allocsrc(p);
9000cd20:	7b23      	ldrb	r3, [r4, #12]
9000cd22:	f003 030f 	and.w	r3, r3, #15
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
9000cd26:	2b02      	cmp	r3, #2
9000cd28:	d104      	bne.n	9000cd34 <pbuf_free+0x94>
          memp_free(MEMP_PBUF_POOL, p);
9000cd2a:	4621      	mov	r1, r4
9000cd2c:	200d      	movs	r0, #13
          memp_free(MEMP_PBUF, p);
9000cd2e:	f7ff fb9d 	bl	9000c46c <memp_free>
9000cd32:	e7ef      	b.n	9000cd14 <pbuf_free+0x74>
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
9000cd34:	2b01      	cmp	r3, #1
9000cd36:	d102      	bne.n	9000cd3e <pbuf_free+0x9e>
          memp_free(MEMP_PBUF, p);
9000cd38:	4621      	mov	r1, r4
9000cd3a:	200c      	movs	r0, #12
9000cd3c:	e7f7      	b.n	9000cd2e <pbuf_free+0x8e>
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
9000cd3e:	b91b      	cbnz	r3, 9000cd48 <pbuf_free+0xa8>
          mem_free(p);
9000cd40:	4620      	mov	r0, r4
9000cd42:	f7ff f8af 	bl	9000bea4 <mem_free>
9000cd46:	e7e5      	b.n	9000cd14 <pbuf_free+0x74>
          LWIP_ASSERT("invalid pbuf type", 0);
9000cd48:	463b      	mov	r3, r7
9000cd4a:	f240 320f 	movw	r2, #783	; 0x30f
9000cd4e:	4906      	ldr	r1, [pc, #24]	; (9000cd68 <pbuf_free+0xc8>)
9000cd50:	4640      	mov	r0, r8
9000cd52:	f004 ff2b 	bl	90011bac <iprintf>
9000cd56:	e7dd      	b.n	9000cd14 <pbuf_free+0x74>
9000cd58:	90014295 	.word	0x90014295
9000cd5c:	9001436e 	.word	0x9001436e
9000cd60:	90012aff 	.word	0x90012aff
9000cd64:	90014312 	.word	0x90014312
9000cd68:	90014333 	.word	0x90014333
9000cd6c:	900142fc 	.word	0x900142fc

9000cd70 <pbuf_alloc>:
  switch (type) {
9000cd70:	f5b2 7fc1 	cmp.w	r2, #386	; 0x182
{
9000cd74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000cd78:	4606      	mov	r6, r0
9000cd7a:	460f      	mov	r7, r1
  u16_t offset = (u16_t)layer;
9000cd7c:	b284      	uxth	r4, r0
  switch (type) {
9000cd7e:	d014      	beq.n	9000cdaa <pbuf_alloc+0x3a>
9000cd80:	d808      	bhi.n	9000cd94 <pbuf_alloc+0x24>
9000cd82:	f022 0340 	bic.w	r3, r2, #64	; 0x40
9000cd86:	2b01      	cmp	r3, #1
9000cd88:	d107      	bne.n	9000cd9a <pbuf_alloc+0x2a>
      p = pbuf_alloc_reference(NULL, length, type);
9000cd8a:	2000      	movs	r0, #0
}
9000cd8c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      p = pbuf_alloc_reference(NULL, length, type);
9000cd90:	f7ff bf10 	b.w	9000cbb4 <pbuf_alloc_reference>
  switch (type) {
9000cd94:	f5b2 7f20 	cmp.w	r2, #640	; 0x280
9000cd98:	d04e      	beq.n	9000ce38 <pbuf_alloc+0xc8>
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
9000cd9a:	4b37      	ldr	r3, [pc, #220]	; (9000ce78 <pbuf_alloc+0x108>)
9000cd9c:	f240 1227 	movw	r2, #295	; 0x127
9000cda0:	4936      	ldr	r1, [pc, #216]	; (9000ce7c <pbuf_alloc+0x10c>)
9000cda2:	4837      	ldr	r0, [pc, #220]	; (9000ce80 <pbuf_alloc+0x110>)
9000cda4:	f004 ff02 	bl	90011bac <iprintf>
9000cda8:	e01f      	b.n	9000cdea <pbuf_alloc+0x7a>
  switch (type) {
9000cdaa:	2600      	movs	r6, #0
  p->type_internal = (u8_t)type;
9000cdac:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 9000ce90 <pbuf_alloc+0x120>
  switch (type) {
9000cdb0:	4635      	mov	r5, r6
  p->next = NULL;
9000cdb2:	46b0      	mov	r8, r6
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
9000cdb4:	200d      	movs	r0, #13
9000cdb6:	46b2      	mov	sl, r6
9000cdb8:	f7ff fb28 	bl	9000c40c <memp_malloc>
        if (q == NULL) {
9000cdbc:	4606      	mov	r6, r0
9000cdbe:	b9d0      	cbnz	r0, 9000cdf6 <pbuf_alloc+0x86>
  queued = pbuf_free_ooseq_pending;
9000cdc0:	4c30      	ldr	r4, [pc, #192]	; (9000ce84 <pbuf_alloc+0x114>)
  SYS_ARCH_PROTECT(old_level);
9000cdc2:	f000 fb71 	bl	9000d4a8 <sys_arch_protect>
  pbuf_free_ooseq_pending = 1;
9000cdc6:	2301      	movs	r3, #1
  queued = pbuf_free_ooseq_pending;
9000cdc8:	7827      	ldrb	r7, [r4, #0]
  pbuf_free_ooseq_pending = 1;
9000cdca:	7023      	strb	r3, [r4, #0]
  queued = pbuf_free_ooseq_pending;
9000cdcc:	b2ff      	uxtb	r7, r7
  SYS_ARCH_UNPROTECT(old_level);
9000cdce:	f000 fb77 	bl	9000d4c0 <sys_arch_unprotect>
  if (!queued) {
9000cdd2:	b94f      	cbnz	r7, 9000cde8 <pbuf_alloc+0x78>
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
9000cdd4:	4631      	mov	r1, r6
9000cdd6:	482c      	ldr	r0, [pc, #176]	; (9000ce88 <pbuf_alloc+0x118>)
9000cdd8:	f004 f96e 	bl	900110b8 <tcpip_try_callback>
9000cddc:	b120      	cbz	r0, 9000cde8 <pbuf_alloc+0x78>
9000cdde:	f000 fb63 	bl	9000d4a8 <sys_arch_protect>
9000cde2:	7026      	strb	r6, [r4, #0]
9000cde4:	f000 fb6c 	bl	9000d4c0 <sys_arch_unprotect>
          if (p) {
9000cde8:	b90d      	cbnz	r5, 9000cdee <pbuf_alloc+0x7e>
      return NULL;
9000cdea:	2500      	movs	r5, #0
9000cdec:	e01f      	b.n	9000ce2e <pbuf_alloc+0xbe>
            pbuf_free(p);
9000cdee:	4628      	mov	r0, r5
9000cdf0:	f7ff ff56 	bl	9000cca0 <pbuf_free>
9000cdf4:	e7f9      	b.n	9000cdea <pbuf_alloc+0x7a>
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
9000cdf6:	1ce3      	adds	r3, r4, #3
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
9000cdf8:	4404      	add	r4, r0
  p->next = NULL;
9000cdfa:	f8c0 8000 	str.w	r8, [r0]
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
9000cdfe:	f023 0303 	bic.w	r3, r3, #3
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
9000ce02:	3413      	adds	r4, #19
  p->tot_len = tot_len;
9000ce04:	8107      	strh	r7, [r0, #8]
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
9000ce06:	f5c3 7314 	rsb	r3, r3, #592	; 0x250
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
9000ce0a:	f024 0403 	bic.w	r4, r4, #3
  p->type_internal = (u8_t)type;
9000ce0e:	f8c0 900c 	str.w	r9, [r0, #12]
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
9000ce12:	b29b      	uxth	r3, r3
  p->payload = payload;
9000ce14:	6044      	str	r4, [r0, #4]
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
9000ce16:	42bb      	cmp	r3, r7
9000ce18:	bf28      	it	cs
9000ce1a:	463b      	movcs	r3, r7
  p->len = len;
9000ce1c:	8143      	strh	r3, [r0, #10]
        if (p == NULL) {
9000ce1e:	b14d      	cbz	r5, 9000ce34 <pbuf_alloc+0xc4>
          last->next = q;
9000ce20:	f8ca 0000 	str.w	r0, [sl]
        rem_len = (u16_t)(rem_len - qlen);
9000ce24:	1afb      	subs	r3, r7, r3
        offset = 0;
9000ce26:	2400      	movs	r4, #0
        rem_len = (u16_t)(rem_len - qlen);
9000ce28:	b29f      	uxth	r7, r3
      } while (rem_len > 0);
9000ce2a:	2f00      	cmp	r7, #0
9000ce2c:	d1c2      	bne.n	9000cdb4 <pbuf_alloc+0x44>
}
9000ce2e:	4628      	mov	r0, r5
9000ce30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
9000ce34:	4605      	mov	r5, r0
9000ce36:	e7f5      	b.n	9000ce24 <pbuf_alloc+0xb4>
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
9000ce38:	3403      	adds	r4, #3
9000ce3a:	1ccb      	adds	r3, r1, #3
9000ce3c:	f024 0403 	bic.w	r4, r4, #3
9000ce40:	f023 0303 	bic.w	r3, r3, #3
9000ce44:	441c      	add	r4, r3
9000ce46:	b2a4      	uxth	r4, r4
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
9000ce48:	f104 0010 	add.w	r0, r4, #16
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
9000ce4c:	429c      	cmp	r4, r3
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
9000ce4e:	b280      	uxth	r0, r0
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
9000ce50:	d3cb      	bcc.n	9000cdea <pbuf_alloc+0x7a>
9000ce52:	4283      	cmp	r3, r0
9000ce54:	d8c9      	bhi.n	9000cdea <pbuf_alloc+0x7a>
      p = (struct pbuf *)mem_malloc(alloc_len);
9000ce56:	f7ff f9b7 	bl	9000c1c8 <mem_malloc>
      if (p == NULL) {
9000ce5a:	4605      	mov	r5, r0
9000ce5c:	2800      	cmp	r0, #0
9000ce5e:	d0e6      	beq.n	9000ce2e <pbuf_alloc+0xbe>
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
9000ce60:	4406      	add	r6, r0
  p->next = NULL;
9000ce62:	2300      	movs	r3, #0
  p->tot_len = tot_len;
9000ce64:	8107      	strh	r7, [r0, #8]
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
9000ce66:	3613      	adds	r6, #19
  p->next = NULL;
9000ce68:	6003      	str	r3, [r0, #0]
  p->type_internal = (u8_t)type;
9000ce6a:	4b08      	ldr	r3, [pc, #32]	; (9000ce8c <pbuf_alloc+0x11c>)
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
9000ce6c:	f026 0603 	bic.w	r6, r6, #3
  p->len = len;
9000ce70:	8147      	strh	r7, [r0, #10]
  p->type_internal = (u8_t)type;
9000ce72:	60c3      	str	r3, [r0, #12]
  p->payload = payload;
9000ce74:	6046      	str	r6, [r0, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
9000ce76:	e7da      	b.n	9000ce2e <pbuf_alloc+0xbe>
9000ce78:	90014295 	.word	0x90014295
9000ce7c:	90014345 	.word	0x90014345
9000ce80:	90012aff 	.word	0x90012aff
9000ce84:	2400d3a5 	.word	0x2400d3a5
9000ce88:	9000cb21 	.word	0x9000cb21
9000ce8c:	00010080 	.word	0x00010080
9000ce90:	00010082 	.word	0x00010082

9000ce94 <pbuf_realloc>:
{
9000ce94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000ce98:	460e      	mov	r6, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
9000ce9a:	4604      	mov	r4, r0
9000ce9c:	b930      	cbnz	r0, 9000ceac <pbuf_realloc+0x18>
9000ce9e:	4b24      	ldr	r3, [pc, #144]	; (9000cf30 <pbuf_realloc+0x9c>)
9000cea0:	f44f 72cc 	mov.w	r2, #408	; 0x198
9000cea4:	4923      	ldr	r1, [pc, #140]	; (9000cf34 <pbuf_realloc+0xa0>)
9000cea6:	4824      	ldr	r0, [pc, #144]	; (9000cf38 <pbuf_realloc+0xa4>)
9000cea8:	f004 fe80 	bl	90011bac <iprintf>
  if (new_len >= p->tot_len) {
9000ceac:	8927      	ldrh	r7, [r4, #8]
9000ceae:	42b7      	cmp	r7, r6
9000ceb0:	d93c      	bls.n	9000cf2c <pbuf_realloc+0x98>
9000ceb2:	4635      	mov	r5, r6
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
9000ceb4:	f8df 8078 	ldr.w	r8, [pc, #120]	; 9000cf30 <pbuf_realloc+0x9c>
9000ceb8:	f8df a084 	ldr.w	sl, [pc, #132]	; 9000cf40 <pbuf_realloc+0xac>
9000cebc:	f8df 9078 	ldr.w	r9, [pc, #120]	; 9000cf38 <pbuf_realloc+0xa4>
  while (rem_len > q->len) {
9000cec0:	8962      	ldrh	r2, [r4, #10]
9000cec2:	42aa      	cmp	r2, r5
9000cec4:	d319      	bcc.n	9000cefa <pbuf_realloc+0x66>
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
9000cec6:	7b23      	ldrb	r3, [r4, #12]
9000cec8:	0719      	lsls	r1, r3, #28
9000ceca:	d127      	bne.n	9000cf1c <pbuf_realloc+0x88>
9000cecc:	42aa      	cmp	r2, r5
9000cece:	d025      	beq.n	9000cf1c <pbuf_realloc+0x88>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
9000ced0:	7b63      	ldrb	r3, [r4, #13]
9000ced2:	079b      	lsls	r3, r3, #30
9000ced4:	d422      	bmi.n	9000cf1c <pbuf_realloc+0x88>
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
9000ced6:	6861      	ldr	r1, [r4, #4]
9000ced8:	4620      	mov	r0, r4
9000ceda:	1b09      	subs	r1, r1, r4
9000cedc:	4429      	add	r1, r5
9000cede:	b289      	uxth	r1, r1
9000cee0:	f7ff f8bc 	bl	9000c05c <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
9000cee4:	4604      	mov	r4, r0
9000cee6:	b9c8      	cbnz	r0, 9000cf1c <pbuf_realloc+0x88>
9000cee8:	4b11      	ldr	r3, [pc, #68]	; (9000cf30 <pbuf_realloc+0x9c>)
9000ceea:	f240 12bd 	movw	r2, #445	; 0x1bd
9000ceee:	4913      	ldr	r1, [pc, #76]	; (9000cf3c <pbuf_realloc+0xa8>)
9000cef0:	4811      	ldr	r0, [pc, #68]	; (9000cf38 <pbuf_realloc+0xa4>)
9000cef2:	f004 fe5b 	bl	90011bac <iprintf>
  q->len = rem_len;
9000cef6:	8164      	strh	r4, [r4, #10]
9000cef8:	deff      	udf	#255	; 0xff
    rem_len = (u16_t)(rem_len - q->len);
9000cefa:	1aad      	subs	r5, r5, r2
    q->tot_len = (u16_t)(q->tot_len - shrink);
9000cefc:	1bf3      	subs	r3, r6, r7
9000cefe:	8922      	ldrh	r2, [r4, #8]
    rem_len = (u16_t)(rem_len - q->len);
9000cf00:	b2ad      	uxth	r5, r5
    q->tot_len = (u16_t)(q->tot_len - shrink);
9000cf02:	4413      	add	r3, r2
9000cf04:	8123      	strh	r3, [r4, #8]
    q = q->next;
9000cf06:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
9000cf08:	2c00      	cmp	r4, #0
9000cf0a:	d1d9      	bne.n	9000cec0 <pbuf_realloc+0x2c>
9000cf0c:	4643      	mov	r3, r8
9000cf0e:	f240 12af 	movw	r2, #431	; 0x1af
9000cf12:	4651      	mov	r1, sl
9000cf14:	4648      	mov	r0, r9
9000cf16:	f004 fe49 	bl	90011bac <iprintf>
9000cf1a:	e7d1      	b.n	9000cec0 <pbuf_realloc+0x2c>
  if (q->next != NULL) {
9000cf1c:	6820      	ldr	r0, [r4, #0]
  q->len = rem_len;
9000cf1e:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
9000cf20:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
9000cf22:	b108      	cbz	r0, 9000cf28 <pbuf_realloc+0x94>
    pbuf_free(q->next);
9000cf24:	f7ff febc 	bl	9000cca0 <pbuf_free>
  q->next = NULL;
9000cf28:	2300      	movs	r3, #0
9000cf2a:	6023      	str	r3, [r4, #0]
}
9000cf2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
9000cf30:	90014295 	.word	0x90014295
9000cf34:	90014360 	.word	0x90014360
9000cf38:	90012aff 	.word	0x90012aff
9000cf3c:	90014390 	.word	0x90014390
9000cf40:	90014378 	.word	0x90014378

9000cf44 <pbuf_clen>:
{
9000cf44:	4603      	mov	r3, r0
  while (p != NULL) {
9000cf46:	2200      	movs	r2, #0
9000cf48:	b290      	uxth	r0, r2
9000cf4a:	3201      	adds	r2, #1
9000cf4c:	b903      	cbnz	r3, 9000cf50 <pbuf_clen+0xc>
}
9000cf4e:	4770      	bx	lr
    p = p->next;
9000cf50:	681b      	ldr	r3, [r3, #0]
9000cf52:	e7f9      	b.n	9000cf48 <pbuf_clen+0x4>

9000cf54 <pbuf_ref>:
{
9000cf54:	b510      	push	{r4, lr}
  if (p != NULL) {
9000cf56:	4604      	mov	r4, r0
9000cf58:	b188      	cbz	r0, 9000cf7e <pbuf_ref+0x2a>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
9000cf5a:	f000 faa5 	bl	9000d4a8 <sys_arch_protect>
9000cf5e:	7ba3      	ldrb	r3, [r4, #14]
9000cf60:	3301      	adds	r3, #1
9000cf62:	73a3      	strb	r3, [r4, #14]
9000cf64:	f000 faac 	bl	9000d4c0 <sys_arch_unprotect>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
9000cf68:	7ba3      	ldrb	r3, [r4, #14]
9000cf6a:	b943      	cbnz	r3, 9000cf7e <pbuf_ref+0x2a>
9000cf6c:	4b04      	ldr	r3, [pc, #16]	; (9000cf80 <pbuf_ref+0x2c>)
9000cf6e:	f240 3242 	movw	r2, #834	; 0x342
9000cf72:	4904      	ldr	r1, [pc, #16]	; (9000cf84 <pbuf_ref+0x30>)
9000cf74:	4804      	ldr	r0, [pc, #16]	; (9000cf88 <pbuf_ref+0x34>)
}
9000cf76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
9000cf7a:	f004 be17 	b.w	90011bac <iprintf>
}
9000cf7e:	bd10      	pop	{r4, pc}
9000cf80:	90014295 	.word	0x90014295
9000cf84:	900143ac 	.word	0x900143ac
9000cf88:	90012aff 	.word	0x90012aff

9000cf8c <pbuf_cat>:
{
9000cf8c:	b570      	push	{r4, r5, r6, lr}
9000cf8e:	460d      	mov	r5, r1
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
9000cf90:	4604      	mov	r4, r0
9000cf92:	b100      	cbz	r0, 9000cf96 <pbuf_cat+0xa>
9000cf94:	b961      	cbnz	r1, 9000cfb0 <pbuf_cat+0x24>
9000cf96:	4b15      	ldr	r3, [pc, #84]	; (9000cfec <pbuf_cat+0x60>)
9000cf98:	f240 3259 	movw	r2, #857	; 0x359
9000cf9c:	4914      	ldr	r1, [pc, #80]	; (9000cff0 <pbuf_cat+0x64>)
9000cf9e:	4815      	ldr	r0, [pc, #84]	; (9000cff4 <pbuf_cat+0x68>)
}
9000cfa0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
9000cfa4:	f004 be02 	b.w	90011bac <iprintf>
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
9000cfa8:	8929      	ldrh	r1, [r5, #8]
9000cfaa:	440b      	add	r3, r1
9000cfac:	8123      	strh	r3, [r4, #8]
9000cfae:	4614      	mov	r4, r2
  for (p = h; p->next != NULL; p = p->next) {
9000cfb0:	6822      	ldr	r2, [r4, #0]
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
9000cfb2:	8923      	ldrh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
9000cfb4:	2a00      	cmp	r2, #0
9000cfb6:	d1f7      	bne.n	9000cfa8 <pbuf_cat+0x1c>
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
9000cfb8:	8962      	ldrh	r2, [r4, #10]
9000cfba:	429a      	cmp	r2, r3
9000cfbc:	d00f      	beq.n	9000cfde <pbuf_cat+0x52>
9000cfbe:	4b0b      	ldr	r3, [pc, #44]	; (9000cfec <pbuf_cat+0x60>)
9000cfc0:	f240 3262 	movw	r2, #866	; 0x362
9000cfc4:	490c      	ldr	r1, [pc, #48]	; (9000cff8 <pbuf_cat+0x6c>)
9000cfc6:	480b      	ldr	r0, [pc, #44]	; (9000cff4 <pbuf_cat+0x68>)
9000cfc8:	f004 fdf0 	bl	90011bac <iprintf>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
9000cfcc:	6823      	ldr	r3, [r4, #0]
9000cfce:	b133      	cbz	r3, 9000cfde <pbuf_cat+0x52>
9000cfd0:	4b06      	ldr	r3, [pc, #24]	; (9000cfec <pbuf_cat+0x60>)
9000cfd2:	f240 3263 	movw	r2, #867	; 0x363
9000cfd6:	4909      	ldr	r1, [pc, #36]	; (9000cffc <pbuf_cat+0x70>)
9000cfd8:	4806      	ldr	r0, [pc, #24]	; (9000cff4 <pbuf_cat+0x68>)
9000cfda:	f004 fde7 	bl	90011bac <iprintf>
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
9000cfde:	892a      	ldrh	r2, [r5, #8]
9000cfe0:	8923      	ldrh	r3, [r4, #8]
  p->next = t;
9000cfe2:	6025      	str	r5, [r4, #0]
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
9000cfe4:	4413      	add	r3, r2
9000cfe6:	8123      	strh	r3, [r4, #8]
}
9000cfe8:	bd70      	pop	{r4, r5, r6, pc}
9000cfea:	bf00      	nop
9000cfec:	90014295 	.word	0x90014295
9000cff0:	900143be 	.word	0x900143be
9000cff4:	90012aff 	.word	0x90012aff
9000cff8:	900143f3 	.word	0x900143f3
9000cffc:	90014420 	.word	0x90014420

9000d000 <pbuf_chain>:
{
9000d000:	b510      	push	{r4, lr}
9000d002:	460c      	mov	r4, r1
  pbuf_cat(h, t);
9000d004:	f7ff ffc2 	bl	9000cf8c <pbuf_cat>
  pbuf_ref(t);
9000d008:	4620      	mov	r0, r4
}
9000d00a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  pbuf_ref(t);
9000d00e:	f7ff bfa1 	b.w	9000cf54 <pbuf_ref>
	...

9000d014 <pbuf_copy>:
{
9000d014:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000d018:	460c      	mov	r4, r1
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
9000d01a:	4605      	mov	r5, r0
9000d01c:	b120      	cbz	r0, 9000d028 <pbuf_copy+0x14>
9000d01e:	b119      	cbz	r1, 9000d028 <pbuf_copy+0x14>
9000d020:	8902      	ldrh	r2, [r0, #8]
9000d022:	890b      	ldrh	r3, [r1, #8]
9000d024:	429a      	cmp	r2, r3
9000d026:	d20a      	bcs.n	9000d03e <pbuf_copy+0x2a>
9000d028:	4b34      	ldr	r3, [pc, #208]	; (9000d0fc <pbuf_copy+0xe8>)
9000d02a:	f240 32c9 	movw	r2, #969	; 0x3c9
9000d02e:	4934      	ldr	r1, [pc, #208]	; (9000d100 <pbuf_copy+0xec>)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
9000d030:	4834      	ldr	r0, [pc, #208]	; (9000d104 <pbuf_copy+0xf0>)
9000d032:	f004 fdbb 	bl	90011bac <iprintf>
9000d036:	f06f 000f 	mvn.w	r0, #15
}
9000d03a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  size_t offset_to = 0, offset_from = 0, len;
9000d03e:	2600      	movs	r6, #0
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
9000d040:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 9000d0fc <pbuf_copy+0xe8>
9000d044:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 9000d114 <pbuf_copy+0x100>
  size_t offset_to = 0, offset_from = 0, len;
9000d048:	4637      	mov	r7, r6
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
9000d04a:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 9000d104 <pbuf_copy+0xf0>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
9000d04e:	f8b5 800a 	ldrh.w	r8, [r5, #10]
9000d052:	8962      	ldrh	r2, [r4, #10]
9000d054:	eba8 0807 	sub.w	r8, r8, r7
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
9000d058:	6868      	ldr	r0, [r5, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
9000d05a:	1b92      	subs	r2, r2, r6
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
9000d05c:	6861      	ldr	r1, [r4, #4]
9000d05e:	4438      	add	r0, r7
9000d060:	4590      	cmp	r8, r2
9000d062:	4431      	add	r1, r6
9000d064:	bf28      	it	cs
9000d066:	4690      	movcs	r8, r2
9000d068:	4642      	mov	r2, r8
    offset_to += len;
9000d06a:	4447      	add	r7, r8
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
9000d06c:	f004 fca8 	bl	900119c0 <memcpy>
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
9000d070:	896b      	ldrh	r3, [r5, #10]
    offset_from += len;
9000d072:	4446      	add	r6, r8
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
9000d074:	429f      	cmp	r7, r3
9000d076:	d906      	bls.n	9000d086 <pbuf_copy+0x72>
9000d078:	465b      	mov	r3, fp
9000d07a:	f240 32d9 	movw	r2, #985	; 0x3d9
9000d07e:	4651      	mov	r1, sl
9000d080:	4648      	mov	r0, r9
9000d082:	f004 fd93 	bl	90011bac <iprintf>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
9000d086:	8963      	ldrh	r3, [r4, #10]
9000d088:	429e      	cmp	r6, r3
9000d08a:	d906      	bls.n	9000d09a <pbuf_copy+0x86>
9000d08c:	465b      	mov	r3, fp
9000d08e:	f240 32da 	movw	r2, #986	; 0x3da
9000d092:	491d      	ldr	r1, [pc, #116]	; (9000d108 <pbuf_copy+0xf4>)
9000d094:	4648      	mov	r0, r9
9000d096:	f004 fd89 	bl	90011bac <iprintf>
    if (offset_from >= p_from->len) {
9000d09a:	8963      	ldrh	r3, [r4, #10]
9000d09c:	429e      	cmp	r6, r3
    if (offset_to == p_to->len) {
9000d09e:	896b      	ldrh	r3, [r5, #10]
      p_from = p_from->next;
9000d0a0:	bf24      	itt	cs
9000d0a2:	6824      	ldrcs	r4, [r4, #0]
      offset_from = 0;
9000d0a4:	2600      	movcs	r6, #0
    if (offset_to == p_to->len) {
9000d0a6:	429f      	cmp	r7, r3
9000d0a8:	d108      	bne.n	9000d0bc <pbuf_copy+0xa8>
      p_to = p_to->next;
9000d0aa:	682d      	ldr	r5, [r5, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
9000d0ac:	b92d      	cbnz	r5, 9000d0ba <pbuf_copy+0xa6>
9000d0ae:	b314      	cbz	r4, 9000d0f6 <pbuf_copy+0xe2>
9000d0b0:	4b12      	ldr	r3, [pc, #72]	; (9000d0fc <pbuf_copy+0xe8>)
9000d0b2:	f44f 7279 	mov.w	r2, #996	; 0x3e4
9000d0b6:	4915      	ldr	r1, [pc, #84]	; (9000d10c <pbuf_copy+0xf8>)
9000d0b8:	e7ba      	b.n	9000d030 <pbuf_copy+0x1c>
      offset_to = 0;
9000d0ba:	2700      	movs	r7, #0
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
9000d0bc:	b17c      	cbz	r4, 9000d0de <pbuf_copy+0xca>
9000d0be:	8962      	ldrh	r2, [r4, #10]
9000d0c0:	8923      	ldrh	r3, [r4, #8]
9000d0c2:	429a      	cmp	r2, r3
9000d0c4:	d10b      	bne.n	9000d0de <pbuf_copy+0xca>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
9000d0c6:	6823      	ldr	r3, [r4, #0]
9000d0c8:	b14b      	cbz	r3, 9000d0de <pbuf_copy+0xca>
9000d0ca:	4b0c      	ldr	r3, [pc, #48]	; (9000d0fc <pbuf_copy+0xe8>)
9000d0cc:	f240 32e9 	movw	r2, #1001	; 0x3e9
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
9000d0d0:	490f      	ldr	r1, [pc, #60]	; (9000d110 <pbuf_copy+0xfc>)
9000d0d2:	480c      	ldr	r0, [pc, #48]	; (9000d104 <pbuf_copy+0xf0>)
9000d0d4:	f004 fd6a 	bl	90011bac <iprintf>
9000d0d8:	f06f 0005 	mvn.w	r0, #5
9000d0dc:	e7ad      	b.n	9000d03a <pbuf_copy+0x26>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
9000d0de:	896a      	ldrh	r2, [r5, #10]
9000d0e0:	892b      	ldrh	r3, [r5, #8]
9000d0e2:	429a      	cmp	r2, r3
9000d0e4:	d105      	bne.n	9000d0f2 <pbuf_copy+0xde>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
9000d0e6:	682b      	ldr	r3, [r5, #0]
9000d0e8:	b11b      	cbz	r3, 9000d0f2 <pbuf_copy+0xde>
9000d0ea:	4b04      	ldr	r3, [pc, #16]	; (9000d0fc <pbuf_copy+0xe8>)
9000d0ec:	f240 32ee 	movw	r2, #1006	; 0x3ee
9000d0f0:	e7ee      	b.n	9000d0d0 <pbuf_copy+0xbc>
  } while (p_from);
9000d0f2:	2c00      	cmp	r4, #0
9000d0f4:	d1ab      	bne.n	9000d04e <pbuf_copy+0x3a>
  return ERR_OK;
9000d0f6:	4620      	mov	r0, r4
9000d0f8:	e79f      	b.n	9000d03a <pbuf_copy+0x26>
9000d0fa:	bf00      	nop
9000d0fc:	90014295 	.word	0x90014295
9000d100:	90014430 	.word	0x90014430
9000d104:	90012aff 	.word	0x90012aff
9000d108:	90014477 	.word	0x90014477
9000d10c:	90014492 	.word	0x90014492
9000d110:	9001449f 	.word	0x9001449f
9000d114:	90014460 	.word	0x90014460

9000d118 <pbuf_copy_partial>:
{
9000d118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9000d11c:	460f      	mov	r7, r1
9000d11e:	4690      	mov	r8, r2
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
9000d120:	4605      	mov	r5, r0
9000d122:	b950      	cbnz	r0, 9000d13a <pbuf_copy_partial+0x22>
9000d124:	462e      	mov	r6, r5
9000d126:	4b1b      	ldr	r3, [pc, #108]	; (9000d194 <pbuf_copy_partial+0x7c>)
9000d128:	f240 420a 	movw	r2, #1034	; 0x40a
9000d12c:	491a      	ldr	r1, [pc, #104]	; (9000d198 <pbuf_copy_partial+0x80>)
9000d12e:	481b      	ldr	r0, [pc, #108]	; (9000d19c <pbuf_copy_partial+0x84>)
9000d130:	f004 fd3c 	bl	90011bac <iprintf>
}
9000d134:	4630      	mov	r0, r6
9000d136:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
9000d13a:	bb41      	cbnz	r1, 9000d18e <pbuf_copy_partial+0x76>
9000d13c:	4b15      	ldr	r3, [pc, #84]	; (9000d194 <pbuf_copy_partial+0x7c>)
9000d13e:	f240 420b 	movw	r2, #1035	; 0x40b
9000d142:	4917      	ldr	r1, [pc, #92]	; (9000d1a0 <pbuf_copy_partial+0x88>)
9000d144:	463e      	mov	r6, r7
9000d146:	4815      	ldr	r0, [pc, #84]	; (9000d19c <pbuf_copy_partial+0x84>)
9000d148:	f004 fd30 	bl	90011bac <iprintf>
9000d14c:	e7f2      	b.n	9000d134 <pbuf_copy_partial+0x1c>
    if ((offset != 0) && (offset >= p->len)) {
9000d14e:	896c      	ldrh	r4, [r5, #10]
9000d150:	b153      	cbz	r3, 9000d168 <pbuf_copy_partial+0x50>
9000d152:	42a3      	cmp	r3, r4
9000d154:	d308      	bcc.n	9000d168 <pbuf_copy_partial+0x50>
      offset = (u16_t)(offset - p->len);
9000d156:	1b1b      	subs	r3, r3, r4
9000d158:	b29b      	uxth	r3, r3
  for (p = buf; len != 0 && p != NULL; p = p->next) {
9000d15a:	682d      	ldr	r5, [r5, #0]
9000d15c:	f1b8 0f00 	cmp.w	r8, #0
9000d160:	d0e8      	beq.n	9000d134 <pbuf_copy_partial+0x1c>
9000d162:	2d00      	cmp	r5, #0
9000d164:	d1f3      	bne.n	9000d14e <pbuf_copy_partial+0x36>
9000d166:	e7e5      	b.n	9000d134 <pbuf_copy_partial+0x1c>
      buf_copy_len = (u16_t)(p->len - offset);
9000d168:	1ae4      	subs	r4, r4, r3
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
9000d16a:	6869      	ldr	r1, [r5, #4]
9000d16c:	19b8      	adds	r0, r7, r6
      buf_copy_len = (u16_t)(p->len - offset);
9000d16e:	b2a4      	uxth	r4, r4
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
9000d170:	4419      	add	r1, r3
9000d172:	4544      	cmp	r4, r8
9000d174:	bf28      	it	cs
9000d176:	4644      	movcs	r4, r8
9000d178:	4622      	mov	r2, r4
      copied_total = (u16_t)(copied_total + buf_copy_len);
9000d17a:	4426      	add	r6, r4
      len = (u16_t)(len - buf_copy_len);
9000d17c:	eba8 0404 	sub.w	r4, r8, r4
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
9000d180:	f004 fc1e 	bl	900119c0 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
9000d184:	b2b6      	uxth	r6, r6
      offset = 0;
9000d186:	2300      	movs	r3, #0
      len = (u16_t)(len - buf_copy_len);
9000d188:	fa1f f884 	uxth.w	r8, r4
      offset = 0;
9000d18c:	e7e5      	b.n	9000d15a <pbuf_copy_partial+0x42>
  u16_t left = 0;
9000d18e:	2600      	movs	r6, #0
9000d190:	e7e4      	b.n	9000d15c <pbuf_copy_partial+0x44>
9000d192:	bf00      	nop
9000d194:	90014295 	.word	0x90014295
9000d198:	900144c9 	.word	0x900144c9
9000d19c:	90012aff 	.word	0x90012aff
9000d1a0:	900144e8 	.word	0x900144e8

9000d1a4 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
9000d1a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000d1a8:	4689      	mov	r9, r1
9000d1aa:	4616      	mov	r6, r2
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
  size_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
9000d1ac:	4605      	mov	r5, r0
9000d1ae:	b950      	cbnz	r0, 9000d1c6 <pbuf_take+0x22>
9000d1b0:	4b24      	ldr	r3, [pc, #144]	; (9000d244 <pbuf_take+0xa0>)
9000d1b2:	f240 42b3 	movw	r2, #1203	; 0x4b3
9000d1b6:	4924      	ldr	r1, [pc, #144]	; (9000d248 <pbuf_take+0xa4>)
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
9000d1b8:	4824      	ldr	r0, [pc, #144]	; (9000d24c <pbuf_take+0xa8>)
9000d1ba:	f004 fcf7 	bl	90011bac <iprintf>
9000d1be:	f06f 000f 	mvn.w	r0, #15
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
}
9000d1c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
9000d1c6:	b921      	cbnz	r1, 9000d1d2 <pbuf_take+0x2e>
9000d1c8:	4b1e      	ldr	r3, [pc, #120]	; (9000d244 <pbuf_take+0xa0>)
9000d1ca:	f240 42b4 	movw	r2, #1204	; 0x4b4
9000d1ce:	4920      	ldr	r1, [pc, #128]	; (9000d250 <pbuf_take+0xac>)
9000d1d0:	e7f2      	b.n	9000d1b8 <pbuf_take+0x14>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
9000d1d2:	8903      	ldrh	r3, [r0, #8]
9000d1d4:	4293      	cmp	r3, r2
9000d1d6:	d22b      	bcs.n	9000d230 <pbuf_take+0x8c>
9000d1d8:	4b1a      	ldr	r3, [pc, #104]	; (9000d244 <pbuf_take+0xa0>)
9000d1da:	f240 42b5 	movw	r2, #1205	; 0x4b5
9000d1de:	491d      	ldr	r1, [pc, #116]	; (9000d254 <pbuf_take+0xb0>)
9000d1e0:	481a      	ldr	r0, [pc, #104]	; (9000d24c <pbuf_take+0xa8>)
9000d1e2:	f004 fce3 	bl	90011bac <iprintf>
9000d1e6:	f04f 30ff 	mov.w	r0, #4294967295
9000d1ea:	e7ea      	b.n	9000d1c2 <pbuf_take+0x1e>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
9000d1ec:	b92d      	cbnz	r5, 9000d1fa <pbuf_take+0x56>
9000d1ee:	f240 42bd 	movw	r2, #1213	; 0x4bd
9000d1f2:	4651      	mov	r1, sl
9000d1f4:	4658      	mov	r0, fp
9000d1f6:	f004 fcd9 	bl	90011bac <iprintf>
    if (buf_copy_len > p->len) {
9000d1fa:	896f      	ldrh	r7, [r5, #10]
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
9000d1fc:	eb09 0108 	add.w	r1, r9, r8
9000d200:	6868      	ldr	r0, [r5, #4]
9000d202:	42a7      	cmp	r7, r4
9000d204:	bf28      	it	cs
9000d206:	4627      	movcs	r7, r4
9000d208:	463a      	mov	r2, r7
    total_copy_len -= buf_copy_len;
9000d20a:	1be4      	subs	r4, r4, r7
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
9000d20c:	f004 fbd8 	bl	900119c0 <memcpy>
    copied_total += buf_copy_len;
9000d210:	44b8      	add	r8, r7
  for (p = buf; total_copy_len != 0; p = p->next) {
9000d212:	682d      	ldr	r5, [r5, #0]
9000d214:	4b0b      	ldr	r3, [pc, #44]	; (9000d244 <pbuf_take+0xa0>)
9000d216:	2c00      	cmp	r4, #0
9000d218:	d1e8      	bne.n	9000d1ec <pbuf_take+0x48>
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
9000d21a:	45b0      	cmp	r8, r6
9000d21c:	d006      	beq.n	9000d22c <pbuf_take+0x88>
9000d21e:	4b09      	ldr	r3, [pc, #36]	; (9000d244 <pbuf_take+0xa0>)
9000d220:	f44f 6299 	mov.w	r2, #1224	; 0x4c8
9000d224:	490c      	ldr	r1, [pc, #48]	; (9000d258 <pbuf_take+0xb4>)
9000d226:	4809      	ldr	r0, [pc, #36]	; (9000d24c <pbuf_take+0xa8>)
9000d228:	f004 fcc0 	bl	90011bac <iprintf>
  return ERR_OK;
9000d22c:	4620      	mov	r0, r4
9000d22e:	e7c8      	b.n	9000d1c2 <pbuf_take+0x1e>
  size_t total_copy_len = len;
9000d230:	4614      	mov	r4, r2
  size_t copied_total = 0;
9000d232:	f04f 0800 	mov.w	r8, #0
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
9000d236:	4b03      	ldr	r3, [pc, #12]	; (9000d244 <pbuf_take+0xa0>)
9000d238:	f8df a020 	ldr.w	sl, [pc, #32]	; 9000d25c <pbuf_take+0xb8>
9000d23c:	f8df b00c 	ldr.w	fp, [pc, #12]	; 9000d24c <pbuf_take+0xa8>
9000d240:	e7e9      	b.n	9000d216 <pbuf_take+0x72>
9000d242:	bf00      	nop
9000d244:	90014295 	.word	0x90014295
9000d248:	9001450b 	.word	0x9001450b
9000d24c:	90012aff 	.word	0x90012aff
9000d250:	90014522 	.word	0x90014522
9000d254:	9001453d 	.word	0x9001453d
9000d258:	90014575 	.word	0x90014575
9000d25c:	9001455d 	.word	0x9001455d

9000d260 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
9000d260:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
9000d262:	460f      	mov	r7, r1
9000d264:	4614      	mov	r4, r2
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
9000d266:	4619      	mov	r1, r3
9000d268:	f10d 0206 	add.w	r2, sp, #6
9000d26c:	f7ff fc4c 	bl	9000cb08 <pbuf_skip_const>
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
9000d270:	4606      	mov	r6, r0
9000d272:	b330      	cbz	r0, 9000d2c2 <pbuf_take_at+0x62>
9000d274:	f8bd 3006 	ldrh.w	r3, [sp, #6]
9000d278:	8901      	ldrh	r1, [r0, #8]
9000d27a:	191a      	adds	r2, r3, r4
9000d27c:	4291      	cmp	r1, r2
9000d27e:	db20      	blt.n	9000d2c2 <pbuf_take_at+0x62>
    u16_t remaining_len = len;
    const u8_t *src_ptr = (const u8_t *)dataptr;
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
9000d280:	8942      	ldrh	r2, [r0, #10]
9000d282:	429a      	cmp	r2, r3
9000d284:	d806      	bhi.n	9000d294 <pbuf_take_at+0x34>
9000d286:	4b11      	ldr	r3, [pc, #68]	; (9000d2cc <pbuf_take_at+0x6c>)
9000d288:	f240 42e3 	movw	r2, #1251	; 0x4e3
9000d28c:	4910      	ldr	r1, [pc, #64]	; (9000d2d0 <pbuf_take_at+0x70>)
9000d28e:	4811      	ldr	r0, [pc, #68]	; (9000d2d4 <pbuf_take_at+0x74>)
9000d290:	f004 fc8c 	bl	90011bac <iprintf>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
9000d294:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
9000d298:	4639      	mov	r1, r7
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
9000d29a:	8975      	ldrh	r5, [r6, #10]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
9000d29c:	6870      	ldr	r0, [r6, #4]
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
9000d29e:	1aed      	subs	r5, r5, r3
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
9000d2a0:	4418      	add	r0, r3
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
9000d2a2:	42ac      	cmp	r4, r5
9000d2a4:	bfcc      	ite	gt
9000d2a6:	b2ad      	uxthgt	r5, r5
9000d2a8:	4625      	movle	r5, r4
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
9000d2aa:	462a      	mov	r2, r5
9000d2ac:	f004 fb88 	bl	900119c0 <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
9000d2b0:	1b62      	subs	r2, r4, r5
9000d2b2:	b292      	uxth	r2, r2
    src_ptr += first_copy_len;
    if (remaining_len > 0) {
9000d2b4:	b142      	cbz	r2, 9000d2c8 <pbuf_take_at+0x68>
      return pbuf_take(q->next, src_ptr, remaining_len);
9000d2b6:	1979      	adds	r1, r7, r5
9000d2b8:	6830      	ldr	r0, [r6, #0]
9000d2ba:	f7ff ff73 	bl	9000d1a4 <pbuf_take>
    }
    return ERR_OK;
  }
  return ERR_MEM;
}
9000d2be:	b003      	add	sp, #12
9000d2c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ERR_MEM;
9000d2c2:	f04f 30ff 	mov.w	r0, #4294967295
9000d2c6:	e7fa      	b.n	9000d2be <pbuf_take_at+0x5e>
    return ERR_OK;
9000d2c8:	4610      	mov	r0, r2
9000d2ca:	e7f8      	b.n	9000d2be <pbuf_take_at+0x5e>
9000d2cc:	90014295 	.word	0x90014295
9000d2d0:	9001458b 	.word	0x9001458b
9000d2d4:	90012aff 	.word	0x90012aff

9000d2d8 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
9000d2d8:	b538      	push	{r3, r4, r5, lr}
9000d2da:	4615      	mov	r5, r2
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
9000d2dc:	460a      	mov	r2, r1
9000d2de:	8929      	ldrh	r1, [r5, #8]
9000d2e0:	f7ff fd46 	bl	9000cd70 <pbuf_alloc>
  if (q == NULL) {
9000d2e4:	4604      	mov	r4, r0
9000d2e6:	b150      	cbz	r0, 9000d2fe <pbuf_clone+0x26>
    return NULL;
  }
  err = pbuf_copy(q, p);
9000d2e8:	4629      	mov	r1, r5
9000d2ea:	f7ff fe93 	bl	9000d014 <pbuf_copy>
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
9000d2ee:	b130      	cbz	r0, 9000d2fe <pbuf_clone+0x26>
9000d2f0:	4b04      	ldr	r3, [pc, #16]	; (9000d304 <pbuf_clone+0x2c>)
9000d2f2:	f240 5224 	movw	r2, #1316	; 0x524
9000d2f6:	4904      	ldr	r1, [pc, #16]	; (9000d308 <pbuf_clone+0x30>)
9000d2f8:	4804      	ldr	r0, [pc, #16]	; (9000d30c <pbuf_clone+0x34>)
9000d2fa:	f004 fc57 	bl	90011bac <iprintf>
  return q;
}
9000d2fe:	4620      	mov	r0, r4
9000d300:	bd38      	pop	{r3, r4, r5, pc}
9000d302:	bf00      	nop
9000d304:	90014295 	.word	0x90014295
9000d308:	900145a2 	.word	0x900145a2
9000d30c:	90012aff 	.word	0x90012aff

9000d310 <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
9000d310:	b507      	push	{r0, r1, r2, lr}
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
9000d312:	f10d 0206 	add.w	r2, sp, #6
9000d316:	f7ff fbf7 	bl	9000cb08 <pbuf_skip_const>

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
9000d31a:	b148      	cbz	r0, 9000d330 <pbuf_try_get_at+0x20>
9000d31c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
9000d320:	8942      	ldrh	r2, [r0, #10]
9000d322:	429a      	cmp	r2, r3
9000d324:	d904      	bls.n	9000d330 <pbuf_try_get_at+0x20>
    return ((u8_t *)q->payload)[q_idx];
9000d326:	6842      	ldr	r2, [r0, #4]
9000d328:	5cd0      	ldrb	r0, [r2, r3]
  }
  return -1;
}
9000d32a:	b003      	add	sp, #12
9000d32c:	f85d fb04 	ldr.w	pc, [sp], #4
  return -1;
9000d330:	f04f 30ff 	mov.w	r0, #4294967295
9000d334:	e7f9      	b.n	9000d32a <pbuf_try_get_at+0x1a>

9000d336 <pbuf_get_at>:
{
9000d336:	b508      	push	{r3, lr}
  int ret = pbuf_try_get_at(p, offset);
9000d338:	f7ff ffea 	bl	9000d310 <pbuf_try_get_at>
}
9000d33c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
9000d340:	b2c0      	uxtb	r0, r0
9000d342:	bd08      	pop	{r3, pc}

9000d344 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
9000d344:	b513      	push	{r0, r1, r4, lr}
9000d346:	4614      	mov	r4, r2
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
9000d348:	f10d 0206 	add.w	r2, sp, #6
9000d34c:	f7ff fbdc 	bl	9000cb08 <pbuf_skip_const>
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
9000d350:	b130      	cbz	r0, 9000d360 <pbuf_put_at+0x1c>
9000d352:	8942      	ldrh	r2, [r0, #10]
9000d354:	f8bd 3006 	ldrh.w	r3, [sp, #6]
9000d358:	429a      	cmp	r2, r3
    ((u8_t *)q->payload)[q_idx] = data;
9000d35a:	bf84      	itt	hi
9000d35c:	6842      	ldrhi	r2, [r0, #4]
9000d35e:	54d4      	strbhi	r4, [r2, r3]
  }
}
9000d360:	b002      	add	sp, #8
9000d362:	bd10      	pop	{r4, pc}

9000d364 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
{
9000d364:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9000d368:	460e      	mov	r6, r1
9000d36a:	4699      	mov	r9, r3
  u16_t start = offset;
  const struct pbuf *q = p;
  u16_t i;

  /* pbuf long enough to perform check? */
  if (p->tot_len < (offset + n)) {
9000d36c:	8901      	ldrh	r1, [r0, #8]
{
9000d36e:	4605      	mov	r5, r0
  if (p->tot_len < (offset + n)) {
9000d370:	18f3      	adds	r3, r6, r3
9000d372:	4299      	cmp	r1, r3
9000d374:	da06      	bge.n	9000d384 <pbuf_memcmp+0x20>
    return 0xffff;
9000d376:	f64f 70ff 	movw	r0, #65535	; 0xffff
9000d37a:	e01f      	b.n	9000d3bc <pbuf_memcmp+0x58>
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start = (u16_t)(start - q->len);
9000d37c:	1a76      	subs	r6, r6, r1
    q = q->next;
9000d37e:	682d      	ldr	r5, [r5, #0]
    start = (u16_t)(start - q->len);
9000d380:	b2b6      	uxth	r6, r6
  while ((q != NULL) && (q->len <= start)) {
9000d382:	b115      	cbz	r5, 9000d38a <pbuf_memcmp+0x26>
9000d384:	8969      	ldrh	r1, [r5, #10]
9000d386:	42b1      	cmp	r1, r6
9000d388:	d9f8      	bls.n	9000d37c <pbuf_memcmp+0x18>
{
9000d38a:	2700      	movs	r7, #0

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
    u8_t b = ((const u8_t *)s2)[i];
9000d38c:	f102 38ff 	add.w	r8, r2, #4294967295
  for (i = 0; i < n; i++) {
9000d390:	45b9      	cmp	r9, r7
9000d392:	b2bc      	uxth	r4, r7
9000d394:	d101      	bne.n	9000d39a <pbuf_memcmp+0x36>
    if (a != b) {
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
    }
  }
  return 0;
9000d396:	2000      	movs	r0, #0
9000d398:	e010      	b.n	9000d3bc <pbuf_memcmp+0x58>
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
9000d39a:	1931      	adds	r1, r6, r4
    if (a != b) {
9000d39c:	3701      	adds	r7, #1
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
9000d39e:	4628      	mov	r0, r5
9000d3a0:	b289      	uxth	r1, r1
9000d3a2:	f7ff ffc8 	bl	9000d336 <pbuf_get_at>
    if (a != b) {
9000d3a6:	f818 3007 	ldrb.w	r3, [r8, r7]
9000d3aa:	4283      	cmp	r3, r0
9000d3ac:	d0f0      	beq.n	9000d390 <pbuf_memcmp+0x2c>
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
9000d3ae:	f64f 70fe 	movw	r0, #65534	; 0xfffe
9000d3b2:	4284      	cmp	r4, r0
9000d3b4:	bf28      	it	cs
9000d3b6:	4604      	movcs	r4, r0
9000d3b8:	1c60      	adds	r0, r4, #1
9000d3ba:	b280      	uxth	r0, r0
}
9000d3bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

9000d3c0 <sys_mbox_new>:
#endif

/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
9000d3c0:	b510      	push	{r4, lr}
9000d3c2:	4604      	mov	r4, r0
#if (osCMSIS < 0x20000U)
  osMessageQDef(QUEUE, size, void *);
  *mbox = osMessageCreate(osMessageQ(QUEUE), NULL);
#else
  *mbox = osMessageQueueNew(size, sizeof(void *), NULL);
9000d3c4:	2200      	movs	r2, #0
{
9000d3c6:	4608      	mov	r0, r1
  *mbox = osMessageQueueNew(size, sizeof(void *), NULL);
9000d3c8:	2104      	movs	r1, #4
9000d3ca:	f7f9 fe8b 	bl	900070e4 <osMessageQueueNew>
9000d3ce:	6020      	str	r0, [r4, #0]
  if(lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used)
  {
    lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
  }
#endif /* SYS_STATS */
  if(*mbox == NULL)
9000d3d0:	fab0 f080 	clz	r0, r0
9000d3d4:	0940      	lsrs	r0, r0, #5
    return ERR_MEM;

  return ERR_OK;
}
9000d3d6:	4240      	negs	r0, r0
9000d3d8:	bd10      	pop	{r4, pc}

9000d3da <sys_mbox_trypost>:
{
  err_t result;
#if (osCMSIS < 0x20000U)
  if(osMessagePut(*mbox, (uint32_t)msg, 0) == osOK)
#else
  if(osMessageQueuePut(*mbox, &msg, 0, 0) == osOK)
9000d3da:	2300      	movs	r3, #0
{
9000d3dc:	b507      	push	{r0, r1, r2, lr}
  if(osMessageQueuePut(*mbox, &msg, 0, 0) == osOK)
9000d3de:	461a      	mov	r2, r3
{
9000d3e0:	9101      	str	r1, [sp, #4]
  if(osMessageQueuePut(*mbox, &msg, 0, 0) == osOK)
9000d3e2:	6800      	ldr	r0, [r0, #0]
9000d3e4:	a901      	add	r1, sp, #4
9000d3e6:	f7f9 feb8 	bl	9000715a <osMessageQueuePut>
9000d3ea:	3800      	subs	r0, #0
9000d3ec:	bf18      	it	ne
9000d3ee:	2001      	movne	r0, #1
    lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */
  }

  return result;
}
9000d3f0:	4240      	negs	r0, r0
9000d3f2:	b003      	add	sp, #12
9000d3f4:	f85d fb04 	ldr.w	pc, [sp], #4

9000d3f8 <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
9000d3f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
9000d3fa:	4605      	mov	r5, r0
9000d3fc:	e9cd 2100 	strd	r2, r1, [sp]
#if (osCMSIS < 0x20000U)
  osEvent event;
  uint32_t starttime = osKernelSysTick();
#else
  osStatus_t status;
  uint32_t starttime = osKernelGetTickCount();
9000d400:	f7f9 fd02 	bl	90006e08 <osKernelGetTickCount>
9000d404:	4604      	mov	r4, r0
#endif
  if(timeout != 0)
9000d406:	e9dd 2100 	ldrd	r2, r1, [sp]
9000d40a:	b152      	cbz	r2, 9000d422 <sys_arch_mbox_fetch+0x2a>
    {
      *msg = (void *)event.value.v;
      return (osKernelSysTick() - starttime);
    }
#else
    status = osMessageQueueGet(*mbox, msg, 0, timeout);
9000d40c:	4613      	mov	r3, r2
9000d40e:	6828      	ldr	r0, [r5, #0]
9000d410:	2200      	movs	r2, #0
9000d412:	f7f9 fed2 	bl	900071ba <osMessageQueueGet>
    if (status == osOK)
9000d416:	b950      	cbnz	r0, 9000d42e <sys_arch_mbox_fetch+0x36>
    event = osMessageGet (*mbox, osWaitForever);
    *msg = (void *)event.value.v;
    return (osKernelSysTick() - starttime);
#else
    osMessageQueueGet(*mbox, msg, 0, osWaitForever );
    return (osKernelGetTickCount() - starttime);
9000d418:	f7f9 fcf6 	bl	90006e08 <osKernelGetTickCount>
9000d41c:	1b00      	subs	r0, r0, r4
#endif
  }
}
9000d41e:	b003      	add	sp, #12
9000d420:	bd30      	pop	{r4, r5, pc}
    osMessageQueueGet(*mbox, msg, 0, osWaitForever );
9000d422:	f04f 33ff 	mov.w	r3, #4294967295
9000d426:	6828      	ldr	r0, [r5, #0]
9000d428:	f7f9 fec7 	bl	900071ba <osMessageQueueGet>
9000d42c:	e7f4      	b.n	9000d418 <sys_arch_mbox_fetch+0x20>
      return SYS_ARCH_TIMEOUT;
9000d42e:	f04f 30ff 	mov.w	r0, #4294967295
9000d432:	e7f4      	b.n	9000d41e <sys_arch_mbox_fetch+0x26>

9000d434 <sys_mbox_valid>:
9000d434:	6800      	ldr	r0, [r0, #0]
9000d436:	3800      	subs	r0, #0
9000d438:	bf18      	it	ne
9000d43a:	2001      	movne	r0, #1
9000d43c:	4770      	bx	lr
	...

9000d440 <sys_init>:
#else
osMutexId_t lwip_sys_mutex;
#endif
// Initialize sys arch
void sys_init(void)
{
9000d440:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  lwip_sys_mutex = osMutexCreate(osMutex(lwip_sys_mutex));
#else
  lwip_sys_mutex = osMutexNew(NULL);
9000d442:	2000      	movs	r0, #0
9000d444:	f7f9 fd3c 	bl	90006ec0 <osMutexNew>
9000d448:	4b01      	ldr	r3, [pc, #4]	; (9000d450 <sys_init+0x10>)
9000d44a:	6018      	str	r0, [r3, #0]
#endif
}
9000d44c:	bd08      	pop	{r3, pc}
9000d44e:	bf00      	nop
9000d450:	2400d3ac 	.word	0x2400d3ac

9000d454 <sys_mutex_new>:
                                      /* Mutexes*/
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
#if LWIP_COMPAT_MUTEX == 0
/* Create a new mutex*/
err_t sys_mutex_new(sys_mutex_t *mutex) {
9000d454:	b510      	push	{r4, lr}
9000d456:	4604      	mov	r4, r0

#if (osCMSIS < 0x20000U)
  osMutexDef(MUTEX);
  *mutex = osMutexCreate(osMutex(MUTEX));
#else
  *mutex = osMutexNew(NULL);
9000d458:	2000      	movs	r0, #0
9000d45a:	f7f9 fd31 	bl	90006ec0 <osMutexNew>
9000d45e:	6020      	str	r0, [r4, #0]
#endif

  if(*mutex == NULL)
9000d460:	fab0 f080 	clz	r0, r0
9000d464:	0940      	lsrs	r0, r0, #5
  if (lwip_stats.sys.mutex.max < lwip_stats.sys.mutex.used) {
    lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
  }
#endif /* SYS_STATS */
  return ERR_OK;
}
9000d466:	4240      	negs	r0, r0
9000d468:	bd10      	pop	{r4, pc}

9000d46a <sys_mutex_lock>:
void sys_mutex_lock(sys_mutex_t *mutex)
{
#if (osCMSIS < 0x20000U)
  osMutexWait(*mutex, osWaitForever);
#else
  osMutexAcquire(*mutex, osWaitForever);
9000d46a:	f04f 31ff 	mov.w	r1, #4294967295
9000d46e:	6800      	ldr	r0, [r0, #0]
9000d470:	f7f9 bd5b 	b.w	90006f2a <osMutexAcquire>

9000d474 <sys_mutex_unlock>:

/*-----------------------------------------------------------------------------------*/
/* Unlock a mutex*/
void sys_mutex_unlock(sys_mutex_t *mutex)
{
  osMutexRelease(*mutex);
9000d474:	6800      	ldr	r0, [r0, #0]
9000d476:	f7f9 bd7a 	b.w	90006f6e <osMutexRelease>

9000d47a <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread , void *arg, int stacksize, int prio)
{
9000d47a:	b5f0      	push	{r4, r5, r6, r7, lr}
9000d47c:	b08b      	sub	sp, #44	; 0x2c
9000d47e:	4615      	mov	r5, r2
9000d480:	4607      	mov	r7, r0
9000d482:	460c      	mov	r4, r1
#if (osCMSIS < 0x20000U)
  const osThreadDef_t os_thread_def = { (char *)name, (os_pthread)thread, (osPriority)prio, 0, stacksize};
  return osThreadCreate(&os_thread_def, arg);
#else
  const osThreadAttr_t attributes = {
9000d484:	2220      	movs	r2, #32
9000d486:	2100      	movs	r1, #0
9000d488:	a802      	add	r0, sp, #8
{
9000d48a:	461e      	mov	r6, r3
  const osThreadAttr_t attributes = {
9000d48c:	f004 faa6 	bl	900119dc <memset>
9000d490:	9b10      	ldr	r3, [sp, #64]	; 0x40
                        .name = name,
                        .stack_size = stacksize,
                        .priority = (osPriority_t)prio,
                      };
  return osThreadNew(thread, arg, &attributes);
9000d492:	aa01      	add	r2, sp, #4
9000d494:	4629      	mov	r1, r5
9000d496:	4620      	mov	r0, r4
  const osThreadAttr_t attributes = {
9000d498:	9701      	str	r7, [sp, #4]
9000d49a:	9606      	str	r6, [sp, #24]
9000d49c:	9307      	str	r3, [sp, #28]
  return osThreadNew(thread, arg, &attributes);
9000d49e:	f7f9 fcba 	bl	90006e16 <osThreadNew>
#endif
}
9000d4a2:	b00b      	add	sp, #44	; 0x2c
9000d4a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

9000d4a8 <sys_arch_protect>:

  Note: This function is based on FreeRTOS API, because no equivalent CMSIS-RTOS
        API is available
*/
sys_prot_t sys_arch_protect(void)
{
9000d4a8:	b508      	push	{r3, lr}
#if (osCMSIS < 0x20000U)
  osMutexWait(lwip_sys_mutex, osWaitForever);
#else
  osMutexAcquire(lwip_sys_mutex, osWaitForever);
9000d4aa:	4b04      	ldr	r3, [pc, #16]	; (9000d4bc <sys_arch_protect+0x14>)
9000d4ac:	f04f 31ff 	mov.w	r1, #4294967295
9000d4b0:	6818      	ldr	r0, [r3, #0]
9000d4b2:	f7f9 fd3a 	bl	90006f2a <osMutexAcquire>
#endif
  return (sys_prot_t)1;
}
9000d4b6:	2001      	movs	r0, #1
9000d4b8:	bd08      	pop	{r3, pc}
9000d4ba:	bf00      	nop
9000d4bc:	2400d3ac 	.word	0x2400d3ac

9000d4c0 <sys_arch_unprotect>:
        API is available
*/
void sys_arch_unprotect(sys_prot_t pval)
{
  ( void ) pval;
  osMutexRelease(lwip_sys_mutex);
9000d4c0:	4b01      	ldr	r3, [pc, #4]	; (9000d4c8 <sys_arch_unprotect+0x8>)
9000d4c2:	6818      	ldr	r0, [r3, #0]
9000d4c4:	f7f9 bd53 	b.w	90006f6e <osMutexRelease>
9000d4c8:	2400d3ac 	.word	0x2400d3ac

9000d4cc <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
9000d4cc:	b5f0      	push	{r4, r5, r6, r7, lr}
9000d4ce:	4c12      	ldr	r4, [pc, #72]	; (9000d518 <tcp_new_port+0x4c>)
9000d4d0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  u16_t n = 0;
  struct tcp_pcb *pcb;

again:
  tcp_port++;
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
9000d4d4:	f64f 76ff 	movw	r6, #65535	; 0xffff
9000d4d8:	8823      	ldrh	r3, [r4, #0]
  tcp_port++;
9000d4da:	3301      	adds	r3, #1
9000d4dc:	4d0f      	ldr	r5, [pc, #60]	; (9000d51c <tcp_new_port+0x50>)
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
9000d4de:	2204      	movs	r2, #4
  tcp_port++;
9000d4e0:	b29b      	uxth	r3, r3
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
9000d4e2:	42b3      	cmp	r3, r6
9000d4e4:	bf08      	it	eq
9000d4e6:	f44f 4340 	moveq.w	r3, #49152	; 0xc000
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
9000d4ea:	f855 1b04 	ldr.w	r1, [r5], #4
9000d4ee:	6809      	ldr	r1, [r1, #0]
9000d4f0:	b931      	cbnz	r1, 9000d500 <tcp_new_port+0x34>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
9000d4f2:	3a01      	subs	r2, #1
9000d4f4:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
9000d4f8:	d1f7      	bne.n	9000d4ea <tcp_new_port+0x1e>
        }
        goto again;
      }
    }
  }
  return tcp_port;
9000d4fa:	4618      	mov	r0, r3
9000d4fc:	8023      	strh	r3, [r4, #0]
9000d4fe:	e007      	b.n	9000d510 <tcp_new_port+0x44>
      if (pcb->local_port == tcp_port) {
9000d500:	8acf      	ldrh	r7, [r1, #22]
9000d502:	429f      	cmp	r7, r3
9000d504:	d105      	bne.n	9000d512 <tcp_new_port+0x46>
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
9000d506:	3801      	subs	r0, #1
9000d508:	b280      	uxth	r0, r0
9000d50a:	2800      	cmp	r0, #0
9000d50c:	d1e5      	bne.n	9000d4da <tcp_new_port+0xe>
9000d50e:	8023      	strh	r3, [r4, #0]
}
9000d510:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
9000d512:	68c9      	ldr	r1, [r1, #12]
9000d514:	e7ec      	b.n	9000d4f0 <tcp_new_port+0x24>
9000d516:	bf00      	nop
9000d518:	24000034 	.word	0x24000034
9000d51c:	90014c38 	.word	0x90014c38

9000d520 <tcp_close_shutdown_fin>:
{
9000d520:	b510      	push	{r4, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
9000d522:	4604      	mov	r4, r0
9000d524:	b930      	cbnz	r0, 9000d534 <tcp_close_shutdown_fin+0x14>
9000d526:	4b13      	ldr	r3, [pc, #76]	; (9000d574 <tcp_close_shutdown_fin+0x54>)
9000d528:	f44f 72ce 	mov.w	r2, #412	; 0x19c
9000d52c:	4912      	ldr	r1, [pc, #72]	; (9000d578 <tcp_close_shutdown_fin+0x58>)
9000d52e:	4813      	ldr	r0, [pc, #76]	; (9000d57c <tcp_close_shutdown_fin+0x5c>)
9000d530:	f004 fb3c 	bl	90011bac <iprintf>
  switch (pcb->state) {
9000d534:	7d23      	ldrb	r3, [r4, #20]
9000d536:	2b04      	cmp	r3, #4
9000d538:	d003      	beq.n	9000d542 <tcp_close_shutdown_fin+0x22>
9000d53a:	2b07      	cmp	r3, #7
9000d53c:	d00c      	beq.n	9000d558 <tcp_close_shutdown_fin+0x38>
9000d53e:	2b03      	cmp	r3, #3
9000d540:	d108      	bne.n	9000d554 <tcp_close_shutdown_fin+0x34>
      err = tcp_send_fin(pcb);
9000d542:	4620      	mov	r0, r4
9000d544:	f003 f94a 	bl	900107dc <tcp_send_fin>
      if (err == ERR_OK) {
9000d548:	b960      	cbnz	r0, 9000d564 <tcp_close_shutdown_fin+0x44>
        pcb->state = FIN_WAIT_1;
9000d54a:	2305      	movs	r3, #5
    tcp_output(pcb);
9000d54c:	4620      	mov	r0, r4
        pcb->state = LAST_ACK;
9000d54e:	7523      	strb	r3, [r4, #20]
    tcp_output(pcb);
9000d550:	f003 faa4 	bl	90010a9c <tcp_output>
  switch (pcb->state) {
9000d554:	2000      	movs	r0, #0
}
9000d556:	bd10      	pop	{r4, pc}
      err = tcp_send_fin(pcb);
9000d558:	4620      	mov	r0, r4
9000d55a:	f003 f93f 	bl	900107dc <tcp_send_fin>
      if (err == ERR_OK) {
9000d55e:	b908      	cbnz	r0, 9000d564 <tcp_close_shutdown_fin+0x44>
        pcb->state = LAST_ACK;
9000d560:	2309      	movs	r3, #9
9000d562:	e7f3      	b.n	9000d54c <tcp_close_shutdown_fin+0x2c>
  } else if (err == ERR_MEM) {
9000d564:	1c43      	adds	r3, r0, #1
9000d566:	d1f6      	bne.n	9000d556 <tcp_close_shutdown_fin+0x36>
    tcp_set_flags(pcb, TF_CLOSEPEND);
9000d568:	8b63      	ldrh	r3, [r4, #26]
9000d56a:	f043 0308 	orr.w	r3, r3, #8
9000d56e:	8363      	strh	r3, [r4, #26]
    return ERR_OK;
9000d570:	e7f0      	b.n	9000d554 <tcp_close_shutdown_fin+0x34>
9000d572:	bf00      	nop
9000d574:	900145b3 	.word	0x900145b3
9000d578:	900145e9 	.word	0x900145e9
9000d57c:	90012aff 	.word	0x90012aff

9000d580 <tcp_init>:
{
9000d580:	b508      	push	{r3, lr}
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
9000d582:	f004 fb2b 	bl	90011bdc <rand>
9000d586:	ea6f 4080 	mvn.w	r0, r0, lsl #18
9000d58a:	4b02      	ldr	r3, [pc, #8]	; (9000d594 <tcp_init+0x14>)
9000d58c:	ea6f 4090 	mvn.w	r0, r0, lsr #18
9000d590:	8018      	strh	r0, [r3, #0]
}
9000d592:	bd08      	pop	{r3, pc}
9000d594:	24000034 	.word	0x24000034

9000d598 <tcp_free>:
{
9000d598:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
9000d59a:	7d03      	ldrb	r3, [r0, #20]
{
9000d59c:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
9000d59e:	2b01      	cmp	r3, #1
9000d5a0:	d105      	bne.n	9000d5ae <tcp_free+0x16>
9000d5a2:	4b06      	ldr	r3, [pc, #24]	; (9000d5bc <tcp_free+0x24>)
9000d5a4:	22d4      	movs	r2, #212	; 0xd4
9000d5a6:	4906      	ldr	r1, [pc, #24]	; (9000d5c0 <tcp_free+0x28>)
9000d5a8:	4806      	ldr	r0, [pc, #24]	; (9000d5c4 <tcp_free+0x2c>)
9000d5aa:	f004 faff 	bl	90011bac <iprintf>
  memp_free(MEMP_TCP_PCB, pcb);
9000d5ae:	4621      	mov	r1, r4
9000d5b0:	2001      	movs	r0, #1
}
9000d5b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  memp_free(MEMP_TCP_PCB, pcb);
9000d5b6:	f7fe bf59 	b.w	9000c46c <memp_free>
9000d5ba:	bf00      	nop
9000d5bc:	900145b3 	.word	0x900145b3
9000d5c0:	900145f5 	.word	0x900145f5
9000d5c4:	90012aff 	.word	0x90012aff

9000d5c8 <tcp_bind>:
{
9000d5c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ipaddr = IP4_ADDR_ANY;
9000d5ca:	4d23      	ldr	r5, [pc, #140]	; (9000d658 <tcp_bind+0x90>)
  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
9000d5cc:	4604      	mov	r4, r0
    ipaddr = IP4_ADDR_ANY;
9000d5ce:	2900      	cmp	r1, #0
9000d5d0:	bf18      	it	ne
9000d5d2:	460d      	movne	r5, r1
  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
9000d5d4:	b948      	cbnz	r0, 9000d5ea <tcp_bind+0x22>
9000d5d6:	4b21      	ldr	r3, [pc, #132]	; (9000d65c <tcp_bind+0x94>)
9000d5d8:	f240 22a9 	movw	r2, #681	; 0x2a9
9000d5dc:	4920      	ldr	r1, [pc, #128]	; (9000d660 <tcp_bind+0x98>)
9000d5de:	4821      	ldr	r0, [pc, #132]	; (9000d664 <tcp_bind+0x9c>)
9000d5e0:	f004 fae4 	bl	90011bac <iprintf>
9000d5e4:	f06f 000f 	mvn.w	r0, #15
}
9000d5e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
9000d5ea:	7d03      	ldrb	r3, [r0, #20]
9000d5ec:	b14b      	cbz	r3, 9000d602 <tcp_bind+0x3a>
9000d5ee:	4b1b      	ldr	r3, [pc, #108]	; (9000d65c <tcp_bind+0x94>)
9000d5f0:	f240 22ab 	movw	r2, #683	; 0x2ab
9000d5f4:	491c      	ldr	r1, [pc, #112]	; (9000d668 <tcp_bind+0xa0>)
9000d5f6:	481b      	ldr	r0, [pc, #108]	; (9000d664 <tcp_bind+0x9c>)
9000d5f8:	f004 fad8 	bl	90011bac <iprintf>
9000d5fc:	f06f 0005 	mvn.w	r0, #5
9000d600:	e7f2      	b.n	9000d5e8 <tcp_bind+0x20>
  if (port == 0) {
9000d602:	b932      	cbnz	r2, 9000d612 <tcp_bind+0x4a>
    port = tcp_new_port();
9000d604:	f7ff ff62 	bl	9000d4cc <tcp_new_port>
    if (port == 0) {
9000d608:	4602      	mov	r2, r0
9000d60a:	b950      	cbnz	r0, 9000d622 <tcp_bind+0x5a>
      return ERR_BUF;
9000d60c:	f06f 0001 	mvn.w	r0, #1
9000d610:	e7ea      	b.n	9000d5e8 <tcp_bind+0x20>
9000d612:	4816      	ldr	r0, [pc, #88]	; (9000d66c <tcp_bind+0xa4>)
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
9000d614:	f850 1b04 	ldr.w	r1, [r0], #4
9000d618:	6809      	ldr	r1, [r1, #0]
9000d61a:	b971      	cbnz	r1, 9000d63a <tcp_bind+0x72>
    for (i = 0; i < max_pcb_list; i++) {
9000d61c:	3301      	adds	r3, #1
9000d61e:	2b04      	cmp	r3, #4
9000d620:	d1f8      	bne.n	9000d614 <tcp_bind+0x4c>
  if (!ip_addr_isany(ipaddr)
9000d622:	682b      	ldr	r3, [r5, #0]
9000d624:	b103      	cbz	r3, 9000d628 <tcp_bind+0x60>
    ip_addr_set(&pcb->local_ip, ipaddr);
9000d626:	6023      	str	r3, [r4, #0]
  TCP_REG(&tcp_bound_pcbs, pcb);
9000d628:	4b11      	ldr	r3, [pc, #68]	; (9000d670 <tcp_bind+0xa8>)
  pcb->local_port = port;
9000d62a:	82e2      	strh	r2, [r4, #22]
  TCP_REG(&tcp_bound_pcbs, pcb);
9000d62c:	681a      	ldr	r2, [r3, #0]
9000d62e:	601c      	str	r4, [r3, #0]
9000d630:	60e2      	str	r2, [r4, #12]
9000d632:	f003 fe17 	bl	90011264 <tcp_timer_needed>
  return ERR_OK;
9000d636:	2000      	movs	r0, #0
9000d638:	e7d6      	b.n	9000d5e8 <tcp_bind+0x20>
        if (cpcb->local_port == port) {
9000d63a:	8ace      	ldrh	r6, [r1, #22]
9000d63c:	4296      	cmp	r6, r2
9000d63e:	d105      	bne.n	9000d64c <tcp_bind+0x84>
                (ip_addr_isany(&cpcb->local_ip) ||
9000d640:	680f      	ldr	r7, [r1, #0]
9000d642:	b12f      	cbz	r7, 9000d650 <tcp_bind+0x88>
                 ip_addr_isany(ipaddr) ||
9000d644:	682e      	ldr	r6, [r5, #0]
9000d646:	b11e      	cbz	r6, 9000d650 <tcp_bind+0x88>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
9000d648:	42b7      	cmp	r7, r6
9000d64a:	d001      	beq.n	9000d650 <tcp_bind+0x88>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
9000d64c:	68c9      	ldr	r1, [r1, #12]
9000d64e:	e7e4      	b.n	9000d61a <tcp_bind+0x52>
              return ERR_USE;
9000d650:	f06f 0007 	mvn.w	r0, #7
9000d654:	e7c8      	b.n	9000d5e8 <tcp_bind+0x20>
9000d656:	bf00      	nop
9000d658:	90013a68 	.word	0x90013a68
9000d65c:	900145b3 	.word	0x900145b3
9000d660:	90014606 	.word	0x90014606
9000d664:	90012aff 	.word	0x90012aff
9000d668:	9001461c 	.word	0x9001461c
9000d66c:	90014c38 	.word	0x90014c38
9000d670:	2400d3b8 	.word	0x2400d3b8

9000d674 <tcp_listen_with_backlog_and_err>:
{
9000d674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000d676:	4616      	mov	r6, r2
  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
9000d678:	4605      	mov	r5, r0
9000d67a:	b968      	cbnz	r0, 9000d698 <tcp_listen_with_backlog_and_err+0x24>
9000d67c:	4b29      	ldr	r3, [pc, #164]	; (9000d724 <tcp_listen_with_backlog_and_err+0xb0>)
9000d67e:	f240 3259 	movw	r2, #857	; 0x359
9000d682:	4929      	ldr	r1, [pc, #164]	; (9000d728 <tcp_listen_with_backlog_and_err+0xb4>)
  struct tcp_pcb_listen *lpcb = NULL;
9000d684:	462c      	mov	r4, r5
  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
9000d686:	4829      	ldr	r0, [pc, #164]	; (9000d72c <tcp_listen_with_backlog_and_err+0xb8>)
9000d688:	f004 fa90 	bl	90011bac <iprintf>
9000d68c:	f06f 030f 	mvn.w	r3, #15
  if (err != NULL) {
9000d690:	b106      	cbz	r6, 9000d694 <tcp_listen_with_backlog_and_err+0x20>
    *err = res;
9000d692:	7033      	strb	r3, [r6, #0]
}
9000d694:	4620      	mov	r0, r4
9000d696:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
9000d698:	7d07      	ldrb	r7, [r0, #20]
9000d69a:	b157      	cbz	r7, 9000d6b2 <tcp_listen_with_backlog_and_err+0x3e>
9000d69c:	4b21      	ldr	r3, [pc, #132]	; (9000d724 <tcp_listen_with_backlog_and_err+0xb0>)
9000d69e:	f240 325a 	movw	r2, #858	; 0x35a
9000d6a2:	4923      	ldr	r1, [pc, #140]	; (9000d730 <tcp_listen_with_backlog_and_err+0xbc>)
  struct tcp_pcb_listen *lpcb = NULL;
9000d6a4:	2400      	movs	r4, #0
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
9000d6a6:	4821      	ldr	r0, [pc, #132]	; (9000d72c <tcp_listen_with_backlog_and_err+0xb8>)
9000d6a8:	f004 fa80 	bl	90011bac <iprintf>
9000d6ac:	f06f 030e 	mvn.w	r3, #14
9000d6b0:	e7ee      	b.n	9000d690 <tcp_listen_with_backlog_and_err+0x1c>
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
9000d6b2:	2002      	movs	r0, #2
9000d6b4:	f7fe feaa 	bl	9000c40c <memp_malloc>
  if (lpcb == NULL) {
9000d6b8:	4604      	mov	r4, r0
9000d6ba:	2800      	cmp	r0, #0
9000d6bc:	d02f      	beq.n	9000d71e <tcp_listen_with_backlog_and_err+0xaa>
  lpcb->callback_arg = pcb->callback_arg;
9000d6be:	692b      	ldr	r3, [r5, #16]
  lpcb->state = LISTEN;
9000d6c0:	2201      	movs	r2, #1
  lpcb->callback_arg = pcb->callback_arg;
9000d6c2:	6103      	str	r3, [r0, #16]
  lpcb->local_port = pcb->local_port;
9000d6c4:	8aeb      	ldrh	r3, [r5, #22]
  lpcb->state = LISTEN;
9000d6c6:	7502      	strb	r2, [r0, #20]
  lpcb->local_port = pcb->local_port;
9000d6c8:	82c3      	strh	r3, [r0, #22]
  lpcb->prio = pcb->prio;
9000d6ca:	7d6a      	ldrb	r2, [r5, #21]
9000d6cc:	7542      	strb	r2, [r0, #21]
  lpcb->so_options = pcb->so_options;
9000d6ce:	7a6a      	ldrb	r2, [r5, #9]
  lpcb->netif_idx = NETIF_NO_INDEX;
9000d6d0:	7207      	strb	r7, [r0, #8]
  lpcb->so_options = pcb->so_options;
9000d6d2:	7242      	strb	r2, [r0, #9]
  lpcb->ttl = pcb->ttl;
9000d6d4:	7aea      	ldrb	r2, [r5, #11]
9000d6d6:	72c2      	strb	r2, [r0, #11]
  lpcb->tos = pcb->tos;
9000d6d8:	7aaa      	ldrb	r2, [r5, #10]
9000d6da:	7282      	strb	r2, [r0, #10]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
9000d6dc:	682a      	ldr	r2, [r5, #0]
9000d6de:	6002      	str	r2, [r0, #0]
  if (pcb->local_port != 0) {
9000d6e0:	b13b      	cbz	r3, 9000d6f2 <tcp_listen_with_backlog_and_err+0x7e>
    TCP_RMV(&tcp_bound_pcbs, pcb);
9000d6e2:	4a14      	ldr	r2, [pc, #80]	; (9000d734 <tcp_listen_with_backlog_and_err+0xc0>)
9000d6e4:	6813      	ldr	r3, [r2, #0]
9000d6e6:	42ab      	cmp	r3, r5
9000d6e8:	d111      	bne.n	9000d70e <tcp_listen_with_backlog_and_err+0x9a>
9000d6ea:	68eb      	ldr	r3, [r5, #12]
9000d6ec:	6013      	str	r3, [r2, #0]
9000d6ee:	2300      	movs	r3, #0
9000d6f0:	60eb      	str	r3, [r5, #12]
  tcp_free(pcb);
9000d6f2:	4628      	mov	r0, r5
9000d6f4:	f7ff ff50 	bl	9000d598 <tcp_free>
  lpcb->accept = tcp_accept_null;
9000d6f8:	4b0f      	ldr	r3, [pc, #60]	; (9000d738 <tcp_listen_with_backlog_and_err+0xc4>)
9000d6fa:	61a3      	str	r3, [r4, #24]
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
9000d6fc:	4b0f      	ldr	r3, [pc, #60]	; (9000d73c <tcp_listen_with_backlog_and_err+0xc8>)
9000d6fe:	681a      	ldr	r2, [r3, #0]
9000d700:	601c      	str	r4, [r3, #0]
9000d702:	60e2      	str	r2, [r4, #12]
9000d704:	f003 fdae 	bl	90011264 <tcp_timer_needed>
  res = ERR_OK;
9000d708:	2300      	movs	r3, #0
9000d70a:	e7c1      	b.n	9000d690 <tcp_listen_with_backlog_and_err+0x1c>
9000d70c:	4613      	mov	r3, r2
    TCP_RMV(&tcp_bound_pcbs, pcb);
9000d70e:	2b00      	cmp	r3, #0
9000d710:	d0ed      	beq.n	9000d6ee <tcp_listen_with_backlog_and_err+0x7a>
9000d712:	68da      	ldr	r2, [r3, #12]
9000d714:	42aa      	cmp	r2, r5
9000d716:	d1f9      	bne.n	9000d70c <tcp_listen_with_backlog_and_err+0x98>
9000d718:	68ea      	ldr	r2, [r5, #12]
9000d71a:	60da      	str	r2, [r3, #12]
9000d71c:	e7e7      	b.n	9000d6ee <tcp_listen_with_backlog_and_err+0x7a>
    res = ERR_MEM;
9000d71e:	f04f 33ff 	mov.w	r3, #4294967295
9000d722:	e7b5      	b.n	9000d690 <tcp_listen_with_backlog_and_err+0x1c>
9000d724:	900145b3 	.word	0x900145b3
9000d728:	90014644 	.word	0x90014644
9000d72c:	90012aff 	.word	0x90012aff
9000d730:	90014671 	.word	0x90014671
9000d734:	2400d3b8 	.word	0x2400d3b8
9000d738:	9000dd81 	.word	0x9000dd81
9000d73c:	2400d3bc 	.word	0x2400d3bc

9000d740 <tcp_listen_with_backlog>:
  return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
9000d740:	2200      	movs	r2, #0
9000d742:	f7ff bf97 	b.w	9000d674 <tcp_listen_with_backlog_and_err>
	...

9000d748 <tcp_update_rcv_ann_wnd>:
{
9000d748:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
9000d74a:	4604      	mov	r4, r0
9000d74c:	b930      	cbnz	r0, 9000d75c <tcp_update_rcv_ann_wnd+0x14>
9000d74e:	4b15      	ldr	r3, [pc, #84]	; (9000d7a4 <tcp_update_rcv_ann_wnd+0x5c>)
9000d750:	f240 32a6 	movw	r2, #934	; 0x3a6
9000d754:	4914      	ldr	r1, [pc, #80]	; (9000d7a8 <tcp_update_rcv_ann_wnd+0x60>)
9000d756:	4815      	ldr	r0, [pc, #84]	; (9000d7ac <tcp_update_rcv_ann_wnd+0x64>)
9000d758:	f004 fa28 	bl	90011bac <iprintf>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
9000d75c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
9000d75e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
9000d760:	8e66      	ldrh	r6, [r4, #50]	; 0x32
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
9000d762:	6a65      	ldr	r5, [r4, #36]	; 0x24
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
9000d764:	1ad0      	subs	r0, r2, r3
9000d766:	f5b6 6f86 	cmp.w	r6, #1072	; 0x430
9000d76a:	4428      	add	r0, r5
9000d76c:	bf94      	ite	ls
9000d76e:	1b81      	subls	r1, r0, r6
9000d770:	f5a0 6186 	subhi.w	r1, r0, #1072	; 0x430
9000d774:	2900      	cmp	r1, #0
9000d776:	db01      	blt.n	9000d77c <tcp_update_rcv_ann_wnd+0x34>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
9000d778:	8562      	strh	r2, [r4, #42]	; 0x2a
}
9000d77a:	bd70      	pop	{r4, r5, r6, pc}
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
9000d77c:	1aea      	subs	r2, r5, r3
9000d77e:	2a00      	cmp	r2, #0
9000d780:	dd02      	ble.n	9000d788 <tcp_update_rcv_ann_wnd+0x40>
      pcb->rcv_ann_wnd = 0;
9000d782:	2000      	movs	r0, #0
9000d784:	8560      	strh	r0, [r4, #42]	; 0x2a
9000d786:	e7f8      	b.n	9000d77a <tcp_update_rcv_ann_wnd+0x32>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
9000d788:	1b5d      	subs	r5, r3, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
9000d78a:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
9000d78e:	d306      	bcc.n	9000d79e <tcp_update_rcv_ann_wnd+0x56>
9000d790:	4b04      	ldr	r3, [pc, #16]	; (9000d7a4 <tcp_update_rcv_ann_wnd+0x5c>)
9000d792:	f240 32b6 	movw	r2, #950	; 0x3b6
9000d796:	4906      	ldr	r1, [pc, #24]	; (9000d7b0 <tcp_update_rcv_ann_wnd+0x68>)
9000d798:	4804      	ldr	r0, [pc, #16]	; (9000d7ac <tcp_update_rcv_ann_wnd+0x64>)
9000d79a:	f004 fa07 	bl	90011bac <iprintf>
    return 0;
9000d79e:	2000      	movs	r0, #0
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
9000d7a0:	8565      	strh	r5, [r4, #42]	; 0x2a
9000d7a2:	e7ea      	b.n	9000d77a <tcp_update_rcv_ann_wnd+0x32>
9000d7a4:	900145b3 	.word	0x900145b3
9000d7a8:	900146a8 	.word	0x900146a8
9000d7ac:	90012aff 	.word	0x90012aff
9000d7b0:	900146cc 	.word	0x900146cc

9000d7b4 <tcp_recved>:
{
9000d7b4:	b570      	push	{r4, r5, r6, lr}
9000d7b6:	460c      	mov	r4, r1
  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
9000d7b8:	4605      	mov	r5, r0
9000d7ba:	b940      	cbnz	r0, 9000d7ce <tcp_recved+0x1a>
9000d7bc:	4b18      	ldr	r3, [pc, #96]	; (9000d820 <tcp_recved+0x6c>)
9000d7be:	f240 32cf 	movw	r2, #975	; 0x3cf
9000d7c2:	4918      	ldr	r1, [pc, #96]	; (9000d824 <tcp_recved+0x70>)
9000d7c4:	4818      	ldr	r0, [pc, #96]	; (9000d828 <tcp_recved+0x74>)
}
9000d7c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
9000d7ca:	f004 b9ef 	b.w	90011bac <iprintf>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
9000d7ce:	7d03      	ldrb	r3, [r0, #20]
9000d7d0:	2b01      	cmp	r3, #1
9000d7d2:	d106      	bne.n	9000d7e2 <tcp_recved+0x2e>
9000d7d4:	4b12      	ldr	r3, [pc, #72]	; (9000d820 <tcp_recved+0x6c>)
9000d7d6:	f240 32d2 	movw	r2, #978	; 0x3d2
9000d7da:	4914      	ldr	r1, [pc, #80]	; (9000d82c <tcp_recved+0x78>)
9000d7dc:	4812      	ldr	r0, [pc, #72]	; (9000d828 <tcp_recved+0x74>)
9000d7de:	f004 f9e5 	bl	90011bac <iprintf>
  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
9000d7e2:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
9000d7e4:	1919      	adds	r1, r3, r4
9000d7e6:	b289      	uxth	r1, r1
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
9000d7e8:	f5b1 6f06 	cmp.w	r1, #2144	; 0x860
9000d7ec:	d813      	bhi.n	9000d816 <tcp_recved+0x62>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
9000d7ee:	428b      	cmp	r3, r1
9000d7f0:	bf88      	it	hi
9000d7f2:	f44f 6106 	movhi.w	r1, #2144	; 0x860
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
9000d7f6:	4628      	mov	r0, r5
9000d7f8:	8529      	strh	r1, [r5, #40]	; 0x28
9000d7fa:	f7ff ffa5 	bl	9000d748 <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
9000d7fe:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
9000d802:	d30b      	bcc.n	9000d81c <tcp_recved+0x68>
    tcp_ack_now(pcb);
9000d804:	8b6b      	ldrh	r3, [r5, #26]
    tcp_output(pcb);
9000d806:	4628      	mov	r0, r5
    tcp_ack_now(pcb);
9000d808:	f043 0302 	orr.w	r3, r3, #2
9000d80c:	836b      	strh	r3, [r5, #26]
}
9000d80e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    tcp_output(pcb);
9000d812:	f003 b943 	b.w	90010a9c <tcp_output>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
9000d816:	f44f 6106 	mov.w	r1, #2144	; 0x860
9000d81a:	e7ec      	b.n	9000d7f6 <tcp_recved+0x42>
}
9000d81c:	bd70      	pop	{r4, r5, r6, pc}
9000d81e:	bf00      	nop
9000d820:	900145b3 	.word	0x900145b3
9000d824:	900146e6 	.word	0x900146e6
9000d828:	90012aff 	.word	0x90012aff
9000d82c:	900146fe 	.word	0x900146fe

9000d830 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
9000d830:	b510      	push	{r4, lr}
  if (seg != NULL) {
9000d832:	4604      	mov	r4, r0
9000d834:	b148      	cbz	r0, 9000d84a <tcp_seg_free+0x1a>
    if (seg->p != NULL) {
9000d836:	6840      	ldr	r0, [r0, #4]
9000d838:	b108      	cbz	r0, 9000d83e <tcp_seg_free+0xe>
      pbuf_free(seg->p);
9000d83a:	f7ff fa31 	bl	9000cca0 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
9000d83e:	4621      	mov	r1, r4
9000d840:	2003      	movs	r0, #3
  }
}
9000d842:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memp_free(MEMP_TCP_SEG, seg);
9000d846:	f7fe be11 	b.w	9000c46c <memp_free>
}
9000d84a:	bd10      	pop	{r4, pc}

9000d84c <tcp_segs_free>:
{
9000d84c:	b510      	push	{r4, lr}
  while (seg != NULL) {
9000d84e:	b900      	cbnz	r0, 9000d852 <tcp_segs_free+0x6>
}
9000d850:	bd10      	pop	{r4, pc}
    struct tcp_seg *next = seg->next;
9000d852:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
9000d854:	f7ff ffec 	bl	9000d830 <tcp_seg_free>
    seg = next;
9000d858:	4620      	mov	r0, r4
9000d85a:	e7f8      	b.n	9000d84e <tcp_segs_free+0x2>

9000d85c <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
9000d85c:	b538      	push	{r3, r4, r5, lr}
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
9000d85e:	4604      	mov	r4, r0
9000d860:	b930      	cbnz	r0, 9000d870 <tcp_seg_copy+0x14>
9000d862:	4b0d      	ldr	r3, [pc, #52]	; (9000d898 <tcp_seg_copy+0x3c>)
9000d864:	f240 6282 	movw	r2, #1666	; 0x682
9000d868:	490c      	ldr	r1, [pc, #48]	; (9000d89c <tcp_seg_copy+0x40>)
9000d86a:	480d      	ldr	r0, [pc, #52]	; (9000d8a0 <tcp_seg_copy+0x44>)
9000d86c:	f004 f99e 	bl	90011bac <iprintf>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
9000d870:	2003      	movs	r0, #3
9000d872:	f7fe fdcb 	bl	9000c40c <memp_malloc>
  if (cseg == NULL) {
9000d876:	4605      	mov	r5, r0
9000d878:	b160      	cbz	r0, 9000d894 <tcp_seg_copy+0x38>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
9000d87a:	4623      	mov	r3, r4
9000d87c:	4602      	mov	r2, r0
9000d87e:	f104 0110 	add.w	r1, r4, #16
9000d882:	f853 0b04 	ldr.w	r0, [r3], #4
9000d886:	428b      	cmp	r3, r1
9000d888:	f842 0b04 	str.w	r0, [r2], #4
9000d88c:	d1f9      	bne.n	9000d882 <tcp_seg_copy+0x26>
  pbuf_ref(cseg->p);
9000d88e:	6868      	ldr	r0, [r5, #4]
9000d890:	f7ff fb60 	bl	9000cf54 <pbuf_ref>
  return cseg;
}
9000d894:	4628      	mov	r0, r5
9000d896:	bd38      	pop	{r3, r4, r5, pc}
9000d898:	900145b3 	.word	0x900145b3
9000d89c:	90014724 	.word	0x90014724
9000d8a0:	90012aff 	.word	0x90012aff

9000d8a4 <tcp_arg>:
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
9000d8a4:	b100      	cbz	r0, 9000d8a8 <tcp_arg+0x4>
    pcb->callback_arg = arg;
9000d8a6:	6101      	str	r1, [r0, #16]
  }
}
9000d8a8:	4770      	bx	lr
	...

9000d8ac <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
9000d8ac:	b538      	push	{r3, r4, r5, lr}
9000d8ae:	460d      	mov	r5, r1
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
9000d8b0:	4604      	mov	r4, r0
9000d8b2:	b158      	cbz	r0, 9000d8cc <tcp_recv+0x20>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
9000d8b4:	7d03      	ldrb	r3, [r0, #20]
9000d8b6:	2b01      	cmp	r3, #1
9000d8b8:	d106      	bne.n	9000d8c8 <tcp_recv+0x1c>
9000d8ba:	4b05      	ldr	r3, [pc, #20]	; (9000d8d0 <tcp_recv+0x24>)
9000d8bc:	f240 72df 	movw	r2, #2015	; 0x7df
9000d8c0:	4904      	ldr	r1, [pc, #16]	; (9000d8d4 <tcp_recv+0x28>)
9000d8c2:	4805      	ldr	r0, [pc, #20]	; (9000d8d8 <tcp_recv+0x2c>)
9000d8c4:	f004 f972 	bl	90011bac <iprintf>
    pcb->recv = recv;
9000d8c8:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  }
}
9000d8cc:	bd38      	pop	{r3, r4, r5, pc}
9000d8ce:	bf00      	nop
9000d8d0:	900145b3 	.word	0x900145b3
9000d8d4:	9001473e 	.word	0x9001473e
9000d8d8:	90012aff 	.word	0x90012aff

9000d8dc <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
9000d8dc:	b538      	push	{r3, r4, r5, lr}
9000d8de:	460d      	mov	r5, r1
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
9000d8e0:	4604      	mov	r4, r0
9000d8e2:	b158      	cbz	r0, 9000d8fc <tcp_sent+0x20>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
9000d8e4:	7d03      	ldrb	r3, [r0, #20]
9000d8e6:	2b01      	cmp	r3, #1
9000d8e8:	d106      	bne.n	9000d8f8 <tcp_sent+0x1c>
9000d8ea:	4b05      	ldr	r3, [pc, #20]	; (9000d900 <tcp_sent+0x24>)
9000d8ec:	f240 72f3 	movw	r2, #2035	; 0x7f3
9000d8f0:	4904      	ldr	r1, [pc, #16]	; (9000d904 <tcp_sent+0x28>)
9000d8f2:	4805      	ldr	r0, [pc, #20]	; (9000d908 <tcp_sent+0x2c>)
9000d8f4:	f004 f95a 	bl	90011bac <iprintf>
    pcb->sent = sent;
9000d8f8:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
  }
}
9000d8fc:	bd38      	pop	{r3, r4, r5, pc}
9000d8fe:	bf00      	nop
9000d900:	900145b3 	.word	0x900145b3
9000d904:	90014765 	.word	0x90014765
9000d908:	90012aff 	.word	0x90012aff

9000d90c <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
9000d90c:	b538      	push	{r3, r4, r5, lr}
9000d90e:	460d      	mov	r5, r1
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
9000d910:	4604      	mov	r4, r0
9000d912:	b158      	cbz	r0, 9000d92c <tcp_err+0x20>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
9000d914:	7d03      	ldrb	r3, [r0, #20]
9000d916:	2b01      	cmp	r3, #1
9000d918:	d106      	bne.n	9000d928 <tcp_err+0x1c>
9000d91a:	4b05      	ldr	r3, [pc, #20]	; (9000d930 <tcp_err+0x24>)
9000d91c:	f640 020d 	movw	r2, #2061	; 0x80d
9000d920:	4904      	ldr	r1, [pc, #16]	; (9000d934 <tcp_err+0x28>)
9000d922:	4805      	ldr	r0, [pc, #20]	; (9000d938 <tcp_err+0x2c>)
9000d924:	f004 f942 	bl	90011bac <iprintf>
    pcb->errf = err;
9000d928:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
  }
}
9000d92c:	bd38      	pop	{r3, r4, r5, pc}
9000d92e:	bf00      	nop
9000d930:	900145b3 	.word	0x900145b3
9000d934:	9001478c 	.word	0x9001478c
9000d938:	90012aff 	.word	0x90012aff

9000d93c <tcp_accept>:
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
9000d93c:	b118      	cbz	r0, 9000d946 <tcp_accept+0xa>
9000d93e:	7d03      	ldrb	r3, [r0, #20]
9000d940:	2b01      	cmp	r3, #1
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
    lpcb->accept = accept;
9000d942:	bf08      	it	eq
9000d944:	6181      	streq	r1, [r0, #24]
  }
}
9000d946:	4770      	bx	lr

9000d948 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
9000d948:	b570      	push	{r4, r5, r6, lr}
9000d94a:	460e      	mov	r6, r1
9000d94c:	4615      	mov	r5, r2
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
9000d94e:	4604      	mov	r4, r0
9000d950:	b940      	cbnz	r0, 9000d964 <tcp_poll+0x1c>
9000d952:	4b0b      	ldr	r3, [pc, #44]	; (9000d980 <tcp_poll+0x38>)
9000d954:	f640 023d 	movw	r2, #2109	; 0x83d
9000d958:	490a      	ldr	r1, [pc, #40]	; (9000d984 <tcp_poll+0x3c>)
9000d95a:	480b      	ldr	r0, [pc, #44]	; (9000d988 <tcp_poll+0x40>)
  pcb->poll = poll;
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
}
9000d95c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
9000d960:	f004 b924 	b.w	90011bac <iprintf>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
9000d964:	7d03      	ldrb	r3, [r0, #20]
9000d966:	2b01      	cmp	r3, #1
9000d968:	d106      	bne.n	9000d978 <tcp_poll+0x30>
9000d96a:	4b05      	ldr	r3, [pc, #20]	; (9000d980 <tcp_poll+0x38>)
9000d96c:	f640 023e 	movw	r2, #2110	; 0x83e
9000d970:	4906      	ldr	r1, [pc, #24]	; (9000d98c <tcp_poll+0x44>)
9000d972:	4805      	ldr	r0, [pc, #20]	; (9000d988 <tcp_poll+0x40>)
9000d974:	f004 f91a 	bl	90011bac <iprintf>
  pcb->poll = poll;
9000d978:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
  pcb->pollinterval = interval;
9000d97c:	7765      	strb	r5, [r4, #29]
}
9000d97e:	bd70      	pop	{r4, r5, r6, pc}
9000d980:	900145b3 	.word	0x900145b3
9000d984:	900147b2 	.word	0x900147b2
9000d988:	90012aff 	.word	0x90012aff
9000d98c:	900147c8 	.word	0x900147c8

9000d990 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
9000d990:	b508      	push	{r3, lr}
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
9000d992:	b930      	cbnz	r0, 9000d9a2 <tcp_next_iss+0x12>
9000d994:	4b06      	ldr	r3, [pc, #24]	; (9000d9b0 <tcp_next_iss+0x20>)
9000d996:	f640 02af 	movw	r2, #2223	; 0x8af
9000d99a:	4906      	ldr	r1, [pc, #24]	; (9000d9b4 <tcp_next_iss+0x24>)
9000d99c:	4806      	ldr	r0, [pc, #24]	; (9000d9b8 <tcp_next_iss+0x28>)
9000d99e:	f004 f905 	bl	90011bac <iprintf>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
9000d9a2:	4b06      	ldr	r3, [pc, #24]	; (9000d9bc <tcp_next_iss+0x2c>)
9000d9a4:	4a06      	ldr	r2, [pc, #24]	; (9000d9c0 <tcp_next_iss+0x30>)
9000d9a6:	6818      	ldr	r0, [r3, #0]
9000d9a8:	6812      	ldr	r2, [r2, #0]
9000d9aa:	4410      	add	r0, r2
9000d9ac:	6018      	str	r0, [r3, #0]
  return iss;
#endif /* LWIP_HOOK_TCP_ISN */
}
9000d9ae:	bd08      	pop	{r3, pc}
9000d9b0:	900145b3 	.word	0x900145b3
9000d9b4:	900147e6 	.word	0x900147e6
9000d9b8:	90012aff 	.word	0x90012aff
9000d9bc:	24000030 	.word	0x24000030
9000d9c0:	2400d3c0 	.word	0x2400d3c0

9000d9c4 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
9000d9c4:	b538      	push	{r3, r4, r5, lr}
9000d9c6:	4604      	mov	r4, r0
9000d9c8:	460d      	mov	r5, r1
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
9000d9ca:	b932      	cbnz	r2, 9000d9da <tcp_eff_send_mss_netif+0x16>
9000d9cc:	4b09      	ldr	r3, [pc, #36]	; (9000d9f4 <tcp_eff_send_mss_netif+0x30>)
9000d9ce:	f640 02c5 	movw	r2, #2245	; 0x8c5
9000d9d2:	4909      	ldr	r1, [pc, #36]	; (9000d9f8 <tcp_eff_send_mss_netif+0x34>)
9000d9d4:	4809      	ldr	r0, [pc, #36]	; (9000d9fc <tcp_eff_send_mss_netif+0x38>)
9000d9d6:	f004 f8e9 	bl	90011bac <iprintf>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
9000d9da:	b14d      	cbz	r5, 9000d9f0 <tcp_eff_send_mss_netif+0x2c>
      return sendmss;
    }
    mtu = outif->mtu;
9000d9dc:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
9000d9de:	b13b      	cbz	r3, 9000d9f0 <tcp_eff_send_mss_netif+0x2c>
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
9000d9e0:	2b28      	cmp	r3, #40	; 0x28
9000d9e2:	bf8a      	itet	hi
9000d9e4:	3b28      	subhi	r3, #40	; 0x28
9000d9e6:	2300      	movls	r3, #0
9000d9e8:	b29b      	uxthhi	r3, r3
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
9000d9ea:	429c      	cmp	r4, r3
9000d9ec:	bf28      	it	cs
9000d9ee:	461c      	movcs	r4, r3
  }
  return sendmss;
}
9000d9f0:	4620      	mov	r0, r4
9000d9f2:	bd38      	pop	{r3, r4, r5, pc}
9000d9f4:	900145b3 	.word	0x900145b3
9000d9f8:	90014800 	.word	0x90014800
9000d9fc:	90012aff 	.word	0x90012aff

9000da00 <tcp_connect>:
{
9000da00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000da02:	461f      	mov	r7, r3
  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
9000da04:	4604      	mov	r4, r0
9000da06:	b950      	cbnz	r0, 9000da1e <tcp_connect+0x1e>
9000da08:	4b40      	ldr	r3, [pc, #256]	; (9000db0c <tcp_connect+0x10c>)
9000da0a:	f240 4235 	movw	r2, #1077	; 0x435
9000da0e:	4940      	ldr	r1, [pc, #256]	; (9000db10 <tcp_connect+0x110>)
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
9000da10:	f06f 050f 	mvn.w	r5, #15
9000da14:	483f      	ldr	r0, [pc, #252]	; (9000db14 <tcp_connect+0x114>)
9000da16:	f004 f8c9 	bl	90011bac <iprintf>
}
9000da1a:	4628      	mov	r0, r5
9000da1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
9000da1e:	b921      	cbnz	r1, 9000da2a <tcp_connect+0x2a>
9000da20:	4b3a      	ldr	r3, [pc, #232]	; (9000db0c <tcp_connect+0x10c>)
9000da22:	f240 4236 	movw	r2, #1078	; 0x436
9000da26:	493c      	ldr	r1, [pc, #240]	; (9000db18 <tcp_connect+0x118>)
9000da28:	e7f2      	b.n	9000da10 <tcp_connect+0x10>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
9000da2a:	7d03      	ldrb	r3, [r0, #20]
9000da2c:	b14b      	cbz	r3, 9000da42 <tcp_connect+0x42>
9000da2e:	4b37      	ldr	r3, [pc, #220]	; (9000db0c <tcp_connect+0x10c>)
9000da30:	f44f 6287 	mov.w	r2, #1080	; 0x438
9000da34:	4939      	ldr	r1, [pc, #228]	; (9000db1c <tcp_connect+0x11c>)
9000da36:	f06f 0509 	mvn.w	r5, #9
9000da3a:	4836      	ldr	r0, [pc, #216]	; (9000db14 <tcp_connect+0x114>)
9000da3c:	f004 f8b6 	bl	90011bac <iprintf>
9000da40:	e7eb      	b.n	9000da1a <tcp_connect+0x1a>
  ip_addr_set(&pcb->remote_ip, ipaddr);
9000da42:	680b      	ldr	r3, [r1, #0]
  pcb->remote_port = port;
9000da44:	8302      	strh	r2, [r0, #24]
  ip_addr_set(&pcb->remote_ip, ipaddr);
9000da46:	6043      	str	r3, [r0, #4]
  if (pcb->netif_idx != NETIF_NO_INDEX) {
9000da48:	7a00      	ldrb	r0, [r0, #8]
9000da4a:	2800      	cmp	r0, #0
9000da4c:	d046      	beq.n	9000dadc <tcp_connect+0xdc>
    netif = netif_get_by_index(pcb->netif_idx);
9000da4e:	f7fe fe57 	bl	9000c700 <netif_get_by_index>
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
9000da52:	4605      	mov	r5, r0
  if (netif == NULL) {
9000da54:	2800      	cmp	r0, #0
9000da56:	d056      	beq.n	9000db06 <tcp_connect+0x106>
  if (ip_addr_isany(&pcb->local_ip)) {
9000da58:	6823      	ldr	r3, [r4, #0]
9000da5a:	b90b      	cbnz	r3, 9000da60 <tcp_connect+0x60>
    ip_addr_copy(pcb->local_ip, *local_ip);
9000da5c:	6843      	ldr	r3, [r0, #4]
9000da5e:	6023      	str	r3, [r4, #0]
  old_local_port = pcb->local_port;
9000da60:	8ae6      	ldrh	r6, [r4, #22]
  if (pcb->local_port == 0) {
9000da62:	2e00      	cmp	r6, #0
9000da64:	d03e      	beq.n	9000dae4 <tcp_connect+0xe4>
  iss = tcp_next_iss(pcb);
9000da66:	4620      	mov	r0, r4
9000da68:	f7ff ff92 	bl	9000d990 <tcp_next_iss>
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
9000da6c:	2300      	movs	r3, #0
9000da6e:	4a2c      	ldr	r2, [pc, #176]	; (9000db20 <tcp_connect+0x120>)
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
9000da70:	4629      	mov	r1, r5
  pcb->snd_nxt = iss;
9000da72:	6520      	str	r0, [r4, #80]	; 0x50
  pcb->lastack = iss - 1;
9000da74:	3801      	subs	r0, #1
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
9000da76:	62e3      	str	r3, [r4, #44]	; 0x2c
  pcb->lastack = iss - 1;
9000da78:	6460      	str	r0, [r4, #68]	; 0x44
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
9000da7a:	e9c4 3209 	strd	r3, r2, [r4, #36]	; 0x24
  pcb->snd_lbb = iss - 1;
9000da7e:	e9c4 0016 	strd	r0, r0, [r4, #88]	; 0x58
  pcb->snd_wnd = TCP_WND;
9000da82:	f44f 6306 	mov.w	r3, #2144	; 0x860
  pcb->mss = INITIAL_MSS;
9000da86:	f44f 7006 	mov.w	r0, #536	; 0x218
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
9000da8a:	1d22      	adds	r2, r4, #4
  pcb->snd_wnd = TCP_WND;
9000da8c:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
  pcb->mss = INITIAL_MSS;
9000da90:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
9000da92:	f7ff ff97 	bl	9000d9c4 <tcp_eff_send_mss_netif>
  pcb->cwnd = 1;
9000da96:	2301      	movs	r3, #1
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
9000da98:	8660      	strh	r0, [r4, #50]	; 0x32
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
9000da9a:	2102      	movs	r1, #2
9000da9c:	4620      	mov	r0, r4
  pcb->cwnd = 1;
9000da9e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
  pcb->connected = connected;
9000daa2:	f8c4 7088 	str.w	r7, [r4, #136]	; 0x88
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
9000daa6:	f002 fe05 	bl	900106b4 <tcp_enqueue_flags>
  if (ret == ERR_OK) {
9000daaa:	4605      	mov	r5, r0
9000daac:	2800      	cmp	r0, #0
9000daae:	d1b4      	bne.n	9000da1a <tcp_connect+0x1a>
    pcb->state = SYN_SENT;
9000dab0:	2302      	movs	r3, #2
9000dab2:	7523      	strb	r3, [r4, #20]
    if (old_local_port != 0) {
9000dab4:	b12e      	cbz	r6, 9000dac2 <tcp_connect+0xc2>
      TCP_RMV(&tcp_bound_pcbs, pcb);
9000dab6:	4a1b      	ldr	r2, [pc, #108]	; (9000db24 <tcp_connect+0x124>)
9000dab8:	6813      	ldr	r3, [r2, #0]
9000daba:	42a3      	cmp	r3, r4
9000dabc:	d11b      	bne.n	9000daf6 <tcp_connect+0xf6>
9000dabe:	68e3      	ldr	r3, [r4, #12]
9000dac0:	6013      	str	r3, [r2, #0]
    TCP_REG_ACTIVE(pcb);
9000dac2:	4b19      	ldr	r3, [pc, #100]	; (9000db28 <tcp_connect+0x128>)
9000dac4:	681a      	ldr	r2, [r3, #0]
9000dac6:	601c      	str	r4, [r3, #0]
9000dac8:	60e2      	str	r2, [r4, #12]
9000daca:	f003 fbcb 	bl	90011264 <tcp_timer_needed>
9000dace:	4b17      	ldr	r3, [pc, #92]	; (9000db2c <tcp_connect+0x12c>)
9000dad0:	2201      	movs	r2, #1
    tcp_output(pcb);
9000dad2:	4620      	mov	r0, r4
    TCP_REG_ACTIVE(pcb);
9000dad4:	701a      	strb	r2, [r3, #0]
    tcp_output(pcb);
9000dad6:	f002 ffe1 	bl	90010a9c <tcp_output>
9000dada:	e79e      	b.n	9000da1a <tcp_connect+0x1a>
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
9000dadc:	1d20      	adds	r0, r4, #4
9000dade:	f7fd fbd5 	bl	9000b28c <ip4_route>
9000dae2:	e7b6      	b.n	9000da52 <tcp_connect+0x52>
    pcb->local_port = tcp_new_port();
9000dae4:	f7ff fcf2 	bl	9000d4cc <tcp_new_port>
9000dae8:	82e0      	strh	r0, [r4, #22]
    if (pcb->local_port == 0) {
9000daea:	2800      	cmp	r0, #0
9000daec:	d1bb      	bne.n	9000da66 <tcp_connect+0x66>
      return ERR_BUF;
9000daee:	f06f 0501 	mvn.w	r5, #1
9000daf2:	e792      	b.n	9000da1a <tcp_connect+0x1a>
9000daf4:	4613      	mov	r3, r2
      TCP_RMV(&tcp_bound_pcbs, pcb);
9000daf6:	2b00      	cmp	r3, #0
9000daf8:	d0e3      	beq.n	9000dac2 <tcp_connect+0xc2>
9000dafa:	68da      	ldr	r2, [r3, #12]
9000dafc:	42a2      	cmp	r2, r4
9000dafe:	d1f9      	bne.n	9000daf4 <tcp_connect+0xf4>
9000db00:	68e2      	ldr	r2, [r4, #12]
9000db02:	60da      	str	r2, [r3, #12]
9000db04:	e7dd      	b.n	9000dac2 <tcp_connect+0xc2>
    return ERR_RTE;
9000db06:	f06f 0503 	mvn.w	r5, #3
9000db0a:	e786      	b.n	9000da1a <tcp_connect+0x1a>
9000db0c:	900145b3 	.word	0x900145b3
9000db10:	90014827 	.word	0x90014827
9000db14:	90012aff 	.word	0x90012aff
9000db18:	90014840 	.word	0x90014840
9000db1c:	9001485c 	.word	0x9001485c
9000db20:	08600860 	.word	0x08600860
9000db24:	2400d3b8 	.word	0x2400d3b8
9000db28:	2400d3b0 	.word	0x2400d3b0
9000db2c:	2400d3b4 	.word	0x2400d3b4

9000db30 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
9000db30:	b510      	push	{r4, lr}
9000db32:	4604      	mov	r4, r0
  if (pcb->ooseq) {
9000db34:	6f40      	ldr	r0, [r0, #116]	; 0x74
9000db36:	b118      	cbz	r0, 9000db40 <tcp_free_ooseq+0x10>
    tcp_segs_free(pcb->ooseq);
9000db38:	f7ff fe88 	bl	9000d84c <tcp_segs_free>
    pcb->ooseq = NULL;
9000db3c:	2300      	movs	r3, #0
9000db3e:	6763      	str	r3, [r4, #116]	; 0x74
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
9000db40:	bd10      	pop	{r4, pc}
	...

9000db44 <tcp_pcb_purge>:
{
9000db44:	b510      	push	{r4, lr}
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
9000db46:	4604      	mov	r4, r0
9000db48:	b940      	cbnz	r0, 9000db5c <tcp_pcb_purge+0x18>
9000db4a:	4b14      	ldr	r3, [pc, #80]	; (9000db9c <tcp_pcb_purge+0x58>)
9000db4c:	f640 0251 	movw	r2, #2129	; 0x851
9000db50:	4913      	ldr	r1, [pc, #76]	; (9000dba0 <tcp_pcb_purge+0x5c>)
9000db52:	4814      	ldr	r0, [pc, #80]	; (9000dba4 <tcp_pcb_purge+0x60>)
}
9000db54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
9000db58:	f004 b828 	b.w	90011bac <iprintf>
  if (pcb->state != CLOSED &&
9000db5c:	7d03      	ldrb	r3, [r0, #20]
9000db5e:	2b01      	cmp	r3, #1
9000db60:	d91a      	bls.n	9000db98 <tcp_pcb_purge+0x54>
9000db62:	2b0a      	cmp	r3, #10
9000db64:	d018      	beq.n	9000db98 <tcp_pcb_purge+0x54>
    if (pcb->refused_data != NULL) {
9000db66:	6f80      	ldr	r0, [r0, #120]	; 0x78
9000db68:	b118      	cbz	r0, 9000db72 <tcp_pcb_purge+0x2e>
      pbuf_free(pcb->refused_data);
9000db6a:	f7ff f899 	bl	9000cca0 <pbuf_free>
      pcb->refused_data = NULL;
9000db6e:	2300      	movs	r3, #0
9000db70:	67a3      	str	r3, [r4, #120]	; 0x78
    if (pcb->ooseq != NULL) {
9000db72:	6f63      	ldr	r3, [r4, #116]	; 0x74
9000db74:	b113      	cbz	r3, 9000db7c <tcp_pcb_purge+0x38>
      tcp_free_ooseq(pcb);
9000db76:	4620      	mov	r0, r4
9000db78:	f7ff ffda 	bl	9000db30 <tcp_free_ooseq>
    pcb->rtime = -1;
9000db7c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    tcp_segs_free(pcb->unsent);
9000db80:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    pcb->rtime = -1;
9000db82:	8623      	strh	r3, [r4, #48]	; 0x30
    tcp_segs_free(pcb->unsent);
9000db84:	f7ff fe62 	bl	9000d84c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
9000db88:	6f20      	ldr	r0, [r4, #112]	; 0x70
9000db8a:	f7ff fe5f 	bl	9000d84c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
9000db8e:	2300      	movs	r3, #0
9000db90:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    pcb->unsent_oversize = 0;
9000db94:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
}
9000db98:	bd10      	pop	{r4, pc}
9000db9a:	bf00      	nop
9000db9c:	900145b3 	.word	0x900145b3
9000dba0:	9001488c 	.word	0x9001488c
9000dba4:	90012aff 	.word	0x90012aff

9000dba8 <tcp_pcb_remove>:
{
9000dba8:	b538      	push	{r3, r4, r5, lr}
9000dbaa:	4605      	mov	r5, r0
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
9000dbac:	460c      	mov	r4, r1
9000dbae:	b931      	cbnz	r1, 9000dbbe <tcp_pcb_remove+0x16>
9000dbb0:	4b29      	ldr	r3, [pc, #164]	; (9000dc58 <tcp_pcb_remove+0xb0>)
9000dbb2:	f640 0283 	movw	r2, #2179	; 0x883
9000dbb6:	4929      	ldr	r1, [pc, #164]	; (9000dc5c <tcp_pcb_remove+0xb4>)
9000dbb8:	4829      	ldr	r0, [pc, #164]	; (9000dc60 <tcp_pcb_remove+0xb8>)
9000dbba:	f003 fff7 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
9000dbbe:	b935      	cbnz	r5, 9000dbce <tcp_pcb_remove+0x26>
9000dbc0:	4b25      	ldr	r3, [pc, #148]	; (9000dc58 <tcp_pcb_remove+0xb0>)
9000dbc2:	f640 0284 	movw	r2, #2180	; 0x884
9000dbc6:	4927      	ldr	r1, [pc, #156]	; (9000dc64 <tcp_pcb_remove+0xbc>)
9000dbc8:	4825      	ldr	r0, [pc, #148]	; (9000dc60 <tcp_pcb_remove+0xb8>)
9000dbca:	f003 ffef 	bl	90011bac <iprintf>
  TCP_RMV(pcblist, pcb);
9000dbce:	682b      	ldr	r3, [r5, #0]
9000dbd0:	42a3      	cmp	r3, r4
9000dbd2:	d11f      	bne.n	9000dc14 <tcp_pcb_remove+0x6c>
9000dbd4:	68e3      	ldr	r3, [r4, #12]
9000dbd6:	602b      	str	r3, [r5, #0]
9000dbd8:	2300      	movs	r3, #0
  tcp_pcb_purge(pcb);
9000dbda:	4620      	mov	r0, r4
  TCP_RMV(pcblist, pcb);
9000dbdc:	60e3      	str	r3, [r4, #12]
  tcp_pcb_purge(pcb);
9000dbde:	f7ff ffb1 	bl	9000db44 <tcp_pcb_purge>
  if ((pcb->state != TIME_WAIT) &&
9000dbe2:	7d23      	ldrb	r3, [r4, #20]
9000dbe4:	2b0a      	cmp	r3, #10
9000dbe6:	d11d      	bne.n	9000dc24 <tcp_pcb_remove+0x7c>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
9000dbe8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000dbea:	bb6b      	cbnz	r3, 9000dc48 <tcp_pcb_remove+0xa0>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
9000dbec:	6f23      	ldr	r3, [r4, #112]	; 0x70
9000dbee:	b133      	cbz	r3, 9000dbfe <tcp_pcb_remove+0x56>
9000dbf0:	4b19      	ldr	r3, [pc, #100]	; (9000dc58 <tcp_pcb_remove+0xb0>)
9000dbf2:	f640 0294 	movw	r2, #2196	; 0x894
9000dbf6:	491c      	ldr	r1, [pc, #112]	; (9000dc68 <tcp_pcb_remove+0xc0>)
9000dbf8:	4819      	ldr	r0, [pc, #100]	; (9000dc60 <tcp_pcb_remove+0xb8>)
9000dbfa:	f003 ffd7 	bl	90011bac <iprintf>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
9000dbfe:	6f63      	ldr	r3, [r4, #116]	; 0x74
9000dc00:	b1f3      	cbz	r3, 9000dc40 <tcp_pcb_remove+0x98>
9000dc02:	4b15      	ldr	r3, [pc, #84]	; (9000dc58 <tcp_pcb_remove+0xb0>)
9000dc04:	f640 0296 	movw	r2, #2198	; 0x896
9000dc08:	4918      	ldr	r1, [pc, #96]	; (9000dc6c <tcp_pcb_remove+0xc4>)
9000dc0a:	4815      	ldr	r0, [pc, #84]	; (9000dc60 <tcp_pcb_remove+0xb8>)
9000dc0c:	f003 ffce 	bl	90011bac <iprintf>
9000dc10:	e016      	b.n	9000dc40 <tcp_pcb_remove+0x98>
9000dc12:	4613      	mov	r3, r2
  TCP_RMV(pcblist, pcb);
9000dc14:	2b00      	cmp	r3, #0
9000dc16:	d0df      	beq.n	9000dbd8 <tcp_pcb_remove+0x30>
9000dc18:	68da      	ldr	r2, [r3, #12]
9000dc1a:	42a2      	cmp	r2, r4
9000dc1c:	d1f9      	bne.n	9000dc12 <tcp_pcb_remove+0x6a>
9000dc1e:	68e2      	ldr	r2, [r4, #12]
9000dc20:	60da      	str	r2, [r3, #12]
9000dc22:	e7d9      	b.n	9000dbd8 <tcp_pcb_remove+0x30>
  if ((pcb->state != TIME_WAIT) &&
9000dc24:	2b01      	cmp	r3, #1
9000dc26:	d00b      	beq.n	9000dc40 <tcp_pcb_remove+0x98>
      (pcb->flags & TF_ACK_DELAY)) {
9000dc28:	8b63      	ldrh	r3, [r4, #26]
      (pcb->state != LISTEN) &&
9000dc2a:	07da      	lsls	r2, r3, #31
9000dc2c:	d5dc      	bpl.n	9000dbe8 <tcp_pcb_remove+0x40>
    tcp_ack_now(pcb);
9000dc2e:	f043 0302 	orr.w	r3, r3, #2
    tcp_output(pcb);
9000dc32:	4620      	mov	r0, r4
    tcp_ack_now(pcb);
9000dc34:	8363      	strh	r3, [r4, #26]
    tcp_output(pcb);
9000dc36:	f002 ff31 	bl	90010a9c <tcp_output>
  if (pcb->state != LISTEN) {
9000dc3a:	7d23      	ldrb	r3, [r4, #20]
9000dc3c:	2b01      	cmp	r3, #1
9000dc3e:	d1d3      	bne.n	9000dbe8 <tcp_pcb_remove+0x40>
  pcb->state = CLOSED;
9000dc40:	2300      	movs	r3, #0
9000dc42:	7523      	strb	r3, [r4, #20]
  pcb->local_port = 0;
9000dc44:	82e3      	strh	r3, [r4, #22]
}
9000dc46:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
9000dc48:	4b03      	ldr	r3, [pc, #12]	; (9000dc58 <tcp_pcb_remove+0xb0>)
9000dc4a:	f640 0293 	movw	r2, #2195	; 0x893
9000dc4e:	4908      	ldr	r1, [pc, #32]	; (9000dc70 <tcp_pcb_remove+0xc8>)
9000dc50:	4803      	ldr	r0, [pc, #12]	; (9000dc60 <tcp_pcb_remove+0xb8>)
9000dc52:	f003 ffab 	bl	90011bac <iprintf>
9000dc56:	e7c9      	b.n	9000dbec <tcp_pcb_remove+0x44>
9000dc58:	900145b3 	.word	0x900145b3
9000dc5c:	900148a7 	.word	0x900148a7
9000dc60:	90012aff 	.word	0x90012aff
9000dc64:	900148c3 	.word	0x900148c3
9000dc68:	900148fb 	.word	0x900148fb
9000dc6c:	90014914 	.word	0x90014914
9000dc70:	900148e3 	.word	0x900148e3

9000dc74 <tcp_abandon>:
{
9000dc74:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
9000dc78:	460e      	mov	r6, r1
  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
9000dc7a:	4604      	mov	r4, r0
9000dc7c:	b948      	cbnz	r0, 9000dc92 <tcp_abandon+0x1e>
9000dc7e:	4b36      	ldr	r3, [pc, #216]	; (9000dd58 <tcp_abandon+0xe4>)
9000dc80:	f240 223d 	movw	r2, #573	; 0x23d
9000dc84:	4935      	ldr	r1, [pc, #212]	; (9000dd5c <tcp_abandon+0xe8>)
9000dc86:	4836      	ldr	r0, [pc, #216]	; (9000dd60 <tcp_abandon+0xec>)
}
9000dc88:	b004      	add	sp, #16
9000dc8a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
9000dc8e:	f003 bf8d 	b.w	90011bac <iprintf>
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
9000dc92:	7d03      	ldrb	r3, [r0, #20]
9000dc94:	2b01      	cmp	r3, #1
9000dc96:	d106      	bne.n	9000dca6 <tcp_abandon+0x32>
9000dc98:	4b2f      	ldr	r3, [pc, #188]	; (9000dd58 <tcp_abandon+0xe4>)
9000dc9a:	f44f 7210 	mov.w	r2, #576	; 0x240
9000dc9e:	4931      	ldr	r1, [pc, #196]	; (9000dd64 <tcp_abandon+0xf0>)
9000dca0:	482f      	ldr	r0, [pc, #188]	; (9000dd60 <tcp_abandon+0xec>)
9000dca2:	f003 ff83 	bl	90011bac <iprintf>
  if (pcb->state == TIME_WAIT) {
9000dca6:	7d23      	ldrb	r3, [r4, #20]
9000dca8:	2b0a      	cmp	r3, #10
9000dcaa:	d109      	bne.n	9000dcc0 <tcp_abandon+0x4c>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
9000dcac:	4621      	mov	r1, r4
9000dcae:	482e      	ldr	r0, [pc, #184]	; (9000dd68 <tcp_abandon+0xf4>)
9000dcb0:	f7ff ff7a 	bl	9000dba8 <tcp_pcb_remove>
    tcp_free(pcb);
9000dcb4:	4620      	mov	r0, r4
}
9000dcb6:	b004      	add	sp, #16
9000dcb8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tcp_free(pcb);
9000dcbc:	f7ff bc6c 	b.w	9000d598 <tcp_free>
    seqno = pcb->snd_nxt;
9000dcc0:	f8d4 9050 	ldr.w	r9, [r4, #80]	; 0x50
    ackno = pcb->rcv_nxt;
9000dcc4:	f8d4 a024 	ldr.w	sl, [r4, #36]	; 0x24
    errf = pcb->errf;
9000dcc8:	f8d4 7090 	ldr.w	r7, [r4, #144]	; 0x90
    errf_arg = pcb->callback_arg;
9000dccc:	f8d4 8010 	ldr.w	r8, [r4, #16]
      if (pcb->local_port != 0) {
9000dcd0:	8ae5      	ldrh	r5, [r4, #22]
    if (pcb->state == CLOSED) {
9000dcd2:	b99b      	cbnz	r3, 9000dcfc <tcp_abandon+0x88>
      if (pcb->local_port != 0) {
9000dcd4:	b13d      	cbz	r5, 9000dce6 <tcp_abandon+0x72>
        TCP_RMV(&tcp_bound_pcbs, pcb);
9000dcd6:	4a25      	ldr	r2, [pc, #148]	; (9000dd6c <tcp_abandon+0xf8>)
9000dcd8:	6813      	ldr	r3, [r2, #0]
9000dcda:	42a3      	cmp	r3, r4
9000dcdc:	d106      	bne.n	9000dcec <tcp_abandon+0x78>
9000dcde:	68e3      	ldr	r3, [r4, #12]
9000dce0:	6013      	str	r3, [r2, #0]
9000dce2:	2500      	movs	r5, #0
9000dce4:	60e5      	str	r5, [r4, #12]
    int send_rst = 0;
9000dce6:	462e      	mov	r6, r5
9000dce8:	e00f      	b.n	9000dd0a <tcp_abandon+0x96>
9000dcea:	4613      	mov	r3, r2
        TCP_RMV(&tcp_bound_pcbs, pcb);
9000dcec:	2b00      	cmp	r3, #0
9000dcee:	d0f8      	beq.n	9000dce2 <tcp_abandon+0x6e>
9000dcf0:	68da      	ldr	r2, [r3, #12]
9000dcf2:	42a2      	cmp	r2, r4
9000dcf4:	d1f9      	bne.n	9000dcea <tcp_abandon+0x76>
9000dcf6:	68e2      	ldr	r2, [r4, #12]
9000dcf8:	60da      	str	r2, [r3, #12]
9000dcfa:	e7f2      	b.n	9000dce2 <tcp_abandon+0x6e>
      TCP_PCB_REMOVE_ACTIVE(pcb);
9000dcfc:	4621      	mov	r1, r4
9000dcfe:	481c      	ldr	r0, [pc, #112]	; (9000dd70 <tcp_abandon+0xfc>)
9000dd00:	f7ff ff52 	bl	9000dba8 <tcp_pcb_remove>
9000dd04:	4b1b      	ldr	r3, [pc, #108]	; (9000dd74 <tcp_abandon+0x100>)
9000dd06:	2201      	movs	r2, #1
9000dd08:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
9000dd0a:	6f20      	ldr	r0, [r4, #112]	; 0x70
9000dd0c:	b108      	cbz	r0, 9000dd12 <tcp_abandon+0x9e>
      tcp_segs_free(pcb->unacked);
9000dd0e:	f7ff fd9d 	bl	9000d84c <tcp_segs_free>
    if (pcb->unsent != NULL) {
9000dd12:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
9000dd14:	b108      	cbz	r0, 9000dd1a <tcp_abandon+0xa6>
      tcp_segs_free(pcb->unsent);
9000dd16:	f7ff fd99 	bl	9000d84c <tcp_segs_free>
    if (pcb->ooseq != NULL) {
9000dd1a:	6f60      	ldr	r0, [r4, #116]	; 0x74
9000dd1c:	b108      	cbz	r0, 9000dd22 <tcp_abandon+0xae>
      tcp_segs_free(pcb->ooseq);
9000dd1e:	f7ff fd95 	bl	9000d84c <tcp_segs_free>
    if (send_rst) {
9000dd22:	b156      	cbz	r6, 9000dd3a <tcp_abandon+0xc6>
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
9000dd24:	8b23      	ldrh	r3, [r4, #24]
9000dd26:	4652      	mov	r2, sl
9000dd28:	4649      	mov	r1, r9
9000dd2a:	4620      	mov	r0, r4
9000dd2c:	e9cd 5301 	strd	r5, r3, [sp, #4]
9000dd30:	1d23      	adds	r3, r4, #4
9000dd32:	9300      	str	r3, [sp, #0]
9000dd34:	4623      	mov	r3, r4
9000dd36:	f002 fe39 	bl	900109ac <tcp_rst>
    tcp_free(pcb);
9000dd3a:	4620      	mov	r0, r4
9000dd3c:	f7ff fc2c 	bl	9000d598 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
9000dd40:	b13f      	cbz	r7, 9000dd52 <tcp_abandon+0xde>
9000dd42:	f06f 010c 	mvn.w	r1, #12
9000dd46:	4640      	mov	r0, r8
9000dd48:	463b      	mov	r3, r7
}
9000dd4a:	b004      	add	sp, #16
9000dd4c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
9000dd50:	4718      	bx	r3
}
9000dd52:	b004      	add	sp, #16
9000dd54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
9000dd58:	900145b3 	.word	0x900145b3
9000dd5c:	9001492b 	.word	0x9001492b
9000dd60:	90012aff 	.word	0x90012aff
9000dd64:	90014944 	.word	0x90014944
9000dd68:	2400d3c8 	.word	0x2400d3c8
9000dd6c:	2400d3b8 	.word	0x2400d3b8
9000dd70:	2400d3b0 	.word	0x2400d3b0
9000dd74:	2400d3b4 	.word	0x2400d3b4

9000dd78 <tcp_abort>:
  tcp_abandon(pcb, 1);
9000dd78:	2101      	movs	r1, #1
9000dd7a:	f7ff bf7b 	b.w	9000dc74 <tcp_abandon>
	...

9000dd80 <tcp_accept_null>:
{
9000dd80:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);
9000dd82:	460c      	mov	r4, r1
9000dd84:	b931      	cbnz	r1, 9000dd94 <tcp_accept_null+0x14>
9000dd86:	4b06      	ldr	r3, [pc, #24]	; (9000dda0 <tcp_accept_null+0x20>)
9000dd88:	f240 320f 	movw	r2, #783	; 0x30f
9000dd8c:	4905      	ldr	r1, [pc, #20]	; (9000dda4 <tcp_accept_null+0x24>)
9000dd8e:	4806      	ldr	r0, [pc, #24]	; (9000dda8 <tcp_accept_null+0x28>)
9000dd90:	f003 ff0c 	bl	90011bac <iprintf>
  tcp_abort(pcb);
9000dd94:	4620      	mov	r0, r4
9000dd96:	f7ff ffef 	bl	9000dd78 <tcp_abort>
}
9000dd9a:	f06f 000c 	mvn.w	r0, #12
9000dd9e:	bd10      	pop	{r4, pc}
9000dda0:	900145b3 	.word	0x900145b3
9000dda4:	90014975 	.word	0x90014975
9000dda8:	90012aff 	.word	0x90012aff

9000ddac <tcp_netif_ip_addr_changed_pcblist>:
{
9000ddac:	b570      	push	{r4, r5, r6, lr}
9000ddae:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
9000ddb0:	4605      	mov	r5, r0
9000ddb2:	b930      	cbnz	r0, 9000ddc2 <tcp_netif_ip_addr_changed_pcblist+0x16>
9000ddb4:	4b09      	ldr	r3, [pc, #36]	; (9000dddc <tcp_netif_ip_addr_changed_pcblist+0x30>)
9000ddb6:	f44f 6210 	mov.w	r2, #2304	; 0x900
9000ddba:	4909      	ldr	r1, [pc, #36]	; (9000dde0 <tcp_netif_ip_addr_changed_pcblist+0x34>)
9000ddbc:	4809      	ldr	r0, [pc, #36]	; (9000dde4 <tcp_netif_ip_addr_changed_pcblist+0x38>)
9000ddbe:	f003 fef5 	bl	90011bac <iprintf>
  while (pcb != NULL) {
9000ddc2:	b904      	cbnz	r4, 9000ddc6 <tcp_netif_ip_addr_changed_pcblist+0x1a>
}
9000ddc4:	bd70      	pop	{r4, r5, r6, pc}
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
9000ddc6:	6822      	ldr	r2, [r4, #0]
9000ddc8:	682b      	ldr	r3, [r5, #0]
      struct tcp_pcb *next = pcb->next;
9000ddca:	68e6      	ldr	r6, [r4, #12]
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
9000ddcc:	429a      	cmp	r2, r3
9000ddce:	d102      	bne.n	9000ddd6 <tcp_netif_ip_addr_changed_pcblist+0x2a>
      tcp_abort(pcb);
9000ddd0:	4620      	mov	r0, r4
9000ddd2:	f7ff ffd1 	bl	9000dd78 <tcp_abort>
{
9000ddd6:	4634      	mov	r4, r6
9000ddd8:	e7f3      	b.n	9000ddc2 <tcp_netif_ip_addr_changed_pcblist+0x16>
9000ddda:	bf00      	nop
9000dddc:	900145b3 	.word	0x900145b3
9000dde0:	90014992 	.word	0x90014992
9000dde4:	90012aff 	.word	0x90012aff

9000dde8 <tcp_netif_ip_addr_changed>:
{
9000dde8:	b538      	push	{r3, r4, r5, lr}
9000ddea:	460d      	mov	r5, r1
  if (!ip_addr_isany(old_addr)) {
9000ddec:	4604      	mov	r4, r0
9000ddee:	b180      	cbz	r0, 9000de12 <tcp_netif_ip_addr_changed+0x2a>
9000ddf0:	6803      	ldr	r3, [r0, #0]
9000ddf2:	b173      	cbz	r3, 9000de12 <tcp_netif_ip_addr_changed+0x2a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
9000ddf4:	4b0b      	ldr	r3, [pc, #44]	; (9000de24 <tcp_netif_ip_addr_changed+0x3c>)
9000ddf6:	6819      	ldr	r1, [r3, #0]
9000ddf8:	f7ff ffd8 	bl	9000ddac <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
9000ddfc:	4b0a      	ldr	r3, [pc, #40]	; (9000de28 <tcp_netif_ip_addr_changed+0x40>)
9000ddfe:	4620      	mov	r0, r4
9000de00:	6819      	ldr	r1, [r3, #0]
9000de02:	f7ff ffd3 	bl	9000ddac <tcp_netif_ip_addr_changed_pcblist>
    if (!ip_addr_isany(new_addr)) {
9000de06:	b125      	cbz	r5, 9000de12 <tcp_netif_ip_addr_changed+0x2a>
9000de08:	682b      	ldr	r3, [r5, #0]
9000de0a:	b113      	cbz	r3, 9000de12 <tcp_netif_ip_addr_changed+0x2a>
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000de0c:	4b07      	ldr	r3, [pc, #28]	; (9000de2c <tcp_netif_ip_addr_changed+0x44>)
9000de0e:	681b      	ldr	r3, [r3, #0]
9000de10:	b903      	cbnz	r3, 9000de14 <tcp_netif_ip_addr_changed+0x2c>
}
9000de12:	bd38      	pop	{r3, r4, r5, pc}
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
9000de14:	6819      	ldr	r1, [r3, #0]
9000de16:	6822      	ldr	r2, [r4, #0]
9000de18:	4291      	cmp	r1, r2
          ip_addr_copy(lpcb->local_ip, *new_addr);
9000de1a:	bf04      	itt	eq
9000de1c:	682a      	ldreq	r2, [r5, #0]
9000de1e:	601a      	streq	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000de20:	68db      	ldr	r3, [r3, #12]
9000de22:	e7f5      	b.n	9000de10 <tcp_netif_ip_addr_changed+0x28>
9000de24:	2400d3b0 	.word	0x2400d3b0
9000de28:	2400d3b8 	.word	0x2400d3b8
9000de2c:	2400d3bc 	.word	0x2400d3bc

9000de30 <tcp_kill_state>:
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000de30:	4b0c      	ldr	r3, [pc, #48]	; (9000de64 <tcp_kill_state+0x34>)
  inactivity = 0;
9000de32:	2200      	movs	r2, #0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000de34:	6819      	ldr	r1, [r3, #0]
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000de36:	4b0c      	ldr	r3, [pc, #48]	; (9000de68 <tcp_kill_state+0x38>)
{
9000de38:	b430      	push	{r4, r5}
9000de3a:	4604      	mov	r4, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000de3c:	681d      	ldr	r5, [r3, #0]
  inactive = NULL;
9000de3e:	4610      	mov	r0, r2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000de40:	b919      	cbnz	r1, 9000de4a <tcp_kill_state+0x1a>
  if (inactive != NULL) {
9000de42:	b168      	cbz	r0, 9000de60 <tcp_kill_state+0x30>
}
9000de44:	bc30      	pop	{r4, r5}
    tcp_abandon(inactive, 0);
9000de46:	f7ff bf15 	b.w	9000dc74 <tcp_abandon>
    if (pcb->state == state) {
9000de4a:	7d0b      	ldrb	r3, [r1, #20]
9000de4c:	42a3      	cmp	r3, r4
9000de4e:	d105      	bne.n	9000de5c <tcp_kill_state+0x2c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000de50:	6a0b      	ldr	r3, [r1, #32]
9000de52:	1aeb      	subs	r3, r5, r3
9000de54:	4293      	cmp	r3, r2
9000de56:	bf24      	itt	cs
9000de58:	461a      	movcs	r2, r3
9000de5a:	4608      	movcs	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000de5c:	68c9      	ldr	r1, [r1, #12]
9000de5e:	e7ef      	b.n	9000de40 <tcp_kill_state+0x10>
}
9000de60:	bc30      	pop	{r4, r5}
9000de62:	4770      	bx	lr
9000de64:	2400d3b0 	.word	0x2400d3b0
9000de68:	2400d3c0 	.word	0x2400d3c0

9000de6c <tcp_alloc>:
{
9000de6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000de6e:	4604      	mov	r4, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
9000de70:	2001      	movs	r0, #1
9000de72:	f7fe facb 	bl	9000c40c <memp_malloc>
  if (pcb == NULL) {
9000de76:	4603      	mov	r3, r0
9000de78:	2800      	cmp	r0, #0
9000de7a:	d136      	bne.n	9000deea <tcp_alloc+0x7e>
  struct tcp_pcb *pcb = tcp_active_pcbs;
9000de7c:	4e3f      	ldr	r6, [pc, #252]	; (9000df7c <tcp_alloc+0x110>)
9000de7e:	6830      	ldr	r0, [r6, #0]
  while (pcb != NULL) {
9000de80:	2800      	cmp	r0, #0
9000de82:	d157      	bne.n	9000df34 <tcp_alloc+0xc8>
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000de84:	4b3e      	ldr	r3, [pc, #248]	; (9000df80 <tcp_alloc+0x114>)
  inactivity = 0;
9000de86:	4601      	mov	r1, r0
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000de88:	4d3e      	ldr	r5, [pc, #248]	; (9000df84 <tcp_alloc+0x118>)
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000de8a:	681b      	ldr	r3, [r3, #0]
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000de8c:	682f      	ldr	r7, [r5, #0]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000de8e:	2b00      	cmp	r3, #0
9000de90:	d15b      	bne.n	9000df4a <tcp_alloc+0xde>
  if (inactive != NULL) {
9000de92:	b108      	cbz	r0, 9000de98 <tcp_alloc+0x2c>
    tcp_abort(inactive);
9000de94:	f7ff ff70 	bl	9000dd78 <tcp_abort>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
9000de98:	2001      	movs	r0, #1
9000de9a:	f7fe fab7 	bl	9000c40c <memp_malloc>
    if (pcb == NULL) {
9000de9e:	4603      	mov	r3, r0
9000dea0:	bb18      	cbnz	r0, 9000deea <tcp_alloc+0x7e>
      tcp_kill_state(LAST_ACK);
9000dea2:	2009      	movs	r0, #9
9000dea4:	f7ff ffc4 	bl	9000de30 <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
9000dea8:	2001      	movs	r0, #1
9000deaa:	f7fe faaf 	bl	9000c40c <memp_malloc>
      if (pcb == NULL) {
9000deae:	4603      	mov	r3, r0
9000deb0:	b9d8      	cbnz	r0, 9000deea <tcp_alloc+0x7e>
        tcp_kill_state(CLOSING);
9000deb2:	2008      	movs	r0, #8
9000deb4:	f7ff ffbc 	bl	9000de30 <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
9000deb8:	2001      	movs	r0, #1
9000deba:	f7fe faa7 	bl	9000c40c <memp_malloc>
        if (pcb == NULL) {
9000debe:	4603      	mov	r3, r0
9000dec0:	b998      	cbnz	r0, 9000deea <tcp_alloc+0x7e>
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
9000dec2:	0622      	lsls	r2, r4, #24
9000dec4:	d449      	bmi.n	9000df5a <tcp_alloc+0xee>
  if (mprio == 0) {
9000dec6:	b15c      	cbz	r4, 9000dee0 <tcp_alloc+0x74>
9000dec8:	4621      	mov	r1, r4
  mprio--;
9000deca:	3901      	subs	r1, #1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000decc:	6832      	ldr	r2, [r6, #0]
  inactivity = 0;
9000dece:	2000      	movs	r0, #0
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
9000ded0:	682e      	ldr	r6, [r5, #0]
  mprio--;
9000ded2:	b2c9      	uxtb	r1, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000ded4:	2a00      	cmp	r2, #0
9000ded6:	d142      	bne.n	9000df5e <tcp_alloc+0xf2>
  if (inactive != NULL) {
9000ded8:	b113      	cbz	r3, 9000dee0 <tcp_alloc+0x74>
    tcp_abort(inactive);
9000deda:	4618      	mov	r0, r3
9000dedc:	f7ff ff4c 	bl	9000dd78 <tcp_abort>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
9000dee0:	2001      	movs	r0, #1
9000dee2:	f7fe fa93 	bl	9000c40c <memp_malloc>
  if (pcb != NULL) {
9000dee6:	4603      	mov	r3, r0
9000dee8:	b310      	cbz	r0, 9000df30 <tcp_alloc+0xc4>
    memset(pcb, 0, sizeof(struct tcp_pcb));
9000deea:	229c      	movs	r2, #156	; 0x9c
9000deec:	4618      	mov	r0, r3
9000deee:	2100      	movs	r1, #0
9000def0:	f003 fd74 	bl	900119dc <memset>
    pcb->snd_buf = TCP_SND_BUF;
9000def4:	f44f 6286 	mov.w	r2, #1072	; 0x430
    memset(pcb, 0, sizeof(struct tcp_pcb));
9000def8:	4603      	mov	r3, r0
    pcb->prio = prio;
9000defa:	7544      	strb	r4, [r0, #21]
    pcb->snd_buf = TCP_SND_BUF;
9000defc:	f8a0 2064 	strh.w	r2, [r0, #100]	; 0x64
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
9000df00:	4a21      	ldr	r2, [pc, #132]	; (9000df88 <tcp_alloc+0x11c>)
9000df02:	6282      	str	r2, [r0, #40]	; 0x28
    pcb->ttl = TCP_TTL;
9000df04:	22ff      	movs	r2, #255	; 0xff
9000df06:	72c2      	strb	r2, [r0, #11]
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
9000df08:	2206      	movs	r2, #6
9000df0a:	f8a0 2040 	strh.w	r2, [r0, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
9000df0e:	87c2      	strh	r2, [r0, #62]	; 0x3e
    pcb->rtime = -1;
9000df10:	4a1e      	ldr	r2, [pc, #120]	; (9000df8c <tcp_alloc+0x120>)
9000df12:	6302      	str	r2, [r0, #48]	; 0x30
    pcb->tmr = tcp_ticks;
9000df14:	4a1b      	ldr	r2, [pc, #108]	; (9000df84 <tcp_alloc+0x118>)
9000df16:	6812      	ldr	r2, [r2, #0]
9000df18:	6202      	str	r2, [r0, #32]
    pcb->last_timer = tcp_timer_ctr;
9000df1a:	4a1d      	ldr	r2, [pc, #116]	; (9000df90 <tcp_alloc+0x124>)
9000df1c:	7812      	ldrb	r2, [r2, #0]
9000df1e:	7782      	strb	r2, [r0, #30]
    pcb->cwnd = 1;
9000df20:	4a1c      	ldr	r2, [pc, #112]	; (9000df94 <tcp_alloc+0x128>)
9000df22:	6482      	str	r2, [r0, #72]	; 0x48
    pcb->recv = tcp_recv_null;
9000df24:	4a1c      	ldr	r2, [pc, #112]	; (9000df98 <tcp_alloc+0x12c>)
9000df26:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
9000df2a:	4a1c      	ldr	r2, [pc, #112]	; (9000df9c <tcp_alloc+0x130>)
9000df2c:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
}
9000df30:	4618      	mov	r0, r3
9000df32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (pcb->flags & TF_CLOSEPEND) {
9000df34:	8b43      	ldrh	r3, [r0, #26]
    struct tcp_pcb *next = pcb->next;
9000df36:	68c5      	ldr	r5, [r0, #12]
    if (pcb->flags & TF_CLOSEPEND) {
9000df38:	0719      	lsls	r1, r3, #28
9000df3a:	d504      	bpl.n	9000df46 <tcp_alloc+0xda>
      tcp_clear_flags(pcb, TF_CLOSEPEND);
9000df3c:	f023 0308 	bic.w	r3, r3, #8
9000df40:	8343      	strh	r3, [r0, #26]
      tcp_close_shutdown_fin(pcb);
9000df42:	f7ff faed 	bl	9000d520 <tcp_close_shutdown_fin>
{
9000df46:	4628      	mov	r0, r5
9000df48:	e79a      	b.n	9000de80 <tcp_alloc+0x14>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
9000df4a:	6a1a      	ldr	r2, [r3, #32]
9000df4c:	1aba      	subs	r2, r7, r2
9000df4e:	428a      	cmp	r2, r1
9000df50:	bf24      	itt	cs
9000df52:	4618      	movcs	r0, r3
9000df54:	4611      	movcs	r1, r2
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000df56:	68db      	ldr	r3, [r3, #12]
9000df58:	e799      	b.n	9000de8e <tcp_alloc+0x22>
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
9000df5a:	217f      	movs	r1, #127	; 0x7f
9000df5c:	e7b5      	b.n	9000deca <tcp_alloc+0x5e>
    if ((pcb->prio < mprio) ||
9000df5e:	7d57      	ldrb	r7, [r2, #21]
9000df60:	428f      	cmp	r7, r1
9000df62:	d304      	bcc.n	9000df6e <tcp_alloc+0x102>
9000df64:	d107      	bne.n	9000df76 <tcp_alloc+0x10a>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
9000df66:	6a15      	ldr	r5, [r2, #32]
9000df68:	1b75      	subs	r5, r6, r5
9000df6a:	4285      	cmp	r5, r0
9000df6c:	d303      	bcc.n	9000df76 <tcp_alloc+0x10a>
      inactivity = tcp_ticks - pcb->tmr;
9000df6e:	6a10      	ldr	r0, [r2, #32]
    if ((pcb->prio < mprio) ||
9000df70:	4639      	mov	r1, r7
      inactivity = tcp_ticks - pcb->tmr;
9000df72:	4613      	mov	r3, r2
9000df74:	1a30      	subs	r0, r6, r0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000df76:	68d2      	ldr	r2, [r2, #12]
9000df78:	e7ac      	b.n	9000ded4 <tcp_alloc+0x68>
9000df7a:	bf00      	nop
9000df7c:	2400d3b0 	.word	0x2400d3b0
9000df80:	2400d3c8 	.word	0x2400d3c8
9000df84:	2400d3c0 	.word	0x2400d3c0
9000df88:	08600860 	.word	0x08600860
9000df8c:	0218ffff 	.word	0x0218ffff
9000df90:	2400d3c5 	.word	0x2400d3c5
9000df94:	04300001 	.word	0x04300001
9000df98:	9000e149 	.word	0x9000e149
9000df9c:	006ddd00 	.word	0x006ddd00

9000dfa0 <tcp_new_ip_type>:
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
9000dfa0:	2040      	movs	r0, #64	; 0x40
9000dfa2:	f7ff bf63 	b.w	9000de6c <tcp_alloc>
	...

9000dfa8 <tcp_close_shutdown>:
{
9000dfa8:	b530      	push	{r4, r5, lr}
9000dfaa:	460d      	mov	r5, r1
9000dfac:	b085      	sub	sp, #20
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
9000dfae:	4604      	mov	r4, r0
9000dfb0:	b930      	cbnz	r0, 9000dfc0 <tcp_close_shutdown+0x18>
9000dfb2:	4b4b      	ldr	r3, [pc, #300]	; (9000e0e0 <tcp_close_shutdown+0x138>)
9000dfb4:	f44f 72af 	mov.w	r2, #350	; 0x15e
9000dfb8:	494a      	ldr	r1, [pc, #296]	; (9000e0e4 <tcp_close_shutdown+0x13c>)
9000dfba:	484b      	ldr	r0, [pc, #300]	; (9000e0e8 <tcp_close_shutdown+0x140>)
9000dfbc:	f003 fdf6 	bl	90011bac <iprintf>
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
9000dfc0:	7d23      	ldrb	r3, [r4, #20]
9000dfc2:	2d00      	cmp	r5, #0
9000dfc4:	d03f      	beq.n	9000e046 <tcp_close_shutdown+0x9e>
9000dfc6:	2b04      	cmp	r3, #4
9000dfc8:	d001      	beq.n	9000dfce <tcp_close_shutdown+0x26>
9000dfca:	2b07      	cmp	r3, #7
9000dfcc:	d13b      	bne.n	9000e046 <tcp_close_shutdown+0x9e>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
9000dfce:	6fa2      	ldr	r2, [r4, #120]	; 0x78
9000dfd0:	b91a      	cbnz	r2, 9000dfda <tcp_close_shutdown+0x32>
9000dfd2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
9000dfd4:	f5b2 6f06 	cmp.w	r2, #2144	; 0x860
9000dfd8:	d035      	beq.n	9000e046 <tcp_close_shutdown+0x9e>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
9000dfda:	8b63      	ldrh	r3, [r4, #26]
9000dfdc:	06db      	lsls	r3, r3, #27
9000dfde:	d406      	bmi.n	9000dfee <tcp_close_shutdown+0x46>
9000dfe0:	4b3f      	ldr	r3, [pc, #252]	; (9000e0e0 <tcp_close_shutdown+0x138>)
9000dfe2:	f44f 72b2 	mov.w	r2, #356	; 0x164
9000dfe6:	4941      	ldr	r1, [pc, #260]	; (9000e0ec <tcp_close_shutdown+0x144>)
9000dfe8:	483f      	ldr	r0, [pc, #252]	; (9000e0e8 <tcp_close_shutdown+0x140>)
9000dfea:	f003 fddf 	bl	90011bac <iprintf>
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
9000dfee:	8b23      	ldrh	r3, [r4, #24]
9000dff0:	4620      	mov	r0, r4
9000dff2:	9302      	str	r3, [sp, #8]
9000dff4:	8ae3      	ldrh	r3, [r4, #22]
9000dff6:	9301      	str	r3, [sp, #4]
9000dff8:	1d23      	adds	r3, r4, #4
9000dffa:	9300      	str	r3, [sp, #0]
9000dffc:	4623      	mov	r3, r4
9000dffe:	6a62      	ldr	r2, [r4, #36]	; 0x24
9000e000:	6d21      	ldr	r1, [r4, #80]	; 0x50
9000e002:	f002 fcd3 	bl	900109ac <tcp_rst>
      tcp_pcb_purge(pcb);
9000e006:	4620      	mov	r0, r4
9000e008:	f7ff fd9c 	bl	9000db44 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
9000e00c:	4a38      	ldr	r2, [pc, #224]	; (9000e0f0 <tcp_close_shutdown+0x148>)
9000e00e:	6813      	ldr	r3, [r2, #0]
9000e010:	42a3      	cmp	r3, r4
9000e012:	d110      	bne.n	9000e036 <tcp_close_shutdown+0x8e>
9000e014:	68e3      	ldr	r3, [r4, #12]
9000e016:	6013      	str	r3, [r2, #0]
9000e018:	2300      	movs	r3, #0
9000e01a:	2201      	movs	r2, #1
9000e01c:	60e3      	str	r3, [r4, #12]
9000e01e:	4b35      	ldr	r3, [pc, #212]	; (9000e0f4 <tcp_close_shutdown+0x14c>)
9000e020:	701a      	strb	r2, [r3, #0]
      if (tcp_input_pcb == pcb) {
9000e022:	4b35      	ldr	r3, [pc, #212]	; (9000e0f8 <tcp_close_shutdown+0x150>)
9000e024:	681b      	ldr	r3, [r3, #0]
9000e026:	42a3      	cmp	r3, r4
9000e028:	d11d      	bne.n	9000e066 <tcp_close_shutdown+0xbe>
        tcp_trigger_input_pcb_close();
9000e02a:	f001 fe4d 	bl	9000fcc8 <tcp_trigger_input_pcb_close>
}
9000e02e:	2000      	movs	r0, #0
9000e030:	b005      	add	sp, #20
9000e032:	bd30      	pop	{r4, r5, pc}
9000e034:	4613      	mov	r3, r2
      TCP_RMV_ACTIVE(pcb);
9000e036:	2b00      	cmp	r3, #0
9000e038:	d0ee      	beq.n	9000e018 <tcp_close_shutdown+0x70>
9000e03a:	68da      	ldr	r2, [r3, #12]
9000e03c:	42a2      	cmp	r2, r4
9000e03e:	d1f9      	bne.n	9000e034 <tcp_close_shutdown+0x8c>
9000e040:	68e2      	ldr	r2, [r4, #12]
9000e042:	60da      	str	r2, [r3, #12]
9000e044:	e7e8      	b.n	9000e018 <tcp_close_shutdown+0x70>
  switch (pcb->state) {
9000e046:	2b01      	cmp	r3, #1
9000e048:	d01a      	beq.n	9000e080 <tcp_close_shutdown+0xd8>
9000e04a:	2b02      	cmp	r3, #2
9000e04c:	d039      	beq.n	9000e0c2 <tcp_close_shutdown+0x11a>
9000e04e:	2b00      	cmp	r3, #0
9000e050:	d13f      	bne.n	9000e0d2 <tcp_close_shutdown+0x12a>
      if (pcb->local_port != 0) {
9000e052:	8ae3      	ldrh	r3, [r4, #22]
9000e054:	b13b      	cbz	r3, 9000e066 <tcp_close_shutdown+0xbe>
        TCP_RMV(&tcp_bound_pcbs, pcb);
9000e056:	4a29      	ldr	r2, [pc, #164]	; (9000e0fc <tcp_close_shutdown+0x154>)
9000e058:	6813      	ldr	r3, [r2, #0]
9000e05a:	42a3      	cmp	r3, r4
9000e05c:	d108      	bne.n	9000e070 <tcp_close_shutdown+0xc8>
9000e05e:	68e3      	ldr	r3, [r4, #12]
9000e060:	6013      	str	r3, [r2, #0]
9000e062:	2300      	movs	r3, #0
9000e064:	60e3      	str	r3, [r4, #12]
      tcp_free(pcb);
9000e066:	4620      	mov	r0, r4
9000e068:	f7ff fa96 	bl	9000d598 <tcp_free>
      break;
9000e06c:	e7df      	b.n	9000e02e <tcp_close_shutdown+0x86>
9000e06e:	4613      	mov	r3, r2
        TCP_RMV(&tcp_bound_pcbs, pcb);
9000e070:	2b00      	cmp	r3, #0
9000e072:	d0f6      	beq.n	9000e062 <tcp_close_shutdown+0xba>
9000e074:	68da      	ldr	r2, [r3, #12]
9000e076:	42a2      	cmp	r2, r4
9000e078:	d1f9      	bne.n	9000e06e <tcp_close_shutdown+0xc6>
9000e07a:	68e2      	ldr	r2, [r4, #12]
9000e07c:	60da      	str	r2, [r3, #12]
9000e07e:	e7f0      	b.n	9000e062 <tcp_close_shutdown+0xba>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
9000e080:	491f      	ldr	r1, [pc, #124]	; (9000e100 <tcp_close_shutdown+0x158>)
      pcb->listener = NULL;
9000e082:	2000      	movs	r0, #0
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
9000e084:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
9000e088:	6812      	ldr	r2, [r2, #0]
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
9000e08a:	b9a2      	cbnz	r2, 9000e0b6 <tcp_close_shutdown+0x10e>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
9000e08c:	3301      	adds	r3, #1
9000e08e:	2b04      	cmp	r3, #4
9000e090:	d1f8      	bne.n	9000e084 <tcp_close_shutdown+0xdc>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
9000e092:	4621      	mov	r1, r4
9000e094:	481b      	ldr	r0, [pc, #108]	; (9000e104 <tcp_close_shutdown+0x15c>)
9000e096:	f7ff fd87 	bl	9000dba8 <tcp_pcb_remove>
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
9000e09a:	7d23      	ldrb	r3, [r4, #20]
9000e09c:	2b01      	cmp	r3, #1
9000e09e:	d105      	bne.n	9000e0ac <tcp_close_shutdown+0x104>
9000e0a0:	4b0f      	ldr	r3, [pc, #60]	; (9000e0e0 <tcp_close_shutdown+0x138>)
9000e0a2:	22df      	movs	r2, #223	; 0xdf
9000e0a4:	4918      	ldr	r1, [pc, #96]	; (9000e108 <tcp_close_shutdown+0x160>)
9000e0a6:	4810      	ldr	r0, [pc, #64]	; (9000e0e8 <tcp_close_shutdown+0x140>)
9000e0a8:	f003 fd80 	bl	90011bac <iprintf>
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
9000e0ac:	4621      	mov	r1, r4
9000e0ae:	2002      	movs	r0, #2
9000e0b0:	f7fe f9dc 	bl	9000c46c <memp_free>
}
9000e0b4:	e7bb      	b.n	9000e02e <tcp_close_shutdown+0x86>
    if (pcb->listener == lpcb) {
9000e0b6:	6fd5      	ldr	r5, [r2, #124]	; 0x7c
9000e0b8:	42ac      	cmp	r4, r5
      pcb->listener = NULL;
9000e0ba:	bf08      	it	eq
9000e0bc:	67d0      	streq	r0, [r2, #124]	; 0x7c
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
9000e0be:	68d2      	ldr	r2, [r2, #12]
9000e0c0:	e7e3      	b.n	9000e08a <tcp_close_shutdown+0xe2>
      TCP_PCB_REMOVE_ACTIVE(pcb);
9000e0c2:	4621      	mov	r1, r4
9000e0c4:	480a      	ldr	r0, [pc, #40]	; (9000e0f0 <tcp_close_shutdown+0x148>)
9000e0c6:	f7ff fd6f 	bl	9000dba8 <tcp_pcb_remove>
9000e0ca:	4b0a      	ldr	r3, [pc, #40]	; (9000e0f4 <tcp_close_shutdown+0x14c>)
9000e0cc:	2201      	movs	r2, #1
9000e0ce:	701a      	strb	r2, [r3, #0]
9000e0d0:	e7c9      	b.n	9000e066 <tcp_close_shutdown+0xbe>
      return tcp_close_shutdown_fin(pcb);
9000e0d2:	4620      	mov	r0, r4
}
9000e0d4:	b005      	add	sp, #20
9000e0d6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      return tcp_close_shutdown_fin(pcb);
9000e0da:	f7ff ba21 	b.w	9000d520 <tcp_close_shutdown_fin>
9000e0de:	bf00      	nop
9000e0e0:	900145b3 	.word	0x900145b3
9000e0e4:	900149c6 	.word	0x900149c6
9000e0e8:	90012aff 	.word	0x90012aff
9000e0ec:	900149e6 	.word	0x900149e6
9000e0f0:	2400d3b0 	.word	0x2400d3b0
9000e0f4:	2400d3b4 	.word	0x2400d3b4
9000e0f8:	2400d3f4 	.word	0x2400d3f4
9000e0fc:	2400d3b8 	.word	0x2400d3b8
9000e100:	90014c38 	.word	0x90014c38
9000e104:	2400d3bc 	.word	0x2400d3bc
9000e108:	900149ff 	.word	0x900149ff

9000e10c <tcp_close>:
{
9000e10c:	b508      	push	{r3, lr}
  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
9000e10e:	b158      	cbz	r0, 9000e128 <tcp_close+0x1c>
  if (pcb->state != LISTEN) {
9000e110:	7d03      	ldrb	r3, [r0, #20]
  return tcp_close_shutdown(pcb, 1);
9000e112:	2101      	movs	r1, #1
  if (pcb->state != LISTEN) {
9000e114:	2b01      	cmp	r3, #1
    tcp_set_flags(pcb, TF_RXCLOSED);
9000e116:	bf1e      	ittt	ne
9000e118:	8b43      	ldrhne	r3, [r0, #26]
9000e11a:	f043 0310 	orrne.w	r3, r3, #16
9000e11e:	8343      	strhne	r3, [r0, #26]
}
9000e120:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return tcp_close_shutdown(pcb, 1);
9000e124:	f7ff bf40 	b.w	9000dfa8 <tcp_close_shutdown>
  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
9000e128:	4b04      	ldr	r3, [pc, #16]	; (9000e13c <tcp_close+0x30>)
9000e12a:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
9000e12e:	4904      	ldr	r1, [pc, #16]	; (9000e140 <tcp_close+0x34>)
9000e130:	4804      	ldr	r0, [pc, #16]	; (9000e144 <tcp_close+0x38>)
9000e132:	f003 fd3b 	bl	90011bac <iprintf>
}
9000e136:	f06f 000f 	mvn.w	r0, #15
9000e13a:	bd08      	pop	{r3, pc}
9000e13c:	900145b3 	.word	0x900145b3
9000e140:	90014a18 	.word	0x90014a18
9000e144:	90012aff 	.word	0x90012aff

9000e148 <tcp_recv_null>:
{
9000e148:	b510      	push	{r4, lr}
  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
9000e14a:	4608      	mov	r0, r1
{
9000e14c:	4614      	mov	r4, r2
  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
9000e14e:	b949      	cbnz	r1, 9000e164 <tcp_recv_null+0x1c>
9000e150:	4b0c      	ldr	r3, [pc, #48]	; (9000e184 <tcp_recv_null+0x3c>)
9000e152:	f44f 62d3 	mov.w	r2, #1688	; 0x698
9000e156:	490c      	ldr	r1, [pc, #48]	; (9000e188 <tcp_recv_null+0x40>)
9000e158:	480c      	ldr	r0, [pc, #48]	; (9000e18c <tcp_recv_null+0x44>)
9000e15a:	f003 fd27 	bl	90011bac <iprintf>
9000e15e:	f06f 000f 	mvn.w	r0, #15
}
9000e162:	bd10      	pop	{r4, pc}
  if (p != NULL) {
9000e164:	b13a      	cbz	r2, 9000e176 <tcp_recv_null+0x2e>
    tcp_recved(pcb, p->tot_len);
9000e166:	8911      	ldrh	r1, [r2, #8]
9000e168:	f7ff fb24 	bl	9000d7b4 <tcp_recved>
    pbuf_free(p);
9000e16c:	4620      	mov	r0, r4
9000e16e:	f7fe fd97 	bl	9000cca0 <pbuf_free>
  return ERR_OK;
9000e172:	2000      	movs	r0, #0
9000e174:	e7f5      	b.n	9000e162 <tcp_recv_null+0x1a>
  } else if (err == ERR_OK) {
9000e176:	b91b      	cbnz	r3, 9000e180 <tcp_recv_null+0x38>
}
9000e178:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return tcp_close(pcb);
9000e17c:	f7ff bfc6 	b.w	9000e10c <tcp_close>
  return ERR_OK;
9000e180:	4610      	mov	r0, r2
9000e182:	e7ee      	b.n	9000e162 <tcp_recv_null+0x1a>
9000e184:	900145b3 	.word	0x900145b3
9000e188:	90014a2f 	.word	0x90014a2f
9000e18c:	90012aff 	.word	0x90012aff

9000e190 <tcp_process_refused_data>:
{
9000e190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
9000e192:	4604      	mov	r4, r0
9000e194:	b950      	cbnz	r0, 9000e1ac <tcp_process_refused_data+0x1c>
9000e196:	f06f 050f 	mvn.w	r5, #15
9000e19a:	4b1c      	ldr	r3, [pc, #112]	; (9000e20c <tcp_process_refused_data+0x7c>)
9000e19c:	f240 6209 	movw	r2, #1545	; 0x609
9000e1a0:	491b      	ldr	r1, [pc, #108]	; (9000e210 <tcp_process_refused_data+0x80>)
9000e1a2:	481c      	ldr	r0, [pc, #112]	; (9000e214 <tcp_process_refused_data+0x84>)
9000e1a4:	f003 fd02 	bl	90011bac <iprintf>
}
9000e1a8:	4628      	mov	r0, r5
9000e1aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    u8_t refused_flags = pcb->refused_data->flags;
9000e1ac:	6f86      	ldr	r6, [r0, #120]	; 0x78
    pcb->refused_data = NULL;
9000e1ae:	2300      	movs	r3, #0
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
9000e1b0:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
    u8_t refused_flags = pcb->refused_data->flags;
9000e1b4:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
9000e1b6:	6783      	str	r3, [r0, #120]	; 0x78
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
9000e1b8:	b1dd      	cbz	r5, 9000e1f2 <tcp_process_refused_data+0x62>
9000e1ba:	4601      	mov	r1, r0
9000e1bc:	4632      	mov	r2, r6
9000e1be:	6900      	ldr	r0, [r0, #16]
9000e1c0:	47a8      	blx	r5
9000e1c2:	4605      	mov	r5, r0
    if (err == ERR_OK) {
9000e1c4:	b9e0      	cbnz	r0, 9000e200 <tcp_process_refused_data+0x70>
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
9000e1c6:	06bb      	lsls	r3, r7, #26
9000e1c8:	d5ee      	bpl.n	9000e1a8 <tcp_process_refused_data+0x18>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
9000e1ca:	8d23      	ldrh	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
9000e1cc:	f8d4 6084 	ldr.w	r6, [r4, #132]	; 0x84
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
9000e1d0:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
          pcb->rcv_wnd++;
9000e1d4:	bf1c      	itt	ne
9000e1d6:	3301      	addne	r3, #1
9000e1d8:	8523      	strhne	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
9000e1da:	2e00      	cmp	r6, #0
9000e1dc:	d0e4      	beq.n	9000e1a8 <tcp_process_refused_data+0x18>
9000e1de:	2300      	movs	r3, #0
9000e1e0:	4621      	mov	r1, r4
9000e1e2:	6920      	ldr	r0, [r4, #16]
9000e1e4:	461a      	mov	r2, r3
9000e1e6:	47b0      	blx	r6
        if (err == ERR_ABRT) {
9000e1e8:	300d      	adds	r0, #13
9000e1ea:	d1dd      	bne.n	9000e1a8 <tcp_process_refused_data+0x18>
          return ERR_ABRT;
9000e1ec:	f06f 050c 	mvn.w	r5, #12
9000e1f0:	e7da      	b.n	9000e1a8 <tcp_process_refused_data+0x18>
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
9000e1f2:	4601      	mov	r1, r0
9000e1f4:	462b      	mov	r3, r5
9000e1f6:	4632      	mov	r2, r6
9000e1f8:	4628      	mov	r0, r5
9000e1fa:	f7ff ffa5 	bl	9000e148 <tcp_recv_null>
9000e1fe:	e7e0      	b.n	9000e1c2 <tcp_process_refused_data+0x32>
    } else if (err == ERR_ABRT) {
9000e200:	350d      	adds	r5, #13
9000e202:	d0f3      	beq.n	9000e1ec <tcp_process_refused_data+0x5c>
      return ERR_INPROGRESS;
9000e204:	f06f 0504 	mvn.w	r5, #4
      pcb->refused_data = refused_data;
9000e208:	67a6      	str	r6, [r4, #120]	; 0x78
      return ERR_INPROGRESS;
9000e20a:	e7cd      	b.n	9000e1a8 <tcp_process_refused_data+0x18>
9000e20c:	900145b3 	.word	0x900145b3
9000e210:	90014a4a 	.word	0x90014a4a
9000e214:	90012aff 	.word	0x90012aff

9000e218 <tcp_fasttmr>:
{
9000e218:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ++tcp_timer_ctr;
9000e21c:	4d1b      	ldr	r5, [pc, #108]	; (9000e28c <tcp_fasttmr+0x74>)
  pcb = tcp_active_pcbs;
9000e21e:	4f1c      	ldr	r7, [pc, #112]	; (9000e290 <tcp_fasttmr+0x78>)
  ++tcp_timer_ctr;
9000e220:	782b      	ldrb	r3, [r5, #0]
        tcp_active_pcbs_changed = 0;
9000e222:	4e1c      	ldr	r6, [pc, #112]	; (9000e294 <tcp_fasttmr+0x7c>)
  ++tcp_timer_ctr;
9000e224:	3301      	adds	r3, #1
9000e226:	702b      	strb	r3, [r5, #0]
  pcb = tcp_active_pcbs;
9000e228:	683c      	ldr	r4, [r7, #0]
        tcp_active_pcbs_changed = 0;
9000e22a:	f04f 0800 	mov.w	r8, #0
  while (pcb != NULL) {
9000e22e:	b90c      	cbnz	r4, 9000e234 <tcp_fasttmr+0x1c>
}
9000e230:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (pcb->last_timer != tcp_timer_ctr) {
9000e234:	782b      	ldrb	r3, [r5, #0]
9000e236:	7fa2      	ldrb	r2, [r4, #30]
9000e238:	429a      	cmp	r2, r3
9000e23a:	d024      	beq.n	9000e286 <tcp_fasttmr+0x6e>
      pcb->last_timer = tcp_timer_ctr;
9000e23c:	77a3      	strb	r3, [r4, #30]
      if (pcb->flags & TF_ACK_DELAY) {
9000e23e:	8b63      	ldrh	r3, [r4, #26]
9000e240:	07d9      	lsls	r1, r3, #31
9000e242:	d509      	bpl.n	9000e258 <tcp_fasttmr+0x40>
        tcp_ack_now(pcb);
9000e244:	f043 0302 	orr.w	r3, r3, #2
        tcp_output(pcb);
9000e248:	4620      	mov	r0, r4
        tcp_ack_now(pcb);
9000e24a:	8363      	strh	r3, [r4, #26]
        tcp_output(pcb);
9000e24c:	f002 fc26 	bl	90010a9c <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
9000e250:	8b63      	ldrh	r3, [r4, #26]
9000e252:	f023 0303 	bic.w	r3, r3, #3
9000e256:	8363      	strh	r3, [r4, #26]
      if (pcb->flags & TF_CLOSEPEND) {
9000e258:	8b63      	ldrh	r3, [r4, #26]
9000e25a:	071a      	lsls	r2, r3, #28
9000e25c:	d505      	bpl.n	9000e26a <tcp_fasttmr+0x52>
        tcp_clear_flags(pcb, TF_CLOSEPEND);
9000e25e:	f023 0308 	bic.w	r3, r3, #8
        tcp_close_shutdown_fin(pcb);
9000e262:	4620      	mov	r0, r4
        tcp_clear_flags(pcb, TF_CLOSEPEND);
9000e264:	8363      	strh	r3, [r4, #26]
        tcp_close_shutdown_fin(pcb);
9000e266:	f7ff f95b 	bl	9000d520 <tcp_close_shutdown_fin>
      if (pcb->refused_data != NULL) {
9000e26a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
      next = pcb->next;
9000e26c:	f8d4 900c 	ldr.w	r9, [r4, #12]
      if (pcb->refused_data != NULL) {
9000e270:	b13b      	cbz	r3, 9000e282 <tcp_fasttmr+0x6a>
        tcp_process_refused_data(pcb);
9000e272:	4620      	mov	r0, r4
        tcp_active_pcbs_changed = 0;
9000e274:	f886 8000 	strb.w	r8, [r6]
        tcp_process_refused_data(pcb);
9000e278:	f7ff ff8a 	bl	9000e190 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
9000e27c:	7833      	ldrb	r3, [r6, #0]
9000e27e:	2b00      	cmp	r3, #0
9000e280:	d1d2      	bne.n	9000e228 <tcp_fasttmr+0x10>
{
9000e282:	464c      	mov	r4, r9
9000e284:	e7d3      	b.n	9000e22e <tcp_fasttmr+0x16>
      pcb = pcb->next;
9000e286:	f8d4 900c 	ldr.w	r9, [r4, #12]
9000e28a:	e7fa      	b.n	9000e282 <tcp_fasttmr+0x6a>
9000e28c:	2400d3c5 	.word	0x2400d3c5
9000e290:	2400d3b0 	.word	0x2400d3b0
9000e294:	2400d3b4 	.word	0x2400d3b4

9000e298 <tcp_slowtmr>:
{
9000e298:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ++tcp_ticks;
9000e29c:	4e91      	ldr	r6, [pc, #580]	; (9000e4e4 <tcp_slowtmr+0x24c>)
{
9000e29e:	b087      	sub	sp, #28
  ++tcp_timer_ctr;
9000e2a0:	4a91      	ldr	r2, [pc, #580]	; (9000e4e8 <tcp_slowtmr+0x250>)
  ++tcp_ticks;
9000e2a2:	6833      	ldr	r3, [r6, #0]
  pcb = tcp_active_pcbs;
9000e2a4:	f8df a26c 	ldr.w	sl, [pc, #620]	; 9000e514 <tcp_slowtmr+0x27c>
  ++tcp_ticks;
9000e2a8:	3301      	adds	r3, #1
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
9000e2aa:	4f90      	ldr	r7, [pc, #576]	; (9000e4ec <tcp_slowtmr+0x254>)
  ++tcp_ticks;
9000e2ac:	6033      	str	r3, [r6, #0]
  ++tcp_timer_ctr;
9000e2ae:	7813      	ldrb	r3, [r2, #0]
9000e2b0:	3301      	adds	r3, #1
9000e2b2:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
9000e2b4:	f8da 4000 	ldr.w	r4, [sl]
  prev = NULL;
9000e2b8:	f04f 0900 	mov.w	r9, #0
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
9000e2bc:	f8df 8258 	ldr.w	r8, [pc, #600]	; 9000e518 <tcp_slowtmr+0x280>
  while (pcb != NULL) {
9000e2c0:	b96c      	cbnz	r4, 9000e2de <tcp_slowtmr+0x46>
  pcb = tcp_tw_pcbs;
9000e2c2:	4f8b      	ldr	r7, [pc, #556]	; (9000e4f0 <tcp_slowtmr+0x258>)
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000e2c4:	f8df 8224 	ldr.w	r8, [pc, #548]	; 9000e4ec <tcp_slowtmr+0x254>
  pcb = tcp_tw_pcbs;
9000e2c8:	683d      	ldr	r5, [r7, #0]
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000e2ca:	f8df a250 	ldr.w	sl, [pc, #592]	; 9000e51c <tcp_slowtmr+0x284>
9000e2ce:	f8df 9248 	ldr.w	r9, [pc, #584]	; 9000e518 <tcp_slowtmr+0x280>
  while (pcb != NULL) {
9000e2d2:	2d00      	cmp	r5, #0
9000e2d4:	f040 81bb 	bne.w	9000e64e <tcp_slowtmr+0x3b6>
}
9000e2d8:	b007      	add	sp, #28
9000e2da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
9000e2de:	7d23      	ldrb	r3, [r4, #20]
9000e2e0:	b933      	cbnz	r3, 9000e2f0 <tcp_slowtmr+0x58>
9000e2e2:	463b      	mov	r3, r7
9000e2e4:	f240 42be 	movw	r2, #1214	; 0x4be
9000e2e8:	4982      	ldr	r1, [pc, #520]	; (9000e4f4 <tcp_slowtmr+0x25c>)
9000e2ea:	4640      	mov	r0, r8
9000e2ec:	f003 fc5e 	bl	90011bac <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
9000e2f0:	7d23      	ldrb	r3, [r4, #20]
9000e2f2:	2b01      	cmp	r3, #1
9000e2f4:	d106      	bne.n	9000e304 <tcp_slowtmr+0x6c>
9000e2f6:	463b      	mov	r3, r7
9000e2f8:	f240 42bf 	movw	r2, #1215	; 0x4bf
9000e2fc:	497e      	ldr	r1, [pc, #504]	; (9000e4f8 <tcp_slowtmr+0x260>)
9000e2fe:	4640      	mov	r0, r8
9000e300:	f003 fc54 	bl	90011bac <iprintf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
9000e304:	7d23      	ldrb	r3, [r4, #20]
9000e306:	2b0a      	cmp	r3, #10
9000e308:	d106      	bne.n	9000e318 <tcp_slowtmr+0x80>
9000e30a:	463b      	mov	r3, r7
9000e30c:	f44f 6298 	mov.w	r2, #1216	; 0x4c0
9000e310:	497a      	ldr	r1, [pc, #488]	; (9000e4fc <tcp_slowtmr+0x264>)
9000e312:	4640      	mov	r0, r8
9000e314:	f003 fc4a 	bl	90011bac <iprintf>
    if (pcb->last_timer == tcp_timer_ctr) {
9000e318:	4b73      	ldr	r3, [pc, #460]	; (9000e4e8 <tcp_slowtmr+0x250>)
9000e31a:	7fa2      	ldrb	r2, [r4, #30]
9000e31c:	781b      	ldrb	r3, [r3, #0]
9000e31e:	429a      	cmp	r2, r3
9000e320:	d103      	bne.n	9000e32a <tcp_slowtmr+0x92>
      pcb = pcb->next;
9000e322:	68e5      	ldr	r5, [r4, #12]
      continue;
9000e324:	46a1      	mov	r9, r4
9000e326:	462c      	mov	r4, r5
9000e328:	e7ca      	b.n	9000e2c0 <tcp_slowtmr+0x28>
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
9000e32a:	7d22      	ldrb	r2, [r4, #20]
    pcb->last_timer = tcp_timer_ctr;
9000e32c:	77a3      	strb	r3, [r4, #30]
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
9000e32e:	2a02      	cmp	r2, #2
9000e330:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
9000e334:	f040 8089 	bne.w	9000e44a <tcp_slowtmr+0x1b2>
9000e338:	2b05      	cmp	r3, #5
9000e33a:	f240 8088 	bls.w	9000e44e <tcp_slowtmr+0x1b6>
      ++pcb_remove;
9000e33e:	f04f 0b01 	mov.w	fp, #1
    if (pcb->state == FIN_WAIT_2) {
9000e342:	7d22      	ldrb	r2, [r4, #20]
9000e344:	2a06      	cmp	r2, #6
9000e346:	d10b      	bne.n	9000e360 <tcp_slowtmr+0xc8>
      if (pcb->flags & TF_RXCLOSED) {
9000e348:	8b61      	ldrh	r1, [r4, #26]
9000e34a:	06cb      	lsls	r3, r1, #27
9000e34c:	d508      	bpl.n	9000e360 <tcp_slowtmr+0xc8>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e34e:	6831      	ldr	r1, [r6, #0]
9000e350:	6a20      	ldr	r0, [r4, #32]
9000e352:	1a09      	subs	r1, r1, r0
9000e354:	2928      	cmp	r1, #40	; 0x28
          ++pcb_remove;
9000e356:	bf84      	itt	hi
9000e358:	f10b 0301 	addhi.w	r3, fp, #1
9000e35c:	fa5f fb83 	uxtbhi.w	fp, r3
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
9000e360:	7a65      	ldrb	r5, [r4, #9]
9000e362:	f015 0508 	ands.w	r5, r5, #8
9000e366:	d019      	beq.n	9000e39c <tcp_slowtmr+0x104>
9000e368:	2a04      	cmp	r2, #4
9000e36a:	d002      	beq.n	9000e372 <tcp_slowtmr+0xda>
        ((pcb->state == ESTABLISHED) ||
9000e36c:	2a07      	cmp	r2, #7
9000e36e:	f040 8135 	bne.w	9000e5dc <tcp_slowtmr+0x344>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e372:	6a22      	ldr	r2, [r4, #32]
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
9000e374:	f44f 75fa 	mov.w	r5, #500	; 0x1f4
      if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e378:	6830      	ldr	r0, [r6, #0]
9000e37a:	1a80      	subs	r0, r0, r2
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
9000e37c:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
9000e380:	f502 2124 	add.w	r1, r2, #671744	; 0xa4000
9000e384:	f601 41b8 	addw	r1, r1, #3256	; 0xcb8
9000e388:	fbb1 f1f5 	udiv	r1, r1, r5
      if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e38c:	4288      	cmp	r0, r1
9000e38e:	f240 8113 	bls.w	9000e5b8 <tcp_slowtmr+0x320>
        ++pcb_remove;
9000e392:	f10b 0301 	add.w	r3, fp, #1
        ++pcb_reset;
9000e396:	2501      	movs	r5, #1
        ++pcb_remove;
9000e398:	fa5f fb83 	uxtb.w	fp, r3
    if (pcb->ooseq != NULL &&
9000e39c:	6f62      	ldr	r2, [r4, #116]	; 0x74
9000e39e:	b162      	cbz	r2, 9000e3ba <tcp_slowtmr+0x122>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
9000e3a0:	6832      	ldr	r2, [r6, #0]
9000e3a2:	6a21      	ldr	r1, [r4, #32]
9000e3a4:	1a51      	subs	r1, r2, r1
9000e3a6:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
9000e3aa:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    if (pcb->ooseq != NULL &&
9000e3ae:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
9000e3b2:	d302      	bcc.n	9000e3ba <tcp_slowtmr+0x122>
      tcp_free_ooseq(pcb);
9000e3b4:	4620      	mov	r0, r4
9000e3b6:	f7ff fbbb 	bl	9000db30 <tcp_free_ooseq>
    if (pcb->state == SYN_RCVD) {
9000e3ba:	7d22      	ldrb	r2, [r4, #20]
9000e3bc:	2a03      	cmp	r2, #3
9000e3be:	f040 810f 	bne.w	9000e5e0 <tcp_slowtmr+0x348>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e3c2:	6832      	ldr	r2, [r6, #0]
9000e3c4:	6a21      	ldr	r1, [r4, #32]
9000e3c6:	1a52      	subs	r2, r2, r1
9000e3c8:	2a28      	cmp	r2, #40	; 0x28
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
9000e3ca:	d803      	bhi.n	9000e3d4 <tcp_slowtmr+0x13c>
    if (pcb_remove) {
9000e3cc:	f1bb 0f00 	cmp.w	fp, #0
9000e3d0:	f000 811b 	beq.w	9000e60a <tcp_slowtmr+0x372>
      tcp_pcb_purge(pcb);
9000e3d4:	4620      	mov	r0, r4
      tcp_err_fn err_fn = pcb->errf;
9000e3d6:	f8d4 b090 	ldr.w	fp, [r4, #144]	; 0x90
      tcp_pcb_purge(pcb);
9000e3da:	f7ff fbb3 	bl	9000db44 <tcp_pcb_purge>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
9000e3de:	f8da 3000 	ldr.w	r3, [sl]
      if (prev != NULL) {
9000e3e2:	f1b9 0f00 	cmp.w	r9, #0
9000e3e6:	f000 8103 	beq.w	9000e5f0 <tcp_slowtmr+0x358>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
9000e3ea:	42a3      	cmp	r3, r4
9000e3ec:	d106      	bne.n	9000e3fc <tcp_slowtmr+0x164>
9000e3ee:	463b      	mov	r3, r7
9000e3f0:	f240 526d 	movw	r2, #1389	; 0x56d
9000e3f4:	4942      	ldr	r1, [pc, #264]	; (9000e500 <tcp_slowtmr+0x268>)
9000e3f6:	4640      	mov	r0, r8
9000e3f8:	f003 fbd8 	bl	90011bac <iprintf>
        prev->next = pcb->next;
9000e3fc:	68e3      	ldr	r3, [r4, #12]
9000e3fe:	f8c9 300c 	str.w	r3, [r9, #12]
      if (pcb_reset) {
9000e402:	b15d      	cbz	r5, 9000e41c <tcp_slowtmr+0x184>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
9000e404:	8b23      	ldrh	r3, [r4, #24]
9000e406:	4620      	mov	r0, r4
9000e408:	9302      	str	r3, [sp, #8]
9000e40a:	8ae3      	ldrh	r3, [r4, #22]
9000e40c:	9301      	str	r3, [sp, #4]
9000e40e:	1d23      	adds	r3, r4, #4
9000e410:	9300      	str	r3, [sp, #0]
9000e412:	4623      	mov	r3, r4
9000e414:	6a62      	ldr	r2, [r4, #36]	; 0x24
9000e416:	6d21      	ldr	r1, [r4, #80]	; 0x50
9000e418:	f002 fac8 	bl	900109ac <tcp_rst>
      err_arg = pcb->callback_arg;
9000e41c:	6923      	ldr	r3, [r4, #16]
      tcp_free(pcb2);
9000e41e:	4620      	mov	r0, r4
      pcb = pcb->next;
9000e420:	68e5      	ldr	r5, [r4, #12]
      err_arg = pcb->callback_arg;
9000e422:	9305      	str	r3, [sp, #20]
      tcp_free(pcb2);
9000e424:	f7ff f8b8 	bl	9000d598 <tcp_free>
      tcp_active_pcbs_changed = 0;
9000e428:	4c36      	ldr	r4, [pc, #216]	; (9000e504 <tcp_slowtmr+0x26c>)
9000e42a:	2200      	movs	r2, #0
9000e42c:	7022      	strb	r2, [r4, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
9000e42e:	f1bb 0f00 	cmp.w	fp, #0
9000e432:	d008      	beq.n	9000e446 <tcp_slowtmr+0x1ae>
9000e434:	9b05      	ldr	r3, [sp, #20]
9000e436:	f06f 010c 	mvn.w	r1, #12
9000e43a:	4618      	mov	r0, r3
9000e43c:	47d8      	blx	fp
      if (tcp_active_pcbs_changed) {
9000e43e:	7823      	ldrb	r3, [r4, #0]
9000e440:	2b00      	cmp	r3, #0
9000e442:	f47f af37 	bne.w	9000e2b4 <tcp_slowtmr+0x1c>
9000e446:	464c      	mov	r4, r9
9000e448:	e76c      	b.n	9000e324 <tcp_slowtmr+0x8c>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
9000e44a:	2b0b      	cmp	r3, #11
9000e44c:	e775      	b.n	9000e33a <tcp_slowtmr+0xa2>
      if (pcb->persist_backoff > 0) {
9000e44e:	f894 b099 	ldrb.w	fp, [r4, #153]	; 0x99
9000e452:	f1bb 0f00 	cmp.w	fp, #0
9000e456:	d063      	beq.n	9000e520 <tcp_slowtmr+0x288>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
9000e458:	6f23      	ldr	r3, [r4, #112]	; 0x70
9000e45a:	b133      	cbz	r3, 9000e46a <tcp_slowtmr+0x1d2>
9000e45c:	463b      	mov	r3, r7
9000e45e:	f240 42d4 	movw	r2, #1236	; 0x4d4
9000e462:	4929      	ldr	r1, [pc, #164]	; (9000e508 <tcp_slowtmr+0x270>)
9000e464:	4640      	mov	r0, r8
9000e466:	f003 fba1 	bl	90011bac <iprintf>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
9000e46a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000e46c:	b933      	cbnz	r3, 9000e47c <tcp_slowtmr+0x1e4>
9000e46e:	463b      	mov	r3, r7
9000e470:	f240 42d5 	movw	r2, #1237	; 0x4d5
9000e474:	4925      	ldr	r1, [pc, #148]	; (9000e50c <tcp_slowtmr+0x274>)
9000e476:	4640      	mov	r0, r8
9000e478:	f003 fb98 	bl	90011bac <iprintf>
        if (pcb->persist_probe >= TCP_MAXRTX) {
9000e47c:	f894 309a 	ldrb.w	r3, [r4, #154]	; 0x9a
9000e480:	2b0b      	cmp	r3, #11
9000e482:	f63f af5c 	bhi.w	9000e33e <tcp_slowtmr+0xa6>
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
9000e486:	f894 2099 	ldrb.w	r2, [r4, #153]	; 0x99
9000e48a:	4b21      	ldr	r3, [pc, #132]	; (9000e510 <tcp_slowtmr+0x278>)
9000e48c:	4413      	add	r3, r2
9000e48e:	f813 2c01 	ldrb.w	r2, [r3, #-1]
          if (pcb->persist_cnt < backoff_cnt) {
9000e492:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
9000e496:	4293      	cmp	r3, r2
9000e498:	d30b      	bcc.n	9000e4b2 <tcp_slowtmr+0x21a>
            if (pcb->snd_wnd == 0) {
9000e49a:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
9000e49e:	b189      	cbz	r1, 9000e4c4 <tcp_slowtmr+0x22c>
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
9000e4a0:	4620      	mov	r0, r4
9000e4a2:	f002 f83b 	bl	9001051c <tcp_split_unsent_seg>
9000e4a6:	b990      	cbnz	r0, 9000e4ce <tcp_slowtmr+0x236>
                if (tcp_output(pcb) == ERR_OK) {
9000e4a8:	4620      	mov	r0, r4
9000e4aa:	f002 faf7 	bl	90010a9c <tcp_output>
9000e4ae:	b130      	cbz	r0, 9000e4be <tcp_slowtmr+0x226>
9000e4b0:	e00d      	b.n	9000e4ce <tcp_slowtmr+0x236>
            pcb->persist_cnt++;
9000e4b2:	3301      	adds	r3, #1
9000e4b4:	b2db      	uxtb	r3, r3
          if (pcb->persist_cnt >= backoff_cnt) {
9000e4b6:	4293      	cmp	r3, r2
            pcb->persist_cnt++;
9000e4b8:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
          if (pcb->persist_cnt >= backoff_cnt) {
9000e4bc:	d2ed      	bcs.n	9000e49a <tcp_slowtmr+0x202>
    pcb_remove = 0;
9000e4be:	f04f 0b00 	mov.w	fp, #0
9000e4c2:	e73e      	b.n	9000e342 <tcp_slowtmr+0xaa>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
9000e4c4:	4620      	mov	r0, r4
9000e4c6:	f002 fcf1 	bl	90010eac <tcp_zero_window_probe>
9000e4ca:	2800      	cmp	r0, #0
9000e4cc:	d1f7      	bne.n	9000e4be <tcp_slowtmr+0x226>
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
9000e4ce:	f894 2099 	ldrb.w	r2, [r4, #153]	; 0x99
              pcb->persist_cnt = 0;
9000e4d2:	2300      	movs	r3, #0
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
9000e4d4:	2a06      	cmp	r2, #6
              pcb->persist_cnt = 0;
9000e4d6:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
9000e4da:	d8f0      	bhi.n	9000e4be <tcp_slowtmr+0x226>
                pcb->persist_backoff++;
9000e4dc:	3201      	adds	r2, #1
9000e4de:	f884 2099 	strb.w	r2, [r4, #153]	; 0x99
9000e4e2:	e7ec      	b.n	9000e4be <tcp_slowtmr+0x226>
9000e4e4:	2400d3c0 	.word	0x2400d3c0
9000e4e8:	2400d3c5 	.word	0x2400d3c5
9000e4ec:	900145b3 	.word	0x900145b3
9000e4f0:	2400d3c8 	.word	0x2400d3c8
9000e4f4:	90014a70 	.word	0x90014a70
9000e4f8:	90014a9a 	.word	0x90014a9a
9000e4fc:	90014ac4 	.word	0x90014ac4
9000e500:	90014b58 	.word	0x90014b58
9000e504:	2400d3b4 	.word	0x2400d3b4
9000e508:	90014af1 	.word	0x90014af1
9000e50c:	90014b23 	.word	0x90014b23
9000e510:	90014c48 	.word	0x90014c48
9000e514:	2400d3b0 	.word	0x2400d3b0
9000e518:	90012aff 	.word	0x90012aff
9000e51c:	90014bad 	.word	0x90014bad
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
9000e520:	8e22      	ldrh	r2, [r4, #48]	; 0x30
9000e522:	f647 71fe 	movw	r1, #32766	; 0x7ffe
9000e526:	428a      	cmp	r2, r1
          ++pcb->rtime;
9000e528:	bf9c      	itt	ls
9000e52a:	3201      	addls	r2, #1
9000e52c:	8622      	strhls	r2, [r4, #48]	; 0x30
        if (pcb->rtime >= pcb->rto) {
9000e52e:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
9000e532:	f9b4 1030 	ldrsh.w	r1, [r4, #48]	; 0x30
9000e536:	4291      	cmp	r1, r2
9000e538:	dbc1      	blt.n	9000e4be <tcp_slowtmr+0x226>
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
9000e53a:	4620      	mov	r0, r4
9000e53c:	f002 f97e 	bl	9001083c <tcp_rexmit_rto_prepare>
9000e540:	b128      	cbz	r0, 9000e54e <tcp_slowtmr+0x2b6>
9000e542:	6f22      	ldr	r2, [r4, #112]	; 0x70
9000e544:	2a00      	cmp	r2, #0
9000e546:	d1ba      	bne.n	9000e4be <tcp_slowtmr+0x226>
9000e548:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
9000e54a:	2a00      	cmp	r2, #0
9000e54c:	d0b7      	beq.n	9000e4be <tcp_slowtmr+0x226>
            if (pcb->state != SYN_SENT) {
9000e54e:	7d22      	ldrb	r2, [r4, #20]
9000e550:	2a02      	cmp	r2, #2
9000e552:	d014      	beq.n	9000e57e <tcp_slowtmr+0x2e6>
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
9000e554:	f9b4 103c 	ldrsh.w	r1, [r4, #60]	; 0x3c
9000e558:	f9b4 203e 	ldrsh.w	r2, [r4, #62]	; 0x3e
9000e55c:	4857      	ldr	r0, [pc, #348]	; (9000e6bc <tcp_slowtmr+0x424>)
9000e55e:	eb02 02e1 	add.w	r2, r2, r1, asr #3
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
9000e562:	f894 1042 	ldrb.w	r1, [r4, #66]	; 0x42
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
9000e566:	290c      	cmp	r1, #12
9000e568:	bf28      	it	cs
9000e56a:	210c      	movcs	r1, #12
9000e56c:	5c41      	ldrb	r1, [r0, r1]
9000e56e:	408a      	lsls	r2, r1
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
9000e570:	f647 71ff 	movw	r1, #32767	; 0x7fff
9000e574:	428a      	cmp	r2, r1
9000e576:	bfa8      	it	ge
9000e578:	460a      	movge	r2, r1
9000e57a:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
9000e57e:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
            pcb->rtime = 0;
9000e582:	2500      	movs	r5, #0
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
9000e584:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
9000e588:	f8b4 c032 	ldrh.w	ip, [r4, #50]	; 0x32
            pcb->ssthresh = eff_wnd >> 1;
9000e58c:	4291      	cmp	r1, r2
            pcb->rtime = 0;
9000e58e:	8625      	strh	r5, [r4, #48]	; 0x30
            pcb->cwnd = pcb->mss;
9000e590:	f8a4 c048 	strh.w	ip, [r4, #72]	; 0x48
            pcb->ssthresh = eff_wnd >> 1;
9000e594:	bf28      	it	cs
9000e596:	4611      	movcs	r1, r2
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
9000e598:	ea4f 024c 	mov.w	r2, ip, lsl #1
            pcb->bytes_acked = 0;
9000e59c:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
9000e5a0:	b292      	uxth	r2, r2
            pcb->ssthresh = eff_wnd >> 1;
9000e5a2:	0848      	lsrs	r0, r1, #1
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
9000e5a4:	ebb2 0f51 	cmp.w	r2, r1, lsr #1
9000e5a8:	bf98      	it	ls
9000e5aa:	4602      	movls	r2, r0
            tcp_rexmit_rto_commit(pcb);
9000e5ac:	4620      	mov	r0, r4
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
9000e5ae:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
            tcp_rexmit_rto_commit(pcb);
9000e5b2:	f002 fc1d 	bl	90010df0 <tcp_rexmit_rto_commit>
9000e5b6:	e6c4      	b.n	9000e342 <tcp_slowtmr+0xaa>
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
9000e5b8:	f894 109b 	ldrb.w	r1, [r4, #155]	; 0x9b
9000e5bc:	4b40      	ldr	r3, [pc, #256]	; (9000e6c0 <tcp_slowtmr+0x428>)
9000e5be:	fb03 2201 	mla	r2, r3, r1, r2
                 / TCP_SLOW_INTERVAL) {
9000e5c2:	fbb2 f2f5 	udiv	r2, r2, r5
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
9000e5c6:	4290      	cmp	r0, r2
9000e5c8:	d908      	bls.n	9000e5dc <tcp_slowtmr+0x344>
        err = tcp_keepalive(pcb);
9000e5ca:	4620      	mov	r0, r4
9000e5cc:	f002 fc46 	bl	90010e5c <tcp_keepalive>
        if (err == ERR_OK) {
9000e5d0:	b920      	cbnz	r0, 9000e5dc <tcp_slowtmr+0x344>
          pcb->keep_cnt_sent++;
9000e5d2:	f894 209b 	ldrb.w	r2, [r4, #155]	; 0x9b
9000e5d6:	3201      	adds	r2, #1
9000e5d8:	f884 209b 	strb.w	r2, [r4, #155]	; 0x9b
    pcb_reset = 0;
9000e5dc:	2500      	movs	r5, #0
9000e5de:	e6dd      	b.n	9000e39c <tcp_slowtmr+0x104>
    if (pcb->state == LAST_ACK) {
9000e5e0:	2a09      	cmp	r2, #9
9000e5e2:	f47f aef3 	bne.w	9000e3cc <tcp_slowtmr+0x134>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
9000e5e6:	6832      	ldr	r2, [r6, #0]
9000e5e8:	6a21      	ldr	r1, [r4, #32]
9000e5ea:	1a52      	subs	r2, r2, r1
9000e5ec:	2af0      	cmp	r2, #240	; 0xf0
9000e5ee:	e6ec      	b.n	9000e3ca <tcp_slowtmr+0x132>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
9000e5f0:	42a3      	cmp	r3, r4
9000e5f2:	d006      	beq.n	9000e602 <tcp_slowtmr+0x36a>
9000e5f4:	463b      	mov	r3, r7
9000e5f6:	f240 5271 	movw	r2, #1393	; 0x571
9000e5fa:	4932      	ldr	r1, [pc, #200]	; (9000e6c4 <tcp_slowtmr+0x42c>)
9000e5fc:	4640      	mov	r0, r8
9000e5fe:	f003 fad5 	bl	90011bac <iprintf>
        tcp_active_pcbs = pcb->next;
9000e602:	68e3      	ldr	r3, [r4, #12]
9000e604:	f8ca 3000 	str.w	r3, [sl]
9000e608:	e6fb      	b.n	9000e402 <tcp_slowtmr+0x16a>
      ++prev->polltmr;
9000e60a:	7f22      	ldrb	r2, [r4, #28]
      if (prev->polltmr >= prev->pollinterval) {
9000e60c:	7f61      	ldrb	r1, [r4, #29]
      ++prev->polltmr;
9000e60e:	3201      	adds	r2, #1
      pcb = pcb->next;
9000e610:	68e5      	ldr	r5, [r4, #12]
      ++prev->polltmr;
9000e612:	b2d2      	uxtb	r2, r2
      if (prev->polltmr >= prev->pollinterval) {
9000e614:	4291      	cmp	r1, r2
      ++prev->polltmr;
9000e616:	7722      	strb	r2, [r4, #28]
      if (prev->polltmr >= prev->pollinterval) {
9000e618:	f63f ae84 	bhi.w	9000e324 <tcp_slowtmr+0x8c>
        tcp_active_pcbs_changed = 0;
9000e61c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 9000e6d0 <tcp_slowtmr+0x438>
        TCP_EVENT_POLL(prev, err);
9000e620:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
        prev->polltmr = 0;
9000e624:	f884 b01c 	strb.w	fp, [r4, #28]
        tcp_active_pcbs_changed = 0;
9000e628:	f889 b000 	strb.w	fp, [r9]
        TCP_EVENT_POLL(prev, err);
9000e62c:	b91b      	cbnz	r3, 9000e636 <tcp_slowtmr+0x39e>
          tcp_output(prev);
9000e62e:	4620      	mov	r0, r4
9000e630:	f002 fa34 	bl	90010a9c <tcp_output>
9000e634:	e676      	b.n	9000e324 <tcp_slowtmr+0x8c>
        TCP_EVENT_POLL(prev, err);
9000e636:	4621      	mov	r1, r4
9000e638:	6920      	ldr	r0, [r4, #16]
9000e63a:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
9000e63c:	f899 3000 	ldrb.w	r3, [r9]
9000e640:	2b00      	cmp	r3, #0
9000e642:	f47f ae37 	bne.w	9000e2b4 <tcp_slowtmr+0x1c>
        if (err == ERR_OK) {
9000e646:	2800      	cmp	r0, #0
9000e648:	f47f ae6c 	bne.w	9000e324 <tcp_slowtmr+0x8c>
9000e64c:	e7ef      	b.n	9000e62e <tcp_slowtmr+0x396>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000e64e:	7d2b      	ldrb	r3, [r5, #20]
9000e650:	2b0a      	cmp	r3, #10
9000e652:	d006      	beq.n	9000e662 <tcp_slowtmr+0x3ca>
9000e654:	4643      	mov	r3, r8
9000e656:	f240 52a1 	movw	r2, #1441	; 0x5a1
9000e65a:	4651      	mov	r1, sl
9000e65c:	4648      	mov	r0, r9
9000e65e:	f003 faa5 	bl	90011bac <iprintf>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
9000e662:	6833      	ldr	r3, [r6, #0]
9000e664:	6a2a      	ldr	r2, [r5, #32]
9000e666:	1a9b      	subs	r3, r3, r2
9000e668:	2bf0      	cmp	r3, #240	; 0xf0
9000e66a:	d910      	bls.n	9000e68e <tcp_slowtmr+0x3f6>
      tcp_pcb_purge(pcb);
9000e66c:	4628      	mov	r0, r5
9000e66e:	f7ff fa69 	bl	9000db44 <tcp_pcb_purge>
      if (prev != NULL) {
9000e672:	b97c      	cbnz	r4, 9000e694 <tcp_slowtmr+0x3fc>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
9000e674:	683b      	ldr	r3, [r7, #0]
9000e676:	42ab      	cmp	r3, r5
9000e678:	d006      	beq.n	9000e688 <tcp_slowtmr+0x3f0>
9000e67a:	4643      	mov	r3, r8
9000e67c:	f240 52b3 	movw	r2, #1459	; 0x5b3
9000e680:	4911      	ldr	r1, [pc, #68]	; (9000e6c8 <tcp_slowtmr+0x430>)
9000e682:	4648      	mov	r0, r9
9000e684:	f003 fa92 	bl	90011bac <iprintf>
        tcp_tw_pcbs = pcb->next;
9000e688:	68eb      	ldr	r3, [r5, #12]
9000e68a:	603b      	str	r3, [r7, #0]
9000e68c:	e00e      	b.n	9000e6ac <tcp_slowtmr+0x414>
      pcb = pcb->next;
9000e68e:	462c      	mov	r4, r5
9000e690:	68ed      	ldr	r5, [r5, #12]
9000e692:	e61e      	b.n	9000e2d2 <tcp_slowtmr+0x3a>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
9000e694:	683b      	ldr	r3, [r7, #0]
9000e696:	42ab      	cmp	r3, r5
9000e698:	d106      	bne.n	9000e6a8 <tcp_slowtmr+0x410>
9000e69a:	4643      	mov	r3, r8
9000e69c:	f240 52af 	movw	r2, #1455	; 0x5af
9000e6a0:	490a      	ldr	r1, [pc, #40]	; (9000e6cc <tcp_slowtmr+0x434>)
9000e6a2:	4648      	mov	r0, r9
9000e6a4:	f003 fa82 	bl	90011bac <iprintf>
        prev->next = pcb->next;
9000e6a8:	68eb      	ldr	r3, [r5, #12]
9000e6aa:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
9000e6ac:	f8d5 b00c 	ldr.w	fp, [r5, #12]
      tcp_free(pcb2);
9000e6b0:	4628      	mov	r0, r5
9000e6b2:	f7fe ff71 	bl	9000d598 <tcp_free>
      pcb = pcb->next;
9000e6b6:	465d      	mov	r5, fp
9000e6b8:	e60b      	b.n	9000e2d2 <tcp_slowtmr+0x3a>
9000e6ba:	bf00      	nop
9000e6bc:	90014c29 	.word	0x90014c29
9000e6c0:	000124f8 	.word	0x000124f8
9000e6c4:	90014b83 	.word	0x90014b83
9000e6c8:	90014c03 	.word	0x90014c03
9000e6cc:	90014bdc 	.word	0x90014bdc
9000e6d0:	2400d3b4 	.word	0x2400d3b4

9000e6d4 <tcp_tmr>:
{
9000e6d4:	b508      	push	{r3, lr}
  tcp_fasttmr();
9000e6d6:	f7ff fd9f 	bl	9000e218 <tcp_fasttmr>
  if (++tcp_timer & 1) {
9000e6da:	4a06      	ldr	r2, [pc, #24]	; (9000e6f4 <tcp_tmr+0x20>)
9000e6dc:	7813      	ldrb	r3, [r2, #0]
9000e6de:	3301      	adds	r3, #1
9000e6e0:	b2db      	uxtb	r3, r3
9000e6e2:	7013      	strb	r3, [r2, #0]
9000e6e4:	07db      	lsls	r3, r3, #31
9000e6e6:	d503      	bpl.n	9000e6f0 <tcp_tmr+0x1c>
}
9000e6e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    tcp_slowtmr();
9000e6ec:	f7ff bdd4 	b.w	9000e298 <tcp_slowtmr>
}
9000e6f0:	bd08      	pop	{r3, pc}
9000e6f2:	bf00      	nop
9000e6f4:	2400d3c4 	.word	0x2400d3c4

9000e6f8 <tcp_get_next_optbyte>:
}

static u8_t
tcp_get_next_optbyte(void)
{
  u16_t optidx = tcp_optidx++;
9000e6f8:	4a09      	ldr	r2, [pc, #36]	; (9000e720 <tcp_get_next_optbyte+0x28>)
9000e6fa:	8813      	ldrh	r3, [r2, #0]
9000e6fc:	1c59      	adds	r1, r3, #1
9000e6fe:	8011      	strh	r1, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
9000e700:	4a08      	ldr	r2, [pc, #32]	; (9000e724 <tcp_get_next_optbyte+0x2c>)
9000e702:	6812      	ldr	r2, [r2, #0]
9000e704:	b11a      	cbz	r2, 9000e70e <tcp_get_next_optbyte+0x16>
9000e706:	4908      	ldr	r1, [pc, #32]	; (9000e728 <tcp_get_next_optbyte+0x30>)
9000e708:	8809      	ldrh	r1, [r1, #0]
9000e70a:	428b      	cmp	r3, r1
9000e70c:	d204      	bcs.n	9000e718 <tcp_get_next_optbyte+0x20>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
9000e70e:	4a07      	ldr	r2, [pc, #28]	; (9000e72c <tcp_get_next_optbyte+0x34>)
    return opts[optidx];
9000e710:	6812      	ldr	r2, [r2, #0]
9000e712:	4413      	add	r3, r2
9000e714:	7d18      	ldrb	r0, [r3, #20]
9000e716:	4770      	bx	lr
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
9000e718:	1a5b      	subs	r3, r3, r1
    return tcphdr_opt2[idx];
9000e71a:	b2db      	uxtb	r3, r3
9000e71c:	5cd0      	ldrb	r0, [r2, r3]
  }
}
9000e71e:	4770      	bx	lr
9000e720:	2400d3f8 	.word	0x2400d3f8
9000e724:	2400d404 	.word	0x2400d404
9000e728:	2400d400 	.word	0x2400d400
9000e72c:	2400d3fc 	.word	0x2400d3fc

9000e730 <tcp_oos_insert_segment>:
{
9000e730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000e732:	460c      	mov	r4, r1
  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
9000e734:	4605      	mov	r5, r0
9000e736:	b930      	cbnz	r0, 9000e746 <tcp_oos_insert_segment+0x16>
9000e738:	4b1e      	ldr	r3, [pc, #120]	; (9000e7b4 <tcp_oos_insert_segment+0x84>)
9000e73a:	f240 421f 	movw	r2, #1055	; 0x41f
9000e73e:	491e      	ldr	r1, [pc, #120]	; (9000e7b8 <tcp_oos_insert_segment+0x88>)
9000e740:	481e      	ldr	r0, [pc, #120]	; (9000e7bc <tcp_oos_insert_segment+0x8c>)
9000e742:	f003 fa33 	bl	90011bac <iprintf>
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
9000e746:	68eb      	ldr	r3, [r5, #12]
9000e748:	8998      	ldrh	r0, [r3, #12]
9000e74a:	f7fa fd19 	bl	90009180 <lwip_htons>
9000e74e:	07c2      	lsls	r2, r0, #31
9000e750:	d414      	bmi.n	9000e77c <tcp_oos_insert_segment+0x4c>
           TCP_SEQ_GEQ((seqno + cseg->len),
9000e752:	4e1b      	ldr	r6, [pc, #108]	; (9000e7c0 <tcp_oos_insert_segment+0x90>)
9000e754:	68e7      	ldr	r7, [r4, #12]
9000e756:	6830      	ldr	r0, [r6, #0]
9000e758:	892b      	ldrh	r3, [r5, #8]
9000e75a:	6879      	ldr	r1, [r7, #4]
9000e75c:	8922      	ldrh	r2, [r4, #8]
9000e75e:	4403      	add	r3, r0
9000e760:	440a      	add	r2, r1
9000e762:	1a9a      	subs	r2, r3, r2
    while (next &&
9000e764:	2a00      	cmp	r2, #0
9000e766:	da0f      	bge.n	9000e788 <tcp_oos_insert_segment+0x58>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
9000e768:	1a5b      	subs	r3, r3, r1
    if (next &&
9000e76a:	2b00      	cmp	r3, #0
9000e76c:	dd0a      	ble.n	9000e784 <tcp_oos_insert_segment+0x54>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
9000e76e:	1a09      	subs	r1, r1, r0
      pbuf_realloc(cseg->p, cseg->len);
9000e770:	6868      	ldr	r0, [r5, #4]
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
9000e772:	b289      	uxth	r1, r1
9000e774:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
9000e776:	f7fe fb8d 	bl	9000ce94 <pbuf_realloc>
9000e77a:	e003      	b.n	9000e784 <tcp_oos_insert_segment+0x54>
    tcp_segs_free(next);
9000e77c:	4620      	mov	r0, r4
    next = NULL;
9000e77e:	2400      	movs	r4, #0
    tcp_segs_free(next);
9000e780:	f7ff f864 	bl	9000d84c <tcp_segs_free>
  cseg->next = next;
9000e784:	602c      	str	r4, [r5, #0]
}
9000e786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
9000e788:	89b8      	ldrh	r0, [r7, #12]
9000e78a:	f7fa fcf9 	bl	90009180 <lwip_htons>
9000e78e:	07c3      	lsls	r3, r0, #31
9000e790:	d507      	bpl.n	9000e7a2 <tcp_oos_insert_segment+0x72>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
9000e792:	68eb      	ldr	r3, [r5, #12]
9000e794:	2001      	movs	r0, #1
9000e796:	899f      	ldrh	r7, [r3, #12]
9000e798:	f7fa fcf2 	bl	90009180 <lwip_htons>
9000e79c:	68eb      	ldr	r3, [r5, #12]
9000e79e:	4338      	orrs	r0, r7
9000e7a0:	8198      	strh	r0, [r3, #12]
      next = next->next;
9000e7a2:	6827      	ldr	r7, [r4, #0]
      tcp_seg_free(old_seg);
9000e7a4:	4620      	mov	r0, r4
9000e7a6:	f7ff f843 	bl	9000d830 <tcp_seg_free>
    while (next &&
9000e7aa:	463c      	mov	r4, r7
9000e7ac:	2f00      	cmp	r7, #0
9000e7ae:	d1d1      	bne.n	9000e754 <tcp_oos_insert_segment+0x24>
9000e7b0:	e7e8      	b.n	9000e784 <tcp_oos_insert_segment+0x54>
9000e7b2:	bf00      	nop
9000e7b4:	90014c4f 	.word	0x90014c4f
9000e7b8:	90014c88 	.word	0x90014c88
9000e7bc:	90012aff 	.word	0x90012aff
9000e7c0:	2400d3f0 	.word	0x2400d3f0

9000e7c4 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
9000e7c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
9000e7c6:	4606      	mov	r6, r0
9000e7c8:	b930      	cbnz	r0, 9000e7d8 <tcp_parseopt+0x14>
9000e7ca:	4b1d      	ldr	r3, [pc, #116]	; (9000e840 <tcp_parseopt+0x7c>)
9000e7cc:	f240 727d 	movw	r2, #1917	; 0x77d
9000e7d0:	491c      	ldr	r1, [pc, #112]	; (9000e844 <tcp_parseopt+0x80>)
9000e7d2:	481d      	ldr	r0, [pc, #116]	; (9000e848 <tcp_parseopt+0x84>)
9000e7d4:	f003 f9ea 	bl	90011bac <iprintf>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
9000e7d8:	4b1c      	ldr	r3, [pc, #112]	; (9000e84c <tcp_parseopt+0x88>)
9000e7da:	881f      	ldrh	r7, [r3, #0]
9000e7dc:	b167      	cbz	r7, 9000e7f8 <tcp_parseopt+0x34>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
9000e7de:	4d1c      	ldr	r5, [pc, #112]	; (9000e850 <tcp_parseopt+0x8c>)
9000e7e0:	2300      	movs	r3, #0
9000e7e2:	802b      	strh	r3, [r5, #0]
9000e7e4:	882b      	ldrh	r3, [r5, #0]
9000e7e6:	42bb      	cmp	r3, r7
9000e7e8:	d206      	bcs.n	9000e7f8 <tcp_parseopt+0x34>
      u8_t opt = tcp_get_next_optbyte();
9000e7ea:	f7ff ff85 	bl	9000e6f8 <tcp_get_next_optbyte>
      switch (opt) {
9000e7ee:	2801      	cmp	r0, #1
9000e7f0:	d0f8      	beq.n	9000e7e4 <tcp_parseopt+0x20>
9000e7f2:	2802      	cmp	r0, #2
9000e7f4:	d001      	beq.n	9000e7fa <tcp_parseopt+0x36>
9000e7f6:	b9c8      	cbnz	r0, 9000e82c <tcp_parseopt+0x68>
             can skip past them. */
          tcp_optidx += data - 2;
      }
    }
  }
}
9000e7f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
9000e7fa:	f7ff ff7d 	bl	9000e6f8 <tcp_get_next_optbyte>
9000e7fe:	2804      	cmp	r0, #4
9000e800:	d1fa      	bne.n	9000e7f8 <tcp_parseopt+0x34>
9000e802:	882b      	ldrh	r3, [r5, #0]
9000e804:	3301      	adds	r3, #1
9000e806:	42bb      	cmp	r3, r7
9000e808:	daf6      	bge.n	9000e7f8 <tcp_parseopt+0x34>
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
9000e80a:	f7ff ff75 	bl	9000e6f8 <tcp_get_next_optbyte>
9000e80e:	0204      	lsls	r4, r0, #8
          mss |= tcp_get_next_optbyte();
9000e810:	f7ff ff72 	bl	9000e6f8 <tcp_get_next_optbyte>
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
9000e814:	b2a4      	uxth	r4, r4
          mss |= tcp_get_next_optbyte();
9000e816:	ea44 0300 	orr.w	r3, r4, r0
9000e81a:	b29b      	uxth	r3, r3
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
9000e81c:	1e5a      	subs	r2, r3, #1
9000e81e:	f5b2 7f06 	cmp.w	r2, #536	; 0x218
9000e822:	bf28      	it	cs
9000e824:	f44f 7306 	movcs.w	r3, #536	; 0x218
9000e828:	8673      	strh	r3, [r6, #50]	; 0x32
          break;
9000e82a:	e7db      	b.n	9000e7e4 <tcp_parseopt+0x20>
          data = tcp_get_next_optbyte();
9000e82c:	f7ff ff64 	bl	9000e6f8 <tcp_get_next_optbyte>
          if (data < 2) {
9000e830:	2801      	cmp	r0, #1
9000e832:	d9e1      	bls.n	9000e7f8 <tcp_parseopt+0x34>
          tcp_optidx += data - 2;
9000e834:	882b      	ldrh	r3, [r5, #0]
9000e836:	3b02      	subs	r3, #2
9000e838:	4418      	add	r0, r3
9000e83a:	8028      	strh	r0, [r5, #0]
9000e83c:	e7d2      	b.n	9000e7e4 <tcp_parseopt+0x20>
9000e83e:	bf00      	nop
9000e840:	90014c4f 	.word	0x90014c4f
9000e844:	90014cad 	.word	0x90014cad
9000e848:	90012aff 	.word	0x90012aff
9000e84c:	2400d408 	.word	0x2400d408
9000e850:	2400d3f8 	.word	0x2400d3f8

9000e854 <tcp_input_delayed_close>:
{
9000e854:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
9000e856:	4604      	mov	r4, r0
9000e858:	b930      	cbnz	r0, 9000e868 <tcp_input_delayed_close+0x14>
9000e85a:	4b0f      	ldr	r3, [pc, #60]	; (9000e898 <tcp_input_delayed_close+0x44>)
9000e85c:	f240 225a 	movw	r2, #602	; 0x25a
9000e860:	490e      	ldr	r1, [pc, #56]	; (9000e89c <tcp_input_delayed_close+0x48>)
9000e862:	480f      	ldr	r0, [pc, #60]	; (9000e8a0 <tcp_input_delayed_close+0x4c>)
9000e864:	f003 f9a2 	bl	90011bac <iprintf>
  if (recv_flags & TF_CLOSED) {
9000e868:	4b0e      	ldr	r3, [pc, #56]	; (9000e8a4 <tcp_input_delayed_close+0x50>)
9000e86a:	7818      	ldrb	r0, [r3, #0]
9000e86c:	f010 0010 	ands.w	r0, r0, #16
9000e870:	d011      	beq.n	9000e896 <tcp_input_delayed_close+0x42>
    if (!(pcb->flags & TF_RXCLOSED)) {
9000e872:	8b63      	ldrh	r3, [r4, #26]
9000e874:	06db      	lsls	r3, r3, #27
9000e876:	d406      	bmi.n	9000e886 <tcp_input_delayed_close+0x32>
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
9000e878:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
9000e87c:	b11b      	cbz	r3, 9000e886 <tcp_input_delayed_close+0x32>
9000e87e:	f06f 010e 	mvn.w	r1, #14
9000e882:	6920      	ldr	r0, [r4, #16]
9000e884:	4798      	blx	r3
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
9000e886:	4621      	mov	r1, r4
9000e888:	4807      	ldr	r0, [pc, #28]	; (9000e8a8 <tcp_input_delayed_close+0x54>)
9000e88a:	f7ff f98d 	bl	9000dba8 <tcp_pcb_remove>
    tcp_free(pcb);
9000e88e:	4620      	mov	r0, r4
9000e890:	f7fe fe82 	bl	9000d598 <tcp_free>
9000e894:	2001      	movs	r0, #1
}
9000e896:	bd10      	pop	{r4, pc}
9000e898:	90014c4f 	.word	0x90014c4f
9000e89c:	90014cc7 	.word	0x90014cc7
9000e8a0:	90012aff 	.word	0x90012aff
9000e8a4:	2400d3ec 	.word	0x2400d3ec
9000e8a8:	2400d3b0 	.word	0x2400d3b0

9000e8ac <tcp_free_acked_segments.constprop.0>:
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
9000e8ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000e8b0:	4606      	mov	r6, r0
9000e8b2:	4617      	mov	r7, r2
    seg_list = seg_list->next;
9000e8b4:	460c      	mov	r4, r1
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
9000e8b6:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 9000e968 <tcp_free_acked_segments.constprop.0+0xbc>
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
9000e8ba:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 9000e960 <tcp_free_acked_segments.constprop.0+0xb4>
9000e8be:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 9000e96c <tcp_free_acked_segments.constprop.0+0xc0>
  while (seg_list != NULL &&
9000e8c2:	2c00      	cmp	r4, #0
9000e8c4:	d03a      	beq.n	9000e93c <tcp_free_acked_segments.constprop.0+0x90>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
9000e8c6:	68e3      	ldr	r3, [r4, #12]
9000e8c8:	6858      	ldr	r0, [r3, #4]
9000e8ca:	f7fa fc5c 	bl	90009186 <lwip_htonl>
9000e8ce:	68e3      	ldr	r3, [r4, #12]
9000e8d0:	4683      	mov	fp, r0
9000e8d2:	8925      	ldrh	r5, [r4, #8]
9000e8d4:	8998      	ldrh	r0, [r3, #12]
9000e8d6:	f7fa fc53 	bl	90009180 <lwip_htons>
9000e8da:	f8d8 3000 	ldr.w	r3, [r8]
9000e8de:	f010 0003 	ands.w	r0, r0, #3
9000e8e2:	eba5 0303 	sub.w	r3, r5, r3
9000e8e6:	bf18      	it	ne
9000e8e8:	2001      	movne	r0, #1
9000e8ea:	eb03 050b 	add.w	r5, r3, fp
9000e8ee:	4405      	add	r5, r0
  while (seg_list != NULL &&
9000e8f0:	2d00      	cmp	r5, #0
9000e8f2:	dc24      	bgt.n	9000e93e <tcp_free_acked_segments.constprop.0+0x92>
    clen = pbuf_clen(next->p);
9000e8f4:	e9d4 b000 	ldrd	fp, r0, [r4]
9000e8f8:	f7fe fb24 	bl	9000cf44 <pbuf_clen>
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
9000e8fc:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
    clen = pbuf_clen(next->p);
9000e900:	4605      	mov	r5, r0
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
9000e902:	4283      	cmp	r3, r0
9000e904:	d206      	bcs.n	9000e914 <tcp_free_acked_segments.constprop.0+0x68>
9000e906:	464b      	mov	r3, r9
9000e908:	f240 4257 	movw	r2, #1111	; 0x457
9000e90c:	4651      	mov	r1, sl
9000e90e:	4812      	ldr	r0, [pc, #72]	; (9000e958 <tcp_free_acked_segments.constprop.0+0xac>)
9000e910:	f003 f94c 	bl	90011bac <iprintf>
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
9000e914:	4a11      	ldr	r2, [pc, #68]	; (9000e95c <tcp_free_acked_segments.constprop.0+0xb0>)
    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
9000e916:	f8b6 0066 	ldrh.w	r0, [r6, #102]	; 0x66
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
9000e91a:	8811      	ldrh	r1, [r2, #0]
9000e91c:	8923      	ldrh	r3, [r4, #8]
    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
9000e91e:	1b45      	subs	r5, r0, r5
    tcp_seg_free(next);
9000e920:	4620      	mov	r0, r4
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
9000e922:	440b      	add	r3, r1
    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
9000e924:	f8a6 5066 	strh.w	r5, [r6, #102]	; 0x66
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
9000e928:	8013      	strh	r3, [r2, #0]
    tcp_seg_free(next);
9000e92a:	f7fe ff81 	bl	9000d830 <tcp_seg_free>
    if (pcb->snd_queuelen != 0) {
9000e92e:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
9000e932:	b17b      	cbz	r3, 9000e954 <tcp_free_acked_segments.constprop.0+0xa8>
      LWIP_ASSERT("tcp_receive: valid queue length",
9000e934:	f1bb 0f00 	cmp.w	fp, #0
9000e938:	d10c      	bne.n	9000e954 <tcp_free_acked_segments.constprop.0+0xa8>
9000e93a:	b11f      	cbz	r7, 9000e944 <tcp_free_acked_segments.constprop.0+0x98>
    seg_list = seg_list->next;
9000e93c:	2400      	movs	r4, #0
}
9000e93e:	4620      	mov	r0, r4
9000e940:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      LWIP_ASSERT("tcp_receive: valid queue length",
9000e944:	4b06      	ldr	r3, [pc, #24]	; (9000e960 <tcp_free_acked_segments.constprop.0+0xb4>)
9000e946:	f240 4261 	movw	r2, #1121	; 0x461
9000e94a:	4906      	ldr	r1, [pc, #24]	; (9000e964 <tcp_free_acked_segments.constprop.0+0xb8>)
9000e94c:	4802      	ldr	r0, [pc, #8]	; (9000e958 <tcp_free_acked_segments.constprop.0+0xac>)
9000e94e:	f003 f92d 	bl	90011bac <iprintf>
  while (seg_list != NULL &&
9000e952:	e7f3      	b.n	9000e93c <tcp_free_acked_segments.constprop.0+0x90>
    seg_list = seg_list->next;
9000e954:	465c      	mov	r4, fp
9000e956:	e7b4      	b.n	9000e8c2 <tcp_free_acked_segments.constprop.0+0x16>
9000e958:	90012aff 	.word	0x90012aff
9000e95c:	2400d3e4 	.word	0x2400d3e4
9000e960:	90014c4f 	.word	0x90014c4f
9000e964:	90014d14 	.word	0x90014d14
9000e968:	2400d3cc 	.word	0x2400d3cc
9000e96c:	90014cec 	.word	0x90014cec

9000e970 <tcp_receive>:
{
9000e970:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
9000e974:	4604      	mov	r4, r0
9000e976:	b930      	cbnz	r0, 9000e986 <tcp_receive+0x16>
9000e978:	4b3b      	ldr	r3, [pc, #236]	; (9000ea68 <tcp_receive+0xf8>)
9000e97a:	f240 427b 	movw	r2, #1147	; 0x47b
9000e97e:	493b      	ldr	r1, [pc, #236]	; (9000ea6c <tcp_receive+0xfc>)
9000e980:	483b      	ldr	r0, [pc, #236]	; (9000ea70 <tcp_receive+0x100>)
9000e982:	f003 f913 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
9000e986:	7d23      	ldrb	r3, [r4, #20]
9000e988:	2b03      	cmp	r3, #3
9000e98a:	d806      	bhi.n	9000e99a <tcp_receive+0x2a>
9000e98c:	4b36      	ldr	r3, [pc, #216]	; (9000ea68 <tcp_receive+0xf8>)
9000e98e:	f240 427c 	movw	r2, #1148	; 0x47c
9000e992:	4938      	ldr	r1, [pc, #224]	; (9000ea74 <tcp_receive+0x104>)
9000e994:	4836      	ldr	r0, [pc, #216]	; (9000ea70 <tcp_receive+0x100>)
9000e996:	f003 f909 	bl	90011bac <iprintf>
  if (flags & TCP_ACK) {
9000e99a:	4b37      	ldr	r3, [pc, #220]	; (9000ea78 <tcp_receive+0x108>)
9000e99c:	4e37      	ldr	r6, [pc, #220]	; (9000ea7c <tcp_receive+0x10c>)
9000e99e:	781b      	ldrb	r3, [r3, #0]
9000e9a0:	4f37      	ldr	r7, [pc, #220]	; (9000ea80 <tcp_receive+0x110>)
9000e9a2:	f013 0f10 	tst.w	r3, #16
9000e9a6:	f000 809e 	beq.w	9000eae6 <tcp_receive+0x176>
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
9000e9aa:	6833      	ldr	r3, [r6, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
9000e9ac:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 9000ea88 <tcp_receive+0x118>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
9000e9b0:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
9000e9b4:	f8d9 2000 	ldr.w	r2, [r9]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
9000e9b8:	e9d4 0c15 	ldrd	r0, ip, [r4, #84]	; 0x54
9000e9bc:	eba0 0e03 	sub.w	lr, r0, r3
9000e9c0:	f1be 0f00 	cmp.w	lr, #0
9000e9c4:	db0c      	blt.n	9000e9e0 <tcp_receive+0x70>
9000e9c6:	4298      	cmp	r0, r3
9000e9c8:	d103      	bne.n	9000e9d2 <tcp_receive+0x62>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
9000e9ca:	ebac 0002 	sub.w	r0, ip, r2
9000e9ce:	2800      	cmp	r0, #0
9000e9d0:	db06      	blt.n	9000e9e0 <tcp_receive+0x70>
9000e9d2:	4594      	cmp	ip, r2
9000e9d4:	d113      	bne.n	9000e9fe <tcp_receive+0x8e>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
9000e9d6:	482b      	ldr	r0, [pc, #172]	; (9000ea84 <tcp_receive+0x114>)
9000e9d8:	6800      	ldr	r0, [r0, #0]
9000e9da:	89c0      	ldrh	r0, [r0, #14]
9000e9dc:	4288      	cmp	r0, r1
9000e9de:	d90e      	bls.n	9000e9fe <tcp_receive+0x8e>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
9000e9e0:	4828      	ldr	r0, [pc, #160]	; (9000ea84 <tcp_receive+0x114>)
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
9000e9e2:	f8b4 8062 	ldrh.w	r8, [r4, #98]	; 0x62
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
9000e9e6:	6800      	ldr	r0, [r0, #0]
9000e9e8:	89c0      	ldrh	r0, [r0, #14]
9000e9ea:	fa1f fe80 	uxth.w	lr, r0
9000e9ee:	f8a4 0060 	strh.w	r0, [r4, #96]	; 0x60
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
9000e9f2:	45f0      	cmp	r8, lr
      pcb->snd_wl2 = ackno;
9000e9f4:	e9c4 3215 	strd	r3, r2, [r4, #84]	; 0x54
        pcb->snd_wnd_max = pcb->snd_wnd;
9000e9f8:	bf38      	it	cc
9000e9fa:	f8a4 0062 	strhcc.w	r0, [r4, #98]	; 0x62
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
9000e9fe:	6c60      	ldr	r0, [r4, #68]	; 0x44
9000ea00:	1a13      	subs	r3, r2, r0
9000ea02:	2b00      	cmp	r3, #0
9000ea04:	f300 8179 	bgt.w	9000ecfa <tcp_receive+0x38a>
      if (tcplen == 0) {
9000ea08:	883b      	ldrh	r3, [r7, #0]
9000ea0a:	2b00      	cmp	r3, #0
9000ea0c:	f040 8171 	bne.w	9000ecf2 <tcp_receive+0x382>
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
9000ea10:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
9000ea14:	4461      	add	r1, ip
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
9000ea16:	6da5      	ldr	r5, [r4, #88]	; 0x58
9000ea18:	442b      	add	r3, r5
9000ea1a:	428b      	cmp	r3, r1
9000ea1c:	f040 8169 	bne.w	9000ecf2 <tcp_receive+0x382>
          if (pcb->rtime >= 0) {
9000ea20:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
9000ea24:	2b00      	cmp	r3, #0
9000ea26:	f2c0 8164 	blt.w	9000ecf2 <tcp_receive+0x382>
            if (pcb->lastack == ackno) {
9000ea2a:	4290      	cmp	r0, r2
9000ea2c:	f040 8161 	bne.w	9000ecf2 <tcp_receive+0x382>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
9000ea30:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
9000ea34:	2bff      	cmp	r3, #255	; 0xff
                ++pcb->dupacks;
9000ea36:	bf1c      	itt	ne
9000ea38:	3301      	addne	r3, #1
9000ea3a:	f884 3043 	strbne.w	r3, [r4, #67]	; 0x43
              if (pcb->dupacks > 3) {
9000ea3e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
9000ea42:	2b03      	cmp	r3, #3
9000ea44:	d922      	bls.n	9000ea8c <tcp_receive+0x11c>
                TCP_WND_INC(pcb->cwnd, pcb->mss);
9000ea46:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
9000ea4a:	f64f 71ff 	movw	r1, #65535	; 0xffff
9000ea4e:	8e63      	ldrh	r3, [r4, #50]	; 0x32
9000ea50:	4413      	add	r3, r2
9000ea52:	b29b      	uxth	r3, r3
9000ea54:	429a      	cmp	r2, r3
9000ea56:	bf88      	it	hi
9000ea58:	460b      	movhi	r3, r1
9000ea5a:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
                tcp_rexmit_fast(pcb);
9000ea5e:	4620      	mov	r0, r4
9000ea60:	f001 ff70 	bl	90010944 <tcp_rexmit_fast>
      if (!found_dupack) {
9000ea64:	e013      	b.n	9000ea8e <tcp_receive+0x11e>
9000ea66:	bf00      	nop
9000ea68:	90014c4f 	.word	0x90014c4f
9000ea6c:	90014d34 	.word	0x90014d34
9000ea70:	90012aff 	.word	0x90012aff
9000ea74:	90014d4d 	.word	0x90014d4d
9000ea78:	2400d3d0 	.word	0x2400d3d0
9000ea7c:	2400d3f0 	.word	0x2400d3f0
9000ea80:	2400d40a 	.word	0x2400d40a
9000ea84:	2400d3fc 	.word	0x2400d3fc
9000ea88:	2400d3cc 	.word	0x2400d3cc
              if (pcb->dupacks >= 3) {
9000ea8c:	d0e7      	beq.n	9000ea5e <tcp_receive+0xee>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
9000ea8e:	6b61      	ldr	r1, [r4, #52]	; 0x34
9000ea90:	b349      	cbz	r1, 9000eae6 <tcp_receive+0x176>
9000ea92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
9000ea94:	f8d9 2000 	ldr.w	r2, [r9]
9000ea98:	1a9b      	subs	r3, r3, r2
9000ea9a:	2b00      	cmp	r3, #0
9000ea9c:	da23      	bge.n	9000eae6 <tcp_receive+0x176>
      m = (s16_t)(tcp_ticks - pcb->rttest);
9000ea9e:	4bb6      	ldr	r3, [pc, #728]	; (9000ed78 <tcp_receive+0x408>)
9000eaa0:	b289      	uxth	r1, r1
9000eaa2:	f8b3 c000 	ldrh.w	ip, [r3]
      m = (s16_t)(m - (pcb->sa >> 3));
9000eaa6:	f9b4 303c 	ldrsh.w	r3, [r4, #60]	; 0x3c
      m = (s16_t)(tcp_ticks - pcb->rttest);
9000eaaa:	ebac 0201 	sub.w	r2, ip, r1
      m = (s16_t)(m - (pcb->sa >> 3));
9000eaae:	f3c3 00cf 	ubfx	r0, r3, #3, #16
9000eab2:	1a12      	subs	r2, r2, r0
9000eab4:	b215      	sxth	r5, r2
      pcb->sa = (s16_t)(pcb->sa + m);
9000eab6:	fa13 f282 	uxtah	r2, r3, r2
      m = (s16_t)(m - (pcb->sv >> 2));
9000eaba:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	; 0x3e
      if (m < 0) {
9000eabe:	2d00      	cmp	r5, #0
      pcb->sa = (s16_t)(pcb->sa + m);
9000eac0:	b212      	sxth	r2, r2
      pcb->sv = (s16_t)(pcb->sv + m);
9000eac2:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
        m = (s16_t) - m;
9000eac6:	bfb8      	it	lt
9000eac8:	eba1 010c 	sublt.w	r1, r1, ip
      pcb->sa = (s16_t)(pcb->sa + m);
9000eacc:	87a2      	strh	r2, [r4, #60]	; 0x3c
        m = (s16_t) - m;
9000eace:	bfbc      	itt	lt
9000ead0:	1809      	addlt	r1, r1, r0
9000ead2:	b20d      	sxthlt	r5, r1
      pcb->sv = (s16_t)(pcb->sv + m);
9000ead4:	442b      	add	r3, r5
9000ead6:	b29b      	uxth	r3, r3
9000ead8:	87e3      	strh	r3, [r4, #62]	; 0x3e
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
9000eada:	eb03 03e2 	add.w	r3, r3, r2, asr #3
9000eade:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      pcb->rttest = 0;
9000eae2:	2300      	movs	r3, #0
9000eae4:	6363      	str	r3, [r4, #52]	; 0x34
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
9000eae6:	8838      	ldrh	r0, [r7, #0]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
9000eae8:	6833      	ldr	r3, [r6, #0]
9000eaea:	6a62      	ldr	r2, [r4, #36]	; 0x24
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
9000eaec:	2800      	cmp	r0, #0
9000eaee:	f000 8359 	beq.w	9000f1a4 <tcp_receive+0x834>
9000eaf2:	7d21      	ldrb	r1, [r4, #20]
9000eaf4:	2906      	cmp	r1, #6
9000eaf6:	f200 8355 	bhi.w	9000f1a4 <tcp_receive+0x834>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
9000eafa:	1ad5      	subs	r5, r2, r3
9000eafc:	2d01      	cmp	r5, #1
9000eafe:	f100 81a6 	bmi.w	9000ee4e <tcp_receive+0x4de>
9000eb02:	f1c3 0101 	rsb	r1, r3, #1
9000eb06:	1a09      	subs	r1, r1, r0
9000eb08:	4411      	add	r1, r2
9000eb0a:	2900      	cmp	r1, #0
9000eb0c:	f300 819f 	bgt.w	9000ee4e <tcp_receive+0x4de>
      struct pbuf *p = inseg.p;
9000eb10:	f8df 927c 	ldr.w	r9, [pc, #636]	; 9000ed90 <tcp_receive+0x420>
9000eb14:	f8d9 8004 	ldr.w	r8, [r9, #4]
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
9000eb18:	f1b8 0f00 	cmp.w	r8, #0
9000eb1c:	d106      	bne.n	9000eb2c <tcp_receive+0x1bc>
9000eb1e:	4b97      	ldr	r3, [pc, #604]	; (9000ed7c <tcp_receive+0x40c>)
9000eb20:	f240 5294 	movw	r2, #1428	; 0x594
9000eb24:	4996      	ldr	r1, [pc, #600]	; (9000ed80 <tcp_receive+0x410>)
9000eb26:	4897      	ldr	r0, [pc, #604]	; (9000ed84 <tcp_receive+0x414>)
9000eb28:	f003 f840 	bl	90011bac <iprintf>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
9000eb2c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
9000eb30:	429d      	cmp	r5, r3
9000eb32:	d906      	bls.n	9000eb42 <tcp_receive+0x1d2>
9000eb34:	4b91      	ldr	r3, [pc, #580]	; (9000ed7c <tcp_receive+0x40c>)
9000eb36:	f240 5295 	movw	r2, #1429	; 0x595
9000eb3a:	4993      	ldr	r1, [pc, #588]	; (9000ed88 <tcp_receive+0x418>)
9000eb3c:	4891      	ldr	r0, [pc, #580]	; (9000ed84 <tcp_receive+0x414>)
9000eb3e:	f003 f835 	bl	90011bac <iprintf>
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
9000eb42:	f8d9 3004 	ldr.w	r3, [r9, #4]
      off = (u16_t)off32;
9000eb46:	b2ad      	uxth	r5, r5
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
9000eb48:	891b      	ldrh	r3, [r3, #8]
9000eb4a:	42ab      	cmp	r3, r5
9000eb4c:	d206      	bcs.n	9000eb5c <tcp_receive+0x1ec>
9000eb4e:	4b8b      	ldr	r3, [pc, #556]	; (9000ed7c <tcp_receive+0x40c>)
9000eb50:	f240 5297 	movw	r2, #1431	; 0x597
9000eb54:	498d      	ldr	r1, [pc, #564]	; (9000ed8c <tcp_receive+0x41c>)
9000eb56:	488b      	ldr	r0, [pc, #556]	; (9000ed84 <tcp_receive+0x414>)
9000eb58:	f003 f828 	bl	90011bac <iprintf>
      inseg.len -= off;
9000eb5c:	f8b9 3008 	ldrh.w	r3, [r9, #8]
        p->len = 0;
9000eb60:	2100      	movs	r1, #0
      inseg.len -= off;
9000eb62:	1b5b      	subs	r3, r3, r5
9000eb64:	f8a9 3008 	strh.w	r3, [r9, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
9000eb68:	f8d9 3004 	ldr.w	r3, [r9, #4]
9000eb6c:	891b      	ldrh	r3, [r3, #8]
9000eb6e:	1b5b      	subs	r3, r3, r5
9000eb70:	b29b      	uxth	r3, r3
      while (p->len < off) {
9000eb72:	f8b8 200a 	ldrh.w	r2, [r8, #10]
9000eb76:	42aa      	cmp	r2, r5
9000eb78:	f0c0 8160 	bcc.w	9000ee3c <tcp_receive+0x4cc>
      pbuf_remove_header(p, off);
9000eb7c:	4629      	mov	r1, r5
9000eb7e:	4640      	mov	r0, r8
9000eb80:	f7fe f85a 	bl	9000cc38 <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
9000eb84:	6a63      	ldr	r3, [r4, #36]	; 0x24
9000eb86:	f8d9 200c 	ldr.w	r2, [r9, #12]
9000eb8a:	6033      	str	r3, [r6, #0]
9000eb8c:	6053      	str	r3, [r2, #4]
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
9000eb8e:	6833      	ldr	r3, [r6, #0]
9000eb90:	6a62      	ldr	r2, [r4, #36]	; 0x24
9000eb92:	1a99      	subs	r1, r3, r2
9000eb94:	2900      	cmp	r1, #0
9000eb96:	f2c0 822e 	blt.w	9000eff6 <tcp_receive+0x686>
9000eb9a:	1c58      	adds	r0, r3, #1
9000eb9c:	8d25      	ldrh	r5, [r4, #40]	; 0x28
9000eb9e:	1a81      	subs	r1, r0, r2
9000eba0:	1b49      	subs	r1, r1, r5
9000eba2:	2900      	cmp	r1, #0
9000eba4:	f300 8227 	bgt.w	9000eff6 <tcp_receive+0x686>
      if (pcb->rcv_nxt == seqno) {
9000eba8:	4293      	cmp	r3, r2
9000ebaa:	f040 821e 	bne.w	9000efea <tcp_receive+0x67a>
        tcplen = TCP_TCPLEN(&inseg);
9000ebae:	4d78      	ldr	r5, [pc, #480]	; (9000ed90 <tcp_receive+0x420>)
9000ebb0:	68eb      	ldr	r3, [r5, #12]
9000ebb2:	f8b5 8008 	ldrh.w	r8, [r5, #8]
9000ebb6:	8998      	ldrh	r0, [r3, #12]
9000ebb8:	f7fa fae2 	bl	90009180 <lwip_htons>
9000ebbc:	f010 0003 	ands.w	r0, r0, #3
        if (tcplen > pcb->rcv_wnd) {
9000ebc0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
        tcplen = TCP_TCPLEN(&inseg);
9000ebc2:	bf18      	it	ne
9000ebc4:	2001      	movne	r0, #1
9000ebc6:	4440      	add	r0, r8
9000ebc8:	b280      	uxth	r0, r0
        if (tcplen > pcb->rcv_wnd) {
9000ebca:	4283      	cmp	r3, r0
        tcplen = TCP_TCPLEN(&inseg);
9000ebcc:	8038      	strh	r0, [r7, #0]
        if (tcplen > pcb->rcv_wnd) {
9000ebce:	d241      	bcs.n	9000ec54 <tcp_receive+0x2e4>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
9000ebd0:	68eb      	ldr	r3, [r5, #12]
9000ebd2:	8998      	ldrh	r0, [r3, #12]
9000ebd4:	f7fa fad4 	bl	90009180 <lwip_htons>
9000ebd8:	07c2      	lsls	r2, r0, #31
9000ebda:	d510      	bpl.n	9000ebfe <tcp_receive+0x28e>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
9000ebdc:	68eb      	ldr	r3, [r5, #12]
9000ebde:	f8b3 800c 	ldrh.w	r8, [r3, #12]
9000ebe2:	4640      	mov	r0, r8
9000ebe4:	f428 587c 	bic.w	r8, r8, #16128	; 0x3f00
9000ebe8:	f7fa faca 	bl	90009180 <lwip_htons>
9000ebec:	f000 003e 	and.w	r0, r0, #62	; 0x3e
9000ebf0:	f7fa fac6 	bl	90009180 <lwip_htons>
9000ebf4:	68eb      	ldr	r3, [r5, #12]
9000ebf6:	ea48 0800 	orr.w	r8, r8, r0
9000ebfa:	f8a3 800c 	strh.w	r8, [r3, #12]
          inseg.len = (u16_t)pcb->rcv_wnd;
9000ebfe:	8d23      	ldrh	r3, [r4, #40]	; 0x28
9000ec00:	812b      	strh	r3, [r5, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
9000ec02:	68eb      	ldr	r3, [r5, #12]
9000ec04:	8998      	ldrh	r0, [r3, #12]
9000ec06:	f7fa fabb 	bl	90009180 <lwip_htons>
9000ec0a:	0783      	lsls	r3, r0, #30
          pbuf_realloc(inseg.p, inseg.len);
9000ec0c:	6868      	ldr	r0, [r5, #4]
            inseg.len -= 1;
9000ec0e:	bf42      	ittt	mi
9000ec10:	892b      	ldrhmi	r3, [r5, #8]
9000ec12:	f103 33ff 	addmi.w	r3, r3, #4294967295
9000ec16:	812b      	strhmi	r3, [r5, #8]
          pbuf_realloc(inseg.p, inseg.len);
9000ec18:	8929      	ldrh	r1, [r5, #8]
9000ec1a:	f7fe f93b 	bl	9000ce94 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
9000ec1e:	68eb      	ldr	r3, [r5, #12]
9000ec20:	f8b5 8008 	ldrh.w	r8, [r5, #8]
9000ec24:	8998      	ldrh	r0, [r3, #12]
9000ec26:	f7fa faab 	bl	90009180 <lwip_htons>
9000ec2a:	f010 0003 	ands.w	r0, r0, #3
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000ec2e:	6833      	ldr	r3, [r6, #0]
          tcplen = TCP_TCPLEN(&inseg);
9000ec30:	bf18      	it	ne
9000ec32:	2001      	movne	r0, #1
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000ec34:	6a62      	ldr	r2, [r4, #36]	; 0x24
          tcplen = TCP_TCPLEN(&inseg);
9000ec36:	4440      	add	r0, r8
9000ec38:	b280      	uxth	r0, r0
9000ec3a:	8038      	strh	r0, [r7, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000ec3c:	4418      	add	r0, r3
9000ec3e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
9000ec40:	4413      	add	r3, r2
9000ec42:	4298      	cmp	r0, r3
9000ec44:	d006      	beq.n	9000ec54 <tcp_receive+0x2e4>
9000ec46:	4b4d      	ldr	r3, [pc, #308]	; (9000ed7c <tcp_receive+0x40c>)
9000ec48:	f240 52cb 	movw	r2, #1483	; 0x5cb
9000ec4c:	4951      	ldr	r1, [pc, #324]	; (9000ed94 <tcp_receive+0x424>)
9000ec4e:	484d      	ldr	r0, [pc, #308]	; (9000ed84 <tcp_receive+0x414>)
9000ec50:	f002 ffac 	bl	90011bac <iprintf>
        if (pcb->ooseq != NULL) {
9000ec54:	6f63      	ldr	r3, [r4, #116]	; 0x74
9000ec56:	2b00      	cmp	r3, #0
9000ec58:	f000 8108 	beq.w	9000ee6c <tcp_receive+0x4fc>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
9000ec5c:	68eb      	ldr	r3, [r5, #12]
9000ec5e:	8998      	ldrh	r0, [r3, #12]
9000ec60:	f7fa fa8e 	bl	90009180 <lwip_htons>
9000ec64:	07c0      	lsls	r0, r0, #31
9000ec66:	f100 80fe 	bmi.w	9000ee66 <tcp_receive+0x4f6>
            struct tcp_seg *next = pcb->ooseq;
9000ec6a:	f8d4 8074 	ldr.w	r8, [r4, #116]	; 0x74
                   TCP_SEQ_GEQ(seqno + tcplen,
9000ec6e:	6830      	ldr	r0, [r6, #0]
9000ec70:	883b      	ldrh	r3, [r7, #0]
9000ec72:	4403      	add	r3, r0
            while (next &&
9000ec74:	f1b8 0f00 	cmp.w	r8, #0
9000ec78:	d038      	beq.n	9000ecec <tcp_receive+0x37c>
                   TCP_SEQ_GEQ(seqno + tcplen,
9000ec7a:	f8d8 c00c 	ldr.w	ip, [r8, #12]
9000ec7e:	f8b8 1008 	ldrh.w	r1, [r8, #8]
9000ec82:	f8dc 2004 	ldr.w	r2, [ip, #4]
9000ec86:	4411      	add	r1, r2
9000ec88:	1a59      	subs	r1, r3, r1
            while (next &&
9000ec8a:	2900      	cmp	r1, #0
9000ec8c:	f280 811b 	bge.w	9000eec6 <tcp_receive+0x556>
                TCP_SEQ_GT(seqno + tcplen,
9000ec90:	1a9b      	subs	r3, r3, r2
            if (next &&
9000ec92:	2b00      	cmp	r3, #0
9000ec94:	dd2a      	ble.n	9000ecec <tcp_receive+0x37c>
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
9000ec96:	68eb      	ldr	r3, [r5, #12]
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
9000ec98:	1a12      	subs	r2, r2, r0
9000ec9a:	812a      	strh	r2, [r5, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
9000ec9c:	8998      	ldrh	r0, [r3, #12]
9000ec9e:	f7fa fa6f 	bl	90009180 <lwip_htons>
9000eca2:	0783      	lsls	r3, r0, #30
              pbuf_realloc(inseg.p, inseg.len);
9000eca4:	6868      	ldr	r0, [r5, #4]
                inseg.len -= 1;
9000eca6:	bf42      	ittt	mi
9000eca8:	892b      	ldrhmi	r3, [r5, #8]
9000ecaa:	f103 33ff 	addmi.w	r3, r3, #4294967295
9000ecae:	812b      	strhmi	r3, [r5, #8]
              pbuf_realloc(inseg.p, inseg.len);
9000ecb0:	8929      	ldrh	r1, [r5, #8]
9000ecb2:	f7fe f8ef 	bl	9000ce94 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
9000ecb6:	68eb      	ldr	r3, [r5, #12]
9000ecb8:	f8b5 9008 	ldrh.w	r9, [r5, #8]
9000ecbc:	8998      	ldrh	r0, [r3, #12]
9000ecbe:	f7fa fa5f 	bl	90009180 <lwip_htons>
9000ecc2:	f010 0003 	ands.w	r0, r0, #3
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
9000ecc6:	6833      	ldr	r3, [r6, #0]
              tcplen = TCP_TCPLEN(&inseg);
9000ecc8:	bf18      	it	ne
9000ecca:	2001      	movne	r0, #1
9000eccc:	4448      	add	r0, r9
9000ecce:	b280      	uxth	r0, r0
9000ecd0:	8038      	strh	r0, [r7, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
9000ecd2:	4418      	add	r0, r3
9000ecd4:	f8d8 300c 	ldr.w	r3, [r8, #12]
9000ecd8:	685b      	ldr	r3, [r3, #4]
9000ecda:	4298      	cmp	r0, r3
9000ecdc:	d006      	beq.n	9000ecec <tcp_receive+0x37c>
9000ecde:	4b27      	ldr	r3, [pc, #156]	; (9000ed7c <tcp_receive+0x40c>)
9000ece0:	f240 52fc 	movw	r2, #1532	; 0x5fc
9000ece4:	492c      	ldr	r1, [pc, #176]	; (9000ed98 <tcp_receive+0x428>)
9000ece6:	4827      	ldr	r0, [pc, #156]	; (9000ed84 <tcp_receive+0x414>)
9000ece8:	f002 ff60 	bl	90011bac <iprintf>
            pcb->ooseq = next;
9000ecec:	f8c4 8074 	str.w	r8, [r4, #116]	; 0x74
9000ecf0:	e0bc      	b.n	9000ee6c <tcp_receive+0x4fc>
        pcb->dupacks = 0;
9000ecf2:	2300      	movs	r3, #0
9000ecf4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
9000ecf8:	e6c9      	b.n	9000ea8e <tcp_receive+0x11e>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
9000ecfa:	6d21      	ldr	r1, [r4, #80]	; 0x50
9000ecfc:	1a51      	subs	r1, r2, r1
9000ecfe:	2900      	cmp	r1, #0
9000ed00:	f300 8098 	bgt.w	9000ee34 <tcp_receive+0x4c4>
      if (pcb->flags & TF_INFR) {
9000ed04:	8b61      	ldrh	r1, [r4, #26]
9000ed06:	0748      	lsls	r0, r1, #29
9000ed08:	d509      	bpl.n	9000ed1e <tcp_receive+0x3ae>
        tcp_clear_flags(pcb, TF_INFR);
9000ed0a:	f021 0104 	bic.w	r1, r1, #4
9000ed0e:	8361      	strh	r1, [r4, #26]
        pcb->cwnd = pcb->ssthresh;
9000ed10:	f8b4 104a 	ldrh.w	r1, [r4, #74]	; 0x4a
9000ed14:	f8a4 1048 	strh.w	r1, [r4, #72]	; 0x48
        pcb->bytes_acked = 0;
9000ed18:	2100      	movs	r1, #0
9000ed1a:	f8a4 106a 	strh.w	r1, [r4, #106]	; 0x6a
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
9000ed1e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
9000ed22:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
      pcb->lastack = ackno;
9000ed24:	6462      	str	r2, [r4, #68]	; 0x44
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
9000ed26:	eb01 01e0 	add.w	r1, r1, r0, asr #3
      if (pcb->state >= ESTABLISHED) {
9000ed2a:	7d22      	ldrb	r2, [r4, #20]
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
9000ed2c:	f8a4 1040 	strh.w	r1, [r4, #64]	; 0x40
      if (pcb->state >= ESTABLISHED) {
9000ed30:	2a03      	cmp	r2, #3
      pcb->nrtx = 0;
9000ed32:	f04f 0100 	mov.w	r1, #0
9000ed36:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
      if (pcb->state >= ESTABLISHED) {
9000ed3a:	d939      	bls.n	9000edb0 <tcp_receive+0x440>
        if (pcb->cwnd < pcb->ssthresh) {
9000ed3c:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
9000ed40:	b29b      	uxth	r3, r3
        if (pcb->cwnd < pcb->ssthresh) {
9000ed42:	f8b4 104a 	ldrh.w	r1, [r4, #74]	; 0x4a
9000ed46:	4291      	cmp	r1, r2
9000ed48:	d928      	bls.n	9000ed9c <tcp_receive+0x42c>
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
9000ed4a:	8b61      	ldrh	r1, [r4, #26]
9000ed4c:	f411 6f00 	tst.w	r1, #2048	; 0x800
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
9000ed50:	8e61      	ldrh	r1, [r4, #50]	; 0x32
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
9000ed52:	bf14      	ite	ne
9000ed54:	2001      	movne	r0, #1
9000ed56:	2002      	moveq	r0, #2
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
9000ed58:	fb11 f100 	smulbb	r1, r1, r0
9000ed5c:	b289      	uxth	r1, r1
          TCP_WND_INC(pcb->cwnd, increase);
9000ed5e:	4299      	cmp	r1, r3
9000ed60:	bf94      	ite	ls
9000ed62:	1850      	addls	r0, r2, r1
9000ed64:	18d0      	addhi	r0, r2, r3
9000ed66:	b283      	uxth	r3, r0
            TCP_WND_INC(pcb->cwnd, pcb->mss);
9000ed68:	429a      	cmp	r2, r3
9000ed6a:	d901      	bls.n	9000ed70 <tcp_receive+0x400>
          TCP_WND_INC(pcb->cwnd, increase);
9000ed6c:	f64f 73ff 	movw	r3, #65535	; 0xffff
            TCP_WND_INC(pcb->cwnd, pcb->mss);
9000ed70:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
9000ed74:	e01c      	b.n	9000edb0 <tcp_receive+0x440>
9000ed76:	bf00      	nop
9000ed78:	2400d3c0 	.word	0x2400d3c0
9000ed7c:	90014c4f 	.word	0x90014c4f
9000ed80:	90014d66 	.word	0x90014d66
9000ed84:	90012aff 	.word	0x90012aff
9000ed88:	90014d76 	.word	0x90014d76
9000ed8c:	90014d85 	.word	0x90014d85
9000ed90:	2400d3d4 	.word	0x2400d3d4
9000ed94:	90014d95 	.word	0x90014d95
9000ed98:	90014dcc 	.word	0x90014dcc
          TCP_WND_INC(pcb->bytes_acked, acked);
9000ed9c:	f8b4 106a 	ldrh.w	r1, [r4, #106]	; 0x6a
9000eda0:	440b      	add	r3, r1
9000eda2:	b29b      	uxth	r3, r3
9000eda4:	4299      	cmp	r1, r3
9000eda6:	d82c      	bhi.n	9000ee02 <tcp_receive+0x492>
          if (pcb->bytes_acked >= pcb->cwnd) {
9000eda8:	429a      	cmp	r2, r3
9000edaa:	d92c      	bls.n	9000ee06 <tcp_receive+0x496>
9000edac:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
9000edb0:	4620      	mov	r0, r4
9000edb2:	e9d4 211b 	ldrd	r2, r1, [r4, #108]	; 0x6c
9000edb6:	f7ff fd79 	bl	9000e8ac <tcp_free_acked_segments.constprop.0>
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
9000edba:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
9000edbc:	4602      	mov	r2, r0
9000edbe:	6720      	str	r0, [r4, #112]	; 0x70
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
9000edc0:	4620      	mov	r0, r4
9000edc2:	f7ff fd73 	bl	9000e8ac <tcp_free_acked_segments.constprop.0>
      if (pcb->unacked == NULL) {
9000edc6:	6f22      	ldr	r2, [r4, #112]	; 0x70
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
9000edc8:	66e0      	str	r0, [r4, #108]	; 0x6c
      if (pcb->unacked == NULL) {
9000edca:	fab2 f382 	clz	r3, r2
9000edce:	095b      	lsrs	r3, r3, #5
9000edd0:	425b      	negs	r3, r3
9000edd2:	8623      	strh	r3, [r4, #48]	; 0x30
      pcb->polltmr = 0;
9000edd4:	2300      	movs	r3, #0
9000edd6:	7723      	strb	r3, [r4, #28]
      if (pcb->unsent == NULL) {
9000edd8:	b908      	cbnz	r0, 9000edde <tcp_receive+0x46e>
        pcb->unsent_oversize = 0;
9000edda:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
9000edde:	499f      	ldr	r1, [pc, #636]	; (9000f05c <tcp_receive+0x6ec>)
9000ede0:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
9000ede4:	8809      	ldrh	r1, [r1, #0]
9000ede6:	440b      	add	r3, r1
9000ede8:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      if (pcb->flags & TF_RTO) {
9000edec:	8b63      	ldrh	r3, [r4, #26]
9000edee:	0519      	lsls	r1, r3, #20
9000edf0:	f57f ae4d 	bpl.w	9000ea8e <tcp_receive+0x11e>
        if (pcb->unacked == NULL) {
9000edf4:	b9d2      	cbnz	r2, 9000ee2c <tcp_receive+0x4bc>
          if ((pcb->unsent == NULL) ||
9000edf6:	b968      	cbnz	r0, 9000ee14 <tcp_receive+0x4a4>
          tcp_clear_flags(pcb, TF_RTO);
9000edf8:	8b63      	ldrh	r3, [r4, #26]
9000edfa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
9000edfe:	8363      	strh	r3, [r4, #26]
9000ee00:	e645      	b.n	9000ea8e <tcp_receive+0x11e>
          TCP_WND_INC(pcb->bytes_acked, acked);
9000ee02:	f64f 73ff 	movw	r3, #65535	; 0xffff
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
9000ee06:	1a9b      	subs	r3, r3, r2
9000ee08:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
            TCP_WND_INC(pcb->cwnd, pcb->mss);
9000ee0c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
9000ee0e:	4413      	add	r3, r2
9000ee10:	b29b      	uxth	r3, r3
9000ee12:	e7a9      	b.n	9000ed68 <tcp_receive+0x3f8>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
9000ee14:	f8d4 804c 	ldr.w	r8, [r4, #76]	; 0x4c
9000ee18:	68c3      	ldr	r3, [r0, #12]
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
9000ee1a:	6858      	ldr	r0, [r3, #4]
9000ee1c:	f7fa f9b3 	bl	90009186 <lwip_htonl>
9000ee20:	eba8 0000 	sub.w	r0, r8, r0
9000ee24:	2800      	cmp	r0, #0
9000ee26:	f73f ae32 	bgt.w	9000ea8e <tcp_receive+0x11e>
9000ee2a:	e7e5      	b.n	9000edf8 <tcp_receive+0x488>
9000ee2c:	f8d4 804c 	ldr.w	r8, [r4, #76]	; 0x4c
9000ee30:	68d3      	ldr	r3, [r2, #12]
9000ee32:	e7f2      	b.n	9000ee1a <tcp_receive+0x4aa>
      tcp_send_empty_ack(pcb);
9000ee34:	4620      	mov	r0, r4
9000ee36:	f001 fdff 	bl	90010a38 <tcp_send_empty_ack>
9000ee3a:	e628      	b.n	9000ea8e <tcp_receive+0x11e>
        off -= p->len;
9000ee3c:	1aad      	subs	r5, r5, r2
        p->tot_len = new_tot_len;
9000ee3e:	f8a8 3008 	strh.w	r3, [r8, #8]
        p->len = 0;
9000ee42:	f8a8 100a 	strh.w	r1, [r8, #10]
        off -= p->len;
9000ee46:	b2ad      	uxth	r5, r5
        p = p->next;
9000ee48:	f8d8 8000 	ldr.w	r8, [r8]
9000ee4c:	e691      	b.n	9000eb72 <tcp_receive+0x202>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
9000ee4e:	1a9b      	subs	r3, r3, r2
9000ee50:	2b00      	cmp	r3, #0
        tcp_ack_now(pcb);
9000ee52:	bfbe      	ittt	lt
9000ee54:	8b63      	ldrhlt	r3, [r4, #26]
9000ee56:	f043 0302 	orrlt.w	r3, r3, #2
9000ee5a:	8363      	strhlt	r3, [r4, #26]
9000ee5c:	e697      	b.n	9000eb8e <tcp_receive+0x21e>
              pcb->ooseq = pcb->ooseq->next;
9000ee5e:	6803      	ldr	r3, [r0, #0]
9000ee60:	6763      	str	r3, [r4, #116]	; 0x74
              tcp_seg_free(old_ooseq);
9000ee62:	f7fe fce5 	bl	9000d830 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
9000ee66:	6f60      	ldr	r0, [r4, #116]	; 0x74
9000ee68:	2800      	cmp	r0, #0
9000ee6a:	d1f8      	bne.n	9000ee5e <tcp_receive+0x4ee>
        pcb->rcv_nxt = seqno + tcplen;
9000ee6c:	883a      	ldrh	r2, [r7, #0]
9000ee6e:	6833      	ldr	r3, [r6, #0]
9000ee70:	4413      	add	r3, r2
9000ee72:	6263      	str	r3, [r4, #36]	; 0x24
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
9000ee74:	8d23      	ldrh	r3, [r4, #40]	; 0x28
9000ee76:	4293      	cmp	r3, r2
9000ee78:	d206      	bcs.n	9000ee88 <tcp_receive+0x518>
9000ee7a:	4b79      	ldr	r3, [pc, #484]	; (9000f060 <tcp_receive+0x6f0>)
9000ee7c:	f240 6207 	movw	r2, #1543	; 0x607
9000ee80:	4978      	ldr	r1, [pc, #480]	; (9000f064 <tcp_receive+0x6f4>)
9000ee82:	4879      	ldr	r0, [pc, #484]	; (9000f068 <tcp_receive+0x6f8>)
9000ee84:	f002 fe92 	bl	90011bac <iprintf>
        pcb->rcv_wnd -= tcplen;
9000ee88:	8d23      	ldrh	r3, [r4, #40]	; 0x28
        tcp_update_rcv_ann_wnd(pcb);
9000ee8a:	4620      	mov	r0, r4
        pcb->rcv_wnd -= tcplen;
9000ee8c:	883a      	ldrh	r2, [r7, #0]
9000ee8e:	1a9b      	subs	r3, r3, r2
9000ee90:	8523      	strh	r3, [r4, #40]	; 0x28
        tcp_update_rcv_ann_wnd(pcb);
9000ee92:	f7fe fc59 	bl	9000d748 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
9000ee96:	686b      	ldr	r3, [r5, #4]
9000ee98:	891a      	ldrh	r2, [r3, #8]
9000ee9a:	b11a      	cbz	r2, 9000eea4 <tcp_receive+0x534>
          recv_data = inseg.p;
9000ee9c:	4a73      	ldr	r2, [pc, #460]	; (9000f06c <tcp_receive+0x6fc>)
9000ee9e:	6013      	str	r3, [r2, #0]
          inseg.p = NULL;
9000eea0:	2300      	movs	r3, #0
9000eea2:	606b      	str	r3, [r5, #4]
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
9000eea4:	68eb      	ldr	r3, [r5, #12]
9000eea6:	8998      	ldrh	r0, [r3, #12]
9000eea8:	f7fa f96a 	bl	90009180 <lwip_htons>
9000eeac:	07c5      	lsls	r5, r0, #31
9000eeae:	d504      	bpl.n	9000eeba <tcp_receive+0x54a>
          recv_flags |= TF_GOT_FIN;
9000eeb0:	4a6f      	ldr	r2, [pc, #444]	; (9000f070 <tcp_receive+0x700>)
9000eeb2:	7813      	ldrb	r3, [r2, #0]
9000eeb4:	f043 0320 	orr.w	r3, r3, #32
9000eeb8:	7013      	strb	r3, [r2, #0]
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
9000eeba:	4f69      	ldr	r7, [pc, #420]	; (9000f060 <tcp_receive+0x6f0>)
9000eebc:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 9000f078 <tcp_receive+0x708>
9000eec0:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 9000f068 <tcp_receive+0x6f8>
9000eec4:	e07b      	b.n	9000efbe <tcp_receive+0x64e>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
9000eec6:	f8bc 000c 	ldrh.w	r0, [ip, #12]
9000eeca:	f7fa f959 	bl	90009180 <lwip_htons>
9000eece:	07c1      	lsls	r1, r0, #31
9000eed0:	d51a      	bpl.n	9000ef08 <tcp_receive+0x598>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
9000eed2:	68eb      	ldr	r3, [r5, #12]
9000eed4:	8998      	ldrh	r0, [r3, #12]
9000eed6:	f7fa f953 	bl	90009180 <lwip_htons>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
9000eeda:	0782      	lsls	r2, r0, #30
9000eedc:	d414      	bmi.n	9000ef08 <tcp_receive+0x598>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
9000eede:	68eb      	ldr	r3, [r5, #12]
9000eee0:	2001      	movs	r0, #1
9000eee2:	f8b3 900c 	ldrh.w	r9, [r3, #12]
9000eee6:	f7fa f94b 	bl	90009180 <lwip_htons>
9000eeea:	68eb      	ldr	r3, [r5, #12]
9000eeec:	ea49 0000 	orr.w	r0, r9, r0
                tcplen = TCP_TCPLEN(&inseg);
9000eef0:	f8b5 9008 	ldrh.w	r9, [r5, #8]
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
9000eef4:	8198      	strh	r0, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
9000eef6:	b280      	uxth	r0, r0
9000eef8:	f7fa f942 	bl	90009180 <lwip_htons>
9000eefc:	f010 0003 	ands.w	r0, r0, #3
9000ef00:	bf18      	it	ne
9000ef02:	2001      	movne	r0, #1
9000ef04:	4448      	add	r0, r9
9000ef06:	8038      	strh	r0, [r7, #0]
              next = next->next;
9000ef08:	f8d8 9000 	ldr.w	r9, [r8]
              tcp_seg_free(tmp);
9000ef0c:	4640      	mov	r0, r8
9000ef0e:	f7fe fc8f 	bl	9000d830 <tcp_seg_free>
              next = next->next;
9000ef12:	46c8      	mov	r8, r9
9000ef14:	e6ab      	b.n	9000ec6e <tcp_receive+0x2fe>
          seqno = pcb->ooseq->tcphdr->seqno;
9000ef16:	6033      	str	r3, [r6, #0]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
9000ef18:	8990      	ldrh	r0, [r2, #12]
9000ef1a:	f8b5 a008 	ldrh.w	sl, [r5, #8]
9000ef1e:	f7fa f92f 	bl	90009180 <lwip_htons>
9000ef22:	6a63      	ldr	r3, [r4, #36]	; 0x24
9000ef24:	f010 0003 	ands.w	r0, r0, #3
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
9000ef28:	f8b5 b008 	ldrh.w	fp, [r5, #8]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
9000ef2c:	bf18      	it	ne
9000ef2e:	2001      	movne	r0, #1
9000ef30:	449a      	add	sl, r3
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
9000ef32:	68eb      	ldr	r3, [r5, #12]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
9000ef34:	4450      	add	r0, sl
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
9000ef36:	f8b4 a028 	ldrh.w	sl, [r4, #40]	; 0x28
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
9000ef3a:	6260      	str	r0, [r4, #36]	; 0x24
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
9000ef3c:	8998      	ldrh	r0, [r3, #12]
9000ef3e:	f7fa f91f 	bl	90009180 <lwip_htons>
9000ef42:	f010 0003 	ands.w	r0, r0, #3
9000ef46:	bf18      	it	ne
9000ef48:	2001      	movne	r0, #1
9000ef4a:	4458      	add	r0, fp
9000ef4c:	4582      	cmp	sl, r0
9000ef4e:	d206      	bcs.n	9000ef5e <tcp_receive+0x5ee>
9000ef50:	463b      	mov	r3, r7
9000ef52:	f240 622b 	movw	r2, #1579	; 0x62b
9000ef56:	4641      	mov	r1, r8
9000ef58:	4648      	mov	r0, r9
9000ef5a:	f002 fe27 	bl	90011bac <iprintf>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
9000ef5e:	68eb      	ldr	r3, [r5, #12]
9000ef60:	f8b5 a008 	ldrh.w	sl, [r5, #8]
9000ef64:	8998      	ldrh	r0, [r3, #12]
9000ef66:	f7fa f90b 	bl	90009180 <lwip_htons>
9000ef6a:	f010 0003 	ands.w	r0, r0, #3
9000ef6e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
9000ef70:	bf18      	it	ne
9000ef72:	2001      	movne	r0, #1
9000ef74:	4450      	add	r0, sl
9000ef76:	1a18      	subs	r0, r3, r0
9000ef78:	8520      	strh	r0, [r4, #40]	; 0x28
          tcp_update_rcv_ann_wnd(pcb);
9000ef7a:	4620      	mov	r0, r4
9000ef7c:	f7fe fbe4 	bl	9000d748 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
9000ef80:	6869      	ldr	r1, [r5, #4]
9000ef82:	890b      	ldrh	r3, [r1, #8]
9000ef84:	b133      	cbz	r3, 9000ef94 <tcp_receive+0x624>
            if (recv_data) {
9000ef86:	4b39      	ldr	r3, [pc, #228]	; (9000f06c <tcp_receive+0x6fc>)
9000ef88:	6818      	ldr	r0, [r3, #0]
9000ef8a:	b338      	cbz	r0, 9000efdc <tcp_receive+0x66c>
              pbuf_cat(recv_data, cseg->p);
9000ef8c:	f7fd fffe 	bl	9000cf8c <pbuf_cat>
            cseg->p = NULL;
9000ef90:	2300      	movs	r3, #0
9000ef92:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
9000ef94:	68eb      	ldr	r3, [r5, #12]
9000ef96:	8998      	ldrh	r0, [r3, #12]
9000ef98:	f7fa f8f2 	bl	90009180 <lwip_htons>
9000ef9c:	07c0      	lsls	r0, r0, #31
9000ef9e:	d509      	bpl.n	9000efb4 <tcp_receive+0x644>
            recv_flags |= TF_GOT_FIN;
9000efa0:	4a33      	ldr	r2, [pc, #204]	; (9000f070 <tcp_receive+0x700>)
9000efa2:	7813      	ldrb	r3, [r2, #0]
9000efa4:	f043 0320 	orr.w	r3, r3, #32
9000efa8:	7013      	strb	r3, [r2, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
9000efaa:	7d23      	ldrb	r3, [r4, #20]
9000efac:	2b04      	cmp	r3, #4
              pcb->state = CLOSE_WAIT;
9000efae:	bf04      	itt	eq
9000efb0:	2307      	moveq	r3, #7
9000efb2:	7523      	strbeq	r3, [r4, #20]
          pcb->ooseq = cseg->next;
9000efb4:	682b      	ldr	r3, [r5, #0]
          tcp_seg_free(cseg);
9000efb6:	4628      	mov	r0, r5
          pcb->ooseq = cseg->next;
9000efb8:	6763      	str	r3, [r4, #116]	; 0x74
          tcp_seg_free(cseg);
9000efba:	f7fe fc39 	bl	9000d830 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
9000efbe:	6f65      	ldr	r5, [r4, #116]	; 0x74
9000efc0:	b125      	cbz	r5, 9000efcc <tcp_receive+0x65c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
9000efc2:	68ea      	ldr	r2, [r5, #12]
        while (pcb->ooseq != NULL &&
9000efc4:	6a61      	ldr	r1, [r4, #36]	; 0x24
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
9000efc6:	6853      	ldr	r3, [r2, #4]
        while (pcb->ooseq != NULL &&
9000efc8:	428b      	cmp	r3, r1
9000efca:	d0a4      	beq.n	9000ef16 <tcp_receive+0x5a6>
        tcp_ack(pcb);
9000efcc:	8b63      	ldrh	r3, [r4, #26]
9000efce:	07d9      	lsls	r1, r3, #31
9000efd0:	d506      	bpl.n	9000efe0 <tcp_receive+0x670>
9000efd2:	f023 0301 	bic.w	r3, r3, #1
      tcp_ack_now(pcb);
9000efd6:	f043 0302 	orr.w	r3, r3, #2
9000efda:	e003      	b.n	9000efe4 <tcp_receive+0x674>
              recv_data = cseg->p;
9000efdc:	6019      	str	r1, [r3, #0]
9000efde:	e7d7      	b.n	9000ef90 <tcp_receive+0x620>
        tcp_ack(pcb);
9000efe0:	f043 0301 	orr.w	r3, r3, #1
      tcp_ack_now(pcb);
9000efe4:	8363      	strh	r3, [r4, #26]
}
9000efe6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (pcb->ooseq == NULL) {
9000efea:	6f65      	ldr	r5, [r4, #116]	; 0x74
9000efec:	b945      	cbnz	r5, 9000f000 <tcp_receive+0x690>
          pcb->ooseq = tcp_seg_copy(&inseg);
9000efee:	4821      	ldr	r0, [pc, #132]	; (9000f074 <tcp_receive+0x704>)
9000eff0:	f7fe fc34 	bl	9000d85c <tcp_seg_copy>
9000eff4:	6760      	str	r0, [r4, #116]	; 0x74
        tcp_send_empty_ack(pcb);
9000eff6:	4620      	mov	r0, r4
}
9000eff8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        tcp_send_empty_ack(pcb);
9000effc:	f001 bd1c 	b.w	90010a38 <tcp_send_empty_ack>
          struct tcp_seg *next, *prev = NULL;
9000f000:	f04f 0800 	mov.w	r8, #0
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
9000f004:	f103 3eff 	add.w	lr, r3, #4294967295
            if (seqno == next->tcphdr->seqno) {
9000f008:	f8d5 c00c 	ldr.w	ip, [r5, #12]
9000f00c:	f8dc 2004 	ldr.w	r2, [ip, #4]
9000f010:	4293      	cmp	r3, r2
9000f012:	d115      	bne.n	9000f040 <tcp_receive+0x6d0>
              if (inseg.len > next->len) {
9000f014:	4817      	ldr	r0, [pc, #92]	; (9000f074 <tcp_receive+0x704>)
9000f016:	892b      	ldrh	r3, [r5, #8]
9000f018:	8902      	ldrh	r2, [r0, #8]
9000f01a:	429a      	cmp	r2, r3
9000f01c:	d9eb      	bls.n	9000eff6 <tcp_receive+0x686>
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
9000f01e:	f7fe fc1d 	bl	9000d85c <tcp_seg_copy>
                if (cseg != NULL) {
9000f022:	2800      	cmp	r0, #0
9000f024:	d0e7      	beq.n	9000eff6 <tcp_receive+0x686>
                  if (prev != NULL) {
9000f026:	f1b8 0f00 	cmp.w	r8, #0
9000f02a:	d007      	beq.n	9000f03c <tcp_receive+0x6cc>
                    prev->next = cseg;
9000f02c:	f8c8 0000 	str.w	r0, [r8]
                    tcp_oos_insert_segment(cseg, next);
9000f030:	4629      	mov	r1, r5
9000f032:	f7ff fb7d 	bl	9000e730 <tcp_oos_insert_segment>
9000f036:	e7de      	b.n	9000eff6 <tcp_receive+0x686>
9000f038:	460d      	mov	r5, r1
9000f03a:	e7e5      	b.n	9000f008 <tcp_receive+0x698>
                    pcb->ooseq = cseg;
9000f03c:	6760      	str	r0, [r4, #116]	; 0x74
                  tcp_oos_insert_segment(cseg, next);
9000f03e:	e7f7      	b.n	9000f030 <tcp_receive+0x6c0>
              if (prev == NULL) {
9000f040:	f1b8 0f00 	cmp.w	r8, #0
9000f044:	d11a      	bne.n	9000f07c <tcp_receive+0x70c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
9000f046:	1a99      	subs	r1, r3, r2
9000f048:	2900      	cmp	r1, #0
9000f04a:	da3e      	bge.n	9000f0ca <tcp_receive+0x75a>
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
9000f04c:	4809      	ldr	r0, [pc, #36]	; (9000f074 <tcp_receive+0x704>)
9000f04e:	f7fe fc05 	bl	9000d85c <tcp_seg_copy>
                  if (cseg != NULL) {
9000f052:	2800      	cmp	r0, #0
9000f054:	d0cf      	beq.n	9000eff6 <tcp_receive+0x686>
                    pcb->ooseq = cseg;
9000f056:	6760      	str	r0, [r4, #116]	; 0x74
9000f058:	e7ea      	b.n	9000f030 <tcp_receive+0x6c0>
9000f05a:	bf00      	nop
9000f05c:	2400d3e4 	.word	0x2400d3e4
9000f060:	90014c4f 	.word	0x90014c4f
9000f064:	90014e07 	.word	0x90014e07
9000f068:	90012aff 	.word	0x90012aff
9000f06c:	2400d3e8 	.word	0x2400d3e8
9000f070:	2400d3ec 	.word	0x2400d3ec
9000f074:	2400d3d4 	.word	0x2400d3d4
9000f078:	90014e26 	.word	0x90014e26
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
9000f07c:	f8d8 100c 	ldr.w	r1, [r8, #12]
9000f080:	6849      	ldr	r1, [r1, #4]
9000f082:	ebae 0101 	sub.w	r1, lr, r1
9000f086:	2900      	cmp	r1, #0
9000f088:	db1f      	blt.n	9000f0ca <tcp_receive+0x75a>
9000f08a:	1a81      	subs	r1, r0, r2
9000f08c:	2900      	cmp	r1, #0
9000f08e:	dc1c      	bgt.n	9000f0ca <tcp_receive+0x75a>
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
9000f090:	484a      	ldr	r0, [pc, #296]	; (9000f1bc <tcp_receive+0x84c>)
9000f092:	f7fe fbe3 	bl	9000d85c <tcp_seg_copy>
                  if (cseg != NULL) {
9000f096:	4607      	mov	r7, r0
9000f098:	2800      	cmp	r0, #0
9000f09a:	d0ac      	beq.n	9000eff6 <tcp_receive+0x686>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
9000f09c:	f8d8 300c 	ldr.w	r3, [r8, #12]
9000f0a0:	6831      	ldr	r1, [r6, #0]
9000f0a2:	685a      	ldr	r2, [r3, #4]
9000f0a4:	f8b8 3008 	ldrh.w	r3, [r8, #8]
9000f0a8:	4413      	add	r3, r2
9000f0aa:	1a5b      	subs	r3, r3, r1
9000f0ac:	2b00      	cmp	r3, #0
9000f0ae:	dd07      	ble.n	9000f0c0 <tcp_receive+0x750>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
9000f0b0:	1a89      	subs	r1, r1, r2
                      pbuf_realloc(prev->p, prev->len);
9000f0b2:	f8d8 0004 	ldr.w	r0, [r8, #4]
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
9000f0b6:	b289      	uxth	r1, r1
9000f0b8:	f8a8 1008 	strh.w	r1, [r8, #8]
                      pbuf_realloc(prev->p, prev->len);
9000f0bc:	f7fd feea 	bl	9000ce94 <pbuf_realloc>
                    tcp_oos_insert_segment(cseg, next);
9000f0c0:	4629      	mov	r1, r5
9000f0c2:	4638      	mov	r0, r7
                    prev->next = cseg;
9000f0c4:	f8c8 7000 	str.w	r7, [r8]
                    tcp_oos_insert_segment(cseg, next);
9000f0c8:	e7b3      	b.n	9000f032 <tcp_receive+0x6c2>
              if (next->next == NULL &&
9000f0ca:	6829      	ldr	r1, [r5, #0]
9000f0cc:	46a8      	mov	r8, r5
9000f0ce:	2900      	cmp	r1, #0
9000f0d0:	d1b2      	bne.n	9000f038 <tcp_receive+0x6c8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
9000f0d2:	1a9b      	subs	r3, r3, r2
              if (next->next == NULL &&
9000f0d4:	2b00      	cmp	r3, #0
9000f0d6:	dd8e      	ble.n	9000eff6 <tcp_receive+0x686>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
9000f0d8:	f8bc 000c 	ldrh.w	r0, [ip, #12]
9000f0dc:	f7fa f850 	bl	90009180 <lwip_htons>
9000f0e0:	07c2      	lsls	r2, r0, #31
9000f0e2:	d488      	bmi.n	9000eff6 <tcp_receive+0x686>
                next->next = tcp_seg_copy(&inseg);
9000f0e4:	4835      	ldr	r0, [pc, #212]	; (9000f1bc <tcp_receive+0x84c>)
9000f0e6:	f7fe fbb9 	bl	9000d85c <tcp_seg_copy>
9000f0ea:	6028      	str	r0, [r5, #0]
                if (next->next != NULL) {
9000f0ec:	2800      	cmp	r0, #0
9000f0ee:	d082      	beq.n	9000eff6 <tcp_receive+0x686>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
9000f0f0:	68eb      	ldr	r3, [r5, #12]
9000f0f2:	6831      	ldr	r1, [r6, #0]
9000f0f4:	685a      	ldr	r2, [r3, #4]
9000f0f6:	892b      	ldrh	r3, [r5, #8]
9000f0f8:	4413      	add	r3, r2
9000f0fa:	1a5b      	subs	r3, r3, r1
9000f0fc:	2b00      	cmp	r3, #0
9000f0fe:	dd05      	ble.n	9000f10c <tcp_receive+0x79c>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
9000f100:	1a89      	subs	r1, r1, r2
                    pbuf_realloc(next->p, next->len);
9000f102:	6868      	ldr	r0, [r5, #4]
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
9000f104:	b289      	uxth	r1, r1
9000f106:	8129      	strh	r1, [r5, #8]
                    pbuf_realloc(next->p, next->len);
9000f108:	f7fd fec4 	bl	9000ce94 <pbuf_realloc>
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
9000f10c:	6832      	ldr	r2, [r6, #0]
9000f10e:	883b      	ldrh	r3, [r7, #0]
9000f110:	4413      	add	r3, r2
9000f112:	6a62      	ldr	r2, [r4, #36]	; 0x24
9000f114:	1a9b      	subs	r3, r3, r2
9000f116:	8d22      	ldrh	r2, [r4, #40]	; 0x28
9000f118:	1a9b      	subs	r3, r3, r2
9000f11a:	2b00      	cmp	r3, #0
9000f11c:	f77f af6b 	ble.w	9000eff6 <tcp_receive+0x686>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
9000f120:	682b      	ldr	r3, [r5, #0]
9000f122:	68db      	ldr	r3, [r3, #12]
9000f124:	8998      	ldrh	r0, [r3, #12]
9000f126:	f7fa f82b 	bl	90009180 <lwip_htons>
9000f12a:	07c3      	lsls	r3, r0, #31
9000f12c:	d512      	bpl.n	9000f154 <tcp_receive+0x7e4>
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
9000f12e:	682b      	ldr	r3, [r5, #0]
9000f130:	68db      	ldr	r3, [r3, #12]
9000f132:	f8b3 800c 	ldrh.w	r8, [r3, #12]
9000f136:	4640      	mov	r0, r8
9000f138:	f428 587c 	bic.w	r8, r8, #16128	; 0x3f00
9000f13c:	f7fa f820 	bl	90009180 <lwip_htons>
9000f140:	f000 003e 	and.w	r0, r0, #62	; 0x3e
9000f144:	f7fa f81c 	bl	90009180 <lwip_htons>
9000f148:	682b      	ldr	r3, [r5, #0]
9000f14a:	ea48 0800 	orr.w	r8, r8, r0
9000f14e:	68db      	ldr	r3, [r3, #12]
9000f150:	f8a3 800c 	strh.w	r8, [r3, #12]
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
9000f154:	6832      	ldr	r2, [r6, #0]
9000f156:	8d21      	ldrh	r1, [r4, #40]	; 0x28
9000f158:	682b      	ldr	r3, [r5, #0]
9000f15a:	1a89      	subs	r1, r1, r2
9000f15c:	6a62      	ldr	r2, [r4, #36]	; 0x24
                    pbuf_realloc(next->next->p, next->next->len);
9000f15e:	6858      	ldr	r0, [r3, #4]
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
9000f160:	4411      	add	r1, r2
9000f162:	b289      	uxth	r1, r1
9000f164:	8119      	strh	r1, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
9000f166:	f7fd fe95 	bl	9000ce94 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
9000f16a:	682b      	ldr	r3, [r5, #0]
9000f16c:	891d      	ldrh	r5, [r3, #8]
9000f16e:	68db      	ldr	r3, [r3, #12]
9000f170:	8998      	ldrh	r0, [r3, #12]
9000f172:	f7fa f805 	bl	90009180 <lwip_htons>
9000f176:	f010 0003 	ands.w	r0, r0, #3
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000f17a:	6833      	ldr	r3, [r6, #0]
                    tcplen = TCP_TCPLEN(next->next);
9000f17c:	bf18      	it	ne
9000f17e:	2001      	movne	r0, #1
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000f180:	6a62      	ldr	r2, [r4, #36]	; 0x24
                    tcplen = TCP_TCPLEN(next->next);
9000f182:	4428      	add	r0, r5
9000f184:	b280      	uxth	r0, r0
9000f186:	8038      	strh	r0, [r7, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
9000f188:	4418      	add	r0, r3
9000f18a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
9000f18c:	4413      	add	r3, r2
9000f18e:	4298      	cmp	r0, r3
9000f190:	f43f af31 	beq.w	9000eff6 <tcp_receive+0x686>
9000f194:	4b0a      	ldr	r3, [pc, #40]	; (9000f1c0 <tcp_receive+0x850>)
9000f196:	f44f 62df 	mov.w	r2, #1784	; 0x6f8
9000f19a:	490a      	ldr	r1, [pc, #40]	; (9000f1c4 <tcp_receive+0x854>)
9000f19c:	480a      	ldr	r0, [pc, #40]	; (9000f1c8 <tcp_receive+0x858>)
9000f19e:	f002 fd05 	bl	90011bac <iprintf>
9000f1a2:	e728      	b.n	9000eff6 <tcp_receive+0x686>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
9000f1a4:	1a99      	subs	r1, r3, r2
9000f1a6:	2900      	cmp	r1, #0
9000f1a8:	db06      	blt.n	9000f1b8 <tcp_receive+0x848>
9000f1aa:	3301      	adds	r3, #1
9000f1ac:	1a9b      	subs	r3, r3, r2
9000f1ae:	8d22      	ldrh	r2, [r4, #40]	; 0x28
9000f1b0:	1a9b      	subs	r3, r3, r2
9000f1b2:	2b00      	cmp	r3, #0
9000f1b4:	f77f af17 	ble.w	9000efe6 <tcp_receive+0x676>
      tcp_ack_now(pcb);
9000f1b8:	8b63      	ldrh	r3, [r4, #26]
9000f1ba:	e70c      	b.n	9000efd6 <tcp_receive+0x666>
9000f1bc:	2400d3d4 	.word	0x2400d3d4
9000f1c0:	90014c4f 	.word	0x90014c4f
9000f1c4:	90014d95 	.word	0x90014d95
9000f1c8:	90012aff 	.word	0x90012aff

9000f1cc <tcp_input>:
{
9000f1cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
9000f1d0:	4605      	mov	r5, r0
{
9000f1d2:	b087      	sub	sp, #28
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
9000f1d4:	b928      	cbnz	r0, 9000f1e2 <tcp_input+0x16>
9000f1d6:	4b63      	ldr	r3, [pc, #396]	; (9000f364 <tcp_input+0x198>)
9000f1d8:	2283      	movs	r2, #131	; 0x83
9000f1da:	4963      	ldr	r1, [pc, #396]	; (9000f368 <tcp_input+0x19c>)
9000f1dc:	4863      	ldr	r0, [pc, #396]	; (9000f36c <tcp_input+0x1a0>)
9000f1de:	f002 fce5 	bl	90011bac <iprintf>
  tcphdr = (struct tcp_hdr *)p->payload;
9000f1e2:	686b      	ldr	r3, [r5, #4]
9000f1e4:	4e62      	ldr	r6, [pc, #392]	; (9000f370 <tcp_input+0x1a4>)
9000f1e6:	6033      	str	r3, [r6, #0]
  if (p->len < TCP_HLEN) {
9000f1e8:	896b      	ldrh	r3, [r5, #10]
9000f1ea:	2b13      	cmp	r3, #19
9000f1ec:	f240 80b3 	bls.w	9000f356 <tcp_input+0x18a>
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
9000f1f0:	4f60      	ldr	r7, [pc, #384]	; (9000f374 <tcp_input+0x1a8>)
9000f1f2:	6839      	ldr	r1, [r7, #0]
9000f1f4:	6978      	ldr	r0, [r7, #20]
9000f1f6:	f7fc f9d2 	bl	9000b59e <ip4_addr_isbroadcast_u32>
9000f1fa:	4604      	mov	r4, r0
9000f1fc:	2800      	cmp	r0, #0
9000f1fe:	f040 80aa 	bne.w	9000f356 <tcp_input+0x18a>
      ip_addr_ismulticast(ip_current_dest_addr())) {
9000f202:	697b      	ldr	r3, [r7, #20]
9000f204:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
9000f208:	2be0      	cmp	r3, #224	; 0xe0
9000f20a:	f000 80a4 	beq.w	9000f356 <tcp_input+0x18a>
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
9000f20e:	6833      	ldr	r3, [r6, #0]
9000f210:	8998      	ldrh	r0, [r3, #12]
9000f212:	f7f9 ffb5 	bl	90009180 <lwip_htons>
9000f216:	0a81      	lsrs	r1, r0, #10
9000f218:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
9000f21c:	2913      	cmp	r1, #19
9000f21e:	f240 809a 	bls.w	9000f356 <tcp_input+0x18a>
9000f222:	892b      	ldrh	r3, [r5, #8]
9000f224:	b28a      	uxth	r2, r1
9000f226:	428b      	cmp	r3, r1
9000f228:	f0c0 8095 	bcc.w	9000f356 <tcp_input+0x18a>
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
9000f22c:	f1a2 0314 	sub.w	r3, r2, #20
  if (p->len >= hdrlen_bytes) {
9000f230:	8968      	ldrh	r0, [r5, #10]
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
9000f232:	f8df 8160 	ldr.w	r8, [pc, #352]	; 9000f394 <tcp_input+0x1c8>
9000f236:	b29b      	uxth	r3, r3
  tcphdr_opt2 = NULL;
9000f238:	f8df a15c 	ldr.w	sl, [pc, #348]	; 9000f398 <tcp_input+0x1cc>
  if (p->len >= hdrlen_bytes) {
9000f23c:	4290      	cmp	r0, r2
9000f23e:	f8df 915c 	ldr.w	r9, [pc, #348]	; 9000f39c <tcp_input+0x1d0>
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
9000f242:	f8a8 3000 	strh.w	r3, [r8]
  tcphdr_opt2 = NULL;
9000f246:	f8ca 4000 	str.w	r4, [sl]
  if (p->len >= hdrlen_bytes) {
9000f24a:	d342      	bcc.n	9000f2d2 <tcp_input+0x106>
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
9000f24c:	4628      	mov	r0, r5
    tcphdr_opt1len = tcphdr_optlen;
9000f24e:	f8a9 3000 	strh.w	r3, [r9]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
9000f252:	f7fd fcf1 	bl	9000cc38 <pbuf_remove_header>
  tcphdr->src = lwip_ntohs(tcphdr->src);
9000f256:	6834      	ldr	r4, [r6, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
9000f258:	f8df b144 	ldr.w	fp, [pc, #324]	; 9000f3a0 <tcp_input+0x1d4>
  tcphdr->src = lwip_ntohs(tcphdr->src);
9000f25c:	8820      	ldrh	r0, [r4, #0]
9000f25e:	f7f9 ff8f 	bl	90009180 <lwip_htons>
9000f262:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
9000f264:	6834      	ldr	r4, [r6, #0]
9000f266:	8860      	ldrh	r0, [r4, #2]
9000f268:	f7f9 ff8a 	bl	90009180 <lwip_htons>
9000f26c:	8060      	strh	r0, [r4, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
9000f26e:	6834      	ldr	r4, [r6, #0]
9000f270:	6860      	ldr	r0, [r4, #4]
9000f272:	f7f9 ff88 	bl	90009186 <lwip_htonl>
9000f276:	4b40      	ldr	r3, [pc, #256]	; (9000f378 <tcp_input+0x1ac>)
9000f278:	6060      	str	r0, [r4, #4]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
9000f27a:	6834      	ldr	r4, [r6, #0]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
9000f27c:	6018      	str	r0, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
9000f27e:	68a0      	ldr	r0, [r4, #8]
9000f280:	f7f9 ff81 	bl	90009186 <lwip_htonl>
9000f284:	60a0      	str	r0, [r4, #8]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
9000f286:	6834      	ldr	r4, [r6, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
9000f288:	f8cb 0000 	str.w	r0, [fp]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
9000f28c:	89e0      	ldrh	r0, [r4, #14]
9000f28e:	f7f9 ff77 	bl	90009180 <lwip_htons>
  flags = TCPH_FLAGS(tcphdr);
9000f292:	6833      	ldr	r3, [r6, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
9000f294:	81e0      	strh	r0, [r4, #14]
  flags = TCPH_FLAGS(tcphdr);
9000f296:	8998      	ldrh	r0, [r3, #12]
9000f298:	f7f9 ff72 	bl	90009180 <lwip_htons>
9000f29c:	4a37      	ldr	r2, [pc, #220]	; (9000f37c <tcp_input+0x1b0>)
9000f29e:	f000 033f 	and.w	r3, r0, #63	; 0x3f
9000f2a2:	7013      	strb	r3, [r2, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
9000f2a4:	0783      	lsls	r3, r0, #30
  tcplen = p->tot_len;
9000f2a6:	892a      	ldrh	r2, [r5, #8]
  if (flags & (TCP_FIN | TCP_SYN)) {
9000f2a8:	d14f      	bne.n	9000f34a <tcp_input+0x17e>
  tcplen = p->tot_len;
9000f2aa:	4b35      	ldr	r3, [pc, #212]	; (9000f380 <tcp_input+0x1b4>)
9000f2ac:	801a      	strh	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2ae:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 9000f3a4 <tcp_input+0x1d8>
  prev = NULL;
9000f2b2:	f04f 0a00 	mov.w	sl, #0
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
9000f2b6:	4b2b      	ldr	r3, [pc, #172]	; (9000f364 <tcp_input+0x198>)
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2b8:	f8d8 4000 	ldr.w	r4, [r8]
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
9000f2bc:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 9000f36c <tcp_input+0x1a0>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2c0:	2c00      	cmp	r4, #0
9000f2c2:	d173      	bne.n	9000f3ac <tcp_input+0x1e0>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2c4:	4b2f      	ldr	r3, [pc, #188]	; (9000f384 <tcp_input+0x1b8>)
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000f2c6:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9000f3a8 <tcp_input+0x1dc>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2ca:	681c      	ldr	r4, [r3, #0]
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000f2cc:	f8df 909c 	ldr.w	r9, [pc, #156]	; 9000f36c <tcp_input+0x1a0>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000f2d0:	e15a      	b.n	9000f588 <tcp_input+0x3bc>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
9000f2d2:	682b      	ldr	r3, [r5, #0]
9000f2d4:	b92b      	cbnz	r3, 9000f2e2 <tcp_input+0x116>
9000f2d6:	4b23      	ldr	r3, [pc, #140]	; (9000f364 <tcp_input+0x198>)
9000f2d8:	22c2      	movs	r2, #194	; 0xc2
9000f2da:	492b      	ldr	r1, [pc, #172]	; (9000f388 <tcp_input+0x1bc>)
9000f2dc:	4823      	ldr	r0, [pc, #140]	; (9000f36c <tcp_input+0x1a0>)
9000f2de:	f002 fc65 	bl	90011bac <iprintf>
    pbuf_remove_header(p, TCP_HLEN);
9000f2e2:	2114      	movs	r1, #20
9000f2e4:	4628      	mov	r0, r5
9000f2e6:	f7fd fca7 	bl	9000cc38 <pbuf_remove_header>
    tcphdr_opt1len = p->len;
9000f2ea:	896c      	ldrh	r4, [r5, #10]
    pbuf_remove_header(p, tcphdr_opt1len);
9000f2ec:	4628      	mov	r0, r5
    tcphdr_opt1len = p->len;
9000f2ee:	f8a9 4000 	strh.w	r4, [r9]
    pbuf_remove_header(p, tcphdr_opt1len);
9000f2f2:	4621      	mov	r1, r4
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
9000f2f4:	f8b8 9000 	ldrh.w	r9, [r8]
    pbuf_remove_header(p, tcphdr_opt1len);
9000f2f8:	f7fd fc9e 	bl	9000cc38 <pbuf_remove_header>
    if (opt2len > p->next->len) {
9000f2fc:	6828      	ldr	r0, [r5, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
9000f2fe:	eba9 0804 	sub.w	r8, r9, r4
    if (opt2len > p->next->len) {
9000f302:	8943      	ldrh	r3, [r0, #10]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
9000f304:	fa1f f888 	uxth.w	r8, r8
    if (opt2len > p->next->len) {
9000f308:	4543      	cmp	r3, r8
9000f30a:	d324      	bcc.n	9000f356 <tcp_input+0x18a>
    tcphdr_opt2 = (u8_t *)p->next->payload;
9000f30c:	6843      	ldr	r3, [r0, #4]
    pbuf_remove_header(p->next, opt2len);
9000f30e:	4641      	mov	r1, r8
    tcphdr_opt2 = (u8_t *)p->next->payload;
9000f310:	f8ca 3000 	str.w	r3, [sl]
    pbuf_remove_header(p->next, opt2len);
9000f314:	f7fd fc90 	bl	9000cc38 <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
9000f318:	892b      	ldrh	r3, [r5, #8]
9000f31a:	441c      	add	r4, r3
    LWIP_ASSERT("p->len == 0", p->len == 0);
9000f31c:	896b      	ldrh	r3, [r5, #10]
    p->tot_len = (u16_t)(p->tot_len - opt2len);
9000f31e:	eba4 0409 	sub.w	r4, r4, r9
9000f322:	812c      	strh	r4, [r5, #8]
    LWIP_ASSERT("p->len == 0", p->len == 0);
9000f324:	b12b      	cbz	r3, 9000f332 <tcp_input+0x166>
9000f326:	4b0f      	ldr	r3, [pc, #60]	; (9000f364 <tcp_input+0x198>)
9000f328:	22df      	movs	r2, #223	; 0xdf
9000f32a:	4918      	ldr	r1, [pc, #96]	; (9000f38c <tcp_input+0x1c0>)
9000f32c:	480f      	ldr	r0, [pc, #60]	; (9000f36c <tcp_input+0x1a0>)
9000f32e:	f002 fc3d 	bl	90011bac <iprintf>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
9000f332:	682b      	ldr	r3, [r5, #0]
9000f334:	892a      	ldrh	r2, [r5, #8]
9000f336:	891b      	ldrh	r3, [r3, #8]
9000f338:	429a      	cmp	r2, r3
9000f33a:	d08c      	beq.n	9000f256 <tcp_input+0x8a>
9000f33c:	4b09      	ldr	r3, [pc, #36]	; (9000f364 <tcp_input+0x198>)
9000f33e:	22e0      	movs	r2, #224	; 0xe0
9000f340:	4913      	ldr	r1, [pc, #76]	; (9000f390 <tcp_input+0x1c4>)
9000f342:	480a      	ldr	r0, [pc, #40]	; (9000f36c <tcp_input+0x1a0>)
9000f344:	f002 fc32 	bl	90011bac <iprintf>
9000f348:	e785      	b.n	9000f256 <tcp_input+0x8a>
    tcplen++;
9000f34a:	1c53      	adds	r3, r2, #1
9000f34c:	490c      	ldr	r1, [pc, #48]	; (9000f380 <tcp_input+0x1b4>)
9000f34e:	b29b      	uxth	r3, r3
    if (tcplen < p->tot_len) {
9000f350:	429a      	cmp	r2, r3
    tcplen++;
9000f352:	800b      	strh	r3, [r1, #0]
    if (tcplen < p->tot_len) {
9000f354:	d9ab      	bls.n	9000f2ae <tcp_input+0xe2>
  pbuf_free(p);
9000f356:	4628      	mov	r0, r5
}
9000f358:	b007      	add	sp, #28
9000f35a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pbuf_free(p);
9000f35e:	f7fd bc9f 	b.w	9000cca0 <pbuf_free>
9000f362:	bf00      	nop
9000f364:	90014c4f 	.word	0x90014c4f
9000f368:	90014e4b 	.word	0x90014e4b
9000f36c:	90012aff 	.word	0x90012aff
9000f370:	2400d3fc 	.word	0x2400d3fc
9000f374:	2400a0e8 	.word	0x2400a0e8
9000f378:	2400d3f0 	.word	0x2400d3f0
9000f37c:	2400d3d0 	.word	0x2400d3d0
9000f380:	2400d40a 	.word	0x2400d40a
9000f384:	2400d3c8 	.word	0x2400d3c8
9000f388:	90014e63 	.word	0x90014e63
9000f38c:	90014e73 	.word	0x90014e73
9000f390:	90014e7f 	.word	0x90014e7f
9000f394:	2400d408 	.word	0x2400d408
9000f398:	2400d404 	.word	0x2400d404
9000f39c:	2400d400 	.word	0x2400d400
9000f3a0:	2400d3cc 	.word	0x2400d3cc
9000f3a4:	2400d3b0 	.word	0x2400d3b0
9000f3a8:	90014f6b 	.word	0x90014f6b
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
9000f3ac:	7d22      	ldrb	r2, [r4, #20]
9000f3ae:	b92a      	cbnz	r2, 9000f3bc <tcp_input+0x1f0>
9000f3b0:	22fb      	movs	r2, #251	; 0xfb
9000f3b2:	499d      	ldr	r1, [pc, #628]	; (9000f628 <tcp_input+0x45c>)
9000f3b4:	4648      	mov	r0, r9
9000f3b6:	f002 fbf9 	bl	90011bac <iprintf>
9000f3ba:	4b9c      	ldr	r3, [pc, #624]	; (9000f62c <tcp_input+0x460>)
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
9000f3bc:	7d22      	ldrb	r2, [r4, #20]
9000f3be:	2a0a      	cmp	r2, #10
9000f3c0:	d105      	bne.n	9000f3ce <tcp_input+0x202>
9000f3c2:	22fc      	movs	r2, #252	; 0xfc
9000f3c4:	499a      	ldr	r1, [pc, #616]	; (9000f630 <tcp_input+0x464>)
9000f3c6:	4648      	mov	r0, r9
9000f3c8:	f002 fbf0 	bl	90011bac <iprintf>
9000f3cc:	4b97      	ldr	r3, [pc, #604]	; (9000f62c <tcp_input+0x460>)
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
9000f3ce:	7d22      	ldrb	r2, [r4, #20]
9000f3d0:	2a01      	cmp	r2, #1
9000f3d2:	d105      	bne.n	9000f3e0 <tcp_input+0x214>
9000f3d4:	22fd      	movs	r2, #253	; 0xfd
9000f3d6:	4997      	ldr	r1, [pc, #604]	; (9000f634 <tcp_input+0x468>)
9000f3d8:	4648      	mov	r0, r9
9000f3da:	f002 fbe7 	bl	90011bac <iprintf>
9000f3de:	4b93      	ldr	r3, [pc, #588]	; (9000f62c <tcp_input+0x460>)
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
9000f3e0:	7a20      	ldrb	r0, [r4, #8]
9000f3e2:	68e1      	ldr	r1, [r4, #12]
9000f3e4:	b130      	cbz	r0, 9000f3f4 <tcp_input+0x228>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
9000f3e6:	687a      	ldr	r2, [r7, #4]
9000f3e8:	f892 2038 	ldrb.w	r2, [r2, #56]	; 0x38
9000f3ec:	3201      	adds	r2, #1
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
9000f3ee:	b2d2      	uxtb	r2, r2
9000f3f0:	4290      	cmp	r0, r2
9000f3f2:	d173      	bne.n	9000f4dc <tcp_input+0x310>
    if (pcb->remote_port == tcphdr->src &&
9000f3f4:	6832      	ldr	r2, [r6, #0]
9000f3f6:	f8b4 c018 	ldrh.w	ip, [r4, #24]
9000f3fa:	8810      	ldrh	r0, [r2, #0]
9000f3fc:	4584      	cmp	ip, r0
9000f3fe:	d16d      	bne.n	9000f4dc <tcp_input+0x310>
9000f400:	8ae0      	ldrh	r0, [r4, #22]
9000f402:	8852      	ldrh	r2, [r2, #2]
9000f404:	4290      	cmp	r0, r2
9000f406:	d169      	bne.n	9000f4dc <tcp_input+0x310>
        pcb->local_port == tcphdr->dest &&
9000f408:	6860      	ldr	r0, [r4, #4]
9000f40a:	693a      	ldr	r2, [r7, #16]
9000f40c:	4290      	cmp	r0, r2
9000f40e:	d165      	bne.n	9000f4dc <tcp_input+0x310>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
9000f410:	6820      	ldr	r0, [r4, #0]
9000f412:	697a      	ldr	r2, [r7, #20]
9000f414:	4290      	cmp	r0, r2
9000f416:	d161      	bne.n	9000f4dc <tcp_input+0x310>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
9000f418:	42a1      	cmp	r1, r4
9000f41a:	f040 8445 	bne.w	9000fca8 <tcp_input+0xadc>
9000f41e:	4b83      	ldr	r3, [pc, #524]	; (9000f62c <tcp_input+0x460>)
9000f420:	f240 120d 	movw	r2, #269	; 0x10d
9000f424:	4984      	ldr	r1, [pc, #528]	; (9000f638 <tcp_input+0x46c>)
9000f426:	4885      	ldr	r0, [pc, #532]	; (9000f63c <tcp_input+0x470>)
9000f428:	f002 fbc0 	bl	90011bac <iprintf>
      if (prev != NULL) {
9000f42c:	f1ba 0f00 	cmp.w	sl, #0
9000f430:	d007      	beq.n	9000f442 <tcp_input+0x276>
        prev->next = pcb->next;
9000f432:	68e3      	ldr	r3, [r4, #12]
9000f434:	f8ca 300c 	str.w	r3, [sl, #12]
        pcb->next = tcp_active_pcbs;
9000f438:	f8d8 3000 	ldr.w	r3, [r8]
        tcp_active_pcbs = pcb;
9000f43c:	f8c8 4000 	str.w	r4, [r8]
        pcb->next = tcp_active_pcbs;
9000f440:	60e3      	str	r3, [r4, #12]
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
9000f442:	68e3      	ldr	r3, [r4, #12]
9000f444:	42a3      	cmp	r3, r4
9000f446:	d106      	bne.n	9000f456 <tcp_input+0x28a>
9000f448:	4b78      	ldr	r3, [pc, #480]	; (9000f62c <tcp_input+0x460>)
9000f44a:	f240 1215 	movw	r2, #277	; 0x115
9000f44e:	497c      	ldr	r1, [pc, #496]	; (9000f640 <tcp_input+0x474>)
9000f450:	487a      	ldr	r0, [pc, #488]	; (9000f63c <tcp_input+0x470>)
9000f452:	f002 fbab 	bl	90011bac <iprintf>
    inseg.next = NULL;
9000f456:	f8df 9210 	ldr.w	r9, [pc, #528]	; 9000f668 <tcp_input+0x49c>
9000f45a:	2300      	movs	r3, #0
    inseg.len = p->tot_len;
9000f45c:	892a      	ldrh	r2, [r5, #8]
    recv_data = NULL;
9000f45e:	f8df a20c 	ldr.w	sl, [pc, #524]	; 9000f66c <tcp_input+0x4a0>
    inseg.len = p->tot_len;
9000f462:	f8a9 2008 	strh.w	r2, [r9, #8]
    inseg.tcphdr = tcphdr;
9000f466:	6832      	ldr	r2, [r6, #0]
    recv_flags = 0;
9000f468:	4f76      	ldr	r7, [pc, #472]	; (9000f644 <tcp_input+0x478>)
    inseg.tcphdr = tcphdr;
9000f46a:	f8c9 200c 	str.w	r2, [r9, #12]
    recv_acked = 0;
9000f46e:	4a76      	ldr	r2, [pc, #472]	; (9000f648 <tcp_input+0x47c>)
    inseg.next = NULL;
9000f470:	f8c9 3000 	str.w	r3, [r9]
    recv_data = NULL;
9000f474:	f8ca 3000 	str.w	r3, [sl]
    recv_flags = 0;
9000f478:	703b      	strb	r3, [r7, #0]
    recv_acked = 0;
9000f47a:	8013      	strh	r3, [r2, #0]
    if (flags & TCP_PSH) {
9000f47c:	4b73      	ldr	r3, [pc, #460]	; (9000f64c <tcp_input+0x480>)
    inseg.p = p;
9000f47e:	f8c9 5004 	str.w	r5, [r9, #4]
    if (flags & TCP_PSH) {
9000f482:	781b      	ldrb	r3, [r3, #0]
9000f484:	071b      	lsls	r3, r3, #28
9000f486:	d503      	bpl.n	9000f490 <tcp_input+0x2c4>
      p->flags |= PBUF_FLAG_PUSH;
9000f488:	7b6b      	ldrb	r3, [r5, #13]
9000f48a:	f043 0301 	orr.w	r3, r3, #1
9000f48e:	736b      	strb	r3, [r5, #13]
    if (pcb->refused_data != NULL) {
9000f490:	6fa3      	ldr	r3, [r4, #120]	; 0x78
9000f492:	4d6f      	ldr	r5, [pc, #444]	; (9000f650 <tcp_input+0x484>)
9000f494:	2b00      	cmp	r3, #0
9000f496:	f000 814c 	beq.w	9000f732 <tcp_input+0x566>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
9000f49a:	4620      	mov	r0, r4
9000f49c:	f7fe fe78 	bl	9000e190 <tcp_process_refused_data>
9000f4a0:	300d      	adds	r0, #13
9000f4a2:	d008      	beq.n	9000f4b6 <tcp_input+0x2ea>
9000f4a4:	6fa3      	ldr	r3, [r4, #120]	; 0x78
9000f4a6:	2b00      	cmp	r3, #0
9000f4a8:	f000 8143 	beq.w	9000f732 <tcp_input+0x566>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
9000f4ac:	4b69      	ldr	r3, [pc, #420]	; (9000f654 <tcp_input+0x488>)
9000f4ae:	881b      	ldrh	r3, [r3, #0]
9000f4b0:	2b00      	cmp	r3, #0
9000f4b2:	f000 813e 	beq.w	9000f732 <tcp_input+0x566>
        if (pcb->rcv_ann_wnd == 0) {
9000f4b6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
9000f4b8:	b913      	cbnz	r3, 9000f4c0 <tcp_input+0x2f4>
          tcp_send_empty_ack(pcb);
9000f4ba:	4620      	mov	r0, r4
9000f4bc:	f001 fabc 	bl	90010a38 <tcp_send_empty_ack>
    tcp_input_pcb = NULL;
9000f4c0:	2400      	movs	r4, #0
    if (inseg.p != NULL) {
9000f4c2:	f8d9 0004 	ldr.w	r0, [r9, #4]
    tcp_input_pcb = NULL;
9000f4c6:	602c      	str	r4, [r5, #0]
    recv_data = NULL;
9000f4c8:	f8ca 4000 	str.w	r4, [sl]
    if (inseg.p != NULL) {
9000f4cc:	b118      	cbz	r0, 9000f4d6 <tcp_input+0x30a>
      pbuf_free(inseg.p);
9000f4ce:	f7fd fbe7 	bl	9000cca0 <pbuf_free>
      inseg.p = NULL;
9000f4d2:	f8c9 4004 	str.w	r4, [r9, #4]
}
9000f4d6:	b007      	add	sp, #28
9000f4d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
9000f4dc:	46a2      	mov	sl, r4
9000f4de:	460c      	mov	r4, r1
9000f4e0:	e6ee      	b.n	9000f2c0 <tcp_input+0xf4>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
9000f4e2:	7d23      	ldrb	r3, [r4, #20]
9000f4e4:	2b0a      	cmp	r3, #10
9000f4e6:	d006      	beq.n	9000f4f6 <tcp_input+0x32a>
9000f4e8:	4b50      	ldr	r3, [pc, #320]	; (9000f62c <tcp_input+0x460>)
9000f4ea:	f240 121f 	movw	r2, #287	; 0x11f
9000f4ee:	4651      	mov	r1, sl
9000f4f0:	4648      	mov	r0, r9
9000f4f2:	f002 fb5b 	bl	90011bac <iprintf>
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
9000f4f6:	7a22      	ldrb	r2, [r4, #8]
9000f4f8:	b132      	cbz	r2, 9000f508 <tcp_input+0x33c>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
9000f4fa:	687b      	ldr	r3, [r7, #4]
9000f4fc:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
9000f500:	3301      	adds	r3, #1
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
9000f502:	b2db      	uxtb	r3, r3
9000f504:	429a      	cmp	r2, r3
9000f506:	d13e      	bne.n	9000f586 <tcp_input+0x3ba>
      if (pcb->remote_port == tcphdr->src &&
9000f508:	6833      	ldr	r3, [r6, #0]
9000f50a:	8b20      	ldrh	r0, [r4, #24]
9000f50c:	881a      	ldrh	r2, [r3, #0]
9000f50e:	4290      	cmp	r0, r2
9000f510:	d139      	bne.n	9000f586 <tcp_input+0x3ba>
          pcb->local_port == tcphdr->dest &&
9000f512:	885b      	ldrh	r3, [r3, #2]
      if (pcb->remote_port == tcphdr->src &&
9000f514:	8ae1      	ldrh	r1, [r4, #22]
9000f516:	4299      	cmp	r1, r3
9000f518:	d135      	bne.n	9000f586 <tcp_input+0x3ba>
          pcb->local_port == tcphdr->dest &&
9000f51a:	6862      	ldr	r2, [r4, #4]
9000f51c:	693b      	ldr	r3, [r7, #16]
9000f51e:	429a      	cmp	r2, r3
9000f520:	d131      	bne.n	9000f586 <tcp_input+0x3ba>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
9000f522:	6822      	ldr	r2, [r4, #0]
9000f524:	697b      	ldr	r3, [r7, #20]
9000f526:	429a      	cmp	r2, r3
9000f528:	d12d      	bne.n	9000f586 <tcp_input+0x3ba>
  if (flags & TCP_RST) {
9000f52a:	4b48      	ldr	r3, [pc, #288]	; (9000f64c <tcp_input+0x480>)
9000f52c:	781b      	ldrb	r3, [r3, #0]
9000f52e:	075e      	lsls	r6, r3, #29
9000f530:	f53f af11 	bmi.w	9000f356 <tcp_input+0x18a>
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f534:	4a47      	ldr	r2, [pc, #284]	; (9000f654 <tcp_input+0x488>)
9000f536:	8816      	ldrh	r6, [r2, #0]
  if (flags & TCP_SYN) {
9000f538:	079a      	lsls	r2, r3, #30
9000f53a:	d514      	bpl.n	9000f566 <tcp_input+0x39a>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
9000f53c:	4b46      	ldr	r3, [pc, #280]	; (9000f658 <tcp_input+0x48c>)
9000f53e:	681a      	ldr	r2, [r3, #0]
9000f540:	6a63      	ldr	r3, [r4, #36]	; 0x24
9000f542:	1ad3      	subs	r3, r2, r3
9000f544:	d414      	bmi.n	9000f570 <tcp_input+0x3a4>
9000f546:	8d27      	ldrh	r7, [r4, #40]	; 0x28
9000f548:	1bdb      	subs	r3, r3, r7
9000f54a:	2b00      	cmp	r3, #0
9000f54c:	dc10      	bgt.n	9000f570 <tcp_input+0x3a4>
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f54e:	4b43      	ldr	r3, [pc, #268]	; (9000f65c <tcp_input+0x490>)
9000f550:	4432      	add	r2, r6
9000f552:	e9cd 1001 	strd	r1, r0, [sp, #4]
9000f556:	9300      	str	r3, [sp, #0]
9000f558:	4620      	mov	r0, r4
9000f55a:	3304      	adds	r3, #4
9000f55c:	f8db 1000 	ldr.w	r1, [fp]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f560:	f001 fa24 	bl	900109ac <tcp_rst>
9000f564:	e6f7      	b.n	9000f356 <tcp_input+0x18a>
  } else if (flags & TCP_FIN) {
9000f566:	07df      	lsls	r7, r3, #31
    pcb->tmr = tcp_ticks;
9000f568:	bf42      	ittt	mi
9000f56a:	4b3d      	ldrmi	r3, [pc, #244]	; (9000f660 <tcp_input+0x494>)
9000f56c:	681b      	ldrmi	r3, [r3, #0]
9000f56e:	6223      	strmi	r3, [r4, #32]
  if ((tcplen > 0)) {
9000f570:	2e00      	cmp	r6, #0
9000f572:	f43f aef0 	beq.w	9000f356 <tcp_input+0x18a>
    tcp_ack_now(pcb);
9000f576:	8b63      	ldrh	r3, [r4, #26]
    tcp_output(pcb);
9000f578:	4620      	mov	r0, r4
    tcp_ack_now(pcb);
9000f57a:	f043 0302 	orr.w	r3, r3, #2
9000f57e:	8363      	strh	r3, [r4, #26]
    tcp_output(pcb);
9000f580:	f001 fa8c 	bl	90010a9c <tcp_output>
        pbuf_free(p);
9000f584:	e6e7      	b.n	9000f356 <tcp_input+0x18a>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
9000f586:	68e4      	ldr	r4, [r4, #12]
9000f588:	2c00      	cmp	r4, #0
9000f58a:	d1aa      	bne.n	9000f4e2 <tcp_input+0x316>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000f58c:	4b35      	ldr	r3, [pc, #212]	; (9000f664 <tcp_input+0x498>)
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
9000f58e:	f8d7 c004 	ldr.w	ip, [r7, #4]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000f592:	681a      	ldr	r2, [r3, #0]
      if (lpcb->local_port == tcphdr->dest) {
9000f594:	6831      	ldr	r1, [r6, #0]
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
9000f596:	f8d7 e014 	ldr.w	lr, [r7, #20]
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000f59a:	4691      	mov	r9, r2
9000f59c:	f1b9 0f00 	cmp.w	r9, #0
9000f5a0:	d113      	bne.n	9000f5ca <tcp_input+0x3fe>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
9000f5a2:	8988      	ldrh	r0, [r1, #12]
9000f5a4:	f7f9 fdec 	bl	90009180 <lwip_htons>
9000f5a8:	0742      	lsls	r2, r0, #29
9000f5aa:	f53f aed4 	bmi.w	9000f356 <tcp_input+0x18a>
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
9000f5ae:	6833      	ldr	r3, [r6, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f5b0:	4a28      	ldr	r2, [pc, #160]	; (9000f654 <tcp_input+0x488>)
9000f5b2:	8818      	ldrh	r0, [r3, #0]
9000f5b4:	8811      	ldrh	r1, [r2, #0]
9000f5b6:	4a28      	ldr	r2, [pc, #160]	; (9000f658 <tcp_input+0x48c>)
9000f5b8:	6812      	ldr	r2, [r2, #0]
9000f5ba:	9002      	str	r0, [sp, #8]
9000f5bc:	885b      	ldrh	r3, [r3, #2]
9000f5be:	440a      	add	r2, r1
9000f5c0:	9301      	str	r3, [sp, #4]
9000f5c2:	4b26      	ldr	r3, [pc, #152]	; (9000f65c <tcp_input+0x490>)
9000f5c4:	9300      	str	r3, [sp, #0]
9000f5c6:	3304      	adds	r3, #4
9000f5c8:	e36a      	b.n	9000fca0 <tcp_input+0xad4>
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
9000f5ca:	f899 0008 	ldrb.w	r0, [r9, #8]
9000f5ce:	b128      	cbz	r0, 9000f5dc <tcp_input+0x410>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
9000f5d0:	f89c 3038 	ldrb.w	r3, [ip, #56]	; 0x38
9000f5d4:	3301      	adds	r3, #1
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
9000f5d6:	b2db      	uxtb	r3, r3
9000f5d8:	4298      	cmp	r0, r3
9000f5da:	d10c      	bne.n	9000f5f6 <tcp_input+0x42a>
      if (lpcb->local_port == tcphdr->dest) {
9000f5dc:	8848      	ldrh	r0, [r1, #2]
9000f5de:	f8b9 3016 	ldrh.w	r3, [r9, #22]
9000f5e2:	4283      	cmp	r3, r0
9000f5e4:	d107      	bne.n	9000f5f6 <tcp_input+0x42a>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
9000f5e6:	f8d9 3000 	ldr.w	r3, [r9]
9000f5ea:	4573      	cmp	r3, lr
9000f5ec:	f000 833b 	beq.w	9000fc66 <tcp_input+0xa9a>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
9000f5f0:	2b00      	cmp	r3, #0
9000f5f2:	f000 8338 	beq.w	9000fc66 <tcp_input+0xa9a>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
9000f5f6:	464c      	mov	r4, r9
9000f5f8:	f8d9 900c 	ldr.w	r9, [r9, #12]
9000f5fc:	e7ce      	b.n	9000f59c <tcp_input+0x3d0>
  } else if (flags & TCP_SYN) {
9000f5fe:	0798      	lsls	r0, r3, #30
9000f600:	f57f aea9 	bpl.w	9000f356 <tcp_input+0x18a>
    npcb = tcp_alloc(pcb->prio);
9000f604:	f899 0015 	ldrb.w	r0, [r9, #21]
9000f608:	f7fe fc30 	bl	9000de6c <tcp_alloc>
    if (npcb == NULL) {
9000f60c:	4682      	mov	sl, r0
9000f60e:	bb78      	cbnz	r0, 9000f670 <tcp_input+0x4a4>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
9000f610:	f8d9 3018 	ldr.w	r3, [r9, #24]
9000f614:	2b00      	cmp	r3, #0
9000f616:	f43f ae9e 	beq.w	9000f356 <tcp_input+0x18a>
9000f61a:	4601      	mov	r1, r0
9000f61c:	f04f 32ff 	mov.w	r2, #4294967295
9000f620:	f8d9 0010 	ldr.w	r0, [r9, #16]
9000f624:	4798      	blx	r3
9000f626:	e696      	b.n	9000f356 <tcp_input+0x18a>
9000f628:	90014e9e 	.word	0x90014e9e
9000f62c:	90014c4f 	.word	0x90014c4f
9000f630:	90014ec5 	.word	0x90014ec5
9000f634:	90014eef 	.word	0x90014eef
9000f638:	90014f16 	.word	0x90014f16
9000f63c:	90012aff 	.word	0x90012aff
9000f640:	90014f41 	.word	0x90014f41
9000f644:	2400d3ec 	.word	0x2400d3ec
9000f648:	2400d3e4 	.word	0x2400d3e4
9000f64c:	2400d3d0 	.word	0x2400d3d0
9000f650:	2400d3f4 	.word	0x2400d3f4
9000f654:	2400d40a 	.word	0x2400d40a
9000f658:	2400d3f0 	.word	0x2400d3f0
9000f65c:	2400a0f8 	.word	0x2400a0f8
9000f660:	2400d3c0 	.word	0x2400d3c0
9000f664:	2400d3bc 	.word	0x2400d3bc
9000f668:	2400d3d4 	.word	0x2400d3d4
9000f66c:	2400d3e8 	.word	0x2400d3e8
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
9000f670:	697b      	ldr	r3, [r7, #20]
    npcb->remote_port = tcphdr->src;
9000f672:	6832      	ldr	r2, [r6, #0]
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
9000f674:	6003      	str	r3, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
9000f676:	693b      	ldr	r3, [r7, #16]
    npcb->rcv_nxt = seqno + 1;
9000f678:	4fa8      	ldr	r7, [pc, #672]	; (9000f91c <tcp_input+0x750>)
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
9000f67a:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
9000f67c:	f8b9 3016 	ldrh.w	r3, [r9, #22]
9000f680:	82c3      	strh	r3, [r0, #22]
    npcb->remote_port = tcphdr->src;
9000f682:	7813      	ldrb	r3, [r2, #0]
9000f684:	7852      	ldrb	r2, [r2, #1]
9000f686:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
9000f68a:	8303      	strh	r3, [r0, #24]
    npcb->state = SYN_RCVD;
9000f68c:	2303      	movs	r3, #3
9000f68e:	7503      	strb	r3, [r0, #20]
    npcb->rcv_nxt = seqno + 1;
9000f690:	683b      	ldr	r3, [r7, #0]
9000f692:	3301      	adds	r3, #1
9000f694:	6243      	str	r3, [r0, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
9000f696:	62c3      	str	r3, [r0, #44]	; 0x2c
    iss = tcp_next_iss(npcb);
9000f698:	f7fe f97a 	bl	9000d990 <tcp_next_iss>
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
9000f69c:	683b      	ldr	r3, [r7, #0]
    npcb->snd_wl2 = iss;
9000f69e:	f8ca 0058 	str.w	r0, [sl, #88]	; 0x58
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
9000f6a2:	3b01      	subs	r3, #1
    npcb->snd_nxt = iss;
9000f6a4:	f8ca 0050 	str.w	r0, [sl, #80]	; 0x50
    npcb->lastack = iss;
9000f6a8:	f8ca 0044 	str.w	r0, [sl, #68]	; 0x44
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
9000f6ac:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
9000f6b0:	f8d9 3010 	ldr.w	r3, [r9, #16]
    npcb->snd_lbb = iss;
9000f6b4:	f8ca 005c 	str.w	r0, [sl, #92]	; 0x5c
    npcb->callback_arg = pcb->callback_arg;
9000f6b8:	f8ca 3010 	str.w	r3, [sl, #16]
    npcb->listener = pcb;
9000f6bc:	f8ca 907c 	str.w	r9, [sl, #124]	; 0x7c
    npcb->so_options = pcb->so_options & SOF_INHERITED;
9000f6c0:	f899 3009 	ldrb.w	r3, [r9, #9]
9000f6c4:	f003 030c 	and.w	r3, r3, #12
9000f6c8:	f88a 3009 	strb.w	r3, [sl, #9]
    npcb->netif_idx = pcb->netif_idx;
9000f6cc:	f899 3008 	ldrb.w	r3, [r9, #8]
9000f6d0:	f88a 3008 	strb.w	r3, [sl, #8]
    TCP_REG_ACTIVE(npcb);
9000f6d4:	f8d8 3000 	ldr.w	r3, [r8]
9000f6d8:	f8c8 a000 	str.w	sl, [r8]
9000f6dc:	f8ca 300c 	str.w	r3, [sl, #12]
9000f6e0:	f001 fdc0 	bl	90011264 <tcp_timer_needed>
9000f6e4:	4b8e      	ldr	r3, [pc, #568]	; (9000f920 <tcp_input+0x754>)
9000f6e6:	2201      	movs	r2, #1
    tcp_parseopt(npcb);
9000f6e8:	4650      	mov	r0, sl
    TCP_REG_ACTIVE(npcb);
9000f6ea:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
9000f6ec:	f7ff f86a 	bl	9000e7c4 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
9000f6f0:	6833      	ldr	r3, [r6, #0]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
9000f6f2:	f10a 0204 	add.w	r2, sl, #4
9000f6f6:	f8ba 6032 	ldrh.w	r6, [sl, #50]	; 0x32
    npcb->snd_wnd = tcphdr->wnd;
9000f6fa:	89db      	ldrh	r3, [r3, #14]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
9000f6fc:	4610      	mov	r0, r2
9000f6fe:	9205      	str	r2, [sp, #20]
    npcb->snd_wnd = tcphdr->wnd;
9000f700:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
    npcb->snd_wnd_max = npcb->snd_wnd;
9000f704:	f8aa 3062 	strh.w	r3, [sl, #98]	; 0x62
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
9000f708:	f7fb fdc0 	bl	9000b28c <ip4_route>
9000f70c:	9a05      	ldr	r2, [sp, #20]
9000f70e:	4601      	mov	r1, r0
9000f710:	4630      	mov	r0, r6
9000f712:	f7fe f957 	bl	9000d9c4 <tcp_eff_send_mss_netif>
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
9000f716:	2112      	movs	r1, #18
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
9000f718:	f8aa 0032 	strh.w	r0, [sl, #50]	; 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
9000f71c:	4650      	mov	r0, sl
9000f71e:	f000 ffc9 	bl	900106b4 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
9000f722:	b120      	cbz	r0, 9000f72e <tcp_input+0x562>
      tcp_abandon(npcb, 0);
9000f724:	4621      	mov	r1, r4
9000f726:	4650      	mov	r0, sl
9000f728:	f7fe faa4 	bl	9000dc74 <tcp_abandon>
      return;
9000f72c:	e613      	b.n	9000f356 <tcp_input+0x18a>
    tcp_output(npcb);
9000f72e:	4650      	mov	r0, sl
9000f730:	e726      	b.n	9000f580 <tcp_input+0x3b4>
  if (flags & TCP_RST) {
9000f732:	4b7c      	ldr	r3, [pc, #496]	; (9000f924 <tcp_input+0x758>)
    tcp_input_pcb = pcb;
9000f734:	602c      	str	r4, [r5, #0]
  if (flags & TCP_RST) {
9000f736:	781a      	ldrb	r2, [r3, #0]
9000f738:	0751      	lsls	r1, r2, #29
9000f73a:	d539      	bpl.n	9000f7b0 <tcp_input+0x5e4>
    if (pcb->state == SYN_SENT) {
9000f73c:	7d21      	ldrb	r1, [r4, #20]
9000f73e:	2902      	cmp	r1, #2
9000f740:	d11f      	bne.n	9000f782 <tcp_input+0x5b6>
      if (ackno == pcb->snd_nxt) {
9000f742:	6d22      	ldr	r2, [r4, #80]	; 0x50
9000f744:	f8db 3000 	ldr.w	r3, [fp]
9000f748:	429a      	cmp	r2, r3
9000f74a:	d107      	bne.n	9000f75c <tcp_input+0x590>
      recv_flags |= TF_RESET;
9000f74c:	783b      	ldrb	r3, [r7, #0]
9000f74e:	f043 0308 	orr.w	r3, r3, #8
9000f752:	703b      	strb	r3, [r7, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
9000f754:	8b63      	ldrh	r3, [r4, #26]
9000f756:	f023 0301 	bic.w	r3, r3, #1
        tcp_ack_now(pcb);
9000f75a:	8363      	strh	r3, [r4, #26]
      if (recv_flags & TF_RESET) {
9000f75c:	783b      	ldrb	r3, [r7, #0]
9000f75e:	0718      	lsls	r0, r3, #28
9000f760:	f140 8204 	bpl.w	9000fb6c <tcp_input+0x9a0>
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
9000f764:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
9000f768:	b11b      	cbz	r3, 9000f772 <tcp_input+0x5a6>
9000f76a:	f06f 010d 	mvn.w	r1, #13
9000f76e:	6920      	ldr	r0, [r4, #16]
9000f770:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
9000f772:	4621      	mov	r1, r4
9000f774:	486c      	ldr	r0, [pc, #432]	; (9000f928 <tcp_input+0x75c>)
9000f776:	f7fe fa17 	bl	9000dba8 <tcp_pcb_remove>
        tcp_free(pcb);
9000f77a:	4620      	mov	r0, r4
9000f77c:	f7fd ff0c 	bl	9000d598 <tcp_free>
9000f780:	e69e      	b.n	9000f4c0 <tcp_input+0x2f4>
      if (seqno == pcb->rcv_nxt) {
9000f782:	4b66      	ldr	r3, [pc, #408]	; (9000f91c <tcp_input+0x750>)
9000f784:	6a62      	ldr	r2, [r4, #36]	; 0x24
9000f786:	681b      	ldr	r3, [r3, #0]
9000f788:	429a      	cmp	r2, r3
9000f78a:	d007      	beq.n	9000f79c <tcp_input+0x5d0>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
9000f78c:	1a9b      	subs	r3, r3, r2
9000f78e:	d4e5      	bmi.n	9000f75c <tcp_input+0x590>
9000f790:	8d22      	ldrh	r2, [r4, #40]	; 0x28
9000f792:	1a9b      	subs	r3, r3, r2
9000f794:	2b00      	cmp	r3, #0
9000f796:	dce1      	bgt.n	9000f75c <tcp_input+0x590>
        tcp_ack_now(pcb);
9000f798:	8b63      	ldrh	r3, [r4, #26]
9000f79a:	e010      	b.n	9000f7be <tcp_input+0x5f2>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
9000f79c:	2900      	cmp	r1, #0
9000f79e:	d1d5      	bne.n	9000f74c <tcp_input+0x580>
9000f7a0:	4b62      	ldr	r3, [pc, #392]	; (9000f92c <tcp_input+0x760>)
9000f7a2:	f44f 724e 	mov.w	r2, #824	; 0x338
9000f7a6:	4962      	ldr	r1, [pc, #392]	; (9000f930 <tcp_input+0x764>)
9000f7a8:	4862      	ldr	r0, [pc, #392]	; (9000f934 <tcp_input+0x768>)
9000f7aa:	f002 f9ff 	bl	90011bac <iprintf>
9000f7ae:	e7cd      	b.n	9000f74c <tcp_input+0x580>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
9000f7b0:	0792      	lsls	r2, r2, #30
        tcp_ack_now(pcb);
9000f7b2:	8b63      	ldrh	r3, [r4, #26]
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
9000f7b4:	d506      	bpl.n	9000f7c4 <tcp_input+0x5f8>
9000f7b6:	7d22      	ldrb	r2, [r4, #20]
9000f7b8:	3a02      	subs	r2, #2
9000f7ba:	2a01      	cmp	r2, #1
9000f7bc:	d902      	bls.n	9000f7c4 <tcp_input+0x5f8>
        tcp_ack_now(pcb);
9000f7be:	f043 0302 	orr.w	r3, r3, #2
9000f7c2:	e7ca      	b.n	9000f75a <tcp_input+0x58e>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
9000f7c4:	06d8      	lsls	r0, r3, #27
  tcp_parseopt(pcb);
9000f7c6:	4620      	mov	r0, r4
    pcb->tmr = tcp_ticks;
9000f7c8:	bf5e      	ittt	pl
9000f7ca:	4b5b      	ldrpl	r3, [pc, #364]	; (9000f938 <tcp_input+0x76c>)
9000f7cc:	681b      	ldrpl	r3, [r3, #0]
9000f7ce:	6223      	strpl	r3, [r4, #32]
  pcb->persist_probe = 0;
9000f7d0:	2300      	movs	r3, #0
9000f7d2:	f8a4 309a 	strh.w	r3, [r4, #154]	; 0x9a
  tcp_parseopt(pcb);
9000f7d6:	f7fe fff5 	bl	9000e7c4 <tcp_parseopt>
  switch (pcb->state) {
9000f7da:	7d23      	ldrb	r3, [r4, #20]
9000f7dc:	3b02      	subs	r3, #2
9000f7de:	2b07      	cmp	r3, #7
9000f7e0:	d8bc      	bhi.n	9000f75c <tcp_input+0x590>
9000f7e2:	e8df f013 	tbh	[pc, r3, lsl #1]
9000f7e6:	0008      	.short	0x0008
9000f7e8:	012400b3 	.word	0x012400b3
9000f7ec:	01730128 	.word	0x01730128
9000f7f0:	018c0124 	.word	0x018c0124
9000f7f4:	01ac      	.short	0x01ac
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
9000f7f6:	4b4b      	ldr	r3, [pc, #300]	; (9000f924 <tcp_input+0x758>)
9000f7f8:	781b      	ldrb	r3, [r3, #0]
9000f7fa:	f003 0212 	and.w	r2, r3, #18
9000f7fe:	2a12      	cmp	r2, #18
9000f800:	d16c      	bne.n	9000f8dc <tcp_input+0x710>
          && (ackno == pcb->lastack + 1)) {
9000f802:	6c62      	ldr	r2, [r4, #68]	; 0x44
9000f804:	f8db 1000 	ldr.w	r1, [fp]
9000f808:	3201      	adds	r2, #1
9000f80a:	428a      	cmp	r2, r1
9000f80c:	d166      	bne.n	9000f8dc <tcp_input+0x710>
        pcb->rcv_nxt = seqno + 1;
9000f80e:	4b43      	ldr	r3, [pc, #268]	; (9000f91c <tcp_input+0x750>)
        pcb->lastack = ackno;
9000f810:	6462      	str	r2, [r4, #68]	; 0x44
        pcb->rcv_nxt = seqno + 1;
9000f812:	681b      	ldr	r3, [r3, #0]
        pcb->snd_wnd = tcphdr->wnd;
9000f814:	6832      	ldr	r2, [r6, #0]
        pcb->rcv_nxt = seqno + 1;
9000f816:	1c59      	adds	r1, r3, #1
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
9000f818:	3b01      	subs	r3, #1
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
9000f81a:	8e66      	ldrh	r6, [r4, #50]	; 0x32
        pcb->rcv_nxt = seqno + 1;
9000f81c:	6261      	str	r1, [r4, #36]	; 0x24
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
9000f81e:	62e1      	str	r1, [r4, #44]	; 0x2c
        pcb->snd_wnd = tcphdr->wnd;
9000f820:	89d2      	ldrh	r2, [r2, #14]
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
9000f822:	6563      	str	r3, [r4, #84]	; 0x54
        pcb->state = ESTABLISHED;
9000f824:	2304      	movs	r3, #4
        pcb->snd_wnd = tcphdr->wnd;
9000f826:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
        pcb->snd_wnd_max = pcb->snd_wnd;
9000f82a:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
9000f82e:	18e2      	adds	r2, r4, r3
        pcb->state = ESTABLISHED;
9000f830:	7523      	strb	r3, [r4, #20]
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
9000f832:	4610      	mov	r0, r2
9000f834:	9205      	str	r2, [sp, #20]
9000f836:	f7fb fd29 	bl	9000b28c <ip4_route>
9000f83a:	9a05      	ldr	r2, [sp, #20]
9000f83c:	4601      	mov	r1, r0
9000f83e:	4630      	mov	r0, r6
9000f840:	f7fe f8c0 	bl	9000d9c4 <tcp_eff_send_mss_netif>
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
9000f844:	f241 131c 	movw	r3, #4380	; 0x111c
9000f848:	0042      	lsls	r2, r0, #1
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
9000f84a:	8660      	strh	r0, [r4, #50]	; 0x32
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
9000f84c:	0081      	lsls	r1, r0, #2
9000f84e:	429a      	cmp	r2, r3
9000f850:	4616      	mov	r6, r2
9000f852:	bf38      	it	cc
9000f854:	461e      	movcc	r6, r3
9000f856:	ebb6 0f80 	cmp.w	r6, r0, lsl #2
9000f85a:	d933      	bls.n	9000f8c4 <tcp_input+0x6f8>
9000f85c:	b28b      	uxth	r3, r1
9000f85e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
9000f862:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
9000f866:	b933      	cbnz	r3, 9000f876 <tcp_input+0x6aa>
9000f868:	4b30      	ldr	r3, [pc, #192]	; (9000f92c <tcp_input+0x760>)
9000f86a:	f44f 725b 	mov.w	r2, #876	; 0x36c
9000f86e:	4933      	ldr	r1, [pc, #204]	; (9000f93c <tcp_input+0x770>)
9000f870:	4830      	ldr	r0, [pc, #192]	; (9000f934 <tcp_input+0x768>)
9000f872:	f002 f99b 	bl	90011bac <iprintf>
        --pcb->snd_queuelen;
9000f876:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
        rseg = pcb->unacked;
9000f87a:	6f26      	ldr	r6, [r4, #112]	; 0x70
        --pcb->snd_queuelen;
9000f87c:	3b01      	subs	r3, #1
9000f87e:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
        if (rseg == NULL) {
9000f882:	bb1e      	cbnz	r6, 9000f8cc <tcp_input+0x700>
          rseg = pcb->unsent;
9000f884:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
          LWIP_ASSERT("no segment to free", rseg != NULL);
9000f886:	b936      	cbnz	r6, 9000f896 <tcp_input+0x6ca>
9000f888:	4b28      	ldr	r3, [pc, #160]	; (9000f92c <tcp_input+0x760>)
9000f88a:	f44f 725d 	mov.w	r2, #884	; 0x374
9000f88e:	492c      	ldr	r1, [pc, #176]	; (9000f940 <tcp_input+0x774>)
9000f890:	4828      	ldr	r0, [pc, #160]	; (9000f934 <tcp_input+0x768>)
9000f892:	f002 f98b 	bl	90011bac <iprintf>
          pcb->unsent = rseg->next;
9000f896:	6833      	ldr	r3, [r6, #0]
9000f898:	66e3      	str	r3, [r4, #108]	; 0x6c
        tcp_seg_free(rseg);
9000f89a:	4630      	mov	r0, r6
9000f89c:	f7fd ffc8 	bl	9000d830 <tcp_seg_free>
        if (pcb->unacked == NULL) {
9000f8a0:	6f23      	ldr	r3, [r4, #112]	; 0x70
9000f8a2:	b9b3      	cbnz	r3, 9000f8d2 <tcp_input+0x706>
          pcb->rtime = -1;
9000f8a4:	f64f 73ff 	movw	r3, #65535	; 0xffff
9000f8a8:	8623      	strh	r3, [r4, #48]	; 0x30
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
9000f8aa:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
9000f8ae:	2b00      	cmp	r3, #0
9000f8b0:	f43f af72 	beq.w	9000f798 <tcp_input+0x5cc>
9000f8b4:	2200      	movs	r2, #0
9000f8b6:	4621      	mov	r1, r4
9000f8b8:	6920      	ldr	r0, [r4, #16]
9000f8ba:	4798      	blx	r3
        if (err == ERR_ABRT) {
9000f8bc:	300d      	adds	r0, #13
9000f8be:	f47f af6b 	bne.w	9000f798 <tcp_input+0x5cc>
9000f8c2:	e5fd      	b.n	9000f4c0 <tcp_input+0x2f4>
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
9000f8c4:	429a      	cmp	r2, r3
9000f8c6:	bf88      	it	hi
9000f8c8:	b293      	uxthhi	r3, r2
9000f8ca:	e7c8      	b.n	9000f85e <tcp_input+0x692>
          pcb->unacked = rseg->next;
9000f8cc:	6833      	ldr	r3, [r6, #0]
9000f8ce:	6723      	str	r3, [r4, #112]	; 0x70
9000f8d0:	e7e3      	b.n	9000f89a <tcp_input+0x6ce>
          pcb->rtime = 0;
9000f8d2:	2300      	movs	r3, #0
9000f8d4:	8623      	strh	r3, [r4, #48]	; 0x30
          pcb->nrtx = 0;
9000f8d6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
9000f8da:	e7e6      	b.n	9000f8aa <tcp_input+0x6de>
      else if (flags & TCP_ACK) {
9000f8dc:	06d9      	lsls	r1, r3, #27
9000f8de:	f57f af3d 	bpl.w	9000f75c <tcp_input+0x590>
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
9000f8e2:	6833      	ldr	r3, [r6, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f8e4:	4a17      	ldr	r2, [pc, #92]	; (9000f944 <tcp_input+0x778>)
9000f8e6:	8818      	ldrh	r0, [r3, #0]
9000f8e8:	8811      	ldrh	r1, [r2, #0]
9000f8ea:	4a0c      	ldr	r2, [pc, #48]	; (9000f91c <tcp_input+0x750>)
9000f8ec:	6812      	ldr	r2, [r2, #0]
9000f8ee:	9002      	str	r0, [sp, #8]
9000f8f0:	4620      	mov	r0, r4
9000f8f2:	885b      	ldrh	r3, [r3, #2]
9000f8f4:	440a      	add	r2, r1
9000f8f6:	f8db 1000 	ldr.w	r1, [fp]
9000f8fa:	9301      	str	r3, [sp, #4]
9000f8fc:	4b12      	ldr	r3, [pc, #72]	; (9000f948 <tcp_input+0x77c>)
9000f8fe:	9300      	str	r3, [sp, #0]
9000f900:	3304      	adds	r3, #4
9000f902:	f001 f853 	bl	900109ac <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
9000f906:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
9000f90a:	2b05      	cmp	r3, #5
9000f90c:	f63f af26 	bhi.w	9000f75c <tcp_input+0x590>
          pcb->rtime = 0;
9000f910:	2300      	movs	r3, #0
          tcp_rexmit_rto(pcb);
9000f912:	4620      	mov	r0, r4
          pcb->rtime = 0;
9000f914:	8623      	strh	r3, [r4, #48]	; 0x30
          tcp_rexmit_rto(pcb);
9000f916:	f001 fa87 	bl	90010e28 <tcp_rexmit_rto>
    if (err != ERR_ABRT) {
9000f91a:	e71f      	b.n	9000f75c <tcp_input+0x590>
9000f91c:	2400d3f0 	.word	0x2400d3f0
9000f920:	2400d3b4 	.word	0x2400d3b4
9000f924:	2400d3d0 	.word	0x2400d3d0
9000f928:	2400d3b0 	.word	0x2400d3b0
9000f92c:	90014c4f 	.word	0x90014c4f
9000f930:	90014f98 	.word	0x90014f98
9000f934:	90012aff 	.word	0x90012aff
9000f938:	2400d3c0 	.word	0x2400d3c0
9000f93c:	90014fb8 	.word	0x90014fb8
9000f940:	90014fce 	.word	0x90014fce
9000f944:	2400d40a 	.word	0x2400d40a
9000f948:	2400a0f8 	.word	0x2400a0f8
      if (flags & TCP_ACK) {
9000f94c:	4b9d      	ldr	r3, [pc, #628]	; (9000fbc4 <tcp_input+0x9f8>)
9000f94e:	781b      	ldrb	r3, [r3, #0]
9000f950:	06da      	lsls	r2, r3, #27
9000f952:	d55e      	bpl.n	9000fa12 <tcp_input+0x846>
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
9000f954:	6c63      	ldr	r3, [r4, #68]	; 0x44
9000f956:	f8db 1000 	ldr.w	r1, [fp]
9000f95a:	43db      	mvns	r3, r3
9000f95c:	42cb      	cmn	r3, r1
9000f95e:	d447      	bmi.n	9000f9f0 <tcp_input+0x824>
9000f960:	6d23      	ldr	r3, [r4, #80]	; 0x50
9000f962:	1acb      	subs	r3, r1, r3
9000f964:	2b00      	cmp	r3, #0
9000f966:	dc43      	bgt.n	9000f9f0 <tcp_input+0x824>
          pcb->state = ESTABLISHED;
9000f968:	2304      	movs	r3, #4
9000f96a:	7523      	strb	r3, [r4, #20]
          if (pcb->listener == NULL) {
9000f96c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
9000f96e:	b91b      	cbnz	r3, 9000f978 <tcp_input+0x7ac>
            tcp_abort(pcb);
9000f970:	4620      	mov	r0, r4
9000f972:	f7fe fa01 	bl	9000dd78 <tcp_abort>
            goto aborted;
9000f976:	e5a3      	b.n	9000f4c0 <tcp_input+0x2f4>
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
9000f978:	699b      	ldr	r3, [r3, #24]
9000f97a:	b933      	cbnz	r3, 9000f98a <tcp_input+0x7be>
9000f97c:	4b92      	ldr	r3, [pc, #584]	; (9000fbc8 <tcp_input+0x9fc>)
9000f97e:	f44f 726a 	mov.w	r2, #936	; 0x3a8
9000f982:	4992      	ldr	r1, [pc, #584]	; (9000fbcc <tcp_input+0xa00>)
9000f984:	4892      	ldr	r0, [pc, #584]	; (9000fbd0 <tcp_input+0xa04>)
9000f986:	f002 f911 	bl	90011bac <iprintf>
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
9000f98a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
9000f98c:	699b      	ldr	r3, [r3, #24]
9000f98e:	2b00      	cmp	r3, #0
9000f990:	d0ee      	beq.n	9000f970 <tcp_input+0x7a4>
9000f992:	2200      	movs	r2, #0
9000f994:	4621      	mov	r1, r4
9000f996:	6920      	ldr	r0, [r4, #16]
9000f998:	4798      	blx	r3
          if (err != ERR_OK) {
9000f99a:	b118      	cbz	r0, 9000f9a4 <tcp_input+0x7d8>
            if (err != ERR_ABRT) {
9000f99c:	300d      	adds	r0, #13
9000f99e:	f43f ad8f 	beq.w	9000f4c0 <tcp_input+0x2f4>
9000f9a2:	e7e5      	b.n	9000f970 <tcp_input+0x7a4>
          tcp_receive(pcb);
9000f9a4:	4620      	mov	r0, r4
9000f9a6:	f7fe ffe3 	bl	9000e970 <tcp_receive>
          if (recv_acked != 0) {
9000f9aa:	4a8a      	ldr	r2, [pc, #552]	; (9000fbd4 <tcp_input+0xa08>)
9000f9ac:	8813      	ldrh	r3, [r2, #0]
9000f9ae:	b10b      	cbz	r3, 9000f9b4 <tcp_input+0x7e8>
            recv_acked--;
9000f9b0:	3b01      	subs	r3, #1
9000f9b2:	8013      	strh	r3, [r2, #0]
          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
9000f9b4:	8e61      	ldrh	r1, [r4, #50]	; 0x32
9000f9b6:	f241 131c 	movw	r3, #4380	; 0x111c
9000f9ba:	004a      	lsls	r2, r1, #1
9000f9bc:	0088      	lsls	r0, r1, #2
9000f9be:	429a      	cmp	r2, r3
9000f9c0:	4616      	mov	r6, r2
9000f9c2:	bf38      	it	cc
9000f9c4:	461e      	movcc	r6, r3
9000f9c6:	ebb6 0f81 	cmp.w	r6, r1, lsl #2
9000f9ca:	d90d      	bls.n	9000f9e8 <tcp_input+0x81c>
9000f9cc:	b283      	uxth	r3, r0
9000f9ce:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      if (recv_flags & TF_GOT_FIN) { /* passive close */
9000f9d2:	783b      	ldrb	r3, [r7, #0]
9000f9d4:	0698      	lsls	r0, r3, #26
9000f9d6:	f57f aec1 	bpl.w	9000f75c <tcp_input+0x590>
        tcp_ack_now(pcb);
9000f9da:	8b63      	ldrh	r3, [r4, #26]
9000f9dc:	f043 0302 	orr.w	r3, r3, #2
9000f9e0:	8363      	strh	r3, [r4, #26]
        pcb->state = CLOSE_WAIT;
9000f9e2:	2307      	movs	r3, #7
        pcb->state = FIN_WAIT_2;
9000f9e4:	7523      	strb	r3, [r4, #20]
    if (err != ERR_ABRT) {
9000f9e6:	e6b9      	b.n	9000f75c <tcp_input+0x590>
          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
9000f9e8:	429a      	cmp	r2, r3
9000f9ea:	bf88      	it	hi
9000f9ec:	b293      	uxthhi	r3, r2
9000f9ee:	e7ee      	b.n	9000f9ce <tcp_input+0x802>
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
9000f9f0:	6833      	ldr	r3, [r6, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000f9f2:	4a79      	ldr	r2, [pc, #484]	; (9000fbd8 <tcp_input+0xa0c>)
9000f9f4:	881e      	ldrh	r6, [r3, #0]
9000f9f6:	8810      	ldrh	r0, [r2, #0]
9000f9f8:	4a78      	ldr	r2, [pc, #480]	; (9000fbdc <tcp_input+0xa10>)
9000f9fa:	6812      	ldr	r2, [r2, #0]
9000f9fc:	9602      	str	r6, [sp, #8]
9000f9fe:	885b      	ldrh	r3, [r3, #2]
9000fa00:	4402      	add	r2, r0
9000fa02:	4620      	mov	r0, r4
9000fa04:	9301      	str	r3, [sp, #4]
9000fa06:	4b76      	ldr	r3, [pc, #472]	; (9000fbe0 <tcp_input+0xa14>)
9000fa08:	9300      	str	r3, [sp, #0]
9000fa0a:	3304      	adds	r3, #4
9000fa0c:	f000 ffce 	bl	900109ac <tcp_rst>
    if (err != ERR_ABRT) {
9000fa10:	e6a4      	b.n	9000f75c <tcp_input+0x590>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
9000fa12:	079e      	lsls	r6, r3, #30
9000fa14:	f57f aea2 	bpl.w	9000f75c <tcp_input+0x590>
9000fa18:	6a63      	ldr	r3, [r4, #36]	; 0x24
9000fa1a:	4a70      	ldr	r2, [pc, #448]	; (9000fbdc <tcp_input+0xa10>)
9000fa1c:	3b01      	subs	r3, #1
9000fa1e:	6812      	ldr	r2, [r2, #0]
9000fa20:	4293      	cmp	r3, r2
9000fa22:	f47f ae9b 	bne.w	9000f75c <tcp_input+0x590>
        tcp_rexmit(pcb);
9000fa26:	4620      	mov	r0, r4
9000fa28:	f000 ff4c 	bl	900108c4 <tcp_rexmit>
    if (err != ERR_ABRT) {
9000fa2c:	e696      	b.n	9000f75c <tcp_input+0x590>
      tcp_receive(pcb);
9000fa2e:	4620      	mov	r0, r4
9000fa30:	f7fe ff9e 	bl	9000e970 <tcp_receive>
9000fa34:	e7cd      	b.n	9000f9d2 <tcp_input+0x806>
      tcp_receive(pcb);
9000fa36:	4620      	mov	r0, r4
9000fa38:	f7fe ff9a 	bl	9000e970 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
9000fa3c:	783b      	ldrb	r3, [r7, #0]
9000fa3e:	f013 0f20 	tst.w	r3, #32
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
9000fa42:	4b60      	ldr	r3, [pc, #384]	; (9000fbc4 <tcp_input+0x9f8>)
9000fa44:	781b      	ldrb	r3, [r3, #0]
      if (recv_flags & TF_GOT_FIN) {
9000fa46:	d032      	beq.n	9000faae <tcp_input+0x8e2>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
9000fa48:	f013 0f10 	tst.w	r3, #16
9000fa4c:	8b63      	ldrh	r3, [r4, #26]
9000fa4e:	d029      	beq.n	9000faa4 <tcp_input+0x8d8>
9000fa50:	6d21      	ldr	r1, [r4, #80]	; 0x50
9000fa52:	f8db 2000 	ldr.w	r2, [fp]
9000fa56:	4291      	cmp	r1, r2
9000fa58:	d124      	bne.n	9000faa4 <tcp_input+0x8d8>
9000fa5a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
9000fa5c:	bb12      	cbnz	r2, 9000faa4 <tcp_input+0x8d8>
          tcp_ack_now(pcb);
9000fa5e:	f043 0302 	orr.w	r3, r3, #2
          tcp_pcb_purge(pcb);
9000fa62:	4620      	mov	r0, r4
          tcp_ack_now(pcb);
9000fa64:	8363      	strh	r3, [r4, #26]
          tcp_pcb_purge(pcb);
9000fa66:	f7fe f86d 	bl	9000db44 <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
9000fa6a:	f8d8 3000 	ldr.w	r3, [r8]
9000fa6e:	429c      	cmp	r4, r3
9000fa70:	d10a      	bne.n	9000fa88 <tcp_input+0x8bc>
        TCP_RMV_ACTIVE(pcb);
9000fa72:	68e3      	ldr	r3, [r4, #12]
9000fa74:	f8c8 3000 	str.w	r3, [r8]
9000fa78:	e008      	b.n	9000fa8c <tcp_input+0x8c0>
          TCP_RMV_ACTIVE(pcb);
9000fa7a:	68da      	ldr	r2, [r3, #12]
9000fa7c:	4294      	cmp	r4, r2
9000fa7e:	d102      	bne.n	9000fa86 <tcp_input+0x8ba>
        TCP_RMV_ACTIVE(pcb);
9000fa80:	68e2      	ldr	r2, [r4, #12]
9000fa82:	60da      	str	r2, [r3, #12]
9000fa84:	e002      	b.n	9000fa8c <tcp_input+0x8c0>
9000fa86:	4613      	mov	r3, r2
          TCP_RMV_ACTIVE(pcb);
9000fa88:	2b00      	cmp	r3, #0
9000fa8a:	d1f6      	bne.n	9000fa7a <tcp_input+0x8ae>
        TCP_RMV_ACTIVE(pcb);
9000fa8c:	4b55      	ldr	r3, [pc, #340]	; (9000fbe4 <tcp_input+0xa18>)
9000fa8e:	2201      	movs	r2, #1
9000fa90:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
9000fa92:	230a      	movs	r3, #10
9000fa94:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
9000fa96:	4b54      	ldr	r3, [pc, #336]	; (9000fbe8 <tcp_input+0xa1c>)
9000fa98:	681a      	ldr	r2, [r3, #0]
9000fa9a:	601c      	str	r4, [r3, #0]
9000fa9c:	60e2      	str	r2, [r4, #12]
9000fa9e:	f001 fbe1 	bl	90011264 <tcp_timer_needed>
    if (err != ERR_ABRT) {
9000faa2:	e65b      	b.n	9000f75c <tcp_input+0x590>
          tcp_ack_now(pcb);
9000faa4:	f043 0302 	orr.w	r3, r3, #2
9000faa8:	8363      	strh	r3, [r4, #26]
          pcb->state = CLOSING;
9000faaa:	2308      	movs	r3, #8
9000faac:	e79a      	b.n	9000f9e4 <tcp_input+0x818>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
9000faae:	06d9      	lsls	r1, r3, #27
9000fab0:	f57f ae54 	bpl.w	9000f75c <tcp_input+0x590>
9000fab4:	6d22      	ldr	r2, [r4, #80]	; 0x50
9000fab6:	f8db 3000 	ldr.w	r3, [fp]
9000faba:	429a      	cmp	r2, r3
9000fabc:	f47f ae4e 	bne.w	9000f75c <tcp_input+0x590>
9000fac0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000fac2:	2b00      	cmp	r3, #0
9000fac4:	f47f ae4a 	bne.w	9000f75c <tcp_input+0x590>
        pcb->state = FIN_WAIT_2;
9000fac8:	2306      	movs	r3, #6
9000faca:	e78b      	b.n	9000f9e4 <tcp_input+0x818>
      tcp_receive(pcb);
9000facc:	4620      	mov	r0, r4
9000face:	f7fe ff4f 	bl	9000e970 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
9000fad2:	783b      	ldrb	r3, [r7, #0]
9000fad4:	069a      	lsls	r2, r3, #26
9000fad6:	f57f ae41 	bpl.w	9000f75c <tcp_input+0x590>
        tcp_ack_now(pcb);
9000fada:	8b63      	ldrh	r3, [r4, #26]
        tcp_pcb_purge(pcb);
9000fadc:	4620      	mov	r0, r4
        tcp_ack_now(pcb);
9000fade:	f043 0302 	orr.w	r3, r3, #2
9000fae2:	8363      	strh	r3, [r4, #26]
        tcp_pcb_purge(pcb);
9000fae4:	f7fe f82e 	bl	9000db44 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
9000fae8:	f8d8 3000 	ldr.w	r3, [r8]
9000faec:	429c      	cmp	r4, r3
9000faee:	d0c0      	beq.n	9000fa72 <tcp_input+0x8a6>
9000faf0:	2b00      	cmp	r3, #0
9000faf2:	d0cb      	beq.n	9000fa8c <tcp_input+0x8c0>
9000faf4:	68da      	ldr	r2, [r3, #12]
9000faf6:	4294      	cmp	r4, r2
9000faf8:	d0c2      	beq.n	9000fa80 <tcp_input+0x8b4>
9000fafa:	4613      	mov	r3, r2
9000fafc:	e7f8      	b.n	9000faf0 <tcp_input+0x924>
      tcp_receive(pcb);
9000fafe:	4620      	mov	r0, r4
9000fb00:	f7fe ff36 	bl	9000e970 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
9000fb04:	4b2f      	ldr	r3, [pc, #188]	; (9000fbc4 <tcp_input+0x9f8>)
9000fb06:	781b      	ldrb	r3, [r3, #0]
9000fb08:	06db      	lsls	r3, r3, #27
9000fb0a:	f57f ae27 	bpl.w	9000f75c <tcp_input+0x590>
9000fb0e:	6d22      	ldr	r2, [r4, #80]	; 0x50
9000fb10:	f8db 3000 	ldr.w	r3, [fp]
9000fb14:	429a      	cmp	r2, r3
9000fb16:	f47f ae21 	bne.w	9000f75c <tcp_input+0x590>
9000fb1a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000fb1c:	2b00      	cmp	r3, #0
9000fb1e:	f47f ae1d 	bne.w	9000f75c <tcp_input+0x590>
        tcp_pcb_purge(pcb);
9000fb22:	4620      	mov	r0, r4
9000fb24:	f7fe f80e 	bl	9000db44 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
9000fb28:	f8d8 3000 	ldr.w	r3, [r8]
9000fb2c:	429c      	cmp	r4, r3
9000fb2e:	d0a0      	beq.n	9000fa72 <tcp_input+0x8a6>
9000fb30:	2b00      	cmp	r3, #0
9000fb32:	d0ab      	beq.n	9000fa8c <tcp_input+0x8c0>
9000fb34:	68da      	ldr	r2, [r3, #12]
9000fb36:	4294      	cmp	r4, r2
9000fb38:	d0a2      	beq.n	9000fa80 <tcp_input+0x8b4>
9000fb3a:	4613      	mov	r3, r2
9000fb3c:	e7f8      	b.n	9000fb30 <tcp_input+0x964>
      tcp_receive(pcb);
9000fb3e:	4620      	mov	r0, r4
9000fb40:	f7fe ff16 	bl	9000e970 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
9000fb44:	4b1f      	ldr	r3, [pc, #124]	; (9000fbc4 <tcp_input+0x9f8>)
9000fb46:	781b      	ldrb	r3, [r3, #0]
9000fb48:	06de      	lsls	r6, r3, #27
9000fb4a:	f57f ae07 	bpl.w	9000f75c <tcp_input+0x590>
9000fb4e:	6d22      	ldr	r2, [r4, #80]	; 0x50
9000fb50:	f8db 3000 	ldr.w	r3, [fp]
9000fb54:	429a      	cmp	r2, r3
9000fb56:	f47f ae01 	bne.w	9000f75c <tcp_input+0x590>
9000fb5a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9000fb5c:	2b00      	cmp	r3, #0
9000fb5e:	f47f adfd 	bne.w	9000f75c <tcp_input+0x590>
        recv_flags |= TF_CLOSED;
9000fb62:	783b      	ldrb	r3, [r7, #0]
9000fb64:	f043 0310 	orr.w	r3, r3, #16
9000fb68:	703b      	strb	r3, [r7, #0]
    if (err != ERR_ABRT) {
9000fb6a:	e5f7      	b.n	9000f75c <tcp_input+0x590>
        if (recv_acked > 0) {
9000fb6c:	4b19      	ldr	r3, [pc, #100]	; (9000fbd4 <tcp_input+0xa08>)
9000fb6e:	881a      	ldrh	r2, [r3, #0]
9000fb70:	b12a      	cbz	r2, 9000fb7e <tcp_input+0x9b2>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
9000fb72:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
9000fb76:	b9fb      	cbnz	r3, 9000fbb8 <tcp_input+0x9ec>
          recv_acked = 0;
9000fb78:	2300      	movs	r3, #0
9000fb7a:	4a16      	ldr	r2, [pc, #88]	; (9000fbd4 <tcp_input+0xa08>)
9000fb7c:	8013      	strh	r3, [r2, #0]
        if (tcp_input_delayed_close(pcb)) {
9000fb7e:	4620      	mov	r0, r4
9000fb80:	f7fe fe68 	bl	9000e854 <tcp_input_delayed_close>
9000fb84:	2800      	cmp	r0, #0
9000fb86:	f47f ac9b 	bne.w	9000f4c0 <tcp_input+0x2f4>
        if (recv_data != NULL) {
9000fb8a:	f8da 3000 	ldr.w	r3, [sl]
9000fb8e:	2b00      	cmp	r3, #0
9000fb90:	d03c      	beq.n	9000fc0c <tcp_input+0xa40>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
9000fb92:	6fa3      	ldr	r3, [r4, #120]	; 0x78
9000fb94:	b133      	cbz	r3, 9000fba4 <tcp_input+0x9d8>
9000fb96:	4b0c      	ldr	r3, [pc, #48]	; (9000fbc8 <tcp_input+0x9fc>)
9000fb98:	f44f 72f3 	mov.w	r2, #486	; 0x1e6
9000fb9c:	4913      	ldr	r1, [pc, #76]	; (9000fbec <tcp_input+0xa20>)
9000fb9e:	480c      	ldr	r0, [pc, #48]	; (9000fbd0 <tcp_input+0xa04>)
9000fba0:	f002 f804 	bl	90011bac <iprintf>
          if (pcb->flags & TF_RXCLOSED) {
9000fba4:	8b63      	ldrh	r3, [r4, #26]
            pbuf_free(recv_data);
9000fba6:	f8da 2000 	ldr.w	r2, [sl]
          if (pcb->flags & TF_RXCLOSED) {
9000fbaa:	f013 0310 	ands.w	r3, r3, #16
9000fbae:	d01f      	beq.n	9000fbf0 <tcp_input+0xa24>
            pbuf_free(recv_data);
9000fbb0:	4610      	mov	r0, r2
9000fbb2:	f7fd f875 	bl	9000cca0 <pbuf_free>
9000fbb6:	e6db      	b.n	9000f970 <tcp_input+0x7a4>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
9000fbb8:	4621      	mov	r1, r4
9000fbba:	6920      	ldr	r0, [r4, #16]
9000fbbc:	4798      	blx	r3
            if (err == ERR_ABRT) {
9000fbbe:	300d      	adds	r0, #13
9000fbc0:	d1da      	bne.n	9000fb78 <tcp_input+0x9ac>
9000fbc2:	e47d      	b.n	9000f4c0 <tcp_input+0x2f4>
9000fbc4:	2400d3d0 	.word	0x2400d3d0
9000fbc8:	90014c4f 	.word	0x90014c4f
9000fbcc:	90014fe1 	.word	0x90014fe1
9000fbd0:	90012aff 	.word	0x90012aff
9000fbd4:	2400d3e4 	.word	0x2400d3e4
9000fbd8:	2400d40a 	.word	0x2400d40a
9000fbdc:	2400d3f0 	.word	0x2400d3f0
9000fbe0:	2400a0f8 	.word	0x2400a0f8
9000fbe4:	2400d3b4 	.word	0x2400d3b4
9000fbe8:	2400d3c8 	.word	0x2400d3c8
9000fbec:	90014fff 	.word	0x90014fff
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
9000fbf0:	f8d4 6084 	ldr.w	r6, [r4, #132]	; 0x84
9000fbf4:	b1fe      	cbz	r6, 9000fc36 <tcp_input+0xa6a>
9000fbf6:	4621      	mov	r1, r4
9000fbf8:	6920      	ldr	r0, [r4, #16]
9000fbfa:	47b0      	blx	r6
          if (err == ERR_ABRT) {
9000fbfc:	f110 0f0d 	cmn.w	r0, #13
9000fc00:	f43f ac5e 	beq.w	9000f4c0 <tcp_input+0x2f4>
          if (err != ERR_OK) {
9000fc04:	b110      	cbz	r0, 9000fc0c <tcp_input+0xa40>
            pcb->refused_data = recv_data;
9000fc06:	f8da 3000 	ldr.w	r3, [sl]
9000fc0a:	67a3      	str	r3, [r4, #120]	; 0x78
        if (recv_flags & TF_GOT_FIN) {
9000fc0c:	783b      	ldrb	r3, [r7, #0]
9000fc0e:	0699      	lsls	r1, r3, #26
9000fc10:	d505      	bpl.n	9000fc1e <tcp_input+0xa52>
          if (pcb->refused_data != NULL) {
9000fc12:	6fa3      	ldr	r3, [r4, #120]	; 0x78
9000fc14:	b1ab      	cbz	r3, 9000fc42 <tcp_input+0xa76>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
9000fc16:	7b5a      	ldrb	r2, [r3, #13]
9000fc18:	f042 0220 	orr.w	r2, r2, #32
9000fc1c:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
9000fc1e:	2300      	movs	r3, #0
        if (tcp_input_delayed_close(pcb)) {
9000fc20:	4620      	mov	r0, r4
        tcp_input_pcb = NULL;
9000fc22:	602b      	str	r3, [r5, #0]
        if (tcp_input_delayed_close(pcb)) {
9000fc24:	f7fe fe16 	bl	9000e854 <tcp_input_delayed_close>
9000fc28:	2800      	cmp	r0, #0
9000fc2a:	f47f ac49 	bne.w	9000f4c0 <tcp_input+0x2f4>
        tcp_output(pcb);
9000fc2e:	4620      	mov	r0, r4
9000fc30:	f000 ff34 	bl	90010a9c <tcp_output>
9000fc34:	e444      	b.n	9000f4c0 <tcp_input+0x2f4>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
9000fc36:	4633      	mov	r3, r6
9000fc38:	4621      	mov	r1, r4
9000fc3a:	4630      	mov	r0, r6
9000fc3c:	f7fe fa84 	bl	9000e148 <tcp_recv_null>
9000fc40:	e7dc      	b.n	9000fbfc <tcp_input+0xa30>
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
9000fc42:	8d23      	ldrh	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
9000fc44:	f8d4 6084 	ldr.w	r6, [r4, #132]	; 0x84
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
9000fc48:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
              pcb->rcv_wnd++;
9000fc4c:	bf1c      	itt	ne
9000fc4e:	3301      	addne	r3, #1
9000fc50:	8523      	strhne	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
9000fc52:	2e00      	cmp	r6, #0
9000fc54:	d0e3      	beq.n	9000fc1e <tcp_input+0xa52>
9000fc56:	2300      	movs	r3, #0
9000fc58:	4621      	mov	r1, r4
9000fc5a:	6920      	ldr	r0, [r4, #16]
9000fc5c:	461a      	mov	r2, r3
9000fc5e:	47b0      	blx	r6
            if (err == ERR_ABRT) {
9000fc60:	300d      	adds	r0, #13
9000fc62:	d1dc      	bne.n	9000fc1e <tcp_input+0xa52>
9000fc64:	e42c      	b.n	9000f4c0 <tcp_input+0x2f4>
      if (prev != NULL) {
9000fc66:	b13c      	cbz	r4, 9000fc78 <tcp_input+0xaac>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
9000fc68:	f8d9 300c 	ldr.w	r3, [r9, #12]
9000fc6c:	60e3      	str	r3, [r4, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
9000fc6e:	4b11      	ldr	r3, [pc, #68]	; (9000fcb4 <tcp_input+0xae8>)
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
9000fc70:	f8c9 200c 	str.w	r2, [r9, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
9000fc74:	f8c3 9000 	str.w	r9, [r3]
  if (flags & TCP_RST) {
9000fc78:	4b0f      	ldr	r3, [pc, #60]	; (9000fcb8 <tcp_input+0xaec>)
9000fc7a:	781b      	ldrb	r3, [r3, #0]
9000fc7c:	075c      	lsls	r4, r3, #29
9000fc7e:	f53f ab6a 	bmi.w	9000f356 <tcp_input+0x18a>
  if (flags & TCP_ACK) {
9000fc82:	f013 0410 	ands.w	r4, r3, #16
9000fc86:	f43f acba 	beq.w	9000f5fe <tcp_input+0x432>
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
9000fc8a:	4b0c      	ldr	r3, [pc, #48]	; (9000fcbc <tcp_input+0xaf0>)
9000fc8c:	881c      	ldrh	r4, [r3, #0]
9000fc8e:	4b0c      	ldr	r3, [pc, #48]	; (9000fcc0 <tcp_input+0xaf4>)
9000fc90:	681a      	ldr	r2, [r3, #0]
9000fc92:	880b      	ldrh	r3, [r1, #0]
9000fc94:	4422      	add	r2, r4
9000fc96:	e9cd 0301 	strd	r0, r3, [sp, #4]
9000fc9a:	4b0a      	ldr	r3, [pc, #40]	; (9000fcc4 <tcp_input+0xaf8>)
9000fc9c:	9300      	str	r3, [sp, #0]
9000fc9e:	3304      	adds	r3, #4
9000fca0:	f8db 1000 	ldr.w	r1, [fp]
9000fca4:	4648      	mov	r0, r9
9000fca6:	e45b      	b.n	9000f560 <tcp_input+0x394>
      if (prev != NULL) {
9000fca8:	f1ba 0f00 	cmp.w	sl, #0
9000fcac:	f47f abc1 	bne.w	9000f432 <tcp_input+0x266>
9000fcb0:	f7ff bbd1 	b.w	9000f456 <tcp_input+0x28a>
9000fcb4:	2400d3bc 	.word	0x2400d3bc
9000fcb8:	2400d3d0 	.word	0x2400d3d0
9000fcbc:	2400d40a 	.word	0x2400d40a
9000fcc0:	2400d3f0 	.word	0x2400d3f0
9000fcc4:	2400a0f8 	.word	0x2400a0f8

9000fcc8 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
9000fcc8:	4a02      	ldr	r2, [pc, #8]	; (9000fcd4 <tcp_trigger_input_pcb_close+0xc>)
9000fcca:	7813      	ldrb	r3, [r2, #0]
9000fccc:	f043 0310 	orr.w	r3, r3, #16
9000fcd0:	7013      	strb	r3, [r2, #0]
}
9000fcd2:	4770      	bx	lr
9000fcd4:	2400d3ec 	.word	0x2400d3ec

9000fcd8 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
9000fcd8:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
9000fcda:	4604      	mov	r4, r0
9000fcdc:	b930      	cbnz	r0, 9000fcec <tcp_output_segment_busy+0x14>
9000fcde:	4b06      	ldr	r3, [pc, #24]	; (9000fcf8 <tcp_output_segment_busy+0x20>)
9000fce0:	f240 529a 	movw	r2, #1434	; 0x59a
9000fce4:	4905      	ldr	r1, [pc, #20]	; (9000fcfc <tcp_output_segment_busy+0x24>)
9000fce6:	4806      	ldr	r0, [pc, #24]	; (9000fd00 <tcp_output_segment_busy+0x28>)
9000fce8:	f001 ff60 	bl	90011bac <iprintf>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
9000fcec:	6863      	ldr	r3, [r4, #4]
9000fcee:	7b98      	ldrb	r0, [r3, #14]
    /* other reference found */
    return 1;
  }
  /* no other references found */
  return 0;
}
9000fcf0:	3801      	subs	r0, #1
9000fcf2:	bf18      	it	ne
9000fcf4:	2001      	movne	r0, #1
9000fcf6:	bd10      	pop	{r4, pc}
9000fcf8:	90015019 	.word	0x90015019
9000fcfc:	90015053 	.word	0x90015053
9000fd00:	90012aff 	.word	0x90012aff

9000fd04 <tcp_pbuf_prealloc>:
{
9000fd04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9000fd08:	9d08      	ldr	r5, [sp, #32]
9000fd0a:	4680      	mov	r8, r0
9000fd0c:	460c      	mov	r4, r1
9000fd0e:	4617      	mov	r7, r2
9000fd10:	461e      	mov	r6, r3
9000fd12:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
9000fd16:	b92d      	cbnz	r5, 9000fd24 <tcp_pbuf_prealloc+0x20>
9000fd18:	4b1c      	ldr	r3, [pc, #112]	; (9000fd8c <tcp_pbuf_prealloc+0x88>)
9000fd1a:	22e9      	movs	r2, #233	; 0xe9
9000fd1c:	491c      	ldr	r1, [pc, #112]	; (9000fd90 <tcp_pbuf_prealloc+0x8c>)
9000fd1e:	481d      	ldr	r0, [pc, #116]	; (9000fd94 <tcp_pbuf_prealloc+0x90>)
9000fd20:	f001 ff44 	bl	90011bac <iprintf>
  if (length < max_length) {
9000fd24:	42bc      	cmp	r4, r7
9000fd26:	d22e      	bcs.n	9000fd86 <tcp_pbuf_prealloc+0x82>
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
9000fd28:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
9000fd2c:	079a      	lsls	r2, r3, #30
9000fd2e:	d409      	bmi.n	9000fd44 <tcp_pbuf_prealloc+0x40>
9000fd30:	8b6b      	ldrh	r3, [r5, #26]
9000fd32:	065b      	lsls	r3, r3, #25
9000fd34:	d427      	bmi.n	9000fd86 <tcp_pbuf_prealloc+0x82>
        (!(pcb->flags & TF_NODELAY) &&
9000fd36:	f1b9 0f00 	cmp.w	r9, #0
9000fd3a:	d003      	beq.n	9000fd44 <tcp_pbuf_prealloc+0x40>
         (!first_seg ||
9000fd3c:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
9000fd3e:	b90b      	cbnz	r3, 9000fd44 <tcp_pbuf_prealloc+0x40>
          pcb->unsent != NULL ||
9000fd40:	6f2b      	ldr	r3, [r5, #112]	; 0x70
9000fd42:	b303      	cbz	r3, 9000fd86 <tcp_pbuf_prealloc+0x82>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
9000fd44:	f204 251b 	addw	r5, r4, #539	; 0x21b
9000fd48:	f025 0103 	bic.w	r1, r5, #3
9000fd4c:	42b9      	cmp	r1, r7
9000fd4e:	460a      	mov	r2, r1
9000fd50:	bf28      	it	cs
9000fd52:	463a      	movcs	r2, r7
9000fd54:	b291      	uxth	r1, r2
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
9000fd56:	f44f 7220 	mov.w	r2, #640	; 0x280
9000fd5a:	4640      	mov	r0, r8
9000fd5c:	f7fd f808 	bl	9000cd70 <pbuf_alloc>
  if (p == NULL) {
9000fd60:	4605      	mov	r5, r0
9000fd62:	b168      	cbz	r0, 9000fd80 <tcp_pbuf_prealloc+0x7c>
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
9000fd64:	6803      	ldr	r3, [r0, #0]
9000fd66:	b133      	cbz	r3, 9000fd76 <tcp_pbuf_prealloc+0x72>
9000fd68:	4b08      	ldr	r3, [pc, #32]	; (9000fd8c <tcp_pbuf_prealloc+0x88>)
9000fd6a:	f240 120b 	movw	r2, #267	; 0x10b
9000fd6e:	490a      	ldr	r1, [pc, #40]	; (9000fd98 <tcp_pbuf_prealloc+0x94>)
9000fd70:	4808      	ldr	r0, [pc, #32]	; (9000fd94 <tcp_pbuf_prealloc+0x90>)
9000fd72:	f001 ff1b 	bl	90011bac <iprintf>
  *oversize = p->len - length;
9000fd76:	896b      	ldrh	r3, [r5, #10]
9000fd78:	1b1b      	subs	r3, r3, r4
9000fd7a:	8033      	strh	r3, [r6, #0]
  p->len = p->tot_len = length;
9000fd7c:	812c      	strh	r4, [r5, #8]
9000fd7e:	816c      	strh	r4, [r5, #10]
}
9000fd80:	4628      	mov	r0, r5
9000fd82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
9000fd86:	4621      	mov	r1, r4
9000fd88:	e7e5      	b.n	9000fd56 <tcp_pbuf_prealloc+0x52>
9000fd8a:	bf00      	nop
9000fd8c:	90015019 	.word	0x90015019
9000fd90:	90015078 	.word	0x90015078
9000fd94:	90012aff 	.word	0x90012aff
9000fd98:	90015097 	.word	0x90015097

9000fd9c <tcp_create_segment>:
{
9000fd9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000fda0:	460e      	mov	r6, r1
9000fda2:	4690      	mov	r8, r2
9000fda4:	4699      	mov	r9, r3
9000fda6:	f89d a020 	ldrb.w	sl, [sp, #32]
  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
9000fdaa:	4607      	mov	r7, r0
9000fdac:	b928      	cbnz	r0, 9000fdba <tcp_create_segment+0x1e>
9000fdae:	4b2f      	ldr	r3, [pc, #188]	; (9000fe6c <tcp_create_segment+0xd0>)
9000fdb0:	22a3      	movs	r2, #163	; 0xa3
9000fdb2:	492f      	ldr	r1, [pc, #188]	; (9000fe70 <tcp_create_segment+0xd4>)
9000fdb4:	482f      	ldr	r0, [pc, #188]	; (9000fe74 <tcp_create_segment+0xd8>)
9000fdb6:	f001 fef9 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
9000fdba:	b92e      	cbnz	r6, 9000fdc8 <tcp_create_segment+0x2c>
9000fdbc:	4b2b      	ldr	r3, [pc, #172]	; (9000fe6c <tcp_create_segment+0xd0>)
9000fdbe:	22a4      	movs	r2, #164	; 0xa4
9000fdc0:	492d      	ldr	r1, [pc, #180]	; (9000fe78 <tcp_create_segment+0xdc>)
9000fdc2:	482c      	ldr	r0, [pc, #176]	; (9000fe74 <tcp_create_segment+0xd8>)
9000fdc4:	f001 fef2 	bl	90011bac <iprintf>
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
9000fdc8:	ea4f 058a 	mov.w	r5, sl, lsl #2
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
9000fdcc:	2003      	movs	r0, #3
9000fdce:	f7fc fb1d 	bl	9000c40c <memp_malloc>
9000fdd2:	4604      	mov	r4, r0
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
9000fdd4:	f005 0504 	and.w	r5, r5, #4
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
9000fdd8:	b928      	cbnz	r0, 9000fde6 <tcp_create_segment+0x4a>
    pbuf_free(p);
9000fdda:	4630      	mov	r0, r6
9000fddc:	f7fc ff60 	bl	9000cca0 <pbuf_free>
}
9000fde0:	4620      	mov	r0, r4
9000fde2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  seg->next = NULL;
9000fde6:	2300      	movs	r3, #0
  seg->flags = optflags;
9000fde8:	f880 a00a 	strb.w	sl, [r0, #10]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
9000fdec:	fa1f fa85 	uxth.w	sl, r5
  seg->p = p;
9000fdf0:	e9c0 3600 	strd	r3, r6, [r0]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
9000fdf4:	8933      	ldrh	r3, [r6, #8]
9000fdf6:	42ab      	cmp	r3, r5
9000fdf8:	d205      	bcs.n	9000fe06 <tcp_create_segment+0x6a>
9000fdfa:	4b1c      	ldr	r3, [pc, #112]	; (9000fe6c <tcp_create_segment+0xd0>)
9000fdfc:	22b0      	movs	r2, #176	; 0xb0
9000fdfe:	491f      	ldr	r1, [pc, #124]	; (9000fe7c <tcp_create_segment+0xe0>)
9000fe00:	481c      	ldr	r0, [pc, #112]	; (9000fe74 <tcp_create_segment+0xd8>)
9000fe02:	f001 fed3 	bl	90011bac <iprintf>
  seg->len = p->tot_len - optlen;
9000fe06:	8933      	ldrh	r3, [r6, #8]
  if (pbuf_add_header(p, TCP_HLEN)) {
9000fe08:	4630      	mov	r0, r6
9000fe0a:	2114      	movs	r1, #20
  seg->len = p->tot_len - optlen;
9000fe0c:	eba3 030a 	sub.w	r3, r3, sl
9000fe10:	8123      	strh	r3, [r4, #8]
  if (pbuf_add_header(p, TCP_HLEN)) {
9000fe12:	f7fc ff0d 	bl	9000cc30 <pbuf_add_header>
9000fe16:	4606      	mov	r6, r0
9000fe18:	b120      	cbz	r0, 9000fe24 <tcp_create_segment+0x88>
    tcp_seg_free(seg);
9000fe1a:	4620      	mov	r0, r4
    return NULL;
9000fe1c:	2400      	movs	r4, #0
    tcp_seg_free(seg);
9000fe1e:	f7fd fd07 	bl	9000d830 <tcp_seg_free>
    return NULL;
9000fe22:	e7dd      	b.n	9000fde0 <tcp_create_segment+0x44>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
9000fe24:	6863      	ldr	r3, [r4, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
9000fe26:	02ad      	lsls	r5, r5, #10
  seg->tcphdr->src = lwip_htons(pcb->local_port);
9000fe28:	8af8      	ldrh	r0, [r7, #22]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
9000fe2a:	f8d3 a004 	ldr.w	sl, [r3, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
9000fe2e:	f505 45a0 	add.w	r5, r5, #20480	; 0x5000
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
9000fe32:	f8c4 a00c 	str.w	sl, [r4, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
9000fe36:	f7f9 f9a3 	bl	90009180 <lwip_htons>
9000fe3a:	f8aa 0000 	strh.w	r0, [sl]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
9000fe3e:	f8d4 a00c 	ldr.w	sl, [r4, #12]
9000fe42:	8b38      	ldrh	r0, [r7, #24]
9000fe44:	f7f9 f99c 	bl	90009180 <lwip_htons>
  seg->tcphdr->seqno = lwip_htonl(seqno);
9000fe48:	68e7      	ldr	r7, [r4, #12]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
9000fe4a:	f8aa 0002 	strh.w	r0, [sl, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
9000fe4e:	4648      	mov	r0, r9
9000fe50:	f7f9 f999 	bl	90009186 <lwip_htonl>
9000fe54:	6078      	str	r0, [r7, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
9000fe56:	ea45 0008 	orr.w	r0, r5, r8
9000fe5a:	68e7      	ldr	r7, [r4, #12]
9000fe5c:	f7f9 f990 	bl	90009180 <lwip_htons>
  seg->tcphdr->urgp = 0;
9000fe60:	68e3      	ldr	r3, [r4, #12]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
9000fe62:	81b8      	strh	r0, [r7, #12]
  seg->tcphdr->urgp = 0;
9000fe64:	749e      	strb	r6, [r3, #18]
9000fe66:	74de      	strb	r6, [r3, #19]
  return seg;
9000fe68:	e7ba      	b.n	9000fde0 <tcp_create_segment+0x44>
9000fe6a:	bf00      	nop
9000fe6c:	90015019 	.word	0x90015019
9000fe70:	900150ab 	.word	0x900150ab
9000fe74:	90012aff 	.word	0x90012aff
9000fe78:	900150cb 	.word	0x900150cb
9000fe7c:	900150ec 	.word	0x900150ec

9000fe80 <tcp_output_alloc_header_common.constprop.0>:
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
9000fe80:	3114      	adds	r1, #20
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
9000fe82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
9000fe86:	b289      	uxth	r1, r1
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
9000fe88:	4606      	mov	r6, r0
9000fe8a:	4617      	mov	r7, r2
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
9000fe8c:	2022      	movs	r0, #34	; 0x22
9000fe8e:	f44f 7220 	mov.w	r2, #640	; 0x280
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
9000fe92:	4698      	mov	r8, r3
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
9000fe94:	f7fc ff6c 	bl	9000cd70 <pbuf_alloc>
  if (p != NULL) {
9000fe98:	4605      	mov	r5, r0
9000fe9a:	b348      	cbz	r0, 9000fef0 <tcp_output_alloc_header_common.constprop.0+0x70>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
9000fe9c:	8943      	ldrh	r3, [r0, #10]
9000fe9e:	2b13      	cmp	r3, #19
9000fea0:	d806      	bhi.n	9000feb0 <tcp_output_alloc_header_common.constprop.0+0x30>
9000fea2:	4b15      	ldr	r3, [pc, #84]	; (9000fef8 <tcp_output_alloc_header_common.constprop.0+0x78>)
9000fea4:	f240 7223 	movw	r2, #1827	; 0x723
9000fea8:	4914      	ldr	r1, [pc, #80]	; (9000fefc <tcp_output_alloc_header_common.constprop.0+0x7c>)
9000feaa:	4815      	ldr	r0, [pc, #84]	; (9000ff00 <tcp_output_alloc_header_common.constprop.0+0x80>)
9000feac:	f001 fe7e 	bl	90011bac <iprintf>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
9000feb0:	686c      	ldr	r4, [r5, #4]
    tcphdr->src = lwip_htons(src_port);
9000feb2:	4640      	mov	r0, r8
9000feb4:	f7f9 f964 	bl	90009180 <lwip_htons>
9000feb8:	8020      	strh	r0, [r4, #0]
    tcphdr->dest = lwip_htons(dst_port);
9000feba:	f8bd 0018 	ldrh.w	r0, [sp, #24]
9000febe:	f7f9 f95f 	bl	90009180 <lwip_htons>
    tcphdr->seqno = seqno_be;
9000fec2:	6067      	str	r7, [r4, #4]
    tcphdr->dest = lwip_htons(dst_port);
9000fec4:	8060      	strh	r0, [r4, #2]
    tcphdr->ackno = lwip_htonl(ackno);
9000fec6:	4630      	mov	r0, r6
9000fec8:	f7f9 f95d 	bl	90009186 <lwip_htonl>
9000fecc:	60a0      	str	r0, [r4, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
9000fece:	f89d 001c 	ldrb.w	r0, [sp, #28]
9000fed2:	f440 40a0 	orr.w	r0, r0, #20480	; 0x5000
9000fed6:	f7f9 f953 	bl	90009180 <lwip_htons>
9000feda:	81a0      	strh	r0, [r4, #12]
    tcphdr->wnd = lwip_htons(wnd);
9000fedc:	f8bd 0020 	ldrh.w	r0, [sp, #32]
9000fee0:	f7f9 f94e 	bl	90009180 <lwip_htons>
    tcphdr->chksum = 0;
9000fee4:	2300      	movs	r3, #0
    tcphdr->wnd = lwip_htons(wnd);
9000fee6:	81e0      	strh	r0, [r4, #14]
    tcphdr->chksum = 0;
9000fee8:	7423      	strb	r3, [r4, #16]
9000feea:	7463      	strb	r3, [r4, #17]
    tcphdr->urgp = 0;
9000feec:	74a3      	strb	r3, [r4, #18]
9000feee:	74e3      	strb	r3, [r4, #19]
  }
  return p;
}
9000fef0:	4628      	mov	r0, r5
9000fef2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9000fef6:	bf00      	nop
9000fef8:	90015019 	.word	0x90015019
9000fefc:	90015101 	.word	0x90015101
9000ff00:	90012aff 	.word	0x90012aff

9000ff04 <tcp_output_alloc_header.constprop.0>:
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
9000ff04:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
9000ff06:	460d      	mov	r5, r1
9000ff08:	4616      	mov	r6, r2
                        u32_t seqno_be /* already in network byte order */)
{
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
9000ff0a:	4604      	mov	r4, r0
9000ff0c:	b930      	cbnz	r0, 9000ff1c <tcp_output_alloc_header.constprop.0+0x18>
9000ff0e:	4b0d      	ldr	r3, [pc, #52]	; (9000ff44 <tcp_output_alloc_header.constprop.0+0x40>)
9000ff10:	f240 7242 	movw	r2, #1858	; 0x742
9000ff14:	490c      	ldr	r1, [pc, #48]	; (9000ff48 <tcp_output_alloc_header.constprop.0+0x44>)
9000ff16:	480d      	ldr	r0, [pc, #52]	; (9000ff4c <tcp_output_alloc_header.constprop.0+0x48>)
9000ff18:	f001 fe48 	bl	90011bac <iprintf>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
9000ff1c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
9000ff1e:	4632      	mov	r2, r6
9000ff20:	4629      	mov	r1, r5
9000ff22:	9302      	str	r3, [sp, #8]
9000ff24:	2310      	movs	r3, #16
9000ff26:	9301      	str	r3, [sp, #4]
9000ff28:	8b23      	ldrh	r3, [r4, #24]
9000ff2a:	9300      	str	r3, [sp, #0]
9000ff2c:	8ae3      	ldrh	r3, [r4, #22]
9000ff2e:	6a60      	ldr	r0, [r4, #36]	; 0x24
9000ff30:	f7ff ffa6 	bl	9000fe80 <tcp_output_alloc_header_common.constprop.0>
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
9000ff34:	b118      	cbz	r0, 9000ff3e <tcp_output_alloc_header.constprop.0+0x3a>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
9000ff36:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
9000ff38:	6a63      	ldr	r3, [r4, #36]	; 0x24
9000ff3a:	4413      	add	r3, r2
9000ff3c:	62e3      	str	r3, [r4, #44]	; 0x2c
  }
  return p;
}
9000ff3e:	b004      	add	sp, #16
9000ff40:	bd70      	pop	{r4, r5, r6, pc}
9000ff42:	bf00      	nop
9000ff44:	90015019 	.word	0x90015019
9000ff48:	9001512f 	.word	0x9001512f
9000ff4c:	90012aff 	.word	0x90012aff

9000ff50 <tcp_output_fill_options.constprop.0>:
{
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
9000ff50:	b930      	cbnz	r0, 9000ff60 <tcp_output_fill_options.constprop.0+0x10>
9000ff52:	4b04      	ldr	r3, [pc, #16]	; (9000ff64 <tcp_output_fill_options.constprop.0+0x14>)
9000ff54:	f240 7256 	movw	r2, #1878	; 0x756
9000ff58:	4903      	ldr	r1, [pc, #12]	; (9000ff68 <tcp_output_fill_options.constprop.0+0x18>)
9000ff5a:	4804      	ldr	r0, [pc, #16]	; (9000ff6c <tcp_output_fill_options.constprop.0+0x1c>)
9000ff5c:	f001 be26 	b.w	90011bac <iprintf>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
9000ff60:	4770      	bx	lr
9000ff62:	bf00      	nop
9000ff64:	90015019 	.word	0x90015019
9000ff68:	90015154 	.word	0x90015154
9000ff6c:	90012aff 	.word	0x90012aff

9000ff70 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
9000ff70:	b5f0      	push	{r4, r5, r6, r7, lr}
9000ff72:	4604      	mov	r4, r0
9000ff74:	b085      	sub	sp, #20
9000ff76:	4617      	mov	r7, r2
9000ff78:	461e      	mov	r6, r3
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
9000ff7a:	460d      	mov	r5, r1
9000ff7c:	b931      	cbnz	r1, 9000ff8c <tcp_output_control_segment+0x1c>
9000ff7e:	4b15      	ldr	r3, [pc, #84]	; (9000ffd4 <tcp_output_control_segment+0x64>)
9000ff80:	f240 7287 	movw	r2, #1927	; 0x787
9000ff84:	4914      	ldr	r1, [pc, #80]	; (9000ffd8 <tcp_output_control_segment+0x68>)
9000ff86:	4815      	ldr	r0, [pc, #84]	; (9000ffdc <tcp_output_control_segment+0x6c>)
9000ff88:	f001 fe10 	bl	90011bac <iprintf>
  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
9000ff8c:	b164      	cbz	r4, 9000ffa8 <tcp_output_control_segment+0x38>
9000ff8e:	7a20      	ldrb	r0, [r4, #8]
9000ff90:	b150      	cbz	r0, 9000ffa8 <tcp_output_control_segment+0x38>
    return netif_get_by_index(pcb->netif_idx);
9000ff92:	f7fc fbb5 	bl	9000c700 <netif_get_by_index>

  netif = tcp_route(pcb, src, dst);
  if (netif == NULL) {
9000ff96:	b968      	cbnz	r0, 9000ffb4 <tcp_output_control_segment+0x44>
    err = ERR_RTE;
9000ff98:	f06f 0403 	mvn.w	r4, #3
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
    NETIF_RESET_HINTS(netif);
  }
  pbuf_free(p);
9000ff9c:	4628      	mov	r0, r5
9000ff9e:	f7fc fe7f 	bl	9000cca0 <pbuf_free>
  return err;
}
9000ffa2:	4620      	mov	r0, r4
9000ffa4:	b005      	add	sp, #20
9000ffa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ip_route(src, dst);
9000ffa8:	4630      	mov	r0, r6
9000ffaa:	f7fb f96f 	bl	9000b28c <ip4_route>
  if (netif == NULL) {
9000ffae:	2800      	cmp	r0, #0
9000ffb0:	d0f2      	beq.n	9000ff98 <tcp_output_control_segment+0x28>
    if (pcb != NULL) {
9000ffb2:	b164      	cbz	r4, 9000ffce <tcp_output_control_segment+0x5e>
      ttl = pcb->ttl;
9000ffb4:	7ae3      	ldrb	r3, [r4, #11]
      tos = pcb->tos;
9000ffb6:	7aa4      	ldrb	r4, [r4, #10]
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
9000ffb8:	2206      	movs	r2, #6
9000ffba:	9002      	str	r0, [sp, #8]
9000ffbc:	4639      	mov	r1, r7
9000ffbe:	4628      	mov	r0, r5
9000ffc0:	e9cd 4200 	strd	r4, r2, [sp]
9000ffc4:	4632      	mov	r2, r6
9000ffc6:	f7fb fad9 	bl	9000b57c <ip4_output_if>
9000ffca:	4604      	mov	r4, r0
9000ffcc:	e7e6      	b.n	9000ff9c <tcp_output_control_segment+0x2c>
      ttl = TCP_TTL;
9000ffce:	23ff      	movs	r3, #255	; 0xff
9000ffd0:	e7f2      	b.n	9000ffb8 <tcp_output_control_segment+0x48>
9000ffd2:	bf00      	nop
9000ffd4:	90015019 	.word	0x90015019
9000ffd8:	9001517a 	.word	0x9001517a
9000ffdc:	90012aff 	.word	0x90012aff

9000ffe0 <tcp_write>:
{
9000ffe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000ffe4:	ed2d 8b02 	vpush	{d8}
9000ffe8:	b08f      	sub	sp, #60	; 0x3c
  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
9000ffea:	4604      	mov	r4, r0
{
9000ffec:	9308      	str	r3, [sp, #32]
  u16_t oversize = 0;
9000ffee:	2300      	movs	r3, #0
{
9000fff0:	9107      	str	r1, [sp, #28]
9000fff2:	9204      	str	r2, [sp, #16]
  u16_t oversize = 0;
9000fff4:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
9000fff8:	b968      	cbnz	r0, 90010016 <tcp_write+0x36>
9000fffa:	4baa      	ldr	r3, [pc, #680]	; (900102a4 <tcp_write+0x2c4>)
9000fffc:	f44f 72cf 	mov.w	r2, #414	; 0x19e
90010000:	49a9      	ldr	r1, [pc, #676]	; (900102a8 <tcp_write+0x2c8>)
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
90010002:	48aa      	ldr	r0, [pc, #680]	; (900102ac <tcp_write+0x2cc>)
90010004:	f001 fdd2 	bl	90011bac <iprintf>
90010008:	f06f 000f 	mvn.w	r0, #15
}
9001000c:	b00f      	add	sp, #60	; 0x3c
9001000e:	ecbd 8b02 	vpop	{d8}
90010012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
90010016:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
9001001a:	8e42      	ldrh	r2, [r0, #50]	; 0x32
9001001c:	085b      	lsrs	r3, r3, #1
9001001e:	4293      	cmp	r3, r2
90010020:	bf28      	it	cs
90010022:	4613      	movcs	r3, r2
  mss_local = mss_local ? mss_local : pcb->mss;
90010024:	2b00      	cmp	r3, #0
90010026:	bf08      	it	eq
90010028:	4613      	moveq	r3, r2
9001002a:	9306      	str	r3, [sp, #24]
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
9001002c:	9b07      	ldr	r3, [sp, #28]
9001002e:	b923      	cbnz	r3, 9001003a <tcp_write+0x5a>
90010030:	4b9c      	ldr	r3, [pc, #624]	; (900102a4 <tcp_write+0x2c4>)
90010032:	f240 12ad 	movw	r2, #429	; 0x1ad
90010036:	499e      	ldr	r1, [pc, #632]	; (900102b0 <tcp_write+0x2d0>)
90010038:	e7e3      	b.n	90010002 <tcp_write+0x22>
  if ((pcb->state != ESTABLISHED) &&
9001003a:	7d03      	ldrb	r3, [r0, #20]
9001003c:	2b07      	cmp	r3, #7
9001003e:	d003      	beq.n	90010048 <tcp_write+0x68>
      (pcb->state != CLOSE_WAIT) &&
90010040:	3b02      	subs	r3, #2
90010042:	2b02      	cmp	r3, #2
90010044:	f200 8259 	bhi.w	900104fa <tcp_write+0x51a>
  } else if (len == 0) {
90010048:	9b04      	ldr	r3, [sp, #16]
9001004a:	b1db      	cbz	r3, 90010084 <tcp_write+0xa4>
  if (len > pcb->snd_buf) {
9001004c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
90010050:	9a04      	ldr	r2, [sp, #16]
90010052:	4293      	cmp	r3, r2
90010054:	d206      	bcs.n	90010064 <tcp_write+0x84>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
90010056:	8b63      	ldrh	r3, [r4, #26]
90010058:	f043 0380 	orr.w	r3, r3, #128	; 0x80
9001005c:	8363      	strh	r3, [r4, #26]
  return ERR_MEM;
9001005e:	f04f 30ff 	mov.w	r0, #4294967295
90010062:	e7d3      	b.n	9001000c <tcp_write+0x2c>
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
90010064:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
90010068:	2a08      	cmp	r2, #8
9001006a:	d8f4      	bhi.n	90010056 <tcp_write+0x76>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
9001006c:	6f23      	ldr	r3, [r4, #112]	; 0x70
  if (pcb->snd_queuelen != 0) {
9001006e:	b302      	cbz	r2, 900100b2 <tcp_write+0xd2>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
90010070:	b943      	cbnz	r3, 90010084 <tcp_write+0xa4>
90010072:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
90010074:	b933      	cbnz	r3, 90010084 <tcp_write+0xa4>
90010076:	4b8b      	ldr	r3, [pc, #556]	; (900102a4 <tcp_write+0x2c4>)
90010078:	f240 1255 	movw	r2, #341	; 0x155
9001007c:	498d      	ldr	r1, [pc, #564]	; (900102b4 <tcp_write+0x2d4>)
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
9001007e:	488b      	ldr	r0, [pc, #556]	; (900102ac <tcp_write+0x2cc>)
90010080:	f001 fd94 	bl	90011bac <iprintf>
  queuelen = pcb->snd_queuelen;
90010084:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
  if (pcb->unsent != NULL) {
90010088:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
  queuelen = pcb->snd_queuelen;
9001008a:	9305      	str	r3, [sp, #20]
  if (pcb->unsent != NULL) {
9001008c:	b9de      	cbnz	r6, 900100c6 <tcp_write+0xe6>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
9001008e:	f8b4 7068 	ldrh.w	r7, [r4, #104]	; 0x68
90010092:	2f00      	cmp	r7, #0
90010094:	f000 81ba 	beq.w	9001040c <tcp_write+0x42c>
90010098:	4b82      	ldr	r3, [pc, #520]	; (900102a4 <tcp_write+0x2c4>)
9001009a:	f240 224a 	movw	r2, #586	; 0x24a
9001009e:	4986      	ldr	r1, [pc, #536]	; (900102b8 <tcp_write+0x2d8>)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
900100a0:	46b0      	mov	r8, r6
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
900100a2:	4882      	ldr	r0, [pc, #520]	; (900102ac <tcp_write+0x2cc>)
  struct pbuf *concat_p = NULL;
900100a4:	46b2      	mov	sl, r6
  u16_t extendlen = 0;
900100a6:	46b1      	mov	r9, r6
  u16_t oversize_used = 0;
900100a8:	4635      	mov	r5, r6
  u16_t pos = 0; /* position in 'arg' data */
900100aa:	4637      	mov	r7, r6
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
900100ac:	f001 fd7e 	bl	90011bac <iprintf>
900100b0:	e088      	b.n	900101c4 <tcp_write+0x1e4>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
900100b2:	b913      	cbnz	r3, 900100ba <tcp_write+0xda>
900100b4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
900100b6:	2b00      	cmp	r3, #0
900100b8:	d0e4      	beq.n	90010084 <tcp_write+0xa4>
900100ba:	4b7a      	ldr	r3, [pc, #488]	; (900102a4 <tcp_write+0x2c4>)
900100bc:	f44f 72ac 	mov.w	r2, #344	; 0x158
900100c0:	497e      	ldr	r1, [pc, #504]	; (900102bc <tcp_write+0x2dc>)
900100c2:	e7dc      	b.n	9001007e <tcp_write+0x9e>
900100c4:	4656      	mov	r6, sl
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
900100c6:	f8d6 a000 	ldr.w	sl, [r6]
900100ca:	46b0      	mov	r8, r6
900100cc:	f1ba 0f00 	cmp.w	sl, #0
900100d0:	d1f8      	bne.n	900100c4 <tcp_write+0xe4>
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
900100d2:	7ab5      	ldrb	r5, [r6, #10]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
900100d4:	8933      	ldrh	r3, [r6, #8]
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
900100d6:	00ad      	lsls	r5, r5, #2
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
900100d8:	9a06      	ldr	r2, [sp, #24]
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
900100da:	f005 0504 	and.w	r5, r5, #4
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
900100de:	442b      	add	r3, r5
900100e0:	429a      	cmp	r2, r3
900100e2:	da06      	bge.n	900100f2 <tcp_write+0x112>
900100e4:	4b6f      	ldr	r3, [pc, #444]	; (900102a4 <tcp_write+0x2c4>)
900100e6:	f44f 72f3 	mov.w	r2, #486	; 0x1e6
900100ea:	4975      	ldr	r1, [pc, #468]	; (900102c0 <tcp_write+0x2e0>)
900100ec:	486f      	ldr	r0, [pc, #444]	; (900102ac <tcp_write+0x2cc>)
900100ee:	f001 fd5d 	bl	90011bac <iprintf>
    space = mss_local - (last_unsent->len + unsent_optlen);
900100f2:	8937      	ldrh	r7, [r6, #8]
900100f4:	9b06      	ldr	r3, [sp, #24]
900100f6:	1bdf      	subs	r7, r3, r7
900100f8:	1b7f      	subs	r7, r7, r5
    oversize = pcb->unsent_oversize;
900100fa:	f8b4 5068 	ldrh.w	r5, [r4, #104]	; 0x68
    space = mss_local - (last_unsent->len + unsent_optlen);
900100fe:	b2bf      	uxth	r7, r7
    oversize = pcb->unsent_oversize;
90010100:	f8ad 5036 	strh.w	r5, [sp, #54]	; 0x36
    if (oversize > 0) {
90010104:	2d00      	cmp	r5, #0
90010106:	d066      	beq.n	900101d6 <tcp_write+0x1f6>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
90010108:	42bd      	cmp	r5, r7
9001010a:	d906      	bls.n	9001011a <tcp_write+0x13a>
9001010c:	4b65      	ldr	r3, [pc, #404]	; (900102a4 <tcp_write+0x2c4>)
9001010e:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
90010112:	496c      	ldr	r1, [pc, #432]	; (900102c4 <tcp_write+0x2e4>)
90010114:	4865      	ldr	r0, [pc, #404]	; (900102ac <tcp_write+0x2cc>)
90010116:	f001 fd49 	bl	90011bac <iprintf>
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
9001011a:	9d04      	ldr	r5, [sp, #16]
9001011c:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
90010120:	429d      	cmp	r5, r3
90010122:	bf28      	it	cs
90010124:	461d      	movcs	r5, r3
90010126:	42bd      	cmp	r5, r7
90010128:	bf28      	it	cs
9001012a:	463d      	movcs	r5, r7
      oversize -= oversize_used;
9001012c:	1b5b      	subs	r3, r3, r5
      space -= oversize_used;
9001012e:	1b7f      	subs	r7, r7, r5
      oversize -= oversize_used;
90010130:	b29b      	uxth	r3, r3
      space -= oversize_used;
90010132:	b2bf      	uxth	r7, r7
      oversize -= oversize_used;
90010134:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
90010138:	b153      	cbz	r3, 90010150 <tcp_write+0x170>
9001013a:	9b04      	ldr	r3, [sp, #16]
9001013c:	42ab      	cmp	r3, r5
9001013e:	f000 816a 	beq.w	90010416 <tcp_write+0x436>
90010142:	4b58      	ldr	r3, [pc, #352]	; (900102a4 <tcp_write+0x2c4>)
90010144:	f44f 7200 	mov.w	r2, #512	; 0x200
90010148:	495f      	ldr	r1, [pc, #380]	; (900102c8 <tcp_write+0x2e8>)
9001014a:	4858      	ldr	r0, [pc, #352]	; (900102ac <tcp_write+0x2cc>)
9001014c:	f001 fd2e 	bl	90011bac <iprintf>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
90010150:	9b04      	ldr	r3, [sp, #16]
90010152:	429d      	cmp	r5, r3
90010154:	f080 815f 	bcs.w	90010416 <tcp_write+0x436>
90010158:	2f00      	cmp	r7, #0
9001015a:	f000 8154 	beq.w	90010406 <tcp_write+0x426>
9001015e:	f8b8 9008 	ldrh.w	r9, [r8, #8]
90010162:	f1b9 0f00 	cmp.w	r9, #0
90010166:	f000 814f 	beq.w	90010408 <tcp_write+0x428>
      u16_t seglen = LWIP_MIN(space, len - pos);
9001016a:	eba3 0905 	sub.w	r9, r3, r5
      if (apiflags & TCP_WRITE_FLAG_COPY) {
9001016e:	9b08      	ldr	r3, [sp, #32]
      u16_t seglen = LWIP_MIN(space, len - pos);
90010170:	45b9      	cmp	r9, r7
90010172:	bfa8      	it	ge
90010174:	46b9      	movge	r9, r7
      if (apiflags & TCP_WRITE_FLAG_COPY) {
90010176:	07db      	lsls	r3, r3, #31
      u16_t seglen = LWIP_MIN(space, len - pos);
90010178:	fa1f f689 	uxth.w	r6, r9
      if (apiflags & TCP_WRITE_FLAG_COPY) {
9001017c:	d52d      	bpl.n	900101da <tcp_write+0x1fa>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
9001017e:	2301      	movs	r3, #1
90010180:	463a      	mov	r2, r7
90010182:	4631      	mov	r1, r6
90010184:	2000      	movs	r0, #0
90010186:	9302      	str	r3, [sp, #8]
90010188:	9b08      	ldr	r3, [sp, #32]
9001018a:	e9cd 4300 	strd	r4, r3, [sp]
9001018e:	f10d 0336 	add.w	r3, sp, #54	; 0x36
90010192:	f7ff fdb7 	bl	9000fd04 <tcp_pbuf_prealloc>
90010196:	4683      	mov	fp, r0
90010198:	2800      	cmp	r0, #0
9001019a:	f000 81ab 	beq.w	900104f4 <tcp_write+0x514>
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
9001019e:	9b07      	ldr	r3, [sp, #28]
900101a0:	4632      	mov	r2, r6
900101a2:	6840      	ldr	r0, [r0, #4]
900101a4:	1959      	adds	r1, r3, r5
900101a6:	f001 fc0b 	bl	900119c0 <memcpy>
        queuelen += pbuf_clen(concat_p);
900101aa:	4658      	mov	r0, fp
          queuelen += pbuf_clen(concat_p);
900101ac:	f7fc feca 	bl	9000cf44 <pbuf_clen>
900101b0:	9b05      	ldr	r3, [sp, #20]
  u16_t extendlen = 0;
900101b2:	f04f 0900 	mov.w	r9, #0
          queuelen += pbuf_clen(concat_p);
900101b6:	4403      	add	r3, r0
900101b8:	b29b      	uxth	r3, r3
900101ba:	9305      	str	r3, [sp, #20]
      pos += seglen;
900101bc:	19af      	adds	r7, r5, r6
900101be:	46da      	mov	sl, fp
900101c0:	4646      	mov	r6, r8
900101c2:	b2bf      	uxth	r7, r7
    if (apiflags & TCP_WRITE_FLAG_COPY) {
900101c4:	9b08      	ldr	r3, [sp, #32]
  struct pbuf *concat_p = NULL;
900101c6:	f04f 0b00 	mov.w	fp, #0
    if (apiflags & TCP_WRITE_FLAG_COPY) {
900101ca:	f003 0301 	and.w	r3, r3, #1
  struct pbuf *concat_p = NULL;
900101ce:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
    if (apiflags & TCP_WRITE_FLAG_COPY) {
900101d2:	930a      	str	r3, [sp, #40]	; 0x28
900101d4:	e0e6      	b.n	900103a4 <tcp_write+0x3c4>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
900101d6:	462e      	mov	r6, r5
900101d8:	e7ba      	b.n	90010150 <tcp_write+0x170>
        for (p = last_unsent->p; p->next != NULL; p = p->next);
900101da:	f8d8 b004 	ldr.w	fp, [r8, #4]
900101de:	465a      	mov	r2, fp
900101e0:	f8db b000 	ldr.w	fp, [fp]
900101e4:	f1bb 0f00 	cmp.w	fp, #0
900101e8:	d1f9      	bne.n	900101de <tcp_write+0x1fe>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
900101ea:	7b13      	ldrb	r3, [r2, #12]
900101ec:	f013 0fc0 	tst.w	r3, #192	; 0xc0
900101f0:	d10f      	bne.n	90010212 <tcp_write+0x232>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
900101f2:	8951      	ldrh	r1, [r2, #10]
900101f4:	6853      	ldr	r3, [r2, #4]
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
900101f6:	9a07      	ldr	r2, [sp, #28]
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
900101f8:	440b      	add	r3, r1
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
900101fa:	429a      	cmp	r2, r3
900101fc:	d109      	bne.n	90010212 <tcp_write+0x232>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
900101fe:	b135      	cbz	r5, 9001020e <tcp_write+0x22e>
90010200:	4b28      	ldr	r3, [pc, #160]	; (900102a4 <tcp_write+0x2c4>)
90010202:	f240 2231 	movw	r2, #561	; 0x231
90010206:	4931      	ldr	r1, [pc, #196]	; (900102cc <tcp_write+0x2ec>)
90010208:	4828      	ldr	r0, [pc, #160]	; (900102ac <tcp_write+0x2cc>)
9001020a:	f001 fccf 	bl	90011bac <iprintf>
          extendlen = seglen;
9001020e:	46b1      	mov	r9, r6
90010210:	e7d4      	b.n	900101bc <tcp_write+0x1dc>
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
90010212:	2201      	movs	r2, #1
90010214:	4631      	mov	r1, r6
90010216:	2000      	movs	r0, #0
90010218:	f7fc fdaa 	bl	9000cd70 <pbuf_alloc>
9001021c:	4683      	mov	fp, r0
9001021e:	2800      	cmp	r0, #0
90010220:	f000 8168 	beq.w	900104f4 <tcp_write+0x514>
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
90010224:	9b07      	ldr	r3, [sp, #28]
90010226:	442b      	add	r3, r5
90010228:	6043      	str	r3, [r0, #4]
9001022a:	e7bf      	b.n	900101ac <tcp_write+0x1cc>
    u16_t left = len - pos;
9001022c:	9b04      	ldr	r3, [sp, #16]
    u16_t seglen = LWIP_MIN(left, max_len);
9001022e:	9a06      	ldr	r2, [sp, #24]
    u16_t left = len - pos;
90010230:	1bdb      	subs	r3, r3, r7
    u16_t seglen = LWIP_MIN(left, max_len);
90010232:	b29b      	uxth	r3, r3
90010234:	4293      	cmp	r3, r2
90010236:	bf28      	it	cs
90010238:	4613      	movcs	r3, r2
9001023a:	b29b      	uxth	r3, r3
9001023c:	ee08 3a10 	vmov	s16, r3
    if (apiflags & TCP_WRITE_FLAG_COPY) {
90010240:	9b0a      	ldr	r3, [sp, #40]	; 0x28
90010242:	2b00      	cmp	r3, #0
90010244:	d046      	beq.n	900102d4 <tcp_write+0x2f4>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
90010246:	fabb f38b 	clz	r3, fp
9001024a:	ee18 1a10 	vmov	r1, s16
9001024e:	2036      	movs	r0, #54	; 0x36
90010250:	095b      	lsrs	r3, r3, #5
90010252:	9302      	str	r3, [sp, #8]
90010254:	9b08      	ldr	r3, [sp, #32]
90010256:	e9cd 4300 	strd	r4, r3, [sp]
9001025a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
9001025e:	f7ff fd51 	bl	9000fd04 <tcp_pbuf_prealloc>
90010262:	4606      	mov	r6, r0
90010264:	2800      	cmp	r0, #0
90010266:	d056      	beq.n	90010316 <tcp_write+0x336>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
90010268:	8943      	ldrh	r3, [r0, #10]
9001026a:	ee18 2a10 	vmov	r2, s16
9001026e:	4293      	cmp	r3, r2
90010270:	d206      	bcs.n	90010280 <tcp_write+0x2a0>
90010272:	4b0c      	ldr	r3, [pc, #48]	; (900102a4 <tcp_write+0x2c4>)
90010274:	f240 2266 	movw	r2, #614	; 0x266
90010278:	4915      	ldr	r1, [pc, #84]	; (900102d0 <tcp_write+0x2f0>)
9001027a:	480c      	ldr	r0, [pc, #48]	; (900102ac <tcp_write+0x2cc>)
9001027c:	f001 fc96 	bl	90011bac <iprintf>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
90010280:	9b07      	ldr	r3, [sp, #28]
90010282:	ee18 2a10 	vmov	r2, s16
90010286:	6870      	ldr	r0, [r6, #4]
90010288:	19d9      	adds	r1, r3, r7
9001028a:	f001 fb99 	bl	900119c0 <memcpy>
    queuelen += pbuf_clen(p);
9001028e:	4630      	mov	r0, r6
90010290:	f7fc fe58 	bl	9000cf44 <pbuf_clen>
90010294:	9b05      	ldr	r3, [sp, #20]
90010296:	4403      	add	r3, r0
90010298:	b29b      	uxth	r3, r3
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
9001029a:	2b09      	cmp	r3, #9
    queuelen += pbuf_clen(p);
9001029c:	9305      	str	r3, [sp, #20]
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
9001029e:	d963      	bls.n	90010368 <tcp_write+0x388>
      pbuf_free(p);
900102a0:	4630      	mov	r0, r6
900102a2:	e036      	b.n	90010312 <tcp_write+0x332>
900102a4:	90015019 	.word	0x90015019
900102a8:	900151a3 	.word	0x900151a3
900102ac:	90012aff 	.word	0x90012aff
900102b0:	900151ba 	.word	0x900151ba
900102b4:	900151eb 	.word	0x900151eb
900102b8:	900152d5 	.word	0x900152d5
900102bc:	90015225 	.word	0x90015225
900102c0:	90015257 	.word	0x90015257
900102c4:	9001526e 	.word	0x9001526e
900102c8:	9001528e 	.word	0x9001528e
900102cc:	900152ac 	.word	0x900152ac
900102d0:	90015304 	.word	0x90015304
      LWIP_ASSERT("oversize == 0", oversize == 0);
900102d4:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
900102d8:	b133      	cbz	r3, 900102e8 <tcp_write+0x308>
900102da:	4b89      	ldr	r3, [pc, #548]	; (90010500 <tcp_write+0x520>)
900102dc:	f240 2271 	movw	r2, #625	; 0x271
900102e0:	4988      	ldr	r1, [pc, #544]	; (90010504 <tcp_write+0x524>)
900102e2:	4889      	ldr	r0, [pc, #548]	; (90010508 <tcp_write+0x528>)
900102e4:	f001 fc62 	bl	90011bac <iprintf>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
900102e8:	2201      	movs	r2, #1
900102ea:	ee18 1a10 	vmov	r1, s16
900102ee:	2036      	movs	r0, #54	; 0x36
900102f0:	f7fc fd3e 	bl	9000cd70 <pbuf_alloc>
900102f4:	b178      	cbz	r0, 90010316 <tcp_write+0x336>
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
900102f6:	9a07      	ldr	r2, [sp, #28]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
900102f8:	2100      	movs	r1, #0
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
900102fa:	900b      	str	r0, [sp, #44]	; 0x2c
900102fc:	443a      	add	r2, r7
900102fe:	6042      	str	r2, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
90010300:	f44f 7220 	mov.w	r2, #640	; 0x280
90010304:	2036      	movs	r0, #54	; 0x36
90010306:	f7fc fd33 	bl	9000cd70 <pbuf_alloc>
9001030a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
9001030c:	4606      	mov	r6, r0
9001030e:	bb38      	cbnz	r0, 90010360 <tcp_write+0x380>
        pbuf_free(p2);
90010310:	4618      	mov	r0, r3
      pbuf_free(p);
90010312:	f7fc fcc5 	bl	9000cca0 <pbuf_free>
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
90010316:	8b63      	ldrh	r3, [r4, #26]
90010318:	f043 0380 	orr.w	r3, r3, #128	; 0x80
9001031c:	8363      	strh	r3, [r4, #26]
  if (concat_p != NULL) {
9001031e:	f1ba 0f00 	cmp.w	sl, #0
90010322:	d002      	beq.n	9001032a <tcp_write+0x34a>
    pbuf_free(concat_p);
90010324:	4650      	mov	r0, sl
90010326:	f7fc fcbb 	bl	9000cca0 <pbuf_free>
  if (queue != NULL) {
9001032a:	f1bb 0f00 	cmp.w	fp, #0
9001032e:	d002      	beq.n	90010336 <tcp_write+0x356>
    tcp_segs_free(queue);
90010330:	4658      	mov	r0, fp
90010332:	f7fd fa8b 	bl	9000d84c <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
90010336:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
9001033a:	2b00      	cmp	r3, #0
9001033c:	f43f ae8f 	beq.w	9001005e <tcp_write+0x7e>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
90010340:	6f23      	ldr	r3, [r4, #112]	; 0x70
90010342:	2b00      	cmp	r3, #0
90010344:	f47f ae8b 	bne.w	9001005e <tcp_write+0x7e>
90010348:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9001034a:	2b00      	cmp	r3, #0
9001034c:	f47f ae87 	bne.w	9001005e <tcp_write+0x7e>
90010350:	4b6b      	ldr	r3, [pc, #428]	; (90010500 <tcp_write+0x520>)
90010352:	f240 3227 	movw	r2, #807	; 0x327
90010356:	496d      	ldr	r1, [pc, #436]	; (9001050c <tcp_write+0x52c>)
90010358:	486b      	ldr	r0, [pc, #428]	; (90010508 <tcp_write+0x528>)
9001035a:	f001 fc27 	bl	90011bac <iprintf>
9001035e:	e67e      	b.n	9001005e <tcp_write+0x7e>
      pbuf_cat(p/*header*/, p2/*data*/);
90010360:	4619      	mov	r1, r3
90010362:	f7fc fe13 	bl	9000cf8c <pbuf_cat>
90010366:	e792      	b.n	9001028e <tcp_write+0x2ae>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
90010368:	6de3      	ldr	r3, [r4, #92]	; 0x5c
9001036a:	2200      	movs	r2, #0
9001036c:	4631      	mov	r1, r6
9001036e:	4620      	mov	r0, r4
90010370:	443b      	add	r3, r7
90010372:	9200      	str	r2, [sp, #0]
90010374:	f7ff fd12 	bl	9000fd9c <tcp_create_segment>
90010378:	4606      	mov	r6, r0
9001037a:	2800      	cmp	r0, #0
9001037c:	d0cb      	beq.n	90010316 <tcp_write+0x336>
    if (queue == NULL) {
9001037e:	f1bb 0f00 	cmp.w	fp, #0
90010382:	d03e      	beq.n	90010402 <tcp_write+0x422>
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
90010384:	9b09      	ldr	r3, [sp, #36]	; 0x24
90010386:	b933      	cbnz	r3, 90010396 <tcp_write+0x3b6>
90010388:	4b5d      	ldr	r3, [pc, #372]	; (90010500 <tcp_write+0x520>)
9001038a:	f240 22ab 	movw	r2, #683	; 0x2ab
9001038e:	4960      	ldr	r1, [pc, #384]	; (90010510 <tcp_write+0x530>)
90010390:	485d      	ldr	r0, [pc, #372]	; (90010508 <tcp_write+0x528>)
90010392:	f001 fc0b 	bl	90011bac <iprintf>
      prev_seg->next = seg;
90010396:	9b09      	ldr	r3, [sp, #36]	; 0x24
90010398:	601e      	str	r6, [r3, #0]
    pos += seglen;
9001039a:	ee18 3a10 	vmov	r3, s16
9001039e:	9609      	str	r6, [sp, #36]	; 0x24
900103a0:	441f      	add	r7, r3
900103a2:	b2bf      	uxth	r7, r7
  while (pos < len) {
900103a4:	9b04      	ldr	r3, [sp, #16]
900103a6:	429f      	cmp	r7, r3
900103a8:	f4ff af40 	bcc.w	9001022c <tcp_write+0x24c>
900103ac:	4657      	mov	r7, sl
900103ae:	46da      	mov	sl, fp
  if (oversize_used > 0) {
900103b0:	b14d      	cbz	r5, 900103c6 <tcp_write+0x3e6>
    for (p = last_unsent->p; p; p = p->next) {
900103b2:	f8d8 b004 	ldr.w	fp, [r8, #4]
900103b6:	f1bb 0f00 	cmp.w	fp, #0
900103ba:	d12f      	bne.n	9001041c <tcp_write+0x43c>
    last_unsent->len += oversize_used;
900103bc:	f8b8 3008 	ldrh.w	r3, [r8, #8]
900103c0:	441d      	add	r5, r3
900103c2:	f8a8 5008 	strh.w	r5, [r8, #8]
  pcb->unsent_oversize = oversize;
900103c6:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
900103ca:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
  if (concat_p != NULL) {
900103ce:	2f00      	cmp	r7, #0
900103d0:	d03d      	beq.n	9001044e <tcp_write+0x46e>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
900103d2:	f1b8 0f00 	cmp.w	r8, #0
900103d6:	d106      	bne.n	900103e6 <tcp_write+0x406>
900103d8:	4b49      	ldr	r3, [pc, #292]	; (90010500 <tcp_write+0x520>)
900103da:	f44f 7238 	mov.w	r2, #736	; 0x2e0
900103de:	494d      	ldr	r1, [pc, #308]	; (90010514 <tcp_write+0x534>)
900103e0:	4849      	ldr	r0, [pc, #292]	; (90010508 <tcp_write+0x528>)
900103e2:	f001 fbe3 	bl	90011bac <iprintf>
    pbuf_cat(last_unsent->p, concat_p);
900103e6:	4639      	mov	r1, r7
900103e8:	f8d8 0004 	ldr.w	r0, [r8, #4]
900103ec:	f7fc fdce 	bl	9000cf8c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
900103f0:	f8b8 3008 	ldrh.w	r3, [r8, #8]
900103f4:	893a      	ldrh	r2, [r7, #8]
900103f6:	4413      	add	r3, r2
900103f8:	f8a8 3008 	strh.w	r3, [r8, #8]
    last_unsent->next = queue;
900103fc:	f8c8 a000 	str.w	sl, [r8]
90010400:	e04d      	b.n	9001049e <tcp_write+0x4be>
90010402:	4683      	mov	fp, r0
90010404:	e7c9      	b.n	9001039a <tcp_write+0x3ba>
  u16_t extendlen = 0;
90010406:	46b9      	mov	r9, r7
90010408:	462f      	mov	r7, r5
9001040a:	e6db      	b.n	900101c4 <tcp_write+0x1e4>
9001040c:	46b9      	mov	r9, r7
  u16_t oversize_used = 0;
9001040e:	463d      	mov	r5, r7
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
90010410:	46b8      	mov	r8, r7
  struct pbuf *concat_p = NULL;
90010412:	46ba      	mov	sl, r7
90010414:	e6d6      	b.n	900101c4 <tcp_write+0x1e4>
90010416:	2700      	movs	r7, #0
  u16_t extendlen = 0;
90010418:	46b9      	mov	r9, r7
9001041a:	e7c9      	b.n	900103b0 <tcp_write+0x3d0>
      p->tot_len += oversize_used;
9001041c:	f8bb 3008 	ldrh.w	r3, [fp, #8]
90010420:	442b      	add	r3, r5
90010422:	f8ab 3008 	strh.w	r3, [fp, #8]
      if (p->next == NULL) {
90010426:	f8db 3000 	ldr.w	r3, [fp]
9001042a:	b96b      	cbnz	r3, 90010448 <tcp_write+0x468>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
9001042c:	f8db 3004 	ldr.w	r3, [fp, #4]
90010430:	462a      	mov	r2, r5
90010432:	f8bb 000a 	ldrh.w	r0, [fp, #10]
90010436:	9907      	ldr	r1, [sp, #28]
90010438:	4418      	add	r0, r3
9001043a:	f001 fac1 	bl	900119c0 <memcpy>
        p->len += oversize_used;
9001043e:	f8bb 300a 	ldrh.w	r3, [fp, #10]
90010442:	442b      	add	r3, r5
90010444:	f8ab 300a 	strh.w	r3, [fp, #10]
    for (p = last_unsent->p; p; p = p->next) {
90010448:	f8db b000 	ldr.w	fp, [fp]
9001044c:	e7b3      	b.n	900103b6 <tcp_write+0x3d6>
  } else if (extendlen > 0) {
9001044e:	f1b9 0f00 	cmp.w	r9, #0
90010452:	d01f      	beq.n	90010494 <tcp_write+0x4b4>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
90010454:	f1b8 0f00 	cmp.w	r8, #0
90010458:	d002      	beq.n	90010460 <tcp_write+0x480>
9001045a:	f8d8 3004 	ldr.w	r3, [r8, #4]
9001045e:	b933      	cbnz	r3, 9001046e <tcp_write+0x48e>
90010460:	4b27      	ldr	r3, [pc, #156]	; (90010500 <tcp_write+0x520>)
90010462:	f240 22e6 	movw	r2, #742	; 0x2e6
90010466:	492c      	ldr	r1, [pc, #176]	; (90010518 <tcp_write+0x538>)
90010468:	4827      	ldr	r0, [pc, #156]	; (90010508 <tcp_write+0x528>)
9001046a:	f001 fb9f 	bl	90011bac <iprintf>
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
9001046e:	f8d8 3004 	ldr.w	r3, [r8, #4]
      p->tot_len += extendlen;
90010472:	891a      	ldrh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
90010474:	6819      	ldr	r1, [r3, #0]
      p->tot_len += extendlen;
90010476:	444a      	add	r2, r9
90010478:	b292      	uxth	r2, r2
9001047a:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
9001047c:	b941      	cbnz	r1, 90010490 <tcp_write+0x4b0>
    p->len += extendlen;
9001047e:	895a      	ldrh	r2, [r3, #10]
90010480:	444a      	add	r2, r9
90010482:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
90010484:	f8b8 3008 	ldrh.w	r3, [r8, #8]
90010488:	4499      	add	r9, r3
9001048a:	f8a8 9008 	strh.w	r9, [r8, #8]
9001048e:	e7b5      	b.n	900103fc <tcp_write+0x41c>
      p->tot_len += extendlen;
90010490:	460b      	mov	r3, r1
90010492:	e7ee      	b.n	90010472 <tcp_write+0x492>
  if (last_unsent == NULL) {
90010494:	f1b8 0f00 	cmp.w	r8, #0
90010498:	d1b0      	bne.n	900103fc <tcp_write+0x41c>
    pcb->unsent = queue;
9001049a:	f8c4 a06c 	str.w	sl, [r4, #108]	; 0x6c
  pcb->snd_lbb += len;
9001049e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
900104a0:	9a04      	ldr	r2, [sp, #16]
900104a2:	4413      	add	r3, r2
  pcb->snd_buf -= len;
900104a4:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
  pcb->snd_lbb += len;
900104a8:	65e3      	str	r3, [r4, #92]	; 0x5c
  pcb->snd_buf -= len;
900104aa:	9b04      	ldr	r3, [sp, #16]
900104ac:	1ad2      	subs	r2, r2, r3
  pcb->snd_queuelen = queuelen;
900104ae:	9b05      	ldr	r3, [sp, #20]
  pcb->snd_buf -= len;
900104b0:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
  pcb->snd_queuelen = queuelen;
900104b4:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  if (pcb->snd_queuelen != 0) {
900104b8:	b153      	cbz	r3, 900104d0 <tcp_write+0x4f0>
    LWIP_ASSERT("tcp_write: valid queue length",
900104ba:	6f23      	ldr	r3, [r4, #112]	; 0x70
900104bc:	b943      	cbnz	r3, 900104d0 <tcp_write+0x4f0>
900104be:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
900104c0:	b933      	cbnz	r3, 900104d0 <tcp_write+0x4f0>
900104c2:	4b0f      	ldr	r3, [pc, #60]	; (90010500 <tcp_write+0x520>)
900104c4:	f240 3212 	movw	r2, #786	; 0x312
900104c8:	4910      	ldr	r1, [pc, #64]	; (9001050c <tcp_write+0x52c>)
900104ca:	480f      	ldr	r0, [pc, #60]	; (90010508 <tcp_write+0x528>)
900104cc:	f001 fb6e 	bl	90011bac <iprintf>
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
900104d0:	b176      	cbz	r6, 900104f0 <tcp_write+0x510>
900104d2:	68f0      	ldr	r0, [r6, #12]
900104d4:	2800      	cmp	r0, #0
900104d6:	f43f ad99 	beq.w	9001000c <tcp_write+0x2c>
900104da:	9b08      	ldr	r3, [sp, #32]
900104dc:	f013 0402 	ands.w	r4, r3, #2
900104e0:	d106      	bne.n	900104f0 <tcp_write+0x510>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
900104e2:	8985      	ldrh	r5, [r0, #12]
900104e4:	2008      	movs	r0, #8
900104e6:	f7f8 fe4b 	bl	90009180 <lwip_htons>
900104ea:	68f3      	ldr	r3, [r6, #12]
900104ec:	4328      	orrs	r0, r5
900104ee:	8198      	strh	r0, [r3, #12]
  return ERR_OK;
900104f0:	2000      	movs	r0, #0
900104f2:	e58b      	b.n	9001000c <tcp_write+0x2c>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
900104f4:	f04f 0b00 	mov.w	fp, #0
900104f8:	e70d      	b.n	90010316 <tcp_write+0x336>
    return ERR_CONN;
900104fa:	f06f 000a 	mvn.w	r0, #10
900104fe:	e585      	b.n	9001000c <tcp_write+0x2c>
90010500:	90015019 	.word	0x90015019
90010504:	90015342 	.word	0x90015342
90010508:	90012aff 	.word	0x90012aff
9001050c:	900153ce 	.word	0x900153ce
90010510:	90015350 	.word	0x90015350
90010514:	90015361 	.word	0x90015361
90010518:	90015399 	.word	0x90015399

9001051c <tcp_split_unsent_seg>:
{
9001051c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90010520:	460d      	mov	r5, r1
  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
90010522:	4606      	mov	r6, r0
90010524:	b930      	cbnz	r0, 90010534 <tcp_split_unsent_seg+0x18>
90010526:	4b5d      	ldr	r3, [pc, #372]	; (9001069c <tcp_split_unsent_seg+0x180>)
90010528:	f240 324b 	movw	r2, #843	; 0x34b
9001052c:	495c      	ldr	r1, [pc, #368]	; (900106a0 <tcp_split_unsent_seg+0x184>)
9001052e:	485d      	ldr	r0, [pc, #372]	; (900106a4 <tcp_split_unsent_seg+0x188>)
90010530:	f001 fb3c 	bl	90011bac <iprintf>
  useg = pcb->unsent;
90010534:	6ef4      	ldr	r4, [r6, #108]	; 0x6c
  if (useg == NULL) {
90010536:	b914      	cbnz	r4, 9001053e <tcp_split_unsent_seg+0x22>
  return ERR_MEM;
90010538:	f04f 30ff 	mov.w	r0, #4294967295
9001053c:	e009      	b.n	90010552 <tcp_split_unsent_seg+0x36>
  if (split == 0) {
9001053e:	b95d      	cbnz	r5, 90010558 <tcp_split_unsent_seg+0x3c>
    LWIP_ASSERT("Can't split segment into length 0", 0);
90010540:	4b56      	ldr	r3, [pc, #344]	; (9001069c <tcp_split_unsent_seg+0x180>)
90010542:	f240 3253 	movw	r2, #851	; 0x353
90010546:	4958      	ldr	r1, [pc, #352]	; (900106a8 <tcp_split_unsent_seg+0x18c>)
90010548:	4856      	ldr	r0, [pc, #344]	; (900106a4 <tcp_split_unsent_seg+0x188>)
9001054a:	f001 fb2f 	bl	90011bac <iprintf>
    return ERR_VAL;
9001054e:	f06f 0005 	mvn.w	r0, #5
}
90010552:	b003      	add	sp, #12
90010554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (useg->len <= split) {
90010558:	8923      	ldrh	r3, [r4, #8]
9001055a:	42ab      	cmp	r3, r5
9001055c:	d801      	bhi.n	90010562 <tcp_split_unsent_seg+0x46>
    return ERR_OK;
9001055e:	2000      	movs	r0, #0
90010560:	e7f7      	b.n	90010552 <tcp_split_unsent_seg+0x36>
  LWIP_ASSERT("split <= mss", split <= pcb->mss);
90010562:	8e73      	ldrh	r3, [r6, #50]	; 0x32
90010564:	42ab      	cmp	r3, r5
90010566:	d20f      	bcs.n	90010588 <tcp_split_unsent_seg+0x6c>
90010568:	4b4c      	ldr	r3, [pc, #304]	; (9001069c <tcp_split_unsent_seg+0x180>)
9001056a:	f240 325b 	movw	r2, #859	; 0x35b
9001056e:	494f      	ldr	r1, [pc, #316]	; (900106ac <tcp_split_unsent_seg+0x190>)
90010570:	484c      	ldr	r0, [pc, #304]	; (900106a4 <tcp_split_unsent_seg+0x188>)
90010572:	f001 fb1b 	bl	90011bac <iprintf>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
90010576:	8923      	ldrh	r3, [r4, #8]
90010578:	b933      	cbnz	r3, 90010588 <tcp_split_unsent_seg+0x6c>
9001057a:	4b48      	ldr	r3, [pc, #288]	; (9001069c <tcp_split_unsent_seg+0x180>)
9001057c:	f44f 7257 	mov.w	r2, #860	; 0x35c
90010580:	494b      	ldr	r1, [pc, #300]	; (900106b0 <tcp_split_unsent_seg+0x194>)
90010582:	4848      	ldr	r0, [pc, #288]	; (900106a4 <tcp_split_unsent_seg+0x188>)
90010584:	f001 fb12 	bl	90011bac <iprintf>
  optflags = useg->flags;
90010588:	f894 b00a 	ldrb.w	fp, [r4, #10]
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
9001058c:	f44f 7220 	mov.w	r2, #640	; 0x280
  remainder = useg->len - split;
90010590:	f8b4 a008 	ldrh.w	sl, [r4, #8]
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
90010594:	2036      	movs	r0, #54	; 0x36
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
90010596:	ea4f 078b 	mov.w	r7, fp, lsl #2
  remainder = useg->len - split;
9001059a:	ebaa 0105 	sub.w	r1, sl, r5
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
9001059e:	f007 0704 	and.w	r7, r7, #4
  remainder = useg->len - split;
900105a2:	fa1f f881 	uxth.w	r8, r1
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
900105a6:	fa17 f181 	uxtah	r1, r7, r1
900105aa:	b289      	uxth	r1, r1
900105ac:	f7fc fbe0 	bl	9000cd70 <pbuf_alloc>
  if (p == NULL) {
900105b0:	4681      	mov	r9, r0
900105b2:	2800      	cmp	r0, #0
900105b4:	d0c0      	beq.n	90010538 <tcp_split_unsent_seg+0x1c>
  offset = useg->p->tot_len - useg->len + split;
900105b6:	6860      	ldr	r0, [r4, #4]
900105b8:	8922      	ldrh	r2, [r4, #8]
900105ba:	8903      	ldrh	r3, [r0, #8]
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
900105bc:	f8d9 1004 	ldr.w	r1, [r9, #4]
  offset = useg->p->tot_len - useg->len + split;
900105c0:	1a9b      	subs	r3, r3, r2
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
900105c2:	4642      	mov	r2, r8
900105c4:	4439      	add	r1, r7
  offset = useg->p->tot_len - useg->len + split;
900105c6:	442b      	add	r3, r5
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
900105c8:	b29b      	uxth	r3, r3
900105ca:	f7fc fda5 	bl	9000d118 <pbuf_copy_partial>
900105ce:	4540      	cmp	r0, r8
900105d0:	d160      	bne.n	90010694 <tcp_split_unsent_seg+0x178>
  split_flags = TCPH_FLAGS(useg->tcphdr);
900105d2:	68e3      	ldr	r3, [r4, #12]
900105d4:	8998      	ldrh	r0, [r3, #12]
900105d6:	f7f8 fdd3 	bl	90009180 <lwip_htons>
  if (split_flags & TCP_PSH) {
900105da:	f010 0808 	ands.w	r8, r0, #8
  split_flags = TCPH_FLAGS(useg->tcphdr);
900105de:	b2c7      	uxtb	r7, r0
    remainder_flags |= TCP_PSH;
900105e0:	bf16      	itet	ne
900105e2:	f04f 0808 	movne.w	r8, #8
  split_flags = TCPH_FLAGS(useg->tcphdr);
900105e6:	f007 073f 	andeq.w	r7, r7, #63	; 0x3f
    split_flags &= ~TCP_PSH;
900105ea:	f007 0737 	andne.w	r7, r7, #55	; 0x37
  if (split_flags & TCP_FIN) {
900105ee:	07fb      	lsls	r3, r7, #31
  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
900105f0:	68e3      	ldr	r3, [r4, #12]
    remainder_flags |= TCP_FIN;
900105f2:	bf48      	it	mi
900105f4:	f048 0801 	orrmi.w	r8, r8, #1
  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
900105f8:	6858      	ldr	r0, [r3, #4]
    split_flags &= ~TCP_FIN;
900105fa:	bf48      	it	mi
900105fc:	f007 07fe 	andmi.w	r7, r7, #254	; 0xfe
  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
90010600:	f7f8 fdc1 	bl	90009186 <lwip_htonl>
90010604:	4642      	mov	r2, r8
90010606:	182b      	adds	r3, r5, r0
90010608:	4649      	mov	r1, r9
9001060a:	4630      	mov	r0, r6
9001060c:	f8cd b000 	str.w	fp, [sp]
90010610:	f7ff fbc4 	bl	9000fd9c <tcp_create_segment>
  if (seg == NULL) {
90010614:	4680      	mov	r8, r0
90010616:	2800      	cmp	r0, #0
90010618:	d03c      	beq.n	90010694 <tcp_split_unsent_seg+0x178>
  pcb->snd_queuelen -= pbuf_clen(useg->p);
9001061a:	6860      	ldr	r0, [r4, #4]
9001061c:	eba5 050a 	sub.w	r5, r5, sl
90010620:	f7fc fc90 	bl	9000cf44 <pbuf_clen>
90010624:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
90010628:	fa1f f985 	uxth.w	r9, r5
9001062c:	1a18      	subs	r0, r3, r0
9001062e:	f8a6 0066 	strh.w	r0, [r6, #102]	; 0x66
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
90010632:	6860      	ldr	r0, [r4, #4]
90010634:	8901      	ldrh	r1, [r0, #8]
90010636:	fa11 f185 	uxtah	r1, r1, r5
9001063a:	b289      	uxth	r1, r1
9001063c:	f7fc fc2a 	bl	9000ce94 <pbuf_realloc>
  useg->len -= remainder;
90010640:	8923      	ldrh	r3, [r4, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
90010642:	4638      	mov	r0, r7
  useg->len -= remainder;
90010644:	4499      	add	r9, r3
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
90010646:	68e3      	ldr	r3, [r4, #12]
  useg->len -= remainder;
90010648:	f8a4 9008 	strh.w	r9, [r4, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
9001064c:	899d      	ldrh	r5, [r3, #12]
9001064e:	f7f8 fd97 	bl	90009180 <lwip_htons>
90010652:	68e3      	ldr	r3, [r4, #12]
90010654:	4328      	orrs	r0, r5
90010656:	8198      	strh	r0, [r3, #12]
  pcb->snd_queuelen += pbuf_clen(useg->p);
90010658:	6860      	ldr	r0, [r4, #4]
9001065a:	f7fc fc73 	bl	9000cf44 <pbuf_clen>
9001065e:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
90010662:	4418      	add	r0, r3
90010664:	f8a6 0066 	strh.w	r0, [r6, #102]	; 0x66
  pcb->snd_queuelen += pbuf_clen(seg->p);
90010668:	f8d8 0004 	ldr.w	r0, [r8, #4]
9001066c:	f7fc fc6a 	bl	9000cf44 <pbuf_clen>
90010670:	f8b6 3066 	ldrh.w	r3, [r6, #102]	; 0x66
90010674:	4418      	add	r0, r3
  seg->next = useg->next;
90010676:	6823      	ldr	r3, [r4, #0]
  pcb->snd_queuelen += pbuf_clen(seg->p);
90010678:	f8a6 0066 	strh.w	r0, [r6, #102]	; 0x66
  seg->next = useg->next;
9001067c:	f8c8 3000 	str.w	r3, [r8]
  useg->next = seg;
90010680:	f8c4 8000 	str.w	r8, [r4]
  if (seg->next == NULL) {
90010684:	f8d8 0000 	ldr.w	r0, [r8]
90010688:	2800      	cmp	r0, #0
9001068a:	f47f af68 	bne.w	9001055e <tcp_split_unsent_seg+0x42>
    pcb->unsent_oversize = 0;
9001068e:	f8a6 0068 	strh.w	r0, [r6, #104]	; 0x68
90010692:	e75e      	b.n	90010552 <tcp_split_unsent_seg+0x36>
    pbuf_free(p);
90010694:	4648      	mov	r0, r9
90010696:	f7fc fb03 	bl	9000cca0 <pbuf_free>
9001069a:	e74d      	b.n	90010538 <tcp_split_unsent_seg+0x1c>
9001069c:	90015019 	.word	0x90015019
900106a0:	900153ec 	.word	0x900153ec
900106a4:	90012aff 	.word	0x90012aff
900106a8:	9001540e 	.word	0x9001540e
900106ac:	90015430 	.word	0x90015430
900106b0:	9001543d 	.word	0x9001543d

900106b4 <tcp_enqueue_flags>:
{
900106b4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
900106b8:	f011 0803 	ands.w	r8, r1, #3
{
900106bc:	4604      	mov	r4, r0
900106be:	460e      	mov	r6, r1
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
900106c0:	d106      	bne.n	900106d0 <tcp_enqueue_flags+0x1c>
900106c2:	4b3e      	ldr	r3, [pc, #248]	; (900107bc <tcp_enqueue_flags+0x108>)
900106c4:	f240 4211 	movw	r2, #1041	; 0x411
900106c8:	493d      	ldr	r1, [pc, #244]	; (900107c0 <tcp_enqueue_flags+0x10c>)
900106ca:	483e      	ldr	r0, [pc, #248]	; (900107c4 <tcp_enqueue_flags+0x110>)
900106cc:	f001 fa6e 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
900106d0:	b934      	cbnz	r4, 900106e0 <tcp_enqueue_flags+0x2c>
900106d2:	4b3a      	ldr	r3, [pc, #232]	; (900107bc <tcp_enqueue_flags+0x108>)
900106d4:	f240 4213 	movw	r2, #1043	; 0x413
900106d8:	493b      	ldr	r1, [pc, #236]	; (900107c8 <tcp_enqueue_flags+0x114>)
900106da:	483a      	ldr	r0, [pc, #232]	; (900107c4 <tcp_enqueue_flags+0x110>)
900106dc:	f001 fa66 	bl	90011bac <iprintf>
  if (flags & TCP_SYN) {
900106e0:	f3c6 0740 	ubfx	r7, r6, #1, #1
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
900106e4:	f44f 7220 	mov.w	r2, #640	; 0x280
900106e8:	2036      	movs	r0, #54	; 0x36
900106ea:	ea4f 0987 	mov.w	r9, r7, lsl #2
900106ee:	4649      	mov	r1, r9
900106f0:	f7fc fb3e 	bl	9000cd70 <pbuf_alloc>
900106f4:	4605      	mov	r5, r0
900106f6:	b940      	cbnz	r0, 9001070a <tcp_enqueue_flags+0x56>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
900106f8:	8b63      	ldrh	r3, [r4, #26]
    return ERR_MEM;
900106fa:	f04f 30ff 	mov.w	r0, #4294967295
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
900106fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90010702:	8363      	strh	r3, [r4, #26]
}
90010704:	b003      	add	sp, #12
90010706:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
9001070a:	8943      	ldrh	r3, [r0, #10]
9001070c:	454b      	cmp	r3, r9
9001070e:	d206      	bcs.n	9001071e <tcp_enqueue_flags+0x6a>
90010710:	4b2a      	ldr	r3, [pc, #168]	; (900107bc <tcp_enqueue_flags+0x108>)
90010712:	f240 4239 	movw	r2, #1081	; 0x439
90010716:	492d      	ldr	r1, [pc, #180]	; (900107cc <tcp_enqueue_flags+0x118>)
90010718:	482a      	ldr	r0, [pc, #168]	; (900107c4 <tcp_enqueue_flags+0x110>)
9001071a:	f001 fa47 	bl	90011bac <iprintf>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
9001071e:	4629      	mov	r1, r5
90010720:	9700      	str	r7, [sp, #0]
90010722:	4632      	mov	r2, r6
90010724:	6de3      	ldr	r3, [r4, #92]	; 0x5c
90010726:	4620      	mov	r0, r4
90010728:	f7ff fb38 	bl	9000fd9c <tcp_create_segment>
9001072c:	4605      	mov	r5, r0
9001072e:	2800      	cmp	r0, #0
90010730:	d0e2      	beq.n	900106f8 <tcp_enqueue_flags+0x44>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
90010732:	68c3      	ldr	r3, [r0, #12]
90010734:	079a      	lsls	r2, r3, #30
90010736:	d006      	beq.n	90010746 <tcp_enqueue_flags+0x92>
90010738:	4b20      	ldr	r3, [pc, #128]	; (900107bc <tcp_enqueue_flags+0x108>)
9001073a:	f240 4242 	movw	r2, #1090	; 0x442
9001073e:	4924      	ldr	r1, [pc, #144]	; (900107d0 <tcp_enqueue_flags+0x11c>)
90010740:	4820      	ldr	r0, [pc, #128]	; (900107c4 <tcp_enqueue_flags+0x110>)
90010742:	f001 fa33 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
90010746:	892b      	ldrh	r3, [r5, #8]
90010748:	b133      	cbz	r3, 90010758 <tcp_enqueue_flags+0xa4>
9001074a:	4b1c      	ldr	r3, [pc, #112]	; (900107bc <tcp_enqueue_flags+0x108>)
9001074c:	f240 4243 	movw	r2, #1091	; 0x443
90010750:	4920      	ldr	r1, [pc, #128]	; (900107d4 <tcp_enqueue_flags+0x120>)
90010752:	481c      	ldr	r0, [pc, #112]	; (900107c4 <tcp_enqueue_flags+0x110>)
90010754:	f001 fa2a 	bl	90011bac <iprintf>
  if (pcb->unsent == NULL) {
90010758:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9001075a:	bb43      	cbnz	r3, 900107ae <tcp_enqueue_flags+0xfa>
    pcb->unsent = seg;
9001075c:	66e5      	str	r5, [r4, #108]	; 0x6c
  pcb->unsent_oversize = 0;
9001075e:	2300      	movs	r3, #0
90010760:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
90010764:	f1b8 0f00 	cmp.w	r8, #0
90010768:	d002      	beq.n	90010770 <tcp_enqueue_flags+0xbc>
    pcb->snd_lbb++;
9001076a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
9001076c:	3301      	adds	r3, #1
9001076e:	65e3      	str	r3, [r4, #92]	; 0x5c
  if (flags & TCP_FIN) {
90010770:	07f3      	lsls	r3, r6, #31
  pcb->snd_queuelen += pbuf_clen(seg->p);
90010772:	6868      	ldr	r0, [r5, #4]
    tcp_set_flags(pcb, TF_FIN);
90010774:	bf42      	ittt	mi
90010776:	8b63      	ldrhmi	r3, [r4, #26]
90010778:	f043 0320 	orrmi.w	r3, r3, #32
9001077c:	8363      	strhmi	r3, [r4, #26]
  pcb->snd_queuelen += pbuf_clen(seg->p);
9001077e:	f7fc fbe1 	bl	9000cf44 <pbuf_clen>
90010782:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
90010786:	4418      	add	r0, r3
90010788:	b280      	uxth	r0, r0
9001078a:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
  if (pcb->snd_queuelen != 0) {
9001078e:	2800      	cmp	r0, #0
90010790:	d0b8      	beq.n	90010704 <tcp_enqueue_flags+0x50>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
90010792:	6f20      	ldr	r0, [r4, #112]	; 0x70
90010794:	b948      	cbnz	r0, 900107aa <tcp_enqueue_flags+0xf6>
90010796:	6ee4      	ldr	r4, [r4, #108]	; 0x6c
90010798:	2c00      	cmp	r4, #0
9001079a:	d1b3      	bne.n	90010704 <tcp_enqueue_flags+0x50>
9001079c:	4b07      	ldr	r3, [pc, #28]	; (900107bc <tcp_enqueue_flags+0x108>)
9001079e:	f240 4265 	movw	r2, #1125	; 0x465
900107a2:	490d      	ldr	r1, [pc, #52]	; (900107d8 <tcp_enqueue_flags+0x124>)
900107a4:	4807      	ldr	r0, [pc, #28]	; (900107c4 <tcp_enqueue_flags+0x110>)
900107a6:	f001 fa01 	bl	90011bac <iprintf>
  return ERR_OK;
900107aa:	2000      	movs	r0, #0
900107ac:	e7aa      	b.n	90010704 <tcp_enqueue_flags+0x50>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
900107ae:	461a      	mov	r2, r3
900107b0:	681b      	ldr	r3, [r3, #0]
900107b2:	2b00      	cmp	r3, #0
900107b4:	d1fb      	bne.n	900107ae <tcp_enqueue_flags+0xfa>
    useg->next = seg;
900107b6:	6015      	str	r5, [r2, #0]
900107b8:	e7d1      	b.n	9001075e <tcp_enqueue_flags+0xaa>
900107ba:	bf00      	nop
900107bc:	90015019 	.word	0x90015019
900107c0:	9001544b 	.word	0x9001544b
900107c4:	90012aff 	.word	0x90012aff
900107c8:	900154a0 	.word	0x900154a0
900107cc:	900154bf 	.word	0x900154bf
900107d0:	900154f8 	.word	0x900154f8
900107d4:	90015510 	.word	0x90015510
900107d8:	9001553a 	.word	0x9001553a

900107dc <tcp_send_fin>:
{
900107dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
900107de:	4604      	mov	r4, r0
900107e0:	b930      	cbnz	r0, 900107f0 <tcp_send_fin+0x14>
900107e2:	4b13      	ldr	r3, [pc, #76]	; (90010830 <tcp_send_fin+0x54>)
900107e4:	f240 32eb 	movw	r2, #1003	; 0x3eb
900107e8:	4912      	ldr	r1, [pc, #72]	; (90010834 <tcp_send_fin+0x58>)
900107ea:	4813      	ldr	r0, [pc, #76]	; (90010838 <tcp_send_fin+0x5c>)
900107ec:	f001 f9de 	bl	90011bac <iprintf>
  if (pcb->unsent != NULL) {
900107f0:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
900107f2:	b14d      	cbz	r5, 90010808 <tcp_send_fin+0x2c>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
900107f4:	462f      	mov	r7, r5
900107f6:	682d      	ldr	r5, [r5, #0]
900107f8:	2d00      	cmp	r5, #0
900107fa:	d1fb      	bne.n	900107f4 <tcp_send_fin+0x18>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
900107fc:	68fb      	ldr	r3, [r7, #12]
900107fe:	8998      	ldrh	r0, [r3, #12]
90010800:	f7f8 fcbe 	bl	90009180 <lwip_htons>
90010804:	0743      	lsls	r3, r0, #29
90010806:	d005      	beq.n	90010814 <tcp_send_fin+0x38>
  return tcp_enqueue_flags(pcb, TCP_FIN);
90010808:	4620      	mov	r0, r4
9001080a:	2101      	movs	r1, #1
}
9001080c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return tcp_enqueue_flags(pcb, TCP_FIN);
90010810:	f7ff bf50 	b.w	900106b4 <tcp_enqueue_flags>
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
90010814:	68fb      	ldr	r3, [r7, #12]
90010816:	2001      	movs	r0, #1
90010818:	899e      	ldrh	r6, [r3, #12]
9001081a:	f7f8 fcb1 	bl	90009180 <lwip_htons>
9001081e:	68fb      	ldr	r3, [r7, #12]
90010820:	4330      	orrs	r0, r6
90010822:	8198      	strh	r0, [r3, #12]
}
90010824:	4628      	mov	r0, r5
      tcp_set_flags(pcb, TF_FIN);
90010826:	8b63      	ldrh	r3, [r4, #26]
90010828:	f043 0320 	orr.w	r3, r3, #32
9001082c:	8363      	strh	r3, [r4, #26]
}
9001082e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
90010830:	90015019 	.word	0x90015019
90010834:	90015562 	.word	0x90015562
90010838:	90012aff 	.word	0x90012aff

9001083c <tcp_rexmit_rto_prepare>:
{
9001083c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
90010840:	4604      	mov	r4, r0
90010842:	b930      	cbnz	r0, 90010852 <tcp_rexmit_rto_prepare+0x16>
90010844:	4b1c      	ldr	r3, [pc, #112]	; (900108b8 <tcp_rexmit_rto_prepare+0x7c>)
90010846:	f240 6263 	movw	r2, #1635	; 0x663
9001084a:	491c      	ldr	r1, [pc, #112]	; (900108bc <tcp_rexmit_rto_prepare+0x80>)
9001084c:	481c      	ldr	r0, [pc, #112]	; (900108c0 <tcp_rexmit_rto_prepare+0x84>)
9001084e:	f001 f9ad 	bl	90011bac <iprintf>
  if (pcb->unacked == NULL) {
90010852:	6f25      	ldr	r5, [r4, #112]	; 0x70
90010854:	b945      	cbnz	r5, 90010868 <tcp_rexmit_rto_prepare+0x2c>
    return ERR_VAL;
90010856:	f06f 0005 	mvn.w	r0, #5
}
9001085a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (tcp_output_segment_busy(seg)) {
9001085e:	f7ff fa3b 	bl	9000fcd8 <tcp_output_segment_busy>
90010862:	2800      	cmp	r0, #0
90010864:	d1f7      	bne.n	90010856 <tcp_rexmit_rto_prepare+0x1a>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
90010866:	682d      	ldr	r5, [r5, #0]
90010868:	682b      	ldr	r3, [r5, #0]
    if (tcp_output_segment_busy(seg)) {
9001086a:	4628      	mov	r0, r5
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
9001086c:	2b00      	cmp	r3, #0
9001086e:	d1f6      	bne.n	9001085e <tcp_rexmit_rto_prepare+0x22>
  if (tcp_output_segment_busy(seg)) {
90010870:	f7ff fa32 	bl	9000fcd8 <tcp_output_segment_busy>
90010874:	4606      	mov	r6, r0
90010876:	2800      	cmp	r0, #0
90010878:	d1ed      	bne.n	90010856 <tcp_rexmit_rto_prepare+0x1a>
  seg->next = pcb->unsent;
9001087a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
9001087c:	602b      	str	r3, [r5, #0]
  pcb->unsent = pcb->unacked;
9001087e:	6f23      	ldr	r3, [r4, #112]	; 0x70
  pcb->unacked = NULL;
90010880:	e9c4 301b 	strd	r3, r0, [r4, #108]	; 0x6c
  tcp_set_flags(pcb, TF_RTO);
90010884:	8b63      	ldrh	r3, [r4, #26]
90010886:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
9001088a:	8363      	strh	r3, [r4, #26]
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
9001088c:	68eb      	ldr	r3, [r5, #12]
9001088e:	6858      	ldr	r0, [r3, #4]
90010890:	f7f8 fc79 	bl	90009186 <lwip_htonl>
90010894:	68eb      	ldr	r3, [r5, #12]
90010896:	4607      	mov	r7, r0
90010898:	f8b5 8008 	ldrh.w	r8, [r5, #8]
9001089c:	8998      	ldrh	r0, [r3, #12]
9001089e:	f7f8 fc6f 	bl	90009180 <lwip_htons>
900108a2:	f010 0303 	ands.w	r3, r0, #3
900108a6:	4447      	add	r7, r8
  return ERR_OK;
900108a8:	4630      	mov	r0, r6
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
900108aa:	bf18      	it	ne
900108ac:	2301      	movne	r3, #1
  pcb->rttest = 0;
900108ae:	6366      	str	r6, [r4, #52]	; 0x34
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
900108b0:	443b      	add	r3, r7
900108b2:	64e3      	str	r3, [r4, #76]	; 0x4c
  return ERR_OK;
900108b4:	e7d1      	b.n	9001085a <tcp_rexmit_rto_prepare+0x1e>
900108b6:	bf00      	nop
900108b8:	90015019 	.word	0x90015019
900108bc:	9001557c 	.word	0x9001557c
900108c0:	90012aff 	.word	0x90012aff

900108c4 <tcp_rexmit>:
{
900108c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
900108c6:	4604      	mov	r4, r0
900108c8:	b930      	cbnz	r0, 900108d8 <tcp_rexmit+0x14>
900108ca:	4b1b      	ldr	r3, [pc, #108]	; (90010938 <tcp_rexmit+0x74>)
900108cc:	f240 62c1 	movw	r2, #1729	; 0x6c1
900108d0:	491a      	ldr	r1, [pc, #104]	; (9001093c <tcp_rexmit+0x78>)
900108d2:	481b      	ldr	r0, [pc, #108]	; (90010940 <tcp_rexmit+0x7c>)
900108d4:	f001 f96a 	bl	90011bac <iprintf>
  if (pcb->unacked == NULL) {
900108d8:	6f25      	ldr	r5, [r4, #112]	; 0x70
900108da:	b915      	cbnz	r5, 900108e2 <tcp_rexmit+0x1e>
    return ERR_VAL;
900108dc:	f06f 0005 	mvn.w	r0, #5
}
900108e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (tcp_output_segment_busy(seg)) {
900108e2:	4628      	mov	r0, r5
900108e4:	f7ff f9f8 	bl	9000fcd8 <tcp_output_segment_busy>
900108e8:	2800      	cmp	r0, #0
900108ea:	d1f7      	bne.n	900108dc <tcp_rexmit+0x18>
  pcb->unacked = seg->next;
900108ec:	682b      	ldr	r3, [r5, #0]
  cur_seg = &(pcb->unsent);
900108ee:	f104 066c 	add.w	r6, r4, #108	; 0x6c
  pcb->unacked = seg->next;
900108f2:	6723      	str	r3, [r4, #112]	; 0x70
  while (*cur_seg &&
900108f4:	6833      	ldr	r3, [r6, #0]
900108f6:	b983      	cbnz	r3, 9001091a <tcp_rexmit+0x56>
  seg->next = *cur_seg;
900108f8:	6833      	ldr	r3, [r6, #0]
900108fa:	602b      	str	r3, [r5, #0]
  *cur_seg = seg;
900108fc:	6035      	str	r5, [r6, #0]
  if (seg->next == NULL) {
900108fe:	682b      	ldr	r3, [r5, #0]
90010900:	b90b      	cbnz	r3, 90010906 <tcp_rexmit+0x42>
    pcb->unsent_oversize = 0;
90010902:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
  if (pcb->nrtx < 0xFF) {
90010906:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  pcb->rttest = 0;
9001090a:	2000      	movs	r0, #0
  if (pcb->nrtx < 0xFF) {
9001090c:	2bff      	cmp	r3, #255	; 0xff
  pcb->rttest = 0;
9001090e:	6360      	str	r0, [r4, #52]	; 0x34
    ++pcb->nrtx;
90010910:	bf1c      	itt	ne
90010912:	3301      	addne	r3, #1
90010914:	f884 3042 	strbne.w	r3, [r4, #66]	; 0x42
  return ERR_OK;
90010918:	e7e2      	b.n	900108e0 <tcp_rexmit+0x1c>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
9001091a:	68db      	ldr	r3, [r3, #12]
9001091c:	6858      	ldr	r0, [r3, #4]
9001091e:	f7f8 fc32 	bl	90009186 <lwip_htonl>
90010922:	68eb      	ldr	r3, [r5, #12]
90010924:	4607      	mov	r7, r0
90010926:	6858      	ldr	r0, [r3, #4]
90010928:	f7f8 fc2d 	bl	90009186 <lwip_htonl>
9001092c:	1a38      	subs	r0, r7, r0
  while (*cur_seg &&
9001092e:	2800      	cmp	r0, #0
90010930:	dae2      	bge.n	900108f8 <tcp_rexmit+0x34>
    cur_seg = &((*cur_seg)->next );
90010932:	6836      	ldr	r6, [r6, #0]
90010934:	e7de      	b.n	900108f4 <tcp_rexmit+0x30>
90010936:	bf00      	nop
90010938:	90015019 	.word	0x90015019
9001093c:	900155a0 	.word	0x900155a0
90010940:	90012aff 	.word	0x90012aff

90010944 <tcp_rexmit_fast>:
{
90010944:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
90010946:	4604      	mov	r4, r0
90010948:	b930      	cbnz	r0, 90010958 <tcp_rexmit_fast+0x14>
9001094a:	4b15      	ldr	r3, [pc, #84]	; (900109a0 <tcp_rexmit_fast+0x5c>)
9001094c:	f240 62f9 	movw	r2, #1785	; 0x6f9
90010950:	4914      	ldr	r1, [pc, #80]	; (900109a4 <tcp_rexmit_fast+0x60>)
90010952:	4815      	ldr	r0, [pc, #84]	; (900109a8 <tcp_rexmit_fast+0x64>)
90010954:	f001 f92a 	bl	90011bac <iprintf>
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
90010958:	6f23      	ldr	r3, [r4, #112]	; 0x70
9001095a:	b1fb      	cbz	r3, 9001099c <tcp_rexmit_fast+0x58>
9001095c:	8b63      	ldrh	r3, [r4, #26]
9001095e:	075b      	lsls	r3, r3, #29
90010960:	d41c      	bmi.n	9001099c <tcp_rexmit_fast+0x58>
    if (tcp_rexmit(pcb) == ERR_OK) {
90010962:	4620      	mov	r0, r4
90010964:	f7ff ffae 	bl	900108c4 <tcp_rexmit>
90010968:	b9c0      	cbnz	r0, 9001099c <tcp_rexmit_fast+0x58>
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
9001096a:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
9001096e:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
      pcb->rtime = 0;
90010972:	8620      	strh	r0, [r4, #48]	; 0x30
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
90010974:	4299      	cmp	r1, r3
90010976:	bf28      	it	cs
90010978:	4619      	movcs	r1, r3
      if (pcb->ssthresh < (2U * pcb->mss)) {
9001097a:	8e63      	ldrh	r3, [r4, #50]	; 0x32
9001097c:	005d      	lsls	r5, r3, #1
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
9001097e:	104a      	asrs	r2, r1, #1
        pcb->ssthresh = 2 * pcb->mss;
90010980:	ebb5 0f51 	cmp.w	r5, r1, lsr #1
      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
90010984:	442b      	add	r3, r5
        pcb->ssthresh = 2 * pcb->mss;
90010986:	bf88      	it	hi
90010988:	462a      	movhi	r2, r5
      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
9001098a:	4413      	add	r3, r2
        pcb->ssthresh = 2 * pcb->mss;
9001098c:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
90010990:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      tcp_set_flags(pcb, TF_INFR);
90010994:	8b63      	ldrh	r3, [r4, #26]
90010996:	f043 0304 	orr.w	r3, r3, #4
9001099a:	8363      	strh	r3, [r4, #26]
}
9001099c:	bd38      	pop	{r3, r4, r5, pc}
9001099e:	bf00      	nop
900109a0:	90015019 	.word	0x90015019
900109a4:	900155b8 	.word	0x900155b8
900109a8:	90012aff 	.word	0x90012aff

900109ac <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
900109ac:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
900109b0:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
900109b4:	4606      	mov	r6, r0
900109b6:	460f      	mov	r7, r1
900109b8:	4614      	mov	r4, r2
900109ba:	f8bd 9034 	ldrh.w	r9, [sp, #52]	; 0x34
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
900109be:	461d      	mov	r5, r3
{
900109c0:	f8bd a038 	ldrh.w	sl, [sp, #56]	; 0x38
  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
900109c4:	b933      	cbnz	r3, 900109d4 <tcp_rst+0x28>
900109c6:	4b18      	ldr	r3, [pc, #96]	; (90010a28 <tcp_rst+0x7c>)
900109c8:	f240 72c4 	movw	r2, #1988	; 0x7c4
900109cc:	4917      	ldr	r1, [pc, #92]	; (90010a2c <tcp_rst+0x80>)
900109ce:	4818      	ldr	r0, [pc, #96]	; (90010a30 <tcp_rst+0x84>)
900109d0:	f001 f8ec 	bl	90011bac <iprintf>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
900109d4:	f1b8 0f00 	cmp.w	r8, #0
900109d8:	d106      	bne.n	900109e8 <tcp_rst+0x3c>
900109da:	4b13      	ldr	r3, [pc, #76]	; (90010a28 <tcp_rst+0x7c>)
900109dc:	f240 72c5 	movw	r2, #1989	; 0x7c5
900109e0:	4914      	ldr	r1, [pc, #80]	; (90010a34 <tcp_rst+0x88>)
900109e2:	4813      	ldr	r0, [pc, #76]	; (90010a30 <tcp_rst+0x84>)
900109e4:	f001 f8e2 	bl	90011bac <iprintf>
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
900109e8:	4638      	mov	r0, r7
900109ea:	f7f8 fbcc 	bl	90009186 <lwip_htonl>
900109ee:	2314      	movs	r3, #20
900109f0:	f246 0108 	movw	r1, #24584	; 0x6008
900109f4:	4602      	mov	r2, r0
900109f6:	f8cd a000 	str.w	sl, [sp]
900109fa:	4620      	mov	r0, r4
900109fc:	e9cd 3101 	strd	r3, r1, [sp, #4]
90010a00:	464b      	mov	r3, r9
90010a02:	2100      	movs	r1, #0
90010a04:	f7ff fa3c 	bl	9000fe80 <tcp_output_alloc_header_common.constprop.0>
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
90010a08:	4604      	mov	r4, r0
90010a0a:	b150      	cbz	r0, 90010a22 <tcp_rst+0x76>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
90010a0c:	f7ff faa0 	bl	9000ff50 <tcp_output_fill_options.constprop.0>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
90010a10:	4643      	mov	r3, r8
90010a12:	462a      	mov	r2, r5
90010a14:	4621      	mov	r1, r4
90010a16:	4630      	mov	r0, r6
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
90010a18:	b004      	add	sp, #16
90010a1a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
90010a1e:	f7ff baa7 	b.w	9000ff70 <tcp_output_control_segment>
}
90010a22:	b004      	add	sp, #16
90010a24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90010a28:	90015019 	.word	0x90015019
90010a2c:	900155d5 	.word	0x900155d5
90010a30:	90012aff 	.word	0x90012aff
90010a34:	900155ef 	.word	0x900155ef

90010a38 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
90010a38:	b538      	push	{r3, r4, r5, lr}
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
  u8_t num_sacks = 0;

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
90010a3a:	4604      	mov	r4, r0
90010a3c:	b930      	cbnz	r0, 90010a4c <tcp_send_empty_ack+0x14>
90010a3e:	4b14      	ldr	r3, [pc, #80]	; (90010a90 <tcp_send_empty_ack+0x58>)
90010a40:	f240 72ea 	movw	r2, #2026	; 0x7ea
90010a44:	4913      	ldr	r1, [pc, #76]	; (90010a94 <tcp_send_empty_ack+0x5c>)
90010a46:	4814      	ldr	r0, [pc, #80]	; (90010a98 <tcp_send_empty_ack+0x60>)
90010a48:	f001 f8b0 	bl	90011bac <iprintf>
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
90010a4c:	6d20      	ldr	r0, [r4, #80]	; 0x50
90010a4e:	f7f8 fb9a 	bl	90009186 <lwip_htonl>
90010a52:	2100      	movs	r1, #0
90010a54:	4602      	mov	r2, r0
90010a56:	4620      	mov	r0, r4
90010a58:	f7ff fa54 	bl	9000ff04 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
90010a5c:	4605      	mov	r5, r0
90010a5e:	b930      	cbnz	r0, 90010a6e <tcp_send_empty_ack+0x36>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
90010a60:	8b63      	ldrh	r3, [r4, #26]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
90010a62:	f06f 0001 	mvn.w	r0, #1
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
90010a66:	f043 0303 	orr.w	r3, r3, #3
90010a6a:	8363      	strh	r3, [r4, #26]
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}
90010a6c:	bd38      	pop	{r3, r4, r5, pc}
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
90010a6e:	f7ff fa6f 	bl	9000ff50 <tcp_output_fill_options.constprop.0>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
90010a72:	1d23      	adds	r3, r4, #4
90010a74:	4622      	mov	r2, r4
90010a76:	4629      	mov	r1, r5
90010a78:	4620      	mov	r0, r4
90010a7a:	f7ff fa79 	bl	9000ff70 <tcp_output_control_segment>
  if (err != ERR_OK) {
90010a7e:	8b63      	ldrh	r3, [r4, #26]
90010a80:	b118      	cbz	r0, 90010a8a <tcp_send_empty_ack+0x52>
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
90010a82:	f043 0303 	orr.w	r3, r3, #3
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
90010a86:	8363      	strh	r3, [r4, #26]
90010a88:	e7f0      	b.n	90010a6c <tcp_send_empty_ack+0x34>
90010a8a:	f023 0303 	bic.w	r3, r3, #3
90010a8e:	e7fa      	b.n	90010a86 <tcp_send_empty_ack+0x4e>
90010a90:	90015019 	.word	0x90015019
90010a94:	9001560a 	.word	0x9001560a
90010a98:	90012aff 	.word	0x90012aff

90010a9c <tcp_output>:
{
90010a9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
90010aa0:	4604      	mov	r4, r0
{
90010aa2:	b087      	sub	sp, #28
  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
90010aa4:	b930      	cbnz	r0, 90010ab4 <tcp_output+0x18>
90010aa6:	4b8f      	ldr	r3, [pc, #572]	; (90010ce4 <tcp_output+0x248>)
90010aa8:	f240 42e1 	movw	r2, #1249	; 0x4e1
90010aac:	498e      	ldr	r1, [pc, #568]	; (90010ce8 <tcp_output+0x24c>)
90010aae:	488f      	ldr	r0, [pc, #572]	; (90010cec <tcp_output+0x250>)
90010ab0:	f001 f87c 	bl	90011bac <iprintf>
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
90010ab4:	7d23      	ldrb	r3, [r4, #20]
90010ab6:	2b01      	cmp	r3, #1
90010ab8:	d106      	bne.n	90010ac8 <tcp_output+0x2c>
90010aba:	4b8a      	ldr	r3, [pc, #552]	; (90010ce4 <tcp_output+0x248>)
90010abc:	f240 42e3 	movw	r2, #1251	; 0x4e3
90010ac0:	498b      	ldr	r1, [pc, #556]	; (90010cf0 <tcp_output+0x254>)
90010ac2:	488a      	ldr	r0, [pc, #552]	; (90010cec <tcp_output+0x250>)
90010ac4:	f001 f872 	bl	90011bac <iprintf>
  if (tcp_input_pcb == pcb) {
90010ac8:	4b8a      	ldr	r3, [pc, #552]	; (90010cf4 <tcp_output+0x258>)
90010aca:	681b      	ldr	r3, [r3, #0]
90010acc:	42a3      	cmp	r3, r4
90010ace:	f000 8171 	beq.w	90010db4 <tcp_output+0x318>
  seg = pcb->unsent;
90010ad2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  if (seg == NULL) {
90010ad4:	b94d      	cbnz	r5, 90010aea <tcp_output+0x4e>
    if (pcb->flags & TF_ACK_NOW) {
90010ad6:	8b63      	ldrh	r3, [r4, #26]
90010ad8:	0798      	lsls	r0, r3, #30
90010ada:	f140 8167 	bpl.w	90010dac <tcp_output+0x310>
      return tcp_send_empty_ack(pcb);
90010ade:	4620      	mov	r0, r4
}
90010ae0:	b007      	add	sp, #28
90010ae2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      return tcp_send_empty_ack(pcb);
90010ae6:	f7ff bfa7 	b.w	90010a38 <tcp_send_empty_ack>
  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
90010aea:	7a20      	ldrb	r0, [r4, #8]
  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
90010aec:	f104 0904 	add.w	r9, r4, #4
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
90010af0:	f8b4 8048 	ldrh.w	r8, [r4, #72]	; 0x48
90010af4:	f8b4 6060 	ldrh.w	r6, [r4, #96]	; 0x60
  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
90010af8:	b340      	cbz	r0, 90010b4c <tcp_output+0xb0>
    return netif_get_by_index(pcb->netif_idx);
90010afa:	f7fb fe01 	bl	9000c700 <netif_get_by_index>
    return ip_route(src, dst);
90010afe:	4607      	mov	r7, r0
  if (netif == NULL) {
90010b00:	2800      	cmp	r0, #0
90010b02:	f000 8170 	beq.w	90010de6 <tcp_output+0x34a>
  if (ip_addr_isany(&pcb->local_ip)) {
90010b06:	6823      	ldr	r3, [r4, #0]
90010b08:	b90b      	cbnz	r3, 90010b0e <tcp_output+0x72>
    ip_addr_copy(pcb->local_ip, *local_ip);
90010b0a:	6843      	ldr	r3, [r0, #4]
90010b0c:	6023      	str	r3, [r4, #0]
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
90010b0e:	68eb      	ldr	r3, [r5, #12]
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
90010b10:	45b0      	cmp	r8, r6
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
90010b12:	6858      	ldr	r0, [r3, #4]
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
90010b14:	bf28      	it	cs
90010b16:	46b0      	movcs	r8, r6
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
90010b18:	f7f8 fb35 	bl	90009186 <lwip_htonl>
90010b1c:	892b      	ldrh	r3, [r5, #8]
90010b1e:	6c62      	ldr	r2, [r4, #68]	; 0x44
90010b20:	1a9b      	subs	r3, r3, r2
90010b22:	4418      	add	r0, r3
90010b24:	4540      	cmp	r0, r8
90010b26:	d915      	bls.n	90010b54 <tcp_output+0xb8>
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
90010b28:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
90010b2c:	4543      	cmp	r3, r8
90010b2e:	d1d2      	bne.n	90010ad6 <tcp_output+0x3a>
90010b30:	6f23      	ldr	r3, [r4, #112]	; 0x70
90010b32:	2b00      	cmp	r3, #0
90010b34:	d1cf      	bne.n	90010ad6 <tcp_output+0x3a>
90010b36:	f894 3099 	ldrb.w	r3, [r4, #153]	; 0x99
90010b3a:	2b00      	cmp	r3, #0
90010b3c:	d1cb      	bne.n	90010ad6 <tcp_output+0x3a>
      pcb->persist_cnt = 0;
90010b3e:	f44f 7280 	mov.w	r2, #256	; 0x100
      pcb->persist_probe = 0;
90010b42:	f884 309a 	strb.w	r3, [r4, #154]	; 0x9a
      pcb->persist_cnt = 0;
90010b46:	f8a4 2098 	strh.w	r2, [r4, #152]	; 0x98
90010b4a:	e7c4      	b.n	90010ad6 <tcp_output+0x3a>
    return ip_route(src, dst);
90010b4c:	4648      	mov	r0, r9
90010b4e:	f7fa fb9d 	bl	9000b28c <ip4_route>
90010b52:	e7d4      	b.n	90010afe <tcp_output+0x62>
  pcb->persist_backoff = 0;
90010b54:	2300      	movs	r3, #0
  useg = pcb->unacked;
90010b56:	6f26      	ldr	r6, [r4, #112]	; 0x70
  pcb->persist_backoff = 0;
90010b58:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
  if (useg != NULL) {
90010b5c:	b126      	cbz	r6, 90010b68 <tcp_output+0xcc>
    for (; useg->next != NULL; useg = useg->next);
90010b5e:	4633      	mov	r3, r6
90010b60:	6836      	ldr	r6, [r6, #0]
90010b62:	2e00      	cmp	r6, #0
90010b64:	d1fb      	bne.n	90010b5e <tcp_output+0xc2>
90010b66:	461e      	mov	r6, r3
    LWIP_ASSERT("RST not expected here!",
90010b68:	f8df a178 	ldr.w	sl, [pc, #376]	; 90010ce4 <tcp_output+0x248>
90010b6c:	f8df b17c 	ldr.w	fp, [pc, #380]	; 90010cec <tcp_output+0x250>
90010b70:	e0de      	b.n	90010d30 <tcp_output+0x294>
    if (pcb->state != SYN_SENT) {
90010b72:	7d23      	ldrb	r3, [r4, #20]
90010b74:	2b02      	cmp	r3, #2
90010b76:	d009      	beq.n	90010b8c <tcp_output+0xf0>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
90010b78:	68eb      	ldr	r3, [r5, #12]
90010b7a:	2010      	movs	r0, #16
90010b7c:	899b      	ldrh	r3, [r3, #12]
90010b7e:	9304      	str	r3, [sp, #16]
90010b80:	f7f8 fafe 	bl	90009180 <lwip_htons>
90010b84:	9b04      	ldr	r3, [sp, #16]
90010b86:	68ea      	ldr	r2, [r5, #12]
90010b88:	4318      	orrs	r0, r3
90010b8a:	8190      	strh	r0, [r2, #12]
  if (tcp_output_segment_busy(seg)) {
90010b8c:	4628      	mov	r0, r5
90010b8e:	f7ff f8a3 	bl	9000fcd8 <tcp_output_segment_busy>
90010b92:	2800      	cmp	r0, #0
90010b94:	d16f      	bne.n	90010c76 <tcp_output+0x1da>
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
90010b96:	68eb      	ldr	r3, [r5, #12]
90010b98:	6a60      	ldr	r0, [r4, #36]	; 0x24
90010b9a:	9304      	str	r3, [sp, #16]
90010b9c:	f7f8 faf3 	bl	90009186 <lwip_htonl>
90010ba0:	9b04      	ldr	r3, [sp, #16]
90010ba2:	6098      	str	r0, [r3, #8]
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
90010ba4:	68eb      	ldr	r3, [r5, #12]
90010ba6:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
90010ba8:	9304      	str	r3, [sp, #16]
90010baa:	f7f8 fae9 	bl	90009180 <lwip_htons>
90010bae:	9b04      	ldr	r3, [sp, #16]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
90010bb0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
90010bb2:	81d8      	strh	r0, [r3, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
90010bb4:	6a63      	ldr	r3, [r4, #36]	; 0x24
90010bb6:	4413      	add	r3, r2
90010bb8:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (seg->flags & TF_SEG_OPTS_MSS) {
90010bba:	7aaa      	ldrb	r2, [r5, #10]
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
90010bbc:	68eb      	ldr	r3, [r5, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
90010bbe:	07d2      	lsls	r2, r2, #31
90010bc0:	d449      	bmi.n	90010c56 <tcp_output+0x1ba>
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
90010bc2:	f103 0214 	add.w	r2, r3, #20
  if (pcb->rtime < 0) {
90010bc6:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
90010bca:	2b00      	cmp	r3, #0
    pcb->rtime = 0;
90010bcc:	bfbc      	itt	lt
90010bce:	2300      	movlt	r3, #0
90010bd0:	8623      	strhlt	r3, [r4, #48]	; 0x30
  if (pcb->rttest == 0) {
90010bd2:	6b63      	ldr	r3, [r4, #52]	; 0x34
90010bd4:	b94b      	cbnz	r3, 90010bea <tcp_output+0x14e>
    pcb->rttest = tcp_ticks;
90010bd6:	4948      	ldr	r1, [pc, #288]	; (90010cf8 <tcp_output+0x25c>)
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
90010bd8:	68eb      	ldr	r3, [r5, #12]
    pcb->rttest = tcp_ticks;
90010bda:	6809      	ldr	r1, [r1, #0]
90010bdc:	9204      	str	r2, [sp, #16]
90010bde:	6361      	str	r1, [r4, #52]	; 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
90010be0:	6858      	ldr	r0, [r3, #4]
90010be2:	f7f8 fad0 	bl	90009186 <lwip_htonl>
90010be6:	9a04      	ldr	r2, [sp, #16]
90010be8:	63a0      	str	r0, [r4, #56]	; 0x38
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
90010bea:	6869      	ldr	r1, [r5, #4]
90010bec:	68eb      	ldr	r3, [r5, #12]
90010bee:	6848      	ldr	r0, [r1, #4]
  seg->p->len -= len;
90010bf0:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
90010bf4:	1a18      	subs	r0, r3, r0
  seg->p->payload = seg->tcphdr;
90010bf6:	604b      	str	r3, [r1, #4]
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
90010bf8:	b280      	uxth	r0, r0
  seg->p->len -= len;
90010bfa:	ebac 0c00 	sub.w	ip, ip, r0
90010bfe:	f8a1 c00a 	strh.w	ip, [r1, #10]
  seg->p->tot_len -= len;
90010c02:	f8b1 c008 	ldrh.w	ip, [r1, #8]
90010c06:	ebac 0000 	sub.w	r0, ip, r0
90010c0a:	8108      	strh	r0, [r1, #8]
  seg->tcphdr->chksum = 0;
90010c0c:	2100      	movs	r1, #0
90010c0e:	7419      	strb	r1, [r3, #16]
90010c10:	7459      	strb	r1, [r3, #17]
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
90010c12:	7aa9      	ldrb	r1, [r5, #10]
90010c14:	0089      	lsls	r1, r1, #2
90010c16:	f001 0104 	and.w	r1, r1, #4
90010c1a:	3114      	adds	r1, #20
90010c1c:	440b      	add	r3, r1
90010c1e:	429a      	cmp	r2, r3
90010c20:	d006      	beq.n	90010c30 <tcp_output+0x194>
90010c22:	4653      	mov	r3, sl
90010c24:	f240 621c 	movw	r2, #1564	; 0x61c
90010c28:	4934      	ldr	r1, [pc, #208]	; (90010cfc <tcp_output+0x260>)
90010c2a:	4658      	mov	r0, fp
90010c2c:	f000 ffbe 	bl	90011bac <iprintf>
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
90010c30:	2306      	movs	r3, #6
90010c32:	9702      	str	r7, [sp, #8]
90010c34:	464a      	mov	r2, r9
90010c36:	4621      	mov	r1, r4
90010c38:	9301      	str	r3, [sp, #4]
90010c3a:	7aa3      	ldrb	r3, [r4, #10]
90010c3c:	9300      	str	r3, [sp, #0]
90010c3e:	7ae3      	ldrb	r3, [r4, #11]
90010c40:	6868      	ldr	r0, [r5, #4]
90010c42:	f7fa fc9b 	bl	9000b57c <ip4_output_if>
    if (err != ERR_OK) {
90010c46:	b1b0      	cbz	r0, 90010c76 <tcp_output+0x1da>
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
90010c48:	8b63      	ldrh	r3, [r4, #26]
90010c4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90010c4e:	8363      	strh	r3, [r4, #26]
}
90010c50:	b007      	add	sp, #28
90010c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
90010c56:	464a      	mov	r2, r9
90010c58:	4639      	mov	r1, r7
90010c5a:	f44f 7006 	mov.w	r0, #536	; 0x218
90010c5e:	9304      	str	r3, [sp, #16]
90010c60:	f7fc feb0 	bl	9000d9c4 <tcp_eff_send_mss_netif>
    *opts = TCP_BUILD_MSS_OPTION(mss);
90010c64:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
90010c68:	f7f8 fa8d 	bl	90009186 <lwip_htonl>
90010c6c:	9b04      	ldr	r3, [sp, #16]
    opts += 1;
90010c6e:	f103 0218 	add.w	r2, r3, #24
    *opts = TCP_BUILD_MSS_OPTION(mss);
90010c72:	6158      	str	r0, [r3, #20]
    opts += 1;
90010c74:	e7a7      	b.n	90010bc6 <tcp_output+0x12a>
    pcb->unsent = seg->next;
90010c76:	682b      	ldr	r3, [r5, #0]
90010c78:	66e3      	str	r3, [r4, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
90010c7a:	7d23      	ldrb	r3, [r4, #20]
90010c7c:	2b02      	cmp	r3, #2
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
90010c7e:	bf1e      	ittt	ne
90010c80:	8b63      	ldrhne	r3, [r4, #26]
90010c82:	f023 0303 	bicne.w	r3, r3, #3
90010c86:	8363      	strhne	r3, [r4, #26]
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
90010c88:	68eb      	ldr	r3, [r5, #12]
90010c8a:	6858      	ldr	r0, [r3, #4]
90010c8c:	f7f8 fa7b 	bl	90009186 <lwip_htonl>
90010c90:	8929      	ldrh	r1, [r5, #8]
90010c92:	68eb      	ldr	r3, [r5, #12]
90010c94:	9104      	str	r1, [sp, #16]
90010c96:	9005      	str	r0, [sp, #20]
90010c98:	8998      	ldrh	r0, [r3, #12]
90010c9a:	f7f8 fa71 	bl	90009180 <lwip_htons>
90010c9e:	f010 0303 	ands.w	r3, r0, #3
90010ca2:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
90010ca6:	bf18      	it	ne
90010ca8:	2301      	movne	r3, #1
90010caa:	440a      	add	r2, r1
90010cac:	4413      	add	r3, r2
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
90010cae:	6d22      	ldr	r2, [r4, #80]	; 0x50
90010cb0:	1ad2      	subs	r2, r2, r3
90010cb2:	2a00      	cmp	r2, #0
    if (TCP_TCPLEN(seg) > 0) {
90010cb4:	68ea      	ldr	r2, [r5, #12]
      pcb->snd_nxt = snd_nxt;
90010cb6:	bfb8      	it	lt
90010cb8:	6523      	strlt	r3, [r4, #80]	; 0x50
    if (TCP_TCPLEN(seg) > 0) {
90010cba:	892b      	ldrh	r3, [r5, #8]
90010cbc:	9304      	str	r3, [sp, #16]
90010cbe:	8990      	ldrh	r0, [r2, #12]
90010cc0:	f7f8 fa5e 	bl	90009180 <lwip_htons>
90010cc4:	f010 0003 	ands.w	r0, r0, #3
90010cc8:	9b04      	ldr	r3, [sp, #16]
90010cca:	bf18      	it	ne
90010ccc:	2001      	movne	r0, #1
90010cce:	42d8      	cmn	r0, r3
90010cd0:	f000 8085 	beq.w	90010dde <tcp_output+0x342>
      seg->next = NULL;
90010cd4:	2300      	movs	r3, #0
90010cd6:	602b      	str	r3, [r5, #0]
      if (pcb->unacked == NULL) {
90010cd8:	6f23      	ldr	r3, [r4, #112]	; 0x70
90010cda:	b98b      	cbnz	r3, 90010d00 <tcp_output+0x264>
        pcb->unacked = seg;
90010cdc:	6725      	str	r5, [r4, #112]	; 0x70
          useg->next = seg;
90010cde:	462e      	mov	r6, r5
90010ce0:	e023      	b.n	90010d2a <tcp_output+0x28e>
90010ce2:	bf00      	nop
90010ce4:	90015019 	.word	0x90015019
90010ce8:	9001562a 	.word	0x9001562a
90010cec:	90012aff 	.word	0x90012aff
90010cf0:	90015642 	.word	0x90015642
90010cf4:	2400d3f4 	.word	0x2400d3f4
90010cf8:	2400d3c0 	.word	0x2400d3c0
90010cfc:	9001567f 	.word	0x9001567f
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
90010d00:	68eb      	ldr	r3, [r5, #12]
90010d02:	6858      	ldr	r0, [r3, #4]
90010d04:	f7f8 fa3f 	bl	90009186 <lwip_htonl>
90010d08:	68f2      	ldr	r2, [r6, #12]
90010d0a:	9004      	str	r0, [sp, #16]
90010d0c:	6850      	ldr	r0, [r2, #4]
90010d0e:	f7f8 fa3a 	bl	90009186 <lwip_htonl>
90010d12:	9b04      	ldr	r3, [sp, #16]
90010d14:	1a18      	subs	r0, r3, r0
90010d16:	2800      	cmp	r0, #0
90010d18:	da5f      	bge.n	90010dda <tcp_output+0x33e>
          struct tcp_seg **cur_seg = &(pcb->unacked);
90010d1a:	f104 0370 	add.w	r3, r4, #112	; 0x70
          while (*cur_seg &&
90010d1e:	681a      	ldr	r2, [r3, #0]
90010d20:	2a00      	cmp	r2, #0
90010d22:	d149      	bne.n	90010db8 <tcp_output+0x31c>
          seg->next = (*cur_seg);
90010d24:	681a      	ldr	r2, [r3, #0]
90010d26:	602a      	str	r2, [r5, #0]
          (*cur_seg) = seg;
90010d28:	601d      	str	r5, [r3, #0]
    seg = pcb->unsent;
90010d2a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  while (seg != NULL &&
90010d2c:	2d00      	cmp	r5, #0
90010d2e:	d03a      	beq.n	90010da6 <tcp_output+0x30a>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
90010d30:	68eb      	ldr	r3, [r5, #12]
90010d32:	6858      	ldr	r0, [r3, #4]
90010d34:	f7f8 fa27 	bl	90009186 <lwip_htonl>
90010d38:	6c63      	ldr	r3, [r4, #68]	; 0x44
90010d3a:	1ac0      	subs	r0, r0, r3
90010d3c:	892b      	ldrh	r3, [r5, #8]
90010d3e:	4418      	add	r0, r3
  while (seg != NULL &&
90010d40:	4540      	cmp	r0, r8
90010d42:	d82e      	bhi.n	90010da2 <tcp_output+0x306>
    LWIP_ASSERT("RST not expected here!",
90010d44:	68eb      	ldr	r3, [r5, #12]
90010d46:	8998      	ldrh	r0, [r3, #12]
90010d48:	f7f8 fa1a 	bl	90009180 <lwip_htons>
90010d4c:	0741      	lsls	r1, r0, #29
90010d4e:	d506      	bpl.n	90010d5e <tcp_output+0x2c2>
90010d50:	4653      	mov	r3, sl
90010d52:	f240 5236 	movw	r2, #1334	; 0x536
90010d56:	4925      	ldr	r1, [pc, #148]	; (90010dec <tcp_output+0x350>)
90010d58:	4658      	mov	r0, fp
90010d5a:	f000 ff27 	bl	90011bac <iprintf>
    if ((tcp_do_output_nagle(pcb) == 0) &&
90010d5e:	6f23      	ldr	r3, [r4, #112]	; 0x70
90010d60:	2b00      	cmp	r3, #0
90010d62:	f43f af06 	beq.w	90010b72 <tcp_output+0xd6>
90010d66:	8b62      	ldrh	r2, [r4, #26]
90010d68:	f012 0f44 	tst.w	r2, #68	; 0x44
90010d6c:	f47f af01 	bne.w	90010b72 <tcp_output+0xd6>
90010d70:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
90010d72:	b143      	cbz	r3, 90010d86 <tcp_output+0x2ea>
90010d74:	6819      	ldr	r1, [r3, #0]
90010d76:	2900      	cmp	r1, #0
90010d78:	f47f aefb 	bne.w	90010b72 <tcp_output+0xd6>
90010d7c:	8919      	ldrh	r1, [r3, #8]
90010d7e:	8e63      	ldrh	r3, [r4, #50]	; 0x32
90010d80:	4299      	cmp	r1, r3
90010d82:	f4bf aef6 	bcs.w	90010b72 <tcp_output+0xd6>
90010d86:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
90010d8a:	2b00      	cmp	r3, #0
90010d8c:	f43f aef1 	beq.w	90010b72 <tcp_output+0xd6>
90010d90:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
90010d94:	2b08      	cmp	r3, #8
90010d96:	f63f aeec 	bhi.w	90010b72 <tcp_output+0xd6>
90010d9a:	f012 0fa0 	tst.w	r2, #160	; 0xa0
90010d9e:	f47f aee8 	bne.w	90010b72 <tcp_output+0xd6>
  if (pcb->unsent == NULL) {
90010da2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
90010da4:	b913      	cbnz	r3, 90010dac <tcp_output+0x310>
    pcb->unsent_oversize = 0;
90010da6:	2300      	movs	r3, #0
90010da8:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
90010dac:	8b63      	ldrh	r3, [r4, #26]
90010dae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
90010db2:	8363      	strh	r3, [r4, #26]
    return ERR_OK;
90010db4:	2000      	movs	r0, #0
90010db6:	e74b      	b.n	90010c50 <tcp_output+0x1b4>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
90010db8:	68d2      	ldr	r2, [r2, #12]
90010dba:	9305      	str	r3, [sp, #20]
90010dbc:	6850      	ldr	r0, [r2, #4]
90010dbe:	f7f8 f9e2 	bl	90009186 <lwip_htonl>
90010dc2:	68e9      	ldr	r1, [r5, #12]
90010dc4:	9004      	str	r0, [sp, #16]
90010dc6:	6848      	ldr	r0, [r1, #4]
90010dc8:	f7f8 f9dd 	bl	90009186 <lwip_htonl>
90010dcc:	9a04      	ldr	r2, [sp, #16]
          while (*cur_seg &&
90010dce:	9b05      	ldr	r3, [sp, #20]
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
90010dd0:	1a10      	subs	r0, r2, r0
          while (*cur_seg &&
90010dd2:	2800      	cmp	r0, #0
90010dd4:	daa6      	bge.n	90010d24 <tcp_output+0x288>
            cur_seg = &((*cur_seg)->next );
90010dd6:	681b      	ldr	r3, [r3, #0]
90010dd8:	e7a1      	b.n	90010d1e <tcp_output+0x282>
          useg->next = seg;
90010dda:	6035      	str	r5, [r6, #0]
90010ddc:	e77f      	b.n	90010cde <tcp_output+0x242>
      tcp_seg_free(seg);
90010dde:	4628      	mov	r0, r5
90010de0:	f7fc fd26 	bl	9000d830 <tcp_seg_free>
90010de4:	e7a1      	b.n	90010d2a <tcp_output+0x28e>
    return ERR_RTE;
90010de6:	f06f 0003 	mvn.w	r0, #3
90010dea:	e731      	b.n	90010c50 <tcp_output+0x1b4>
90010dec:	90015668 	.word	0x90015668

90010df0 <tcp_rexmit_rto_commit>:
{
90010df0:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
90010df2:	4604      	mov	r4, r0
90010df4:	b930      	cbnz	r0, 90010e04 <tcp_rexmit_rto_commit+0x14>
90010df6:	4b09      	ldr	r3, [pc, #36]	; (90010e1c <tcp_rexmit_rto_commit+0x2c>)
90010df8:	f44f 62d3 	mov.w	r2, #1688	; 0x698
90010dfc:	4908      	ldr	r1, [pc, #32]	; (90010e20 <tcp_rexmit_rto_commit+0x30>)
90010dfe:	4809      	ldr	r0, [pc, #36]	; (90010e24 <tcp_rexmit_rto_commit+0x34>)
90010e00:	f000 fed4 	bl	90011bac <iprintf>
  if (pcb->nrtx < 0xFF) {
90010e04:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  tcp_output(pcb);
90010e08:	4620      	mov	r0, r4
  if (pcb->nrtx < 0xFF) {
90010e0a:	2bff      	cmp	r3, #255	; 0xff
    ++pcb->nrtx;
90010e0c:	bf1c      	itt	ne
90010e0e:	3301      	addne	r3, #1
90010e10:	f884 3042 	strbne.w	r3, [r4, #66]	; 0x42
}
90010e14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  tcp_output(pcb);
90010e18:	f7ff be40 	b.w	90010a9c <tcp_output>
90010e1c:	90015019 	.word	0x90015019
90010e20:	90015692 	.word	0x90015692
90010e24:	90012aff 	.word	0x90012aff

90010e28 <tcp_rexmit_rto>:
{
90010e28:	b510      	push	{r4, lr}
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
90010e2a:	4604      	mov	r4, r0
90010e2c:	b930      	cbnz	r0, 90010e3c <tcp_rexmit_rto+0x14>
90010e2e:	4b08      	ldr	r3, [pc, #32]	; (90010e50 <tcp_rexmit_rto+0x28>)
90010e30:	f240 62ad 	movw	r2, #1709	; 0x6ad
90010e34:	4907      	ldr	r1, [pc, #28]	; (90010e54 <tcp_rexmit_rto+0x2c>)
90010e36:	4808      	ldr	r0, [pc, #32]	; (90010e58 <tcp_rexmit_rto+0x30>)
90010e38:	f000 feb8 	bl	90011bac <iprintf>
  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
90010e3c:	4620      	mov	r0, r4
90010e3e:	f7ff fcfd 	bl	9001083c <tcp_rexmit_rto_prepare>
90010e42:	b920      	cbnz	r0, 90010e4e <tcp_rexmit_rto+0x26>
    tcp_rexmit_rto_commit(pcb);
90010e44:	4620      	mov	r0, r4
}
90010e46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tcp_rexmit_rto_commit(pcb);
90010e4a:	f7ff bfd1 	b.w	90010df0 <tcp_rexmit_rto_commit>
}
90010e4e:	bd10      	pop	{r4, pc}
90010e50:	90015019 	.word	0x90015019
90010e54:	900156b5 	.word	0x900156b5
90010e58:	90012aff 	.word	0x90012aff

90010e5c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
90010e5c:	b570      	push	{r4, r5, r6, lr}
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
90010e5e:	4604      	mov	r4, r0
90010e60:	b930      	cbnz	r0, 90010e70 <tcp_keepalive+0x14>
90010e62:	4b0f      	ldr	r3, [pc, #60]	; (90010ea0 <tcp_keepalive+0x44>)
90010e64:	f640 0224 	movw	r2, #2084	; 0x824
90010e68:	490e      	ldr	r1, [pc, #56]	; (90010ea4 <tcp_keepalive+0x48>)
90010e6a:	480f      	ldr	r0, [pc, #60]	; (90010ea8 <tcp_keepalive+0x4c>)
90010e6c:	f000 fe9e 	bl	90011bac <iprintf>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
90010e70:	6d20      	ldr	r0, [r4, #80]	; 0x50
90010e72:	3801      	subs	r0, #1
90010e74:	f7f8 f987 	bl	90009186 <lwip_htonl>
90010e78:	2100      	movs	r1, #0
90010e7a:	4602      	mov	r2, r0
90010e7c:	4620      	mov	r0, r4
90010e7e:	f7ff f841 	bl	9000ff04 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
90010e82:	4605      	mov	r5, r0
90010e84:	b148      	cbz	r0, 90010e9a <tcp_keepalive+0x3e>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
90010e86:	f7ff f863 	bl	9000ff50 <tcp_output_fill_options.constprop.0>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
90010e8a:	1d23      	adds	r3, r4, #4
90010e8c:	4622      	mov	r2, r4
90010e8e:	4629      	mov	r1, r5
90010e90:	4620      	mov	r0, r4

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
90010e92:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
90010e96:	f7ff b86b 	b.w	9000ff70 <tcp_output_control_segment>
}
90010e9a:	f04f 30ff 	mov.w	r0, #4294967295
90010e9e:	bd70      	pop	{r4, r5, r6, pc}
90010ea0:	90015019 	.word	0x90015019
90010ea4:	900156d1 	.word	0x900156d1
90010ea8:	90012aff 	.word	0x90012aff

90010eac <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
90010eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
90010eb0:	4606      	mov	r6, r0
90010eb2:	b930      	cbnz	r0, 90010ec2 <tcp_zero_window_probe+0x16>
90010eb4:	4b2c      	ldr	r3, [pc, #176]	; (90010f68 <tcp_zero_window_probe+0xbc>)
90010eb6:	f640 024f 	movw	r2, #2127	; 0x84f
90010eba:	492c      	ldr	r1, [pc, #176]	; (90010f6c <tcp_zero_window_probe+0xc0>)
90010ebc:	482c      	ldr	r0, [pc, #176]	; (90010f70 <tcp_zero_window_probe+0xc4>)
90010ebe:	f000 fe75 	bl	90011bac <iprintf>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
90010ec2:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
  if (seg == NULL) {
90010ec4:	2d00      	cmp	r5, #0
90010ec6:	d048      	beq.n	90010f5a <tcp_zero_window_probe+0xae>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
90010ec8:	f896 309a 	ldrb.w	r3, [r6, #154]	; 0x9a
90010ecc:	2bff      	cmp	r3, #255	; 0xff
    ++pcb->persist_probe;
90010ece:	bf1c      	itt	ne
90010ed0:	3301      	addne	r3, #1
90010ed2:	f886 309a 	strbne.w	r3, [r6, #154]	; 0x9a
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
90010ed6:	68eb      	ldr	r3, [r5, #12]
90010ed8:	8998      	ldrh	r0, [r3, #12]
90010eda:	f7f8 f951 	bl	90009180 <lwip_htons>
90010ede:	f010 0401 	ands.w	r4, r0, #1
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
90010ee2:	68eb      	ldr	r3, [r5, #12]
90010ee4:	4630      	mov	r0, r6
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
90010ee6:	bf18      	it	ne
90010ee8:	892c      	ldrhne	r4, [r5, #8]
  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
90010eea:	685a      	ldr	r2, [r3, #4]
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
90010eec:	bf1c      	itt	ne
90010eee:	fab4 f484 	clzne	r4, r4
90010ef2:	0964      	lsrne	r4, r4, #5
  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
90010ef4:	f084 0101 	eor.w	r1, r4, #1
90010ef8:	f7ff f804 	bl	9000ff04 <tcp_output_alloc_header.constprop.0>
  if (p == NULL) {
90010efc:	4607      	mov	r7, r0
90010efe:	b378      	cbz	r0, 90010f60 <tcp_zero_window_probe+0xb4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
90010f00:	f8d0 8004 	ldr.w	r8, [r0, #4]

  if (is_fin) {
90010f04:	b1f4      	cbz	r4, 90010f44 <tcp_zero_window_probe+0x98>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
90010f06:	f9b8 400c 	ldrsh.w	r4, [r8, #12]
90010f0a:	2011      	movs	r0, #17
90010f0c:	f7f8 f938 	bl	90009180 <lwip_htons>
90010f10:	f424 547c 	bic.w	r4, r4, #16128	; 0x3f00
90010f14:	4320      	orrs	r0, r4
90010f16:	f8a8 000c 	strh.w	r0, [r8, #12]
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
90010f1a:	68eb      	ldr	r3, [r5, #12]
90010f1c:	6858      	ldr	r0, [r3, #4]
90010f1e:	f7f8 f932 	bl	90009186 <lwip_htonl>
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
90010f22:	6d33      	ldr	r3, [r6, #80]	; 0x50
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
90010f24:	3001      	adds	r0, #1
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
90010f26:	1a1b      	subs	r3, r3, r0
90010f28:	2b00      	cmp	r3, #0
    pcb->snd_nxt = snd_nxt;
90010f2a:	bfb8      	it	lt
90010f2c:	6530      	strlt	r0, [r6, #80]	; 0x50
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
90010f2e:	4638      	mov	r0, r7
90010f30:	f7ff f80e 	bl	9000ff50 <tcp_output_fill_options.constprop.0>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
90010f34:	1d33      	adds	r3, r6, #4
90010f36:	4632      	mov	r2, r6
90010f38:	4639      	mov	r1, r7
90010f3a:	4630      	mov	r0, r6

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
90010f3c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
90010f40:	f7ff b816 	b.w	9000ff70 <tcp_output_control_segment>
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
90010f44:	6868      	ldr	r0, [r5, #4]
90010f46:	f108 0114 	add.w	r1, r8, #20
90010f4a:	892a      	ldrh	r2, [r5, #8]
90010f4c:	8903      	ldrh	r3, [r0, #8]
90010f4e:	1a9b      	subs	r3, r3, r2
90010f50:	2201      	movs	r2, #1
90010f52:	b29b      	uxth	r3, r3
90010f54:	f7fc f8e0 	bl	9000d118 <pbuf_copy_partial>
90010f58:	e7df      	b.n	90010f1a <tcp_zero_window_probe+0x6e>
    return ERR_OK;
90010f5a:	4628      	mov	r0, r5
}
90010f5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return ERR_MEM;
90010f60:	f04f 30ff 	mov.w	r0, #4294967295
90010f64:	e7fa      	b.n	90010f5c <tcp_zero_window_probe+0xb0>
90010f66:	bf00      	nop
90010f68:	90015019 	.word	0x90015019
90010f6c:	900156ec 	.word	0x900156ec
90010f70:	90012aff 	.word	0x90012aff

90010f74 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
90010f74:	b583      	push	{r0, r1, r7, lr}
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  LWIP_MARK_TCPIP_THREAD();

  LOCK_TCPIP_CORE();
90010f76:	482c      	ldr	r0, [pc, #176]	; (90011028 <tcpip_thread+0xb4>)
90010f78:	f7fc fa77 	bl	9000d46a <sys_mutex_lock>
  if (tcpip_init_done != NULL) {
90010f7c:	4b2b      	ldr	r3, [pc, #172]	; (9001102c <tcpip_thread+0xb8>)
90010f7e:	681b      	ldr	r3, [r3, #0]
90010f80:	b113      	cbz	r3, 90010f88 <tcpip_thread+0x14>
    tcpip_init_done(tcpip_init_done_arg);
90010f82:	4a2b      	ldr	r2, [pc, #172]	; (90011030 <tcpip_thread+0xbc>)
90010f84:	6810      	ldr	r0, [r2, #0]
90010f86:	4798      	blx	r3
  UNLOCK_TCPIP_CORE();
90010f88:	4d27      	ldr	r5, [pc, #156]	; (90011028 <tcpip_thread+0xb4>)
  res = sys_arch_mbox_fetch(mbox, msg, sleeptime);
90010f8a:	4f2a      	ldr	r7, [pc, #168]	; (90011034 <tcpip_thread+0xc0>)
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
90010f8c:	4e2a      	ldr	r6, [pc, #168]	; (90011038 <tcpip_thread+0xc4>)
  sleeptime = sys_timeouts_sleeptime();
90010f8e:	f000 f9d3 	bl	90011338 <sys_timeouts_sleeptime>
  if (sleeptime == SYS_TIMEOUTS_SLEEPTIME_INFINITE) {
90010f92:	1c43      	adds	r3, r0, #1
  sleeptime = sys_timeouts_sleeptime();
90010f94:	4604      	mov	r4, r0
  if (sleeptime == SYS_TIMEOUTS_SLEEPTIME_INFINITE) {
90010f96:	d113      	bne.n	90010fc0 <tcpip_thread+0x4c>
    UNLOCK_TCPIP_CORE();
90010f98:	4628      	mov	r0, r5
90010f9a:	f7fc fa6b 	bl	9000d474 <sys_mutex_unlock>
    sys_arch_mbox_fetch(mbox, msg, 0);
90010f9e:	2200      	movs	r2, #0
90010fa0:	a901      	add	r1, sp, #4
90010fa2:	4638      	mov	r0, r7
90010fa4:	f7fc fa28 	bl	9000d3f8 <sys_arch_mbox_fetch>
    LOCK_TCPIP_CORE();
90010fa8:	4628      	mov	r0, r5
90010faa:	f7fc fa5e 	bl	9000d46a <sys_mutex_lock>
    if (msg == NULL) {
90010fae:	9c01      	ldr	r4, [sp, #4]
90010fb0:	b9cc      	cbnz	r4, 90010fe6 <tcpip_thread+0x72>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
90010fb2:	4633      	mov	r3, r6
90010fb4:	2291      	movs	r2, #145	; 0x91
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
90010fb6:	4921      	ldr	r1, [pc, #132]	; (9001103c <tcpip_thread+0xc8>)
90010fb8:	4821      	ldr	r0, [pc, #132]	; (90011040 <tcpip_thread+0xcc>)
90010fba:	f000 fdf7 	bl	90011bac <iprintf>
      break;
90010fbe:	e7e6      	b.n	90010f8e <tcpip_thread+0x1a>
  } else if (sleeptime == 0) {
90010fc0:	b910      	cbnz	r0, 90010fc8 <tcpip_thread+0x54>
    sys_check_timeouts();
90010fc2:	f000 f997 	bl	900112f4 <sys_check_timeouts>
    goto again;
90010fc6:	e7e2      	b.n	90010f8e <tcpip_thread+0x1a>
  UNLOCK_TCPIP_CORE();
90010fc8:	4628      	mov	r0, r5
90010fca:	f7fc fa53 	bl	9000d474 <sys_mutex_unlock>
  res = sys_arch_mbox_fetch(mbox, msg, sleeptime);
90010fce:	4622      	mov	r2, r4
90010fd0:	a901      	add	r1, sp, #4
90010fd2:	4638      	mov	r0, r7
90010fd4:	f7fc fa10 	bl	9000d3f8 <sys_arch_mbox_fetch>
90010fd8:	4604      	mov	r4, r0
  LOCK_TCPIP_CORE();
90010fda:	4628      	mov	r0, r5
90010fdc:	f7fc fa45 	bl	9000d46a <sys_mutex_lock>
  if (res == SYS_ARCH_TIMEOUT) {
90010fe0:	3401      	adds	r4, #1
90010fe2:	d0ee      	beq.n	90010fc2 <tcpip_thread+0x4e>
90010fe4:	e7e3      	b.n	90010fae <tcpip_thread+0x3a>
  switch (msg->type) {
90010fe6:	7823      	ldrb	r3, [r4, #0]
90010fe8:	2b01      	cmp	r3, #1
90010fea:	d00f      	beq.n	9001100c <tcpip_thread+0x98>
90010fec:	2b02      	cmp	r3, #2
90010fee:	d013      	beq.n	90011018 <tcpip_thread+0xa4>
90010ff0:	b9b3      	cbnz	r3, 90011020 <tcpip_thread+0xac>
      if (msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif) != ERR_OK) {
90010ff2:	6860      	ldr	r0, [r4, #4]
90010ff4:	e9d4 1302 	ldrd	r1, r3, [r4, #8]
90010ff8:	4798      	blx	r3
90010ffa:	b110      	cbz	r0, 90011002 <tcpip_thread+0x8e>
        pbuf_free(msg->msg.inp.p);
90010ffc:	6860      	ldr	r0, [r4, #4]
90010ffe:	f7fb fe4f 	bl	9000cca0 <pbuf_free>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
90011002:	4621      	mov	r1, r4
90011004:	2009      	movs	r0, #9
      memp_free(MEMP_TCPIP_MSG_API, msg);
90011006:	f7fb fa31 	bl	9000c46c <memp_free>
      break;
9001100a:	e7c0      	b.n	90010f8e <tcpip_thread+0x1a>
      msg->msg.cb.function(msg->msg.cb.ctx);
9001100c:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
90011010:	4798      	blx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
90011012:	4621      	mov	r1, r4
90011014:	2008      	movs	r0, #8
90011016:	e7f6      	b.n	90011006 <tcpip_thread+0x92>
      msg->msg.cb.function(msg->msg.cb.ctx);
90011018:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
9001101c:	4798      	blx	r3
      break;
9001101e:	e7b6      	b.n	90010f8e <tcpip_thread+0x1a>
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
90011020:	4633      	mov	r3, r6
90011022:	22cf      	movs	r2, #207	; 0xcf
90011024:	e7c7      	b.n	90010fb6 <tcpip_thread+0x42>
90011026:	bf00      	nop
90011028:	2400d40c 	.word	0x2400d40c
9001102c:	2400d410 	.word	0x2400d410
90011030:	2400d414 	.word	0x2400d414
90011034:	2400d418 	.word	0x2400d418
90011038:	9001570f 	.word	0x9001570f
9001103c:	90015746 	.word	0x90015746
90011040:	90012aff 	.word	0x90012aff

90011044 <tcpip_inpkt>:
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
90011044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90011046:	4607      	mov	r7, r0
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
90011048:	4810      	ldr	r0, [pc, #64]	; (9001108c <tcpip_inpkt+0x48>)
{
9001104a:	460e      	mov	r6, r1
9001104c:	4615      	mov	r5, r2
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
9001104e:	f7fc f9f1 	bl	9000d434 <sys_mbox_valid>
90011052:	b928      	cbnz	r0, 90011060 <tcpip_inpkt+0x1c>
90011054:	4b0e      	ldr	r3, [pc, #56]	; (90011090 <tcpip_inpkt+0x4c>)
90011056:	22fc      	movs	r2, #252	; 0xfc
90011058:	490e      	ldr	r1, [pc, #56]	; (90011094 <tcpip_inpkt+0x50>)
9001105a:	480f      	ldr	r0, [pc, #60]	; (90011098 <tcpip_inpkt+0x54>)
9001105c:	f000 fda6 	bl	90011bac <iprintf>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
90011060:	2009      	movs	r0, #9
90011062:	f7fb f9d3 	bl	9000c40c <memp_malloc>
  if (msg == NULL) {
90011066:	4604      	mov	r4, r0
90011068:	b168      	cbz	r0, 90011086 <tcpip_inpkt+0x42>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
9001106a:	2300      	movs	r3, #0
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  msg->msg.inp.input_fn = input_fn;
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
9001106c:	4601      	mov	r1, r0
  msg->msg.inp.input_fn = input_fn;
9001106e:	60c5      	str	r5, [r0, #12]
  msg->type = TCPIP_MSG_INPKT;
90011070:	7003      	strb	r3, [r0, #0]
  msg->msg.inp.netif = inp;
90011072:	e9c0 7601 	strd	r7, r6, [r0, #4]
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
90011076:	4805      	ldr	r0, [pc, #20]	; (9001108c <tcpip_inpkt+0x48>)
90011078:	f7fc f9af 	bl	9000d3da <sys_mbox_trypost>
9001107c:	b128      	cbz	r0, 9001108a <tcpip_inpkt+0x46>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
9001107e:	4621      	mov	r1, r4
90011080:	2009      	movs	r0, #9
90011082:	f7fb f9f3 	bl	9000c46c <memp_free>
    return ERR_MEM;
90011086:	f04f 30ff 	mov.w	r0, #4294967295
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
9001108a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9001108c:	2400d418 	.word	0x2400d418
90011090:	9001570f 	.word	0x9001570f
90011094:	90015764 	.word	0x90015764
90011098:	90012aff 	.word	0x90012aff

9001109c <tcpip_input>:
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
9001109c:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
900110a0:	f013 0f18 	tst.w	r3, #24
    return tcpip_inpkt(p, inp, ethernet_input);
900110a4:	bf14      	ite	ne
900110a6:	4a02      	ldrne	r2, [pc, #8]	; (900110b0 <tcpip_input+0x14>)
  } else
#endif /* LWIP_ETHERNET */
    return tcpip_inpkt(p, inp, ip_input);
900110a8:	4a02      	ldreq	r2, [pc, #8]	; (900110b4 <tcpip_input+0x18>)
900110aa:	f7ff bfcb 	b.w	90011044 <tcpip_inpkt>
900110ae:	bf00      	nop
900110b0:	9000ae79 	.word	0x9000ae79
900110b4:	9000b2e9 	.word	0x9000b2e9

900110b8 <tcpip_try_callback>:
 *
 * @see tcpip_callback
 */
err_t
tcpip_try_callback(tcpip_callback_fn function, void *ctx)
{
900110b8:	b570      	push	{r4, r5, r6, lr}
900110ba:	4606      	mov	r6, r0
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
900110bc:	4810      	ldr	r0, [pc, #64]	; (90011100 <tcpip_try_callback+0x48>)
{
900110be:	460d      	mov	r5, r1
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
900110c0:	f7fc f9b8 	bl	9000d434 <sys_mbox_valid>
900110c4:	b930      	cbnz	r0, 900110d4 <tcpip_try_callback+0x1c>
900110c6:	4b0f      	ldr	r3, [pc, #60]	; (90011104 <tcpip_try_callback+0x4c>)
900110c8:	f240 125d 	movw	r2, #349	; 0x15d
900110cc:	490e      	ldr	r1, [pc, #56]	; (90011108 <tcpip_try_callback+0x50>)
900110ce:	480f      	ldr	r0, [pc, #60]	; (9001110c <tcpip_try_callback+0x54>)
900110d0:	f000 fd6c 	bl	90011bac <iprintf>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
900110d4:	2008      	movs	r0, #8
900110d6:	f7fb f999 	bl	9000c40c <memp_malloc>
  if (msg == NULL) {
900110da:	4604      	mov	r4, r0
900110dc:	b160      	cbz	r0, 900110f8 <tcpip_try_callback+0x40>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_CALLBACK;
900110de:	2301      	movs	r3, #1
  msg->msg.cb.function = function;
  msg->msg.cb.ctx = ctx;

  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
900110e0:	4601      	mov	r1, r0
  msg->type = TCPIP_MSG_CALLBACK;
900110e2:	7003      	strb	r3, [r0, #0]
  msg->msg.cb.ctx = ctx;
900110e4:	e9c0 6501 	strd	r6, r5, [r0, #4]
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
900110e8:	4805      	ldr	r0, [pc, #20]	; (90011100 <tcpip_try_callback+0x48>)
900110ea:	f7fc f976 	bl	9000d3da <sys_mbox_trypost>
900110ee:	b128      	cbz	r0, 900110fc <tcpip_try_callback+0x44>
    memp_free(MEMP_TCPIP_MSG_API, msg);
900110f0:	4621      	mov	r1, r4
900110f2:	2008      	movs	r0, #8
900110f4:	f7fb f9ba 	bl	9000c46c <memp_free>
    return ERR_MEM;
900110f8:	f04f 30ff 	mov.w	r0, #4294967295
    return ERR_MEM;
  }
  return ERR_OK;
}
900110fc:	bd70      	pop	{r4, r5, r6, pc}
900110fe:	bf00      	nop
90011100:	2400d418 	.word	0x2400d418
90011104:	9001570f 	.word	0x9001570f
90011108:	90015764 	.word	0x90015764
9001110c:	90012aff 	.word	0x90012aff

90011110 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
90011110:	b537      	push	{r0, r1, r2, r4, r5, lr}
90011112:	4605      	mov	r5, r0
90011114:	460c      	mov	r4, r1
  lwip_init();
90011116:	f7fa f88c 	bl	9000b232 <lwip_init>

  tcpip_init_done = initfunc;
9001111a:	4b13      	ldr	r3, [pc, #76]	; (90011168 <tcpip_init+0x58>)
  tcpip_init_done_arg = arg;
  if (sys_mbox_new(&tcpip_mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
9001111c:	2106      	movs	r1, #6
9001111e:	4813      	ldr	r0, [pc, #76]	; (9001116c <tcpip_init+0x5c>)
  tcpip_init_done = initfunc;
90011120:	601d      	str	r5, [r3, #0]
  tcpip_init_done_arg = arg;
90011122:	4b13      	ldr	r3, [pc, #76]	; (90011170 <tcpip_init+0x60>)
90011124:	601c      	str	r4, [r3, #0]
  if (sys_mbox_new(&tcpip_mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
90011126:	f7fc f94b 	bl	9000d3c0 <sys_mbox_new>
9001112a:	b130      	cbz	r0, 9001113a <tcpip_init+0x2a>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
9001112c:	4b11      	ldr	r3, [pc, #68]	; (90011174 <tcpip_init+0x64>)
9001112e:	f240 2261 	movw	r2, #609	; 0x261
90011132:	4911      	ldr	r1, [pc, #68]	; (90011178 <tcpip_init+0x68>)
90011134:	4811      	ldr	r0, [pc, #68]	; (9001117c <tcpip_init+0x6c>)
90011136:	f000 fd39 	bl	90011bac <iprintf>
  }
#if LWIP_TCPIP_CORE_LOCKING
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
9001113a:	4811      	ldr	r0, [pc, #68]	; (90011180 <tcpip_init+0x70>)
9001113c:	f7fc f98a 	bl	9000d454 <sys_mutex_new>
90011140:	b130      	cbz	r0, 90011150 <tcpip_init+0x40>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
90011142:	4b0c      	ldr	r3, [pc, #48]	; (90011174 <tcpip_init+0x64>)
90011144:	f240 2265 	movw	r2, #613	; 0x265
90011148:	490e      	ldr	r1, [pc, #56]	; (90011184 <tcpip_init+0x74>)
9001114a:	480c      	ldr	r0, [pc, #48]	; (9001117c <tcpip_init+0x6c>)
9001114c:	f000 fd2e 	bl	90011bac <iprintf>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
90011150:	2308      	movs	r3, #8
90011152:	2200      	movs	r2, #0
90011154:	490c      	ldr	r1, [pc, #48]	; (90011188 <tcpip_init+0x78>)
90011156:	9300      	str	r3, [sp, #0]
90011158:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001115c:	480b      	ldr	r0, [pc, #44]	; (9001118c <tcpip_init+0x7c>)
9001115e:	f7fc f98c 	bl	9000d47a <sys_thread_new>
}
90011162:	b003      	add	sp, #12
90011164:	bd30      	pop	{r4, r5, pc}
90011166:	bf00      	nop
90011168:	2400d410 	.word	0x2400d410
9001116c:	2400d418 	.word	0x2400d418
90011170:	2400d414 	.word	0x2400d414
90011174:	9001570f 	.word	0x9001570f
90011178:	90015771 	.word	0x90015771
9001117c:	90012aff 	.word	0x90012aff
90011180:	2400d40c 	.word	0x2400d40c
90011184:	90015794 	.word	0x90015794
90011188:	90010f75 	.word	0x90010f75
9001118c:	900157b5 	.word	0x900157b5

90011190 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
90011190:	b570      	push	{r4, r5, r6, lr}
90011192:	4604      	mov	r4, r0
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
90011194:	200a      	movs	r0, #10
{
90011196:	460e      	mov	r6, r1
90011198:	4615      	mov	r5, r2
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
9001119a:	f7fb f937 	bl	9000c40c <memp_malloc>
  if (timeout == NULL) {
9001119e:	b938      	cbnz	r0, 900111b0 <sys_timeout_abs+0x20>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
900111a0:	4b10      	ldr	r3, [pc, #64]	; (900111e4 <sys_timeout_abs+0x54>)
900111a2:	22be      	movs	r2, #190	; 0xbe
900111a4:	4910      	ldr	r1, [pc, #64]	; (900111e8 <sys_timeout_abs+0x58>)
900111a6:	4811      	ldr	r0, [pc, #68]	; (900111ec <sys_timeout_abs+0x5c>)
        t->next = timeout;
        break;
      }
    }
  }
}
900111a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
900111ac:	f000 bcfe 	b.w	90011bac <iprintf>
  timeout->next = NULL;
900111b0:	2300      	movs	r3, #0
  if (next_timeout == NULL) {
900111b2:	4a0f      	ldr	r2, [pc, #60]	; (900111f0 <sys_timeout_abs+0x60>)
  timeout->time = abs_time;
900111b4:	6044      	str	r4, [r0, #4]
  timeout->next = NULL;
900111b6:	6003      	str	r3, [r0, #0]
  if (next_timeout == NULL) {
900111b8:	6813      	ldr	r3, [r2, #0]
  timeout->arg = arg;
900111ba:	e9c0 6502 	strd	r6, r5, [r0, #8]
  if (next_timeout == NULL) {
900111be:	b90b      	cbnz	r3, 900111c4 <sys_timeout_abs+0x34>
    next_timeout = timeout;
900111c0:	6010      	str	r0, [r2, #0]
}
900111c2:	bd70      	pop	{r4, r5, r6, pc}
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
900111c4:	6859      	ldr	r1, [r3, #4]
900111c6:	1a61      	subs	r1, r4, r1
900111c8:	2900      	cmp	r1, #0
900111ca:	da01      	bge.n	900111d0 <sys_timeout_abs+0x40>
    timeout->next = next_timeout;
900111cc:	6003      	str	r3, [r0, #0]
900111ce:	e7f7      	b.n	900111c0 <sys_timeout_abs+0x30>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
900111d0:	4619      	mov	r1, r3
900111d2:	681b      	ldr	r3, [r3, #0]
900111d4:	b11b      	cbz	r3, 900111de <sys_timeout_abs+0x4e>
900111d6:	685a      	ldr	r2, [r3, #4]
900111d8:	1aa2      	subs	r2, r4, r2
900111da:	2a00      	cmp	r2, #0
900111dc:	daf8      	bge.n	900111d0 <sys_timeout_abs+0x40>
        timeout->next = t->next;
900111de:	6003      	str	r3, [r0, #0]
        t->next = timeout;
900111e0:	6008      	str	r0, [r1, #0]
        break;
900111e2:	e7ee      	b.n	900111c2 <sys_timeout_abs+0x32>
900111e4:	900157c2 	.word	0x900157c2
900111e8:	900157fd 	.word	0x900157fd
900111ec:	90012aff 	.word	0x90012aff
900111f0:	2400d420 	.word	0x2400d420

900111f4 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
900111f4:	b538      	push	{r3, r4, r5, lr}
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
900111f6:	6843      	ldr	r3, [r0, #4]
{
900111f8:	4604      	mov	r4, r0
  cyclic->handler();
900111fa:	4798      	blx	r3

  now = sys_now();
900111fc:	f7f0 f838 	bl	90001270 <sys_now>
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
90011200:	4b07      	ldr	r3, [pc, #28]	; (90011220 <lwip_cyclic_timer+0x2c>)
90011202:	6825      	ldr	r5, [r4, #0]
90011204:	681b      	ldr	r3, [r3, #0]
  if (TIME_LESS_THAN(next_timeout_time, now)) {
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
90011206:	4907      	ldr	r1, [pc, #28]	; (90011224 <lwip_cyclic_timer+0x30>)
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
90011208:	442b      	add	r3, r5
  if (TIME_LESS_THAN(next_timeout_time, now)) {
9001120a:	1a1a      	subs	r2, r3, r0
9001120c:	2a00      	cmp	r2, #0
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
9001120e:	4622      	mov	r2, r4
90011210:	bfb4      	ite	lt
90011212:	1940      	addlt	r0, r0, r5
  } else {
    /* correct cyclic interval with handler execution delay and sys_check_timeouts jitter */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
90011214:	4618      	movge	r0, r3
#endif
  }
}
90011216:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
9001121a:	f7ff bfb9 	b.w	90011190 <sys_timeout_abs>
9001121e:	bf00      	nop
90011220:	2400d41c 	.word	0x2400d41c
90011224:	900111f5 	.word	0x900111f5

90011228 <sys_timeout>:
{
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
90011228:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
{
9001122c:	b570      	push	{r4, r5, r6, lr}
9001122e:	4604      	mov	r4, r0
90011230:	460d      	mov	r5, r1
90011232:	4616      	mov	r6, r2
  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
90011234:	d306      	bcc.n	90011244 <sys_timeout+0x1c>
90011236:	4b08      	ldr	r3, [pc, #32]	; (90011258 <sys_timeout+0x30>)
90011238:	f240 1229 	movw	r2, #297	; 0x129
9001123c:	4907      	ldr	r1, [pc, #28]	; (9001125c <sys_timeout+0x34>)
9001123e:	4808      	ldr	r0, [pc, #32]	; (90011260 <sys_timeout+0x38>)
90011240:	f000 fcb4 	bl	90011bac <iprintf>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
90011244:	f7f0 f814 	bl	90001270 <sys_now>

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
90011248:	4632      	mov	r2, r6
9001124a:	4629      	mov	r1, r5
9001124c:	4420      	add	r0, r4
#endif
}
9001124e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  sys_timeout_abs(next_timeout_time, handler, arg);
90011252:	f7ff bf9d 	b.w	90011190 <sys_timeout_abs>
90011256:	bf00      	nop
90011258:	900157c2 	.word	0x900157c2
9001125c:	9001583a 	.word	0x9001583a
90011260:	90012aff 	.word	0x90012aff

90011264 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
90011264:	4b08      	ldr	r3, [pc, #32]	; (90011288 <tcp_timer_needed+0x24>)
90011266:	681a      	ldr	r2, [r3, #0]
90011268:	b962      	cbnz	r2, 90011284 <tcp_timer_needed+0x20>
9001126a:	4a08      	ldr	r2, [pc, #32]	; (9001128c <tcp_timer_needed+0x28>)
9001126c:	6812      	ldr	r2, [r2, #0]
9001126e:	b912      	cbnz	r2, 90011276 <tcp_timer_needed+0x12>
90011270:	4a07      	ldr	r2, [pc, #28]	; (90011290 <tcp_timer_needed+0x2c>)
90011272:	6812      	ldr	r2, [r2, #0]
90011274:	b132      	cbz	r2, 90011284 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
90011276:	2201      	movs	r2, #1
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
90011278:	4906      	ldr	r1, [pc, #24]	; (90011294 <tcp_timer_needed+0x30>)
9001127a:	20fa      	movs	r0, #250	; 0xfa
    tcpip_tcp_timer_active = 1;
9001127c:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
9001127e:	2200      	movs	r2, #0
90011280:	f7ff bfd2 	b.w	90011228 <sys_timeout>
}
90011284:	4770      	bx	lr
90011286:	bf00      	nop
90011288:	2400d424 	.word	0x2400d424
9001128c:	2400d3b0 	.word	0x2400d3b0
90011290:	2400d3c8 	.word	0x2400d3c8
90011294:	90011299 	.word	0x90011299

90011298 <tcpip_tcp_timer>:
{
90011298:	b508      	push	{r3, lr}
  tcp_tmr();
9001129a:	f7fd fa1b 	bl	9000e6d4 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
9001129e:	4b08      	ldr	r3, [pc, #32]	; (900112c0 <tcpip_tcp_timer+0x28>)
900112a0:	681b      	ldr	r3, [r3, #0]
900112a2:	b913      	cbnz	r3, 900112aa <tcpip_tcp_timer+0x12>
900112a4:	4b07      	ldr	r3, [pc, #28]	; (900112c4 <tcpip_tcp_timer+0x2c>)
900112a6:	681b      	ldr	r3, [r3, #0]
900112a8:	b133      	cbz	r3, 900112b8 <tcpip_tcp_timer+0x20>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
900112aa:	2200      	movs	r2, #0
900112ac:	4906      	ldr	r1, [pc, #24]	; (900112c8 <tcpip_tcp_timer+0x30>)
900112ae:	20fa      	movs	r0, #250	; 0xfa
}
900112b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
900112b4:	f7ff bfb8 	b.w	90011228 <sys_timeout>
    tcpip_tcp_timer_active = 0;
900112b8:	4a04      	ldr	r2, [pc, #16]	; (900112cc <tcpip_tcp_timer+0x34>)
900112ba:	6013      	str	r3, [r2, #0]
}
900112bc:	bd08      	pop	{r3, pc}
900112be:	bf00      	nop
900112c0:	2400d3b0 	.word	0x2400d3b0
900112c4:	2400d3c8 	.word	0x2400d3c8
900112c8:	90011299 	.word	0x90011299
900112cc:	2400d424 	.word	0x2400d424

900112d0 <sys_timeouts_init>:
{
900112d0:	b570      	push	{r4, r5, r6, lr}
900112d2:	4d06      	ldr	r5, [pc, #24]	; (900112ec <sys_timeouts_init+0x1c>)
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
900112d4:	2401      	movs	r4, #1
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
900112d6:	4e06      	ldr	r6, [pc, #24]	; (900112f0 <sys_timeouts_init+0x20>)
900112d8:	f855 0f08 	ldr.w	r0, [r5, #8]!
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
900112dc:	3401      	adds	r4, #1
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
900112de:	4631      	mov	r1, r6
900112e0:	462a      	mov	r2, r5
900112e2:	f7ff ffa1 	bl	90011228 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
900112e6:	2c06      	cmp	r4, #6
900112e8:	d1f6      	bne.n	900112d8 <sys_timeouts_init+0x8>
}
900112ea:	bd70      	pop	{r4, r5, r6, pc}
900112ec:	90015870 	.word	0x90015870
900112f0:	900111f5 	.word	0x900111f5

900112f4 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
900112f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
900112f8:	f7ef ffba 	bl	90001270 <sys_now>
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();

    tmptimeout = next_timeout;
900112fc:	4e0c      	ldr	r6, [pc, #48]	; (90011330 <sys_check_timeouts+0x3c>)
  now = sys_now();
900112fe:	4604      	mov	r4, r0

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
    handler = tmptimeout->h;
    arg = tmptimeout->arg;
    current_timeout_due_time = tmptimeout->time;
90011300:	f8df 8030 	ldr.w	r8, [pc, #48]	; 90011334 <sys_check_timeouts+0x40>
    tmptimeout = next_timeout;
90011304:	6831      	ldr	r1, [r6, #0]
    if (tmptimeout == NULL) {
90011306:	b189      	cbz	r1, 9001132c <sys_check_timeouts+0x38>
    if (TIME_LESS_THAN(now, tmptimeout->time)) {
90011308:	684b      	ldr	r3, [r1, #4]
9001130a:	1ae2      	subs	r2, r4, r3
9001130c:	2a00      	cmp	r2, #0
9001130e:	db0d      	blt.n	9001132c <sys_check_timeouts+0x38>
    next_timeout = tmptimeout->next;
90011310:	680a      	ldr	r2, [r1, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
90011312:	200a      	movs	r0, #10
    current_timeout_due_time = tmptimeout->time;
90011314:	f8c8 3000 	str.w	r3, [r8]
    next_timeout = tmptimeout->next;
90011318:	6032      	str	r2, [r6, #0]
    arg = tmptimeout->arg;
9001131a:	e9d1 5702 	ldrd	r5, r7, [r1, #8]
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
9001131e:	f7fb f8a5 	bl	9000c46c <memp_free>
    if (handler != NULL) {
90011322:	2d00      	cmp	r5, #0
90011324:	d0ee      	beq.n	90011304 <sys_check_timeouts+0x10>
      handler(arg);
90011326:	4638      	mov	r0, r7
90011328:	47a8      	blx	r5
9001132a:	e7eb      	b.n	90011304 <sys_check_timeouts+0x10>
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
9001132c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
90011330:	2400d420 	.word	0x2400d420
90011334:	2400d41c 	.word	0x2400d41c

90011338 <sys_timeouts_sleeptime>:
/** Return the time left before the next timeout is due. If no timeouts are
 * enqueued, returns 0xffffffff
 */
u32_t
sys_timeouts_sleeptime(void)
{
90011338:	b510      	push	{r4, lr}
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
9001133a:	4c07      	ldr	r4, [pc, #28]	; (90011358 <sys_timeouts_sleeptime+0x20>)
9001133c:	6823      	ldr	r3, [r4, #0]
9001133e:	b13b      	cbz	r3, 90011350 <sys_timeouts_sleeptime+0x18>
    return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
  }
  now = sys_now();
90011340:	f7ef ff96 	bl	90001270 <sys_now>
  if (TIME_LESS_THAN(next_timeout->time, now)) {
90011344:	6823      	ldr	r3, [r4, #0]
90011346:	685b      	ldr	r3, [r3, #4]
    return 0;
90011348:	1a18      	subs	r0, r3, r0
9001134a:	bf48      	it	mi
9001134c:	2000      	movmi	r0, #0
  } else {
    u32_t ret = (u32_t)(next_timeout->time - now);
    LWIP_ASSERT("invalid sleeptime", ret <= LWIP_MAX_TIMEOUT);
    return ret;
  }
}
9001134e:	bd10      	pop	{r4, pc}
    return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
90011350:	f04f 30ff 	mov.w	r0, #4294967295
90011354:	e7fb      	b.n	9001134e <sys_timeouts_sleeptime+0x16>
90011356:	bf00      	nop
90011358:	2400d420 	.word	0x2400d420

9001135c <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
9001135c:	b508      	push	{r3, lr}
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
9001135e:	f000 fc3d 	bl	90011bdc <rand>
90011362:	ea6f 4080 	mvn.w	r0, r0, lsl #18
90011366:	4b02      	ldr	r3, [pc, #8]	; (90011370 <udp_init+0x14>)
90011368:	ea6f 4090 	mvn.w	r0, r0, lsr #18
9001136c:	8018      	strh	r0, [r3, #0]
#endif /* LWIP_RAND */
}
9001136e:	bd08      	pop	{r3, pc}
90011370:	24000036 	.word	0x24000036

90011374 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
90011374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90011378:	4688      	mov	r8, r1
9001137a:	b085      	sub	sp, #20

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
9001137c:	4606      	mov	r6, r0
9001137e:	b928      	cbnz	r0, 9001138c <udp_input+0x18>
90011380:	4b5f      	ldr	r3, [pc, #380]	; (90011500 <udp_input+0x18c>)
90011382:	22cf      	movs	r2, #207	; 0xcf
90011384:	495f      	ldr	r1, [pc, #380]	; (90011504 <udp_input+0x190>)
90011386:	4860      	ldr	r0, [pc, #384]	; (90011508 <udp_input+0x194>)
90011388:	f000 fc10 	bl	90011bac <iprintf>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
9001138c:	f1b8 0f00 	cmp.w	r8, #0
90011390:	d105      	bne.n	9001139e <udp_input+0x2a>
90011392:	4b5b      	ldr	r3, [pc, #364]	; (90011500 <udp_input+0x18c>)
90011394:	22d0      	movs	r2, #208	; 0xd0
90011396:	495d      	ldr	r1, [pc, #372]	; (9001150c <udp_input+0x198>)
90011398:	485b      	ldr	r0, [pc, #364]	; (90011508 <udp_input+0x194>)
9001139a:	f000 fc07 	bl	90011bac <iprintf>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
9001139e:	8973      	ldrh	r3, [r6, #10]
900113a0:	2b07      	cmp	r3, #7
900113a2:	d805      	bhi.n	900113b0 <udp_input+0x3c>
    if (pbuf_remove_header(p, UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
900113a4:	4630      	mov	r0, r6
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
900113a6:	b005      	add	sp, #20
900113a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      pbuf_free(p);
900113ac:	f7fb bc78 	b.w	9000cca0 <pbuf_free>
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
900113b0:	4f57      	ldr	r7, [pc, #348]	; (90011510 <udp_input+0x19c>)
  uncon_pcb = NULL;
900113b2:	2500      	movs	r5, #0
  udphdr = (struct udp_hdr *)p->payload;
900113b4:	6874      	ldr	r4, [r6, #4]
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
900113b6:	6839      	ldr	r1, [r7, #0]
  prev = NULL;
900113b8:	46aa      	mov	sl, r5
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
900113ba:	6978      	ldr	r0, [r7, #20]
900113bc:	f7fa f8ef 	bl	9000b59e <ip4_addr_isbroadcast_u32>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
900113c0:	f8df b15c 	ldr.w	fp, [pc, #348]	; 90011520 <udp_input+0x1ac>
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
900113c4:	4681      	mov	r9, r0
  src = lwip_ntohs(udphdr->src);
900113c6:	8820      	ldrh	r0, [r4, #0]
900113c8:	f7f7 feda 	bl	90009180 <lwip_htons>
900113cc:	9002      	str	r0, [sp, #8]
  dest = lwip_ntohs(udphdr->dest);
900113ce:	8860      	ldrh	r0, [r4, #2]
900113d0:	f7f7 fed6 	bl	90009180 <lwip_htons>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
900113d4:	f8db 4000 	ldr.w	r4, [fp]
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
900113d8:	f8df c124 	ldr.w	ip, [pc, #292]	; 90011500 <udp_input+0x18c>
900113dc:	494d      	ldr	r1, [pc, #308]	; (90011514 <udp_input+0x1a0>)
  dest = lwip_ntohs(udphdr->dest);
900113de:	9003      	str	r0, [sp, #12]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
900113e0:	b99c      	cbnz	r4, 9001140a <udp_input+0x96>
  if (pcb != NULL) {
900113e2:	b925      	cbnz	r5, 900113ee <udp_input+0x7a>
  if (for_us) {
900113e4:	f8d8 2004 	ldr.w	r2, [r8, #4]
900113e8:	697b      	ldr	r3, [r7, #20]
900113ea:	429a      	cmp	r2, r3
900113ec:	d1da      	bne.n	900113a4 <udp_input+0x30>
    if (pbuf_remove_header(p, UDP_HLEN)) {
900113ee:	2108      	movs	r1, #8
900113f0:	4630      	mov	r0, r6
900113f2:	f7fb fc21 	bl	9000cc38 <pbuf_remove_header>
900113f6:	2800      	cmp	r0, #0
900113f8:	d05e      	beq.n	900114b8 <udp_input+0x144>
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
900113fa:	4b41      	ldr	r3, [pc, #260]	; (90011500 <udp_input+0x18c>)
900113fc:	f44f 72b8 	mov.w	r2, #368	; 0x170
90011400:	4945      	ldr	r1, [pc, #276]	; (90011518 <udp_input+0x1a4>)
90011402:	4841      	ldr	r0, [pc, #260]	; (90011508 <udp_input+0x194>)
90011404:	f000 fbd2 	bl	90011bac <iprintf>
90011408:	e7cc      	b.n	900113a4 <udp_input+0x30>
    if ((pcb->local_port == dest) &&
9001140a:	8a62      	ldrh	r2, [r4, #18]
9001140c:	9803      	ldr	r0, [sp, #12]
9001140e:	4282      	cmp	r2, r0
90011410:	d14d      	bne.n	900114ae <udp_input+0x13a>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
90011412:	f1b8 0f00 	cmp.w	r8, #0
90011416:	d107      	bne.n	90011428 <udp_input+0xb4>
90011418:	4663      	mov	r3, ip
9001141a:	2288      	movs	r2, #136	; 0x88
9001141c:	483a      	ldr	r0, [pc, #232]	; (90011508 <udp_input+0x194>)
9001141e:	f000 fbc5 	bl	90011bac <iprintf>
90011422:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 90011500 <udp_input+0x18c>
90011426:	493b      	ldr	r1, [pc, #236]	; (90011514 <udp_input+0x1a0>)
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
90011428:	7a20      	ldrb	r0, [r4, #8]
9001142a:	b130      	cbz	r0, 9001143a <udp_input+0xc6>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
9001142c:	687a      	ldr	r2, [r7, #4]
9001142e:	f892 2038 	ldrb.w	r2, [r2, #56]	; 0x38
90011432:	3201      	adds	r2, #1
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
90011434:	b2d2      	uxtb	r2, r2
90011436:	4290      	cmp	r0, r2
90011438:	d139      	bne.n	900114ae <udp_input+0x13a>
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
9001143a:	6822      	ldr	r2, [r4, #0]
    if (broadcast != 0) {
9001143c:	f1b9 0f00 	cmp.w	r9, #0
90011440:	d030      	beq.n	900114a4 <udp_input+0x130>
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
90011442:	b13a      	cbz	r2, 90011454 <udp_input+0xe0>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
90011444:	6978      	ldr	r0, [r7, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
90011446:	1c43      	adds	r3, r0, #1
90011448:	d004      	beq.n	90011454 <udp_input+0xe0>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
9001144a:	4050      	eors	r0, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
9001144c:	f8d8 3008 	ldr.w	r3, [r8, #8]
90011450:	4218      	tst	r0, r3
90011452:	d12c      	bne.n	900114ae <udp_input+0x13a>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
90011454:	7c20      	ldrb	r0, [r4, #16]
90011456:	0743      	lsls	r3, r0, #29
90011458:	d40e      	bmi.n	90011478 <udp_input+0x104>
        if (uncon_pcb == NULL) {
9001145a:	b35d      	cbz	r5, 900114b4 <udp_input+0x140>
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
9001145c:	f1b9 0f00 	cmp.w	r9, #0
90011460:	d00a      	beq.n	90011478 <udp_input+0x104>
90011462:	6978      	ldr	r0, [r7, #20]
90011464:	3001      	adds	r0, #1
90011466:	d107      	bne.n	90011478 <udp_input+0x104>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
90011468:	f8d8 0004 	ldr.w	r0, [r8, #4]
9001146c:	682b      	ldr	r3, [r5, #0]
9001146e:	4283      	cmp	r3, r0
90011470:	d002      	beq.n	90011478 <udp_input+0x104>
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
90011472:	4290      	cmp	r0, r2
90011474:	bf08      	it	eq
90011476:	4625      	moveq	r5, r4
      if ((pcb->remote_port == src) &&
90011478:	8aa2      	ldrh	r2, [r4, #20]
9001147a:	9b02      	ldr	r3, [sp, #8]
9001147c:	429a      	cmp	r2, r3
9001147e:	d116      	bne.n	900114ae <udp_input+0x13a>
          (ip_addr_isany_val(pcb->remote_ip) ||
90011480:	6862      	ldr	r2, [r4, #4]
      if ((pcb->remote_port == src) &&
90011482:	b112      	cbz	r2, 9001148a <udp_input+0x116>
          (ip_addr_isany_val(pcb->remote_ip) ||
90011484:	6938      	ldr	r0, [r7, #16]
90011486:	4282      	cmp	r2, r0
90011488:	d111      	bne.n	900114ae <udp_input+0x13a>
        if (prev != NULL) {
9001148a:	f1ba 0f00 	cmp.w	sl, #0
9001148e:	d007      	beq.n	900114a0 <udp_input+0x12c>
          prev->next = pcb->next;
90011490:	68e3      	ldr	r3, [r4, #12]
90011492:	f8ca 300c 	str.w	r3, [sl, #12]
          pcb->next = udp_pcbs;
90011496:	f8db 3000 	ldr.w	r3, [fp]
          udp_pcbs = pcb;
9001149a:	f8cb 4000 	str.w	r4, [fp]
          pcb->next = udp_pcbs;
9001149e:	60e3      	str	r3, [r4, #12]
          udp_pcbs = pcb;
900114a0:	4625      	mov	r5, r4
900114a2:	e7a4      	b.n	900113ee <udp_input+0x7a>
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
900114a4:	2a00      	cmp	r2, #0
900114a6:	d0d5      	beq.n	90011454 <udp_input+0xe0>
900114a8:	6978      	ldr	r0, [r7, #20]
900114aa:	4290      	cmp	r0, r2
900114ac:	d0d2      	beq.n	90011454 <udp_input+0xe0>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
900114ae:	46a2      	mov	sl, r4
900114b0:	68e4      	ldr	r4, [r4, #12]
900114b2:	e795      	b.n	900113e0 <udp_input+0x6c>
900114b4:	4625      	mov	r5, r4
900114b6:	e7df      	b.n	90011478 <udp_input+0x104>
    if (pcb != NULL) {
900114b8:	b16d      	cbz	r5, 900114d6 <udp_input+0x162>
      if (pcb->recv != NULL) {
900114ba:	69ac      	ldr	r4, [r5, #24]
900114bc:	2c00      	cmp	r4, #0
900114be:	f43f af71 	beq.w	900113a4 <udp_input+0x30>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
900114c2:	9b02      	ldr	r3, [sp, #8]
900114c4:	4632      	mov	r2, r6
900114c6:	4629      	mov	r1, r5
900114c8:	9300      	str	r3, [sp, #0]
900114ca:	4b14      	ldr	r3, [pc, #80]	; (9001151c <udp_input+0x1a8>)
900114cc:	69e8      	ldr	r0, [r5, #28]
900114ce:	47a0      	blx	r4
}
900114d0:	b005      	add	sp, #20
900114d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
900114d6:	f1b9 0f00 	cmp.w	r9, #0
900114da:	f47f af63 	bne.w	900113a4 <udp_input+0x30>
900114de:	697b      	ldr	r3, [r7, #20]
900114e0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
900114e4:	2be0      	cmp	r3, #224	; 0xe0
900114e6:	f43f af5d 	beq.w	900113a4 <udp_input+0x30>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
900114ea:	89b9      	ldrh	r1, [r7, #12]
900114ec:	4630      	mov	r0, r6
900114ee:	3108      	adds	r1, #8
900114f0:	b209      	sxth	r1, r1
900114f2:	f7fb fbcd 	bl	9000cc90 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
900114f6:	2103      	movs	r1, #3
900114f8:	4630      	mov	r0, r6
900114fa:	f7f9 fe3d 	bl	9000b178 <icmp_dest_unreach>
900114fe:	e751      	b.n	900113a4 <udp_input+0x30>
90011500:	900158a0 	.word	0x900158a0
90011504:	900158d6 	.word	0x900158d6
90011508:	90012aff 	.word	0x90012aff
9001150c:	900158ee 	.word	0x900158ee
90011510:	2400a0e8 	.word	0x2400a0e8
90011514:	90015907 	.word	0x90015907
90011518:	9001592c 	.word	0x9001592c
9001151c:	2400a0f8 	.word	0x2400a0f8
90011520:	2400d428 	.word	0x2400d428

90011524 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
90011524:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
    ipaddr = IP4_ADDR_ANY;
90011528:	4c2b      	ldr	r4, [pc, #172]	; (900115d8 <udp_bind+0xb4>)
9001152a:	2900      	cmp	r1, #0
9001152c:	bf18      	it	ne
9001152e:	460c      	movne	r4, r1
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
90011530:	b950      	cbnz	r0, 90011548 <udp_bind+0x24>
90011532:	4b2a      	ldr	r3, [pc, #168]	; (900115dc <udp_bind+0xb8>)
90011534:	f240 32b7 	movw	r2, #951	; 0x3b7
90011538:	4929      	ldr	r1, [pc, #164]	; (900115e0 <udp_bind+0xbc>)
9001153a:	482a      	ldr	r0, [pc, #168]	; (900115e4 <udp_bind+0xc0>)
9001153c:	f000 fb36 	bl	90011bac <iprintf>
90011540:	f06f 000f 	mvn.w	r0, #15
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
}
90011544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
90011548:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 900115ec <udp_bind+0xc8>
9001154c:	f8dc 5000 	ldr.w	r5, [ip]
90011550:	4629      	mov	r1, r5
90011552:	b9c9      	cbnz	r1, 90011588 <udp_bind+0x64>
  if (port == 0) {
90011554:	2a00      	cmp	r2, #0
90011556:	d13c      	bne.n	900115d2 <udp_bind+0xae>
90011558:	4f23      	ldr	r7, [pc, #140]	; (900115e8 <udp_bind+0xc4>)
9001155a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
9001155e:	f64f 7eff 	movw	lr, #65535	; 0xffff
90011562:	883a      	ldrh	r2, [r7, #0]
90011564:	4572      	cmp	r2, lr
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
90011566:	462e      	mov	r6, r5
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
90011568:	bf16      	itet	ne
9001156a:	3201      	addne	r2, #1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
9001156c:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
90011570:	b292      	uxthne	r2, r2
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
90011572:	b97e      	cbnz	r6, 90011594 <udp_bind+0x70>
90011574:	803a      	strh	r2, [r7, #0]
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
90011576:	6823      	ldr	r3, [r4, #0]
  pcb->local_port = port;
90011578:	8242      	strh	r2, [r0, #18]
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
9001157a:	6003      	str	r3, [r0, #0]
  if (rebind == 0) {
9001157c:	b911      	cbnz	r1, 90011584 <udp_bind+0x60>
    pcb->next = udp_pcbs;
9001157e:	60c5      	str	r5, [r0, #12]
    udp_pcbs = pcb;
90011580:	f8cc 0000 	str.w	r0, [ip]
  return ERR_OK;
90011584:	2000      	movs	r0, #0
90011586:	e7dd      	b.n	90011544 <udp_bind+0x20>
    if (pcb == ipcb) {
90011588:	4281      	cmp	r1, r0
9001158a:	d001      	beq.n	90011590 <udp_bind+0x6c>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
9001158c:	68c9      	ldr	r1, [r1, #12]
9001158e:	e7e0      	b.n	90011552 <udp_bind+0x2e>
      rebind = 1;
90011590:	2101      	movs	r1, #1
90011592:	e7df      	b.n	90011554 <udp_bind+0x30>
    if (pcb->local_port == udp_port) {
90011594:	f8b6 8012 	ldrh.w	r8, [r6, #18]
90011598:	4590      	cmp	r8, r2
9001159a:	d107      	bne.n	900115ac <udp_bind+0x88>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
9001159c:	3b01      	subs	r3, #1
9001159e:	b29b      	uxth	r3, r3
900115a0:	2b00      	cmp	r3, #0
900115a2:	d1df      	bne.n	90011564 <udp_bind+0x40>
900115a4:	803a      	strh	r2, [r7, #0]
      return ERR_USE;
900115a6:	f06f 0007 	mvn.w	r0, #7
900115aa:	e7cb      	b.n	90011544 <udp_bind+0x20>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
900115ac:	68f6      	ldr	r6, [r6, #12]
900115ae:	e7e0      	b.n	90011572 <udp_bind+0x4e>
      if (pcb != ipcb) {
900115b0:	4283      	cmp	r3, r0
900115b2:	d00a      	beq.n	900115ca <udp_bind+0xa6>
          if ((ipcb->local_port == port) &&
900115b4:	8a5e      	ldrh	r6, [r3, #18]
900115b6:	4296      	cmp	r6, r2
900115b8:	d107      	bne.n	900115ca <udp_bind+0xa6>
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
900115ba:	6827      	ldr	r7, [r4, #0]
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
900115bc:	681e      	ldr	r6, [r3, #0]
          if ((ipcb->local_port == port) &&
900115be:	42be      	cmp	r6, r7
900115c0:	d0f1      	beq.n	900115a6 <udp_bind+0x82>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
900115c2:	2f00      	cmp	r7, #0
900115c4:	d0ef      	beq.n	900115a6 <udp_bind+0x82>
              ip_addr_isany(&ipcb->local_ip))) {
900115c6:	2e00      	cmp	r6, #0
900115c8:	d0ed      	beq.n	900115a6 <udp_bind+0x82>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
900115ca:	68db      	ldr	r3, [r3, #12]
900115cc:	2b00      	cmp	r3, #0
900115ce:	d1ef      	bne.n	900115b0 <udp_bind+0x8c>
900115d0:	e7d1      	b.n	90011576 <udp_bind+0x52>
900115d2:	462b      	mov	r3, r5
900115d4:	e7fa      	b.n	900115cc <udp_bind+0xa8>
900115d6:	bf00      	nop
900115d8:	90013a68 	.word	0x90013a68
900115dc:	900158a0 	.word	0x900158a0
900115e0:	90015947 	.word	0x90015947
900115e4:	90012aff 	.word	0x90012aff
900115e8:	24000036 	.word	0x24000036
900115ec:	2400d428 	.word	0x2400d428

900115f0 <udp_sendto_if_src>:
{
900115f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900115f4:	b085      	sub	sp, #20
900115f6:	460e      	mov	r6, r1
900115f8:	4690      	mov	r8, r2
900115fa:	4699      	mov	r9, r3
  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
900115fc:	4607      	mov	r7, r0
{
900115fe:	e9dd ba0e 	ldrd	fp, sl, [sp, #56]	; 0x38
  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
90011602:	b960      	cbnz	r0, 9001161e <udp_sendto_if_src+0x2e>
90011604:	4b3e      	ldr	r3, [pc, #248]	; (90011700 <udp_sendto_if_src+0x110>)
90011606:	f240 22d1 	movw	r2, #721	; 0x2d1
9001160a:	493e      	ldr	r1, [pc, #248]	; (90011704 <udp_sendto_if_src+0x114>)
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
9001160c:	f06f 040f 	mvn.w	r4, #15
90011610:	483d      	ldr	r0, [pc, #244]	; (90011708 <udp_sendto_if_src+0x118>)
90011612:	f000 facb 	bl	90011bac <iprintf>
}
90011616:	4620      	mov	r0, r4
90011618:	b005      	add	sp, #20
9001161a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
9001161e:	b921      	cbnz	r1, 9001162a <udp_sendto_if_src+0x3a>
90011620:	4b37      	ldr	r3, [pc, #220]	; (90011700 <udp_sendto_if_src+0x110>)
90011622:	f240 22d2 	movw	r2, #722	; 0x2d2
90011626:	4939      	ldr	r1, [pc, #228]	; (9001170c <udp_sendto_if_src+0x11c>)
90011628:	e7f0      	b.n	9001160c <udp_sendto_if_src+0x1c>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
9001162a:	b922      	cbnz	r2, 90011636 <udp_sendto_if_src+0x46>
9001162c:	4b34      	ldr	r3, [pc, #208]	; (90011700 <udp_sendto_if_src+0x110>)
9001162e:	f240 22d3 	movw	r2, #723	; 0x2d3
90011632:	4937      	ldr	r1, [pc, #220]	; (90011710 <udp_sendto_if_src+0x120>)
90011634:	e7ea      	b.n	9001160c <udp_sendto_if_src+0x1c>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
90011636:	f1ba 0f00 	cmp.w	sl, #0
9001163a:	d104      	bne.n	90011646 <udp_sendto_if_src+0x56>
9001163c:	4b30      	ldr	r3, [pc, #192]	; (90011700 <udp_sendto_if_src+0x110>)
9001163e:	f44f 7235 	mov.w	r2, #724	; 0x2d4
90011642:	4934      	ldr	r1, [pc, #208]	; (90011714 <udp_sendto_if_src+0x124>)
90011644:	e7e2      	b.n	9001160c <udp_sendto_if_src+0x1c>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
90011646:	f1bb 0f00 	cmp.w	fp, #0
9001164a:	d104      	bne.n	90011656 <udp_sendto_if_src+0x66>
9001164c:	4b2c      	ldr	r3, [pc, #176]	; (90011700 <udp_sendto_if_src+0x110>)
9001164e:	f240 22d5 	movw	r2, #725	; 0x2d5
90011652:	4931      	ldr	r1, [pc, #196]	; (90011718 <udp_sendto_if_src+0x128>)
90011654:	e7da      	b.n	9001160c <udp_sendto_if_src+0x1c>
  if (pcb->local_port == 0) {
90011656:	8a42      	ldrh	r2, [r0, #18]
90011658:	b13a      	cbz	r2, 9001166a <udp_sendto_if_src+0x7a>
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
9001165a:	8932      	ldrh	r2, [r6, #8]
9001165c:	f64f 73f7 	movw	r3, #65527	; 0xfff7
90011660:	429a      	cmp	r2, r3
90011662:	d909      	bls.n	90011678 <udp_sendto_if_src+0x88>
    return ERR_MEM;
90011664:	f04f 34ff 	mov.w	r4, #4294967295
90011668:	e7d5      	b.n	90011616 <udp_sendto_if_src+0x26>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
9001166a:	4601      	mov	r1, r0
9001166c:	f7ff ff5a 	bl	90011524 <udp_bind>
    if (err != ERR_OK) {
90011670:	4604      	mov	r4, r0
90011672:	2800      	cmp	r0, #0
90011674:	d0f1      	beq.n	9001165a <udp_sendto_if_src+0x6a>
90011676:	e7ce      	b.n	90011616 <udp_sendto_if_src+0x26>
  if (pbuf_add_header(p, UDP_HLEN)) {
90011678:	2108      	movs	r1, #8
9001167a:	4630      	mov	r0, r6
9001167c:	f7fb fad8 	bl	9000cc30 <pbuf_add_header>
90011680:	2800      	cmp	r0, #0
90011682:	d03a      	beq.n	900116fa <udp_sendto_if_src+0x10a>
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
90011684:	f44f 7220 	mov.w	r2, #640	; 0x280
90011688:	2108      	movs	r1, #8
9001168a:	2022      	movs	r0, #34	; 0x22
9001168c:	f7fb fb70 	bl	9000cd70 <pbuf_alloc>
    if (q == NULL) {
90011690:	4605      	mov	r5, r0
90011692:	2800      	cmp	r0, #0
90011694:	d0e6      	beq.n	90011664 <udp_sendto_if_src+0x74>
    if (p->tot_len != 0) {
90011696:	8933      	ldrh	r3, [r6, #8]
90011698:	b113      	cbz	r3, 900116a0 <udp_sendto_if_src+0xb0>
      pbuf_chain(q, p);
9001169a:	4631      	mov	r1, r6
9001169c:	f7fb fcb0 	bl	9000d000 <pbuf_chain>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
900116a0:	896b      	ldrh	r3, [r5, #10]
900116a2:	2b07      	cmp	r3, #7
900116a4:	d806      	bhi.n	900116b4 <udp_sendto_if_src+0xc4>
900116a6:	4b16      	ldr	r3, [pc, #88]	; (90011700 <udp_sendto_if_src+0x110>)
900116a8:	f240 320d 	movw	r2, #781	; 0x30d
900116ac:	491b      	ldr	r1, [pc, #108]	; (9001171c <udp_sendto_if_src+0x12c>)
900116ae:	4816      	ldr	r0, [pc, #88]	; (90011708 <udp_sendto_if_src+0x118>)
900116b0:	f000 fa7c 	bl	90011bac <iprintf>
  udphdr = (struct udp_hdr *)q->payload;
900116b4:	686c      	ldr	r4, [r5, #4]
  udphdr->src = lwip_htons(pcb->local_port);
900116b6:	8a78      	ldrh	r0, [r7, #18]
900116b8:	f7f7 fd62 	bl	90009180 <lwip_htons>
900116bc:	8020      	strh	r0, [r4, #0]
  udphdr->dest = lwip_htons(dst_port);
900116be:	4648      	mov	r0, r9
900116c0:	f7f7 fd5e 	bl	90009180 <lwip_htons>
  udphdr->chksum = 0x0000;
900116c4:	2300      	movs	r3, #0
  udphdr->dest = lwip_htons(dst_port);
900116c6:	8060      	strh	r0, [r4, #2]
  udphdr->chksum = 0x0000;
900116c8:	71a3      	strb	r3, [r4, #6]
900116ca:	71e3      	strb	r3, [r4, #7]
    udphdr->len = lwip_htons(q->tot_len);
900116cc:	8928      	ldrh	r0, [r5, #8]
900116ce:	f7f7 fd57 	bl	90009180 <lwip_htons>
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
900116d2:	2311      	movs	r3, #17
    udphdr->len = lwip_htons(q->tot_len);
900116d4:	80a0      	strh	r0, [r4, #4]
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
900116d6:	4642      	mov	r2, r8
900116d8:	f8cd b008 	str.w	fp, [sp, #8]
900116dc:	4651      	mov	r1, sl
900116de:	9301      	str	r3, [sp, #4]
900116e0:	4628      	mov	r0, r5
900116e2:	7abb      	ldrb	r3, [r7, #10]
900116e4:	9300      	str	r3, [sp, #0]
900116e6:	7afb      	ldrb	r3, [r7, #11]
900116e8:	f7f9 fec2 	bl	9000b470 <ip4_output_if_src>
  if (q != p) {
900116ec:	42b5      	cmp	r5, r6
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
900116ee:	4604      	mov	r4, r0
  if (q != p) {
900116f0:	d091      	beq.n	90011616 <udp_sendto_if_src+0x26>
    pbuf_free(q);
900116f2:	4628      	mov	r0, r5
900116f4:	f7fb fad4 	bl	9000cca0 <pbuf_free>
    q = NULL;
900116f8:	e78d      	b.n	90011616 <udp_sendto_if_src+0x26>
900116fa:	4635      	mov	r5, r6
900116fc:	e7d0      	b.n	900116a0 <udp_sendto_if_src+0xb0>
900116fe:	bf00      	nop
90011700:	900158a0 	.word	0x900158a0
90011704:	9001595d 	.word	0x9001595d
90011708:	90012aff 	.word	0x90012aff
9001170c:	9001597c 	.word	0x9001597c
90011710:	9001599c 	.word	0x9001599c
90011714:	900159be 	.word	0x900159be
90011718:	900159e0 	.word	0x900159e0
9001171c:	90015a01 	.word	0x90015a01

90011720 <udp_sendto_if>:
{
90011720:	b573      	push	{r0, r1, r4, r5, r6, lr}
90011722:	9c06      	ldr	r4, [sp, #24]
  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
90011724:	b950      	cbnz	r0, 9001173c <udp_sendto_if+0x1c>
90011726:	4b18      	ldr	r3, [pc, #96]	; (90011788 <udp_sendto_if+0x68>)
90011728:	f44f 7220 	mov.w	r2, #640	; 0x280
9001172c:	4917      	ldr	r1, [pc, #92]	; (9001178c <udp_sendto_if+0x6c>)
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
9001172e:	4818      	ldr	r0, [pc, #96]	; (90011790 <udp_sendto_if+0x70>)
90011730:	f000 fa3c 	bl	90011bac <iprintf>
90011734:	f06f 000f 	mvn.w	r0, #15
}
90011738:	b002      	add	sp, #8
9001173a:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
9001173c:	b921      	cbnz	r1, 90011748 <udp_sendto_if+0x28>
9001173e:	4b12      	ldr	r3, [pc, #72]	; (90011788 <udp_sendto_if+0x68>)
90011740:	f240 2281 	movw	r2, #641	; 0x281
90011744:	4913      	ldr	r1, [pc, #76]	; (90011794 <udp_sendto_if+0x74>)
90011746:	e7f2      	b.n	9001172e <udp_sendto_if+0xe>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
90011748:	b922      	cbnz	r2, 90011754 <udp_sendto_if+0x34>
9001174a:	4b0f      	ldr	r3, [pc, #60]	; (90011788 <udp_sendto_if+0x68>)
9001174c:	f240 2282 	movw	r2, #642	; 0x282
90011750:	4911      	ldr	r1, [pc, #68]	; (90011798 <udp_sendto_if+0x78>)
90011752:	e7ec      	b.n	9001172e <udp_sendto_if+0xe>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
90011754:	b924      	cbnz	r4, 90011760 <udp_sendto_if+0x40>
90011756:	4b0c      	ldr	r3, [pc, #48]	; (90011788 <udp_sendto_if+0x68>)
90011758:	f240 2283 	movw	r2, #643	; 0x283
9001175c:	490f      	ldr	r1, [pc, #60]	; (9001179c <udp_sendto_if+0x7c>)
9001175e:	e7e6      	b.n	9001172e <udp_sendto_if+0xe>
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
90011760:	6805      	ldr	r5, [r0, #0]
90011762:	b11d      	cbz	r5, 9001176c <udp_sendto_if+0x4c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
90011764:	f005 06f0 	and.w	r6, r5, #240	; 0xf0
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
90011768:	2ee0      	cmp	r6, #224	; 0xe0
9001176a:	d105      	bne.n	90011778 <udp_sendto_if+0x58>
      src_ip = netif_ip_addr4(netif);
9001176c:	1d25      	adds	r5, r4, #4
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
9001176e:	e9cd 4500 	strd	r4, r5, [sp]
90011772:	f7ff ff3d 	bl	900115f0 <udp_sendto_if_src>
90011776:	e7df      	b.n	90011738 <udp_sendto_if+0x18>
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
90011778:	6866      	ldr	r6, [r4, #4]
9001177a:	42b5      	cmp	r5, r6
9001177c:	d101      	bne.n	90011782 <udp_sendto_if+0x62>
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
9001177e:	4605      	mov	r5, r0
90011780:	e7f5      	b.n	9001176e <udp_sendto_if+0x4e>
        return ERR_RTE;
90011782:	f06f 0003 	mvn.w	r0, #3
90011786:	e7d7      	b.n	90011738 <udp_sendto_if+0x18>
90011788:	900158a0 	.word	0x900158a0
9001178c:	90015a2f 	.word	0x90015a2f
90011790:	90012aff 	.word	0x90012aff
90011794:	90015a4a 	.word	0x90015a4a
90011798:	90015a66 	.word	0x90015a66
9001179c:	90015a84 	.word	0x90015a84

900117a0 <udp_sendto>:
{
900117a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
900117a2:	460e      	mov	r6, r1
900117a4:	4615      	mov	r5, r2
900117a6:	461f      	mov	r7, r3
  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
900117a8:	4604      	mov	r4, r0
900117aa:	b950      	cbnz	r0, 900117c2 <udp_sendto+0x22>
900117ac:	4b15      	ldr	r3, [pc, #84]	; (90011804 <udp_sendto+0x64>)
900117ae:	f44f 7206 	mov.w	r2, #536	; 0x218
900117b2:	4915      	ldr	r1, [pc, #84]	; (90011808 <udp_sendto+0x68>)
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
900117b4:	4815      	ldr	r0, [pc, #84]	; (9001180c <udp_sendto+0x6c>)
900117b6:	f000 f9f9 	bl	90011bac <iprintf>
900117ba:	f06f 000f 	mvn.w	r0, #15
}
900117be:	b003      	add	sp, #12
900117c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
900117c2:	b921      	cbnz	r1, 900117ce <udp_sendto+0x2e>
900117c4:	4b0f      	ldr	r3, [pc, #60]	; (90011804 <udp_sendto+0x64>)
900117c6:	f240 2219 	movw	r2, #537	; 0x219
900117ca:	4911      	ldr	r1, [pc, #68]	; (90011810 <udp_sendto+0x70>)
900117cc:	e7f2      	b.n	900117b4 <udp_sendto+0x14>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
900117ce:	b922      	cbnz	r2, 900117da <udp_sendto+0x3a>
900117d0:	4b0c      	ldr	r3, [pc, #48]	; (90011804 <udp_sendto+0x64>)
900117d2:	f240 221a 	movw	r2, #538	; 0x21a
900117d6:	490f      	ldr	r1, [pc, #60]	; (90011814 <udp_sendto+0x74>)
900117d8:	e7ec      	b.n	900117b4 <udp_sendto+0x14>
  if (pcb->netif_idx != NETIF_NO_INDEX) {
900117da:	7a00      	ldrb	r0, [r0, #8]
900117dc:	b150      	cbz	r0, 900117f4 <udp_sendto+0x54>
    netif = netif_get_by_index(pcb->netif_idx);
900117de:	f7fa ff8f 	bl	9000c700 <netif_get_by_index>
  if (netif == NULL) {
900117e2:	b158      	cbz	r0, 900117fc <udp_sendto+0x5c>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
900117e4:	9000      	str	r0, [sp, #0]
900117e6:	463b      	mov	r3, r7
900117e8:	462a      	mov	r2, r5
900117ea:	4631      	mov	r1, r6
900117ec:	4620      	mov	r0, r4
900117ee:	f7ff ff97 	bl	90011720 <udp_sendto_if>
900117f2:	e7e4      	b.n	900117be <udp_sendto+0x1e>
      netif = ip_route(&pcb->local_ip, dst_ip);
900117f4:	4610      	mov	r0, r2
900117f6:	f7f9 fd49 	bl	9000b28c <ip4_route>
900117fa:	e7f2      	b.n	900117e2 <udp_sendto+0x42>
    return ERR_RTE;
900117fc:	f06f 0003 	mvn.w	r0, #3
90011800:	e7dd      	b.n	900117be <udp_sendto+0x1e>
90011802:	bf00      	nop
90011804:	900158a0 	.word	0x900158a0
90011808:	90015aa1 	.word	0x90015aa1
9001180c:	90012aff 	.word	0x90012aff
90011810:	90015ab9 	.word	0x90015ab9
90011814:	90015ad2 	.word	0x90015ad2

90011818 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
90011818:	b570      	push	{r4, r5, r6, lr}
9001181a:	460d      	mov	r5, r1
9001181c:	4616      	mov	r6, r2
  struct udp_pcb *ipcb;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
9001181e:	4604      	mov	r4, r0
90011820:	b948      	cbnz	r0, 90011836 <udp_connect+0x1e>
90011822:	4b16      	ldr	r3, [pc, #88]	; (9001187c <udp_connect+0x64>)
90011824:	f240 4235 	movw	r2, #1077	; 0x435
90011828:	4915      	ldr	r1, [pc, #84]	; (90011880 <udp_connect+0x68>)
  LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
9001182a:	4816      	ldr	r0, [pc, #88]	; (90011884 <udp_connect+0x6c>)
9001182c:	f000 f9be 	bl	90011bac <iprintf>
90011830:	f06f 000f 	mvn.w	r0, #15
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
90011834:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
90011836:	b921      	cbnz	r1, 90011842 <udp_connect+0x2a>
90011838:	4b10      	ldr	r3, [pc, #64]	; (9001187c <udp_connect+0x64>)
9001183a:	f240 4236 	movw	r2, #1078	; 0x436
9001183e:	4912      	ldr	r1, [pc, #72]	; (90011888 <udp_connect+0x70>)
90011840:	e7f3      	b.n	9001182a <udp_connect+0x12>
  if (pcb->local_port == 0) {
90011842:	8a42      	ldrh	r2, [r0, #18]
90011844:	b16a      	cbz	r2, 90011862 <udp_connect+0x4a>
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
90011846:	682b      	ldr	r3, [r5, #0]
  pcb->remote_port = port;
90011848:	82a6      	strh	r6, [r4, #20]
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
9001184a:	6063      	str	r3, [r4, #4]
  pcb->flags |= UDP_FLAGS_CONNECTED;
9001184c:	7c23      	ldrb	r3, [r4, #16]
9001184e:	f043 0304 	orr.w	r3, r3, #4
90011852:	7423      	strb	r3, [r4, #16]
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
90011854:	4b0d      	ldr	r3, [pc, #52]	; (9001188c <udp_connect+0x74>)
90011856:	681a      	ldr	r2, [r3, #0]
90011858:	4610      	mov	r0, r2
9001185a:	b940      	cbnz	r0, 9001186e <udp_connect+0x56>
  pcb->next = udp_pcbs;
9001185c:	60e2      	str	r2, [r4, #12]
  udp_pcbs = pcb;
9001185e:	601c      	str	r4, [r3, #0]
  return ERR_OK;
90011860:	e7e8      	b.n	90011834 <udp_connect+0x1c>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
90011862:	4601      	mov	r1, r0
90011864:	f7ff fe5e 	bl	90011524 <udp_bind>
    if (err != ERR_OK) {
90011868:	2800      	cmp	r0, #0
9001186a:	d0ec      	beq.n	90011846 <udp_connect+0x2e>
9001186c:	e7e2      	b.n	90011834 <udp_connect+0x1c>
    if (pcb == ipcb) {
9001186e:	42a0      	cmp	r0, r4
90011870:	d001      	beq.n	90011876 <udp_connect+0x5e>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
90011872:	68c0      	ldr	r0, [r0, #12]
90011874:	e7f1      	b.n	9001185a <udp_connect+0x42>
      return ERR_OK;
90011876:	2000      	movs	r0, #0
90011878:	e7dc      	b.n	90011834 <udp_connect+0x1c>
9001187a:	bf00      	nop
9001187c:	900158a0 	.word	0x900158a0
90011880:	90015aed 	.word	0x90015aed
90011884:	90012aff 	.word	0x90012aff
90011888:	90015b06 	.word	0x90015b06
9001188c:	2400d428 	.word	0x2400d428

90011890 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
90011890:	b930      	cbnz	r0, 900118a0 <udp_recv+0x10>
90011892:	4b05      	ldr	r3, [pc, #20]	; (900118a8 <udp_recv+0x18>)
90011894:	f240 428a 	movw	r2, #1162	; 0x48a
90011898:	4904      	ldr	r1, [pc, #16]	; (900118ac <udp_recv+0x1c>)
9001189a:	4805      	ldr	r0, [pc, #20]	; (900118b0 <udp_recv+0x20>)
9001189c:	f000 b986 	b.w	90011bac <iprintf>

  /* remember recv() callback and user data */
  pcb->recv = recv;
  pcb->recv_arg = recv_arg;
900118a0:	e9c0 1206 	strd	r1, r2, [r0, #24]
}
900118a4:	4770      	bx	lr
900118a6:	bf00      	nop
900118a8:	900158a0 	.word	0x900158a0
900118ac:	90015b22 	.word	0x90015b22
900118b0:	90012aff 	.word	0x90012aff

900118b4 <udp_remove>:
{
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
900118b4:	4601      	mov	r1, r0
900118b6:	b930      	cbnz	r0, 900118c6 <udp_remove+0x12>
900118b8:	4b0d      	ldr	r3, [pc, #52]	; (900118f0 <udp_remove+0x3c>)
900118ba:	f240 42a1 	movw	r2, #1185	; 0x4a1
900118be:	490d      	ldr	r1, [pc, #52]	; (900118f4 <udp_remove+0x40>)
900118c0:	480d      	ldr	r0, [pc, #52]	; (900118f8 <udp_remove+0x44>)
900118c2:	f000 b973 	b.w	90011bac <iprintf>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
900118c6:	4a0d      	ldr	r2, [pc, #52]	; (900118fc <udp_remove+0x48>)
900118c8:	6813      	ldr	r3, [r2, #0]
900118ca:	4283      	cmp	r3, r0
900118cc:	d105      	bne.n	900118da <udp_remove+0x26>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
900118ce:	68c3      	ldr	r3, [r0, #12]
900118d0:	6013      	str	r3, [r2, #0]
        pcb2->next = pcb->next;
        break;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
900118d2:	2000      	movs	r0, #0
900118d4:	f7fa bdca 	b.w	9000c46c <memp_free>
900118d8:	4613      	mov	r3, r2
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
900118da:	2b00      	cmp	r3, #0
900118dc:	d0f9      	beq.n	900118d2 <udp_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
900118de:	68da      	ldr	r2, [r3, #12]
900118e0:	2a00      	cmp	r2, #0
900118e2:	d0f6      	beq.n	900118d2 <udp_remove+0x1e>
900118e4:	428a      	cmp	r2, r1
900118e6:	d1f7      	bne.n	900118d8 <udp_remove+0x24>
        pcb2->next = pcb->next;
900118e8:	68ca      	ldr	r2, [r1, #12]
900118ea:	60da      	str	r2, [r3, #12]
        break;
900118ec:	e7f1      	b.n	900118d2 <udp_remove+0x1e>
900118ee:	bf00      	nop
900118f0:	900158a0 	.word	0x900158a0
900118f4:	90015b38 	.word	0x90015b38
900118f8:	90012aff 	.word	0x90012aff
900118fc:	2400d428 	.word	0x2400d428

90011900 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
90011900:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
90011902:	2000      	movs	r0, #0
90011904:	f7fa fd82 	bl	9000c40c <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
90011908:	4604      	mov	r4, r0
9001190a:	b128      	cbz	r0, 90011918 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
9001190c:	2220      	movs	r2, #32
9001190e:	2100      	movs	r1, #0
90011910:	f000 f864 	bl	900119dc <memset>
    pcb->ttl = UDP_TTL;
90011914:	23ff      	movs	r3, #255	; 0xff
90011916:	72e3      	strb	r3, [r4, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
}
90011918:	4620      	mov	r0, r4
9001191a:	bd10      	pop	{r4, pc}

9001191c <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
9001191c:	b510      	push	{r4, lr}
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
9001191e:	b138      	cbz	r0, 90011930 <udp_netif_ip_addr_changed+0x14>
90011920:	6803      	ldr	r3, [r0, #0]
90011922:	b12b      	cbz	r3, 90011930 <udp_netif_ip_addr_changed+0x14>
90011924:	b121      	cbz	r1, 90011930 <udp_netif_ip_addr_changed+0x14>
90011926:	680b      	ldr	r3, [r1, #0]
90011928:	b113      	cbz	r3, 90011930 <udp_netif_ip_addr_changed+0x14>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
9001192a:	4b06      	ldr	r3, [pc, #24]	; (90011944 <udp_netif_ip_addr_changed+0x28>)
9001192c:	681b      	ldr	r3, [r3, #0]
9001192e:	b903      	cbnz	r3, 90011932 <udp_netif_ip_addr_changed+0x16>
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
      }
    }
  }
}
90011930:	bd10      	pop	{r4, pc}
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
90011932:	681c      	ldr	r4, [r3, #0]
90011934:	6802      	ldr	r2, [r0, #0]
90011936:	4294      	cmp	r4, r2
        ip_addr_copy(upcb->local_ip, *new_addr);
90011938:	bf04      	itt	eq
9001193a:	680a      	ldreq	r2, [r1, #0]
9001193c:	601a      	streq	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
9001193e:	68db      	ldr	r3, [r3, #12]
90011940:	e7f5      	b.n	9001192e <udp_netif_ip_addr_changed+0x12>
90011942:	bf00      	nop
90011944:	2400d428 	.word	0x2400d428

90011948 <__libc_init_array>:
90011948:	b570      	push	{r4, r5, r6, lr}
9001194a:	4d0d      	ldr	r5, [pc, #52]	; (90011980 <__libc_init_array+0x38>)
9001194c:	4c0d      	ldr	r4, [pc, #52]	; (90011984 <__libc_init_array+0x3c>)
9001194e:	1b64      	subs	r4, r4, r5
90011950:	10a4      	asrs	r4, r4, #2
90011952:	2600      	movs	r6, #0
90011954:	42a6      	cmp	r6, r4
90011956:	d109      	bne.n	9001196c <__libc_init_array+0x24>
90011958:	4d0b      	ldr	r5, [pc, #44]	; (90011988 <__libc_init_array+0x40>)
9001195a:	4c0c      	ldr	r4, [pc, #48]	; (9001198c <__libc_init_array+0x44>)
9001195c:	f001 f88c 	bl	90012a78 <_init>
90011960:	1b64      	subs	r4, r4, r5
90011962:	10a4      	asrs	r4, r4, #2
90011964:	2600      	movs	r6, #0
90011966:	42a6      	cmp	r6, r4
90011968:	d105      	bne.n	90011976 <__libc_init_array+0x2e>
9001196a:	bd70      	pop	{r4, r5, r6, pc}
9001196c:	f855 3b04 	ldr.w	r3, [r5], #4
90011970:	4798      	blx	r3
90011972:	3601      	adds	r6, #1
90011974:	e7ee      	b.n	90011954 <__libc_init_array+0xc>
90011976:	f855 3b04 	ldr.w	r3, [r5], #4
9001197a:	4798      	blx	r3
9001197c:	3601      	adds	r6, #1
9001197e:	e7f2      	b.n	90011966 <__libc_init_array+0x1e>
90011980:	90015c98 	.word	0x90015c98
90011984:	90015c98 	.word	0x90015c98
90011988:	90015c98 	.word	0x90015c98
9001198c:	90015c9c 	.word	0x90015c9c

90011990 <malloc>:
90011990:	4b02      	ldr	r3, [pc, #8]	; (9001199c <malloc+0xc>)
90011992:	4601      	mov	r1, r0
90011994:	6818      	ldr	r0, [r3, #0]
90011996:	f000 b895 	b.w	90011ac4 <_malloc_r>
9001199a:	bf00      	nop
9001199c:	24000038 	.word	0x24000038

900119a0 <memcmp>:
900119a0:	b510      	push	{r4, lr}
900119a2:	3901      	subs	r1, #1
900119a4:	4402      	add	r2, r0
900119a6:	4290      	cmp	r0, r2
900119a8:	d101      	bne.n	900119ae <memcmp+0xe>
900119aa:	2000      	movs	r0, #0
900119ac:	e005      	b.n	900119ba <memcmp+0x1a>
900119ae:	7803      	ldrb	r3, [r0, #0]
900119b0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
900119b4:	42a3      	cmp	r3, r4
900119b6:	d001      	beq.n	900119bc <memcmp+0x1c>
900119b8:	1b18      	subs	r0, r3, r4
900119ba:	bd10      	pop	{r4, pc}
900119bc:	3001      	adds	r0, #1
900119be:	e7f2      	b.n	900119a6 <memcmp+0x6>

900119c0 <memcpy>:
900119c0:	440a      	add	r2, r1
900119c2:	4291      	cmp	r1, r2
900119c4:	f100 33ff 	add.w	r3, r0, #4294967295
900119c8:	d100      	bne.n	900119cc <memcpy+0xc>
900119ca:	4770      	bx	lr
900119cc:	b510      	push	{r4, lr}
900119ce:	f811 4b01 	ldrb.w	r4, [r1], #1
900119d2:	f803 4f01 	strb.w	r4, [r3, #1]!
900119d6:	4291      	cmp	r1, r2
900119d8:	d1f9      	bne.n	900119ce <memcpy+0xe>
900119da:	bd10      	pop	{r4, pc}

900119dc <memset>:
900119dc:	4402      	add	r2, r0
900119de:	4603      	mov	r3, r0
900119e0:	4293      	cmp	r3, r2
900119e2:	d100      	bne.n	900119e6 <memset+0xa>
900119e4:	4770      	bx	lr
900119e6:	f803 1b01 	strb.w	r1, [r3], #1
900119ea:	e7f9      	b.n	900119e0 <memset+0x4>

900119ec <_free_r>:
900119ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
900119ee:	2900      	cmp	r1, #0
900119f0:	d044      	beq.n	90011a7c <_free_r+0x90>
900119f2:	f851 3c04 	ldr.w	r3, [r1, #-4]
900119f6:	9001      	str	r0, [sp, #4]
900119f8:	2b00      	cmp	r3, #0
900119fa:	f1a1 0404 	sub.w	r4, r1, #4
900119fe:	bfb8      	it	lt
90011a00:	18e4      	addlt	r4, r4, r3
90011a02:	f000 fa5f 	bl	90011ec4 <__malloc_lock>
90011a06:	4a1e      	ldr	r2, [pc, #120]	; (90011a80 <_free_r+0x94>)
90011a08:	9801      	ldr	r0, [sp, #4]
90011a0a:	6813      	ldr	r3, [r2, #0]
90011a0c:	b933      	cbnz	r3, 90011a1c <_free_r+0x30>
90011a0e:	6063      	str	r3, [r4, #4]
90011a10:	6014      	str	r4, [r2, #0]
90011a12:	b003      	add	sp, #12
90011a14:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
90011a18:	f000 ba5a 	b.w	90011ed0 <__malloc_unlock>
90011a1c:	42a3      	cmp	r3, r4
90011a1e:	d908      	bls.n	90011a32 <_free_r+0x46>
90011a20:	6825      	ldr	r5, [r4, #0]
90011a22:	1961      	adds	r1, r4, r5
90011a24:	428b      	cmp	r3, r1
90011a26:	bf01      	itttt	eq
90011a28:	6819      	ldreq	r1, [r3, #0]
90011a2a:	685b      	ldreq	r3, [r3, #4]
90011a2c:	1949      	addeq	r1, r1, r5
90011a2e:	6021      	streq	r1, [r4, #0]
90011a30:	e7ed      	b.n	90011a0e <_free_r+0x22>
90011a32:	461a      	mov	r2, r3
90011a34:	685b      	ldr	r3, [r3, #4]
90011a36:	b10b      	cbz	r3, 90011a3c <_free_r+0x50>
90011a38:	42a3      	cmp	r3, r4
90011a3a:	d9fa      	bls.n	90011a32 <_free_r+0x46>
90011a3c:	6811      	ldr	r1, [r2, #0]
90011a3e:	1855      	adds	r5, r2, r1
90011a40:	42a5      	cmp	r5, r4
90011a42:	d10b      	bne.n	90011a5c <_free_r+0x70>
90011a44:	6824      	ldr	r4, [r4, #0]
90011a46:	4421      	add	r1, r4
90011a48:	1854      	adds	r4, r2, r1
90011a4a:	42a3      	cmp	r3, r4
90011a4c:	6011      	str	r1, [r2, #0]
90011a4e:	d1e0      	bne.n	90011a12 <_free_r+0x26>
90011a50:	681c      	ldr	r4, [r3, #0]
90011a52:	685b      	ldr	r3, [r3, #4]
90011a54:	6053      	str	r3, [r2, #4]
90011a56:	4421      	add	r1, r4
90011a58:	6011      	str	r1, [r2, #0]
90011a5a:	e7da      	b.n	90011a12 <_free_r+0x26>
90011a5c:	d902      	bls.n	90011a64 <_free_r+0x78>
90011a5e:	230c      	movs	r3, #12
90011a60:	6003      	str	r3, [r0, #0]
90011a62:	e7d6      	b.n	90011a12 <_free_r+0x26>
90011a64:	6825      	ldr	r5, [r4, #0]
90011a66:	1961      	adds	r1, r4, r5
90011a68:	428b      	cmp	r3, r1
90011a6a:	bf04      	itt	eq
90011a6c:	6819      	ldreq	r1, [r3, #0]
90011a6e:	685b      	ldreq	r3, [r3, #4]
90011a70:	6063      	str	r3, [r4, #4]
90011a72:	bf04      	itt	eq
90011a74:	1949      	addeq	r1, r1, r5
90011a76:	6021      	streq	r1, [r4, #0]
90011a78:	6054      	str	r4, [r2, #4]
90011a7a:	e7ca      	b.n	90011a12 <_free_r+0x26>
90011a7c:	b003      	add	sp, #12
90011a7e:	bd30      	pop	{r4, r5, pc}
90011a80:	2400d42c 	.word	0x2400d42c

90011a84 <sbrk_aligned>:
90011a84:	b570      	push	{r4, r5, r6, lr}
90011a86:	4e0e      	ldr	r6, [pc, #56]	; (90011ac0 <sbrk_aligned+0x3c>)
90011a88:	460c      	mov	r4, r1
90011a8a:	6831      	ldr	r1, [r6, #0]
90011a8c:	4605      	mov	r5, r0
90011a8e:	b911      	cbnz	r1, 90011a96 <sbrk_aligned+0x12>
90011a90:	f000 f8e2 	bl	90011c58 <_sbrk_r>
90011a94:	6030      	str	r0, [r6, #0]
90011a96:	4621      	mov	r1, r4
90011a98:	4628      	mov	r0, r5
90011a9a:	f000 f8dd 	bl	90011c58 <_sbrk_r>
90011a9e:	1c43      	adds	r3, r0, #1
90011aa0:	d00a      	beq.n	90011ab8 <sbrk_aligned+0x34>
90011aa2:	1cc4      	adds	r4, r0, #3
90011aa4:	f024 0403 	bic.w	r4, r4, #3
90011aa8:	42a0      	cmp	r0, r4
90011aaa:	d007      	beq.n	90011abc <sbrk_aligned+0x38>
90011aac:	1a21      	subs	r1, r4, r0
90011aae:	4628      	mov	r0, r5
90011ab0:	f000 f8d2 	bl	90011c58 <_sbrk_r>
90011ab4:	3001      	adds	r0, #1
90011ab6:	d101      	bne.n	90011abc <sbrk_aligned+0x38>
90011ab8:	f04f 34ff 	mov.w	r4, #4294967295
90011abc:	4620      	mov	r0, r4
90011abe:	bd70      	pop	{r4, r5, r6, pc}
90011ac0:	2400d430 	.word	0x2400d430

90011ac4 <_malloc_r>:
90011ac4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90011ac8:	1ccd      	adds	r5, r1, #3
90011aca:	f025 0503 	bic.w	r5, r5, #3
90011ace:	3508      	adds	r5, #8
90011ad0:	2d0c      	cmp	r5, #12
90011ad2:	bf38      	it	cc
90011ad4:	250c      	movcc	r5, #12
90011ad6:	2d00      	cmp	r5, #0
90011ad8:	4607      	mov	r7, r0
90011ada:	db01      	blt.n	90011ae0 <_malloc_r+0x1c>
90011adc:	42a9      	cmp	r1, r5
90011ade:	d905      	bls.n	90011aec <_malloc_r+0x28>
90011ae0:	230c      	movs	r3, #12
90011ae2:	603b      	str	r3, [r7, #0]
90011ae4:	2600      	movs	r6, #0
90011ae6:	4630      	mov	r0, r6
90011ae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
90011aec:	4e2e      	ldr	r6, [pc, #184]	; (90011ba8 <_malloc_r+0xe4>)
90011aee:	f000 f9e9 	bl	90011ec4 <__malloc_lock>
90011af2:	6833      	ldr	r3, [r6, #0]
90011af4:	461c      	mov	r4, r3
90011af6:	bb34      	cbnz	r4, 90011b46 <_malloc_r+0x82>
90011af8:	4629      	mov	r1, r5
90011afa:	4638      	mov	r0, r7
90011afc:	f7ff ffc2 	bl	90011a84 <sbrk_aligned>
90011b00:	1c43      	adds	r3, r0, #1
90011b02:	4604      	mov	r4, r0
90011b04:	d14d      	bne.n	90011ba2 <_malloc_r+0xde>
90011b06:	6834      	ldr	r4, [r6, #0]
90011b08:	4626      	mov	r6, r4
90011b0a:	2e00      	cmp	r6, #0
90011b0c:	d140      	bne.n	90011b90 <_malloc_r+0xcc>
90011b0e:	6823      	ldr	r3, [r4, #0]
90011b10:	4631      	mov	r1, r6
90011b12:	4638      	mov	r0, r7
90011b14:	eb04 0803 	add.w	r8, r4, r3
90011b18:	f000 f89e 	bl	90011c58 <_sbrk_r>
90011b1c:	4580      	cmp	r8, r0
90011b1e:	d13a      	bne.n	90011b96 <_malloc_r+0xd2>
90011b20:	6821      	ldr	r1, [r4, #0]
90011b22:	3503      	adds	r5, #3
90011b24:	1a6d      	subs	r5, r5, r1
90011b26:	f025 0503 	bic.w	r5, r5, #3
90011b2a:	3508      	adds	r5, #8
90011b2c:	2d0c      	cmp	r5, #12
90011b2e:	bf38      	it	cc
90011b30:	250c      	movcc	r5, #12
90011b32:	4629      	mov	r1, r5
90011b34:	4638      	mov	r0, r7
90011b36:	f7ff ffa5 	bl	90011a84 <sbrk_aligned>
90011b3a:	3001      	adds	r0, #1
90011b3c:	d02b      	beq.n	90011b96 <_malloc_r+0xd2>
90011b3e:	6823      	ldr	r3, [r4, #0]
90011b40:	442b      	add	r3, r5
90011b42:	6023      	str	r3, [r4, #0]
90011b44:	e00e      	b.n	90011b64 <_malloc_r+0xa0>
90011b46:	6822      	ldr	r2, [r4, #0]
90011b48:	1b52      	subs	r2, r2, r5
90011b4a:	d41e      	bmi.n	90011b8a <_malloc_r+0xc6>
90011b4c:	2a0b      	cmp	r2, #11
90011b4e:	d916      	bls.n	90011b7e <_malloc_r+0xba>
90011b50:	1961      	adds	r1, r4, r5
90011b52:	42a3      	cmp	r3, r4
90011b54:	6025      	str	r5, [r4, #0]
90011b56:	bf18      	it	ne
90011b58:	6059      	strne	r1, [r3, #4]
90011b5a:	6863      	ldr	r3, [r4, #4]
90011b5c:	bf08      	it	eq
90011b5e:	6031      	streq	r1, [r6, #0]
90011b60:	5162      	str	r2, [r4, r5]
90011b62:	604b      	str	r3, [r1, #4]
90011b64:	4638      	mov	r0, r7
90011b66:	f104 060b 	add.w	r6, r4, #11
90011b6a:	f000 f9b1 	bl	90011ed0 <__malloc_unlock>
90011b6e:	f026 0607 	bic.w	r6, r6, #7
90011b72:	1d23      	adds	r3, r4, #4
90011b74:	1af2      	subs	r2, r6, r3
90011b76:	d0b6      	beq.n	90011ae6 <_malloc_r+0x22>
90011b78:	1b9b      	subs	r3, r3, r6
90011b7a:	50a3      	str	r3, [r4, r2]
90011b7c:	e7b3      	b.n	90011ae6 <_malloc_r+0x22>
90011b7e:	6862      	ldr	r2, [r4, #4]
90011b80:	42a3      	cmp	r3, r4
90011b82:	bf0c      	ite	eq
90011b84:	6032      	streq	r2, [r6, #0]
90011b86:	605a      	strne	r2, [r3, #4]
90011b88:	e7ec      	b.n	90011b64 <_malloc_r+0xa0>
90011b8a:	4623      	mov	r3, r4
90011b8c:	6864      	ldr	r4, [r4, #4]
90011b8e:	e7b2      	b.n	90011af6 <_malloc_r+0x32>
90011b90:	4634      	mov	r4, r6
90011b92:	6876      	ldr	r6, [r6, #4]
90011b94:	e7b9      	b.n	90011b0a <_malloc_r+0x46>
90011b96:	230c      	movs	r3, #12
90011b98:	603b      	str	r3, [r7, #0]
90011b9a:	4638      	mov	r0, r7
90011b9c:	f000 f998 	bl	90011ed0 <__malloc_unlock>
90011ba0:	e7a1      	b.n	90011ae6 <_malloc_r+0x22>
90011ba2:	6025      	str	r5, [r4, #0]
90011ba4:	e7de      	b.n	90011b64 <_malloc_r+0xa0>
90011ba6:	bf00      	nop
90011ba8:	2400d42c 	.word	0x2400d42c

90011bac <iprintf>:
90011bac:	b40f      	push	{r0, r1, r2, r3}
90011bae:	4b0a      	ldr	r3, [pc, #40]	; (90011bd8 <iprintf+0x2c>)
90011bb0:	b513      	push	{r0, r1, r4, lr}
90011bb2:	681c      	ldr	r4, [r3, #0]
90011bb4:	b124      	cbz	r4, 90011bc0 <iprintf+0x14>
90011bb6:	69a3      	ldr	r3, [r4, #24]
90011bb8:	b913      	cbnz	r3, 90011bc0 <iprintf+0x14>
90011bba:	4620      	mov	r0, r4
90011bbc:	f000 f8d2 	bl	90011d64 <__sinit>
90011bc0:	ab05      	add	r3, sp, #20
90011bc2:	9a04      	ldr	r2, [sp, #16]
90011bc4:	68a1      	ldr	r1, [r4, #8]
90011bc6:	9301      	str	r3, [sp, #4]
90011bc8:	4620      	mov	r0, r4
90011bca:	f000 f9b1 	bl	90011f30 <_vfiprintf_r>
90011bce:	b002      	add	sp, #8
90011bd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
90011bd4:	b004      	add	sp, #16
90011bd6:	4770      	bx	lr
90011bd8:	24000038 	.word	0x24000038

90011bdc <rand>:
90011bdc:	4b16      	ldr	r3, [pc, #88]	; (90011c38 <rand+0x5c>)
90011bde:	b510      	push	{r4, lr}
90011be0:	681c      	ldr	r4, [r3, #0]
90011be2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90011be4:	b9b3      	cbnz	r3, 90011c14 <rand+0x38>
90011be6:	2018      	movs	r0, #24
90011be8:	f7ff fed2 	bl	90011990 <malloc>
90011bec:	63a0      	str	r0, [r4, #56]	; 0x38
90011bee:	b928      	cbnz	r0, 90011bfc <rand+0x20>
90011bf0:	4602      	mov	r2, r0
90011bf2:	4b12      	ldr	r3, [pc, #72]	; (90011c3c <rand+0x60>)
90011bf4:	4812      	ldr	r0, [pc, #72]	; (90011c40 <rand+0x64>)
90011bf6:	214e      	movs	r1, #78	; 0x4e
90011bf8:	f000 f83e 	bl	90011c78 <__assert_func>
90011bfc:	4a11      	ldr	r2, [pc, #68]	; (90011c44 <rand+0x68>)
90011bfe:	4b12      	ldr	r3, [pc, #72]	; (90011c48 <rand+0x6c>)
90011c00:	e9c0 2300 	strd	r2, r3, [r0]
90011c04:	4b11      	ldr	r3, [pc, #68]	; (90011c4c <rand+0x70>)
90011c06:	6083      	str	r3, [r0, #8]
90011c08:	230b      	movs	r3, #11
90011c0a:	8183      	strh	r3, [r0, #12]
90011c0c:	2201      	movs	r2, #1
90011c0e:	2300      	movs	r3, #0
90011c10:	e9c0 2304 	strd	r2, r3, [r0, #16]
90011c14:	6ba4      	ldr	r4, [r4, #56]	; 0x38
90011c16:	4a0e      	ldr	r2, [pc, #56]	; (90011c50 <rand+0x74>)
90011c18:	6920      	ldr	r0, [r4, #16]
90011c1a:	6963      	ldr	r3, [r4, #20]
90011c1c:	490d      	ldr	r1, [pc, #52]	; (90011c54 <rand+0x78>)
90011c1e:	4342      	muls	r2, r0
90011c20:	fb01 2203 	mla	r2, r1, r3, r2
90011c24:	fba0 0101 	umull	r0, r1, r0, r1
90011c28:	1c43      	adds	r3, r0, #1
90011c2a:	eb42 0001 	adc.w	r0, r2, r1
90011c2e:	e9c4 3004 	strd	r3, r0, [r4, #16]
90011c32:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
90011c36:	bd10      	pop	{r4, pc}
90011c38:	24000038 	.word	0x24000038
90011c3c:	90015b54 	.word	0x90015b54
90011c40:	90015b6b 	.word	0x90015b6b
90011c44:	abcd330e 	.word	0xabcd330e
90011c48:	e66d1234 	.word	0xe66d1234
90011c4c:	0005deec 	.word	0x0005deec
90011c50:	5851f42d 	.word	0x5851f42d
90011c54:	4c957f2d 	.word	0x4c957f2d

90011c58 <_sbrk_r>:
90011c58:	b538      	push	{r3, r4, r5, lr}
90011c5a:	4d06      	ldr	r5, [pc, #24]	; (90011c74 <_sbrk_r+0x1c>)
90011c5c:	2300      	movs	r3, #0
90011c5e:	4604      	mov	r4, r0
90011c60:	4608      	mov	r0, r1
90011c62:	602b      	str	r3, [r5, #0]
90011c64:	f7ee ff74 	bl	90000b50 <_sbrk>
90011c68:	1c43      	adds	r3, r0, #1
90011c6a:	d102      	bne.n	90011c72 <_sbrk_r+0x1a>
90011c6c:	682b      	ldr	r3, [r5, #0]
90011c6e:	b103      	cbz	r3, 90011c72 <_sbrk_r+0x1a>
90011c70:	6023      	str	r3, [r4, #0]
90011c72:	bd38      	pop	{r3, r4, r5, pc}
90011c74:	2400d3a8 	.word	0x2400d3a8

90011c78 <__assert_func>:
90011c78:	b51f      	push	{r0, r1, r2, r3, r4, lr}
90011c7a:	4614      	mov	r4, r2
90011c7c:	461a      	mov	r2, r3
90011c7e:	4b09      	ldr	r3, [pc, #36]	; (90011ca4 <__assert_func+0x2c>)
90011c80:	681b      	ldr	r3, [r3, #0]
90011c82:	4605      	mov	r5, r0
90011c84:	68d8      	ldr	r0, [r3, #12]
90011c86:	b14c      	cbz	r4, 90011c9c <__assert_func+0x24>
90011c88:	4b07      	ldr	r3, [pc, #28]	; (90011ca8 <__assert_func+0x30>)
90011c8a:	9100      	str	r1, [sp, #0]
90011c8c:	e9cd 3401 	strd	r3, r4, [sp, #4]
90011c90:	4906      	ldr	r1, [pc, #24]	; (90011cac <__assert_func+0x34>)
90011c92:	462b      	mov	r3, r5
90011c94:	f000 f8e4 	bl	90011e60 <fiprintf>
90011c98:	f000 fd24 	bl	900126e4 <abort>
90011c9c:	4b04      	ldr	r3, [pc, #16]	; (90011cb0 <__assert_func+0x38>)
90011c9e:	461c      	mov	r4, r3
90011ca0:	e7f3      	b.n	90011c8a <__assert_func+0x12>
90011ca2:	bf00      	nop
90011ca4:	24000038 	.word	0x24000038
90011ca8:	90015bc6 	.word	0x90015bc6
90011cac:	90015bd3 	.word	0x90015bd3
90011cb0:	90014a99 	.word	0x90014a99

90011cb4 <std>:
90011cb4:	2300      	movs	r3, #0
90011cb6:	b510      	push	{r4, lr}
90011cb8:	4604      	mov	r4, r0
90011cba:	e9c0 3300 	strd	r3, r3, [r0]
90011cbe:	e9c0 3304 	strd	r3, r3, [r0, #16]
90011cc2:	6083      	str	r3, [r0, #8]
90011cc4:	8181      	strh	r1, [r0, #12]
90011cc6:	6643      	str	r3, [r0, #100]	; 0x64
90011cc8:	81c2      	strh	r2, [r0, #14]
90011cca:	6183      	str	r3, [r0, #24]
90011ccc:	4619      	mov	r1, r3
90011cce:	2208      	movs	r2, #8
90011cd0:	305c      	adds	r0, #92	; 0x5c
90011cd2:	f7ff fe83 	bl	900119dc <memset>
90011cd6:	4b05      	ldr	r3, [pc, #20]	; (90011cec <std+0x38>)
90011cd8:	6263      	str	r3, [r4, #36]	; 0x24
90011cda:	4b05      	ldr	r3, [pc, #20]	; (90011cf0 <std+0x3c>)
90011cdc:	62a3      	str	r3, [r4, #40]	; 0x28
90011cde:	4b05      	ldr	r3, [pc, #20]	; (90011cf4 <std+0x40>)
90011ce0:	62e3      	str	r3, [r4, #44]	; 0x2c
90011ce2:	4b05      	ldr	r3, [pc, #20]	; (90011cf8 <std+0x44>)
90011ce4:	6224      	str	r4, [r4, #32]
90011ce6:	6323      	str	r3, [r4, #48]	; 0x30
90011ce8:	bd10      	pop	{r4, pc}
90011cea:	bf00      	nop
90011cec:	900124b9 	.word	0x900124b9
90011cf0:	900124db 	.word	0x900124db
90011cf4:	90012513 	.word	0x90012513
90011cf8:	90012537 	.word	0x90012537

90011cfc <_cleanup_r>:
90011cfc:	4901      	ldr	r1, [pc, #4]	; (90011d04 <_cleanup_r+0x8>)
90011cfe:	f000 b8c1 	b.w	90011e84 <_fwalk_reent>
90011d02:	bf00      	nop
90011d04:	90012821 	.word	0x90012821

90011d08 <__sfmoreglue>:
90011d08:	b570      	push	{r4, r5, r6, lr}
90011d0a:	2268      	movs	r2, #104	; 0x68
90011d0c:	1e4d      	subs	r5, r1, #1
90011d0e:	4355      	muls	r5, r2
90011d10:	460e      	mov	r6, r1
90011d12:	f105 0174 	add.w	r1, r5, #116	; 0x74
90011d16:	f7ff fed5 	bl	90011ac4 <_malloc_r>
90011d1a:	4604      	mov	r4, r0
90011d1c:	b140      	cbz	r0, 90011d30 <__sfmoreglue+0x28>
90011d1e:	2100      	movs	r1, #0
90011d20:	e9c0 1600 	strd	r1, r6, [r0]
90011d24:	300c      	adds	r0, #12
90011d26:	60a0      	str	r0, [r4, #8]
90011d28:	f105 0268 	add.w	r2, r5, #104	; 0x68
90011d2c:	f7ff fe56 	bl	900119dc <memset>
90011d30:	4620      	mov	r0, r4
90011d32:	bd70      	pop	{r4, r5, r6, pc}

90011d34 <__sfp_lock_acquire>:
90011d34:	4801      	ldr	r0, [pc, #4]	; (90011d3c <__sfp_lock_acquire+0x8>)
90011d36:	f7ef bc59 	b.w	900015ec <__retarget_lock_acquire_recursive>
90011d3a:	bf00      	nop
90011d3c:	24004da8 	.word	0x24004da8

90011d40 <__sfp_lock_release>:
90011d40:	4801      	ldr	r0, [pc, #4]	; (90011d48 <__sfp_lock_release+0x8>)
90011d42:	f7ef bc5f 	b.w	90001604 <__retarget_lock_release_recursive>
90011d46:	bf00      	nop
90011d48:	24004da8 	.word	0x24004da8

90011d4c <__sinit_lock_acquire>:
90011d4c:	4801      	ldr	r0, [pc, #4]	; (90011d54 <__sinit_lock_acquire+0x8>)
90011d4e:	f7ef bc4d 	b.w	900015ec <__retarget_lock_acquire_recursive>
90011d52:	bf00      	nop
90011d54:	24004db4 	.word	0x24004db4

90011d58 <__sinit_lock_release>:
90011d58:	4801      	ldr	r0, [pc, #4]	; (90011d60 <__sinit_lock_release+0x8>)
90011d5a:	f7ef bc53 	b.w	90001604 <__retarget_lock_release_recursive>
90011d5e:	bf00      	nop
90011d60:	24004db4 	.word	0x24004db4

90011d64 <__sinit>:
90011d64:	b510      	push	{r4, lr}
90011d66:	4604      	mov	r4, r0
90011d68:	f7ff fff0 	bl	90011d4c <__sinit_lock_acquire>
90011d6c:	69a3      	ldr	r3, [r4, #24]
90011d6e:	b11b      	cbz	r3, 90011d78 <__sinit+0x14>
90011d70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
90011d74:	f7ff bff0 	b.w	90011d58 <__sinit_lock_release>
90011d78:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
90011d7c:	6523      	str	r3, [r4, #80]	; 0x50
90011d7e:	4b13      	ldr	r3, [pc, #76]	; (90011dcc <__sinit+0x68>)
90011d80:	4a13      	ldr	r2, [pc, #76]	; (90011dd0 <__sinit+0x6c>)
90011d82:	681b      	ldr	r3, [r3, #0]
90011d84:	62a2      	str	r2, [r4, #40]	; 0x28
90011d86:	42a3      	cmp	r3, r4
90011d88:	bf04      	itt	eq
90011d8a:	2301      	moveq	r3, #1
90011d8c:	61a3      	streq	r3, [r4, #24]
90011d8e:	4620      	mov	r0, r4
90011d90:	f000 f820 	bl	90011dd4 <__sfp>
90011d94:	6060      	str	r0, [r4, #4]
90011d96:	4620      	mov	r0, r4
90011d98:	f000 f81c 	bl	90011dd4 <__sfp>
90011d9c:	60a0      	str	r0, [r4, #8]
90011d9e:	4620      	mov	r0, r4
90011da0:	f000 f818 	bl	90011dd4 <__sfp>
90011da4:	2200      	movs	r2, #0
90011da6:	60e0      	str	r0, [r4, #12]
90011da8:	2104      	movs	r1, #4
90011daa:	6860      	ldr	r0, [r4, #4]
90011dac:	f7ff ff82 	bl	90011cb4 <std>
90011db0:	68a0      	ldr	r0, [r4, #8]
90011db2:	2201      	movs	r2, #1
90011db4:	2109      	movs	r1, #9
90011db6:	f7ff ff7d 	bl	90011cb4 <std>
90011dba:	68e0      	ldr	r0, [r4, #12]
90011dbc:	2202      	movs	r2, #2
90011dbe:	2112      	movs	r1, #18
90011dc0:	f7ff ff78 	bl	90011cb4 <std>
90011dc4:	2301      	movs	r3, #1
90011dc6:	61a3      	str	r3, [r4, #24]
90011dc8:	e7d2      	b.n	90011d70 <__sinit+0xc>
90011dca:	bf00      	nop
90011dcc:	90015b50 	.word	0x90015b50
90011dd0:	90011cfd 	.word	0x90011cfd

90011dd4 <__sfp>:
90011dd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90011dd6:	4607      	mov	r7, r0
90011dd8:	f7ff ffac 	bl	90011d34 <__sfp_lock_acquire>
90011ddc:	4b1e      	ldr	r3, [pc, #120]	; (90011e58 <__sfp+0x84>)
90011dde:	681e      	ldr	r6, [r3, #0]
90011de0:	69b3      	ldr	r3, [r6, #24]
90011de2:	b913      	cbnz	r3, 90011dea <__sfp+0x16>
90011de4:	4630      	mov	r0, r6
90011de6:	f7ff ffbd 	bl	90011d64 <__sinit>
90011dea:	3648      	adds	r6, #72	; 0x48
90011dec:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
90011df0:	3b01      	subs	r3, #1
90011df2:	d503      	bpl.n	90011dfc <__sfp+0x28>
90011df4:	6833      	ldr	r3, [r6, #0]
90011df6:	b30b      	cbz	r3, 90011e3c <__sfp+0x68>
90011df8:	6836      	ldr	r6, [r6, #0]
90011dfa:	e7f7      	b.n	90011dec <__sfp+0x18>
90011dfc:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
90011e00:	b9d5      	cbnz	r5, 90011e38 <__sfp+0x64>
90011e02:	4b16      	ldr	r3, [pc, #88]	; (90011e5c <__sfp+0x88>)
90011e04:	60e3      	str	r3, [r4, #12]
90011e06:	f104 0058 	add.w	r0, r4, #88	; 0x58
90011e0a:	6665      	str	r5, [r4, #100]	; 0x64
90011e0c:	f7ef fbcc 	bl	900015a8 <__retarget_lock_init_recursive>
90011e10:	f7ff ff96 	bl	90011d40 <__sfp_lock_release>
90011e14:	e9c4 5501 	strd	r5, r5, [r4, #4]
90011e18:	e9c4 5504 	strd	r5, r5, [r4, #16]
90011e1c:	6025      	str	r5, [r4, #0]
90011e1e:	61a5      	str	r5, [r4, #24]
90011e20:	2208      	movs	r2, #8
90011e22:	4629      	mov	r1, r5
90011e24:	f104 005c 	add.w	r0, r4, #92	; 0x5c
90011e28:	f7ff fdd8 	bl	900119dc <memset>
90011e2c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
90011e30:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
90011e34:	4620      	mov	r0, r4
90011e36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
90011e38:	3468      	adds	r4, #104	; 0x68
90011e3a:	e7d9      	b.n	90011df0 <__sfp+0x1c>
90011e3c:	2104      	movs	r1, #4
90011e3e:	4638      	mov	r0, r7
90011e40:	f7ff ff62 	bl	90011d08 <__sfmoreglue>
90011e44:	4604      	mov	r4, r0
90011e46:	6030      	str	r0, [r6, #0]
90011e48:	2800      	cmp	r0, #0
90011e4a:	d1d5      	bne.n	90011df8 <__sfp+0x24>
90011e4c:	f7ff ff78 	bl	90011d40 <__sfp_lock_release>
90011e50:	230c      	movs	r3, #12
90011e52:	603b      	str	r3, [r7, #0]
90011e54:	e7ee      	b.n	90011e34 <__sfp+0x60>
90011e56:	bf00      	nop
90011e58:	90015b50 	.word	0x90015b50
90011e5c:	ffff0001 	.word	0xffff0001

90011e60 <fiprintf>:
90011e60:	b40e      	push	{r1, r2, r3}
90011e62:	b503      	push	{r0, r1, lr}
90011e64:	4601      	mov	r1, r0
90011e66:	ab03      	add	r3, sp, #12
90011e68:	4805      	ldr	r0, [pc, #20]	; (90011e80 <fiprintf+0x20>)
90011e6a:	f853 2b04 	ldr.w	r2, [r3], #4
90011e6e:	6800      	ldr	r0, [r0, #0]
90011e70:	9301      	str	r3, [sp, #4]
90011e72:	f000 f85d 	bl	90011f30 <_vfiprintf_r>
90011e76:	b002      	add	sp, #8
90011e78:	f85d eb04 	ldr.w	lr, [sp], #4
90011e7c:	b003      	add	sp, #12
90011e7e:	4770      	bx	lr
90011e80:	24000038 	.word	0x24000038

90011e84 <_fwalk_reent>:
90011e84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
90011e88:	4606      	mov	r6, r0
90011e8a:	4688      	mov	r8, r1
90011e8c:	f100 0448 	add.w	r4, r0, #72	; 0x48
90011e90:	2700      	movs	r7, #0
90011e92:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
90011e96:	f1b9 0901 	subs.w	r9, r9, #1
90011e9a:	d505      	bpl.n	90011ea8 <_fwalk_reent+0x24>
90011e9c:	6824      	ldr	r4, [r4, #0]
90011e9e:	2c00      	cmp	r4, #0
90011ea0:	d1f7      	bne.n	90011e92 <_fwalk_reent+0xe>
90011ea2:	4638      	mov	r0, r7
90011ea4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
90011ea8:	89ab      	ldrh	r3, [r5, #12]
90011eaa:	2b01      	cmp	r3, #1
90011eac:	d907      	bls.n	90011ebe <_fwalk_reent+0x3a>
90011eae:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
90011eb2:	3301      	adds	r3, #1
90011eb4:	d003      	beq.n	90011ebe <_fwalk_reent+0x3a>
90011eb6:	4629      	mov	r1, r5
90011eb8:	4630      	mov	r0, r6
90011eba:	47c0      	blx	r8
90011ebc:	4307      	orrs	r7, r0
90011ebe:	3568      	adds	r5, #104	; 0x68
90011ec0:	e7e9      	b.n	90011e96 <_fwalk_reent+0x12>
	...

90011ec4 <__malloc_lock>:
90011ec4:	4801      	ldr	r0, [pc, #4]	; (90011ecc <__malloc_lock+0x8>)
90011ec6:	f7ef bb91 	b.w	900015ec <__retarget_lock_acquire_recursive>
90011eca:	bf00      	nop
90011ecc:	24004d9c 	.word	0x24004d9c

90011ed0 <__malloc_unlock>:
90011ed0:	4801      	ldr	r0, [pc, #4]	; (90011ed8 <__malloc_unlock+0x8>)
90011ed2:	f7ef bb97 	b.w	90001604 <__retarget_lock_release_recursive>
90011ed6:	bf00      	nop
90011ed8:	24004d9c 	.word	0x24004d9c

90011edc <__sfputc_r>:
90011edc:	6893      	ldr	r3, [r2, #8]
90011ede:	3b01      	subs	r3, #1
90011ee0:	2b00      	cmp	r3, #0
90011ee2:	b410      	push	{r4}
90011ee4:	6093      	str	r3, [r2, #8]
90011ee6:	da08      	bge.n	90011efa <__sfputc_r+0x1e>
90011ee8:	6994      	ldr	r4, [r2, #24]
90011eea:	42a3      	cmp	r3, r4
90011eec:	db01      	blt.n	90011ef2 <__sfputc_r+0x16>
90011eee:	290a      	cmp	r1, #10
90011ef0:	d103      	bne.n	90011efa <__sfputc_r+0x1e>
90011ef2:	f85d 4b04 	ldr.w	r4, [sp], #4
90011ef6:	f000 bb23 	b.w	90012540 <__swbuf_r>
90011efa:	6813      	ldr	r3, [r2, #0]
90011efc:	1c58      	adds	r0, r3, #1
90011efe:	6010      	str	r0, [r2, #0]
90011f00:	7019      	strb	r1, [r3, #0]
90011f02:	4608      	mov	r0, r1
90011f04:	f85d 4b04 	ldr.w	r4, [sp], #4
90011f08:	4770      	bx	lr

90011f0a <__sfputs_r>:
90011f0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90011f0c:	4606      	mov	r6, r0
90011f0e:	460f      	mov	r7, r1
90011f10:	4614      	mov	r4, r2
90011f12:	18d5      	adds	r5, r2, r3
90011f14:	42ac      	cmp	r4, r5
90011f16:	d101      	bne.n	90011f1c <__sfputs_r+0x12>
90011f18:	2000      	movs	r0, #0
90011f1a:	e007      	b.n	90011f2c <__sfputs_r+0x22>
90011f1c:	f814 1b01 	ldrb.w	r1, [r4], #1
90011f20:	463a      	mov	r2, r7
90011f22:	4630      	mov	r0, r6
90011f24:	f7ff ffda 	bl	90011edc <__sfputc_r>
90011f28:	1c43      	adds	r3, r0, #1
90011f2a:	d1f3      	bne.n	90011f14 <__sfputs_r+0xa>
90011f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

90011f30 <_vfiprintf_r>:
90011f30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90011f34:	460d      	mov	r5, r1
90011f36:	b09d      	sub	sp, #116	; 0x74
90011f38:	4614      	mov	r4, r2
90011f3a:	4698      	mov	r8, r3
90011f3c:	4606      	mov	r6, r0
90011f3e:	b118      	cbz	r0, 90011f48 <_vfiprintf_r+0x18>
90011f40:	6983      	ldr	r3, [r0, #24]
90011f42:	b90b      	cbnz	r3, 90011f48 <_vfiprintf_r+0x18>
90011f44:	f7ff ff0e 	bl	90011d64 <__sinit>
90011f48:	4b89      	ldr	r3, [pc, #548]	; (90012170 <_vfiprintf_r+0x240>)
90011f4a:	429d      	cmp	r5, r3
90011f4c:	d11b      	bne.n	90011f86 <_vfiprintf_r+0x56>
90011f4e:	6875      	ldr	r5, [r6, #4]
90011f50:	6e6b      	ldr	r3, [r5, #100]	; 0x64
90011f52:	07d9      	lsls	r1, r3, #31
90011f54:	d405      	bmi.n	90011f62 <_vfiprintf_r+0x32>
90011f56:	89ab      	ldrh	r3, [r5, #12]
90011f58:	059a      	lsls	r2, r3, #22
90011f5a:	d402      	bmi.n	90011f62 <_vfiprintf_r+0x32>
90011f5c:	6da8      	ldr	r0, [r5, #88]	; 0x58
90011f5e:	f7ef fb45 	bl	900015ec <__retarget_lock_acquire_recursive>
90011f62:	89ab      	ldrh	r3, [r5, #12]
90011f64:	071b      	lsls	r3, r3, #28
90011f66:	d501      	bpl.n	90011f6c <_vfiprintf_r+0x3c>
90011f68:	692b      	ldr	r3, [r5, #16]
90011f6a:	b9eb      	cbnz	r3, 90011fa8 <_vfiprintf_r+0x78>
90011f6c:	4629      	mov	r1, r5
90011f6e:	4630      	mov	r0, r6
90011f70:	f000 fb4a 	bl	90012608 <__swsetup_r>
90011f74:	b1c0      	cbz	r0, 90011fa8 <_vfiprintf_r+0x78>
90011f76:	6e6b      	ldr	r3, [r5, #100]	; 0x64
90011f78:	07dc      	lsls	r4, r3, #31
90011f7a:	d50e      	bpl.n	90011f9a <_vfiprintf_r+0x6a>
90011f7c:	f04f 30ff 	mov.w	r0, #4294967295
90011f80:	b01d      	add	sp, #116	; 0x74
90011f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
90011f86:	4b7b      	ldr	r3, [pc, #492]	; (90012174 <_vfiprintf_r+0x244>)
90011f88:	429d      	cmp	r5, r3
90011f8a:	d101      	bne.n	90011f90 <_vfiprintf_r+0x60>
90011f8c:	68b5      	ldr	r5, [r6, #8]
90011f8e:	e7df      	b.n	90011f50 <_vfiprintf_r+0x20>
90011f90:	4b79      	ldr	r3, [pc, #484]	; (90012178 <_vfiprintf_r+0x248>)
90011f92:	429d      	cmp	r5, r3
90011f94:	bf08      	it	eq
90011f96:	68f5      	ldreq	r5, [r6, #12]
90011f98:	e7da      	b.n	90011f50 <_vfiprintf_r+0x20>
90011f9a:	89ab      	ldrh	r3, [r5, #12]
90011f9c:	0598      	lsls	r0, r3, #22
90011f9e:	d4ed      	bmi.n	90011f7c <_vfiprintf_r+0x4c>
90011fa0:	6da8      	ldr	r0, [r5, #88]	; 0x58
90011fa2:	f7ef fb2f 	bl	90001604 <__retarget_lock_release_recursive>
90011fa6:	e7e9      	b.n	90011f7c <_vfiprintf_r+0x4c>
90011fa8:	2300      	movs	r3, #0
90011faa:	9309      	str	r3, [sp, #36]	; 0x24
90011fac:	2320      	movs	r3, #32
90011fae:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
90011fb2:	f8cd 800c 	str.w	r8, [sp, #12]
90011fb6:	2330      	movs	r3, #48	; 0x30
90011fb8:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 9001217c <_vfiprintf_r+0x24c>
90011fbc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
90011fc0:	f04f 0901 	mov.w	r9, #1
90011fc4:	4623      	mov	r3, r4
90011fc6:	469a      	mov	sl, r3
90011fc8:	f813 2b01 	ldrb.w	r2, [r3], #1
90011fcc:	b10a      	cbz	r2, 90011fd2 <_vfiprintf_r+0xa2>
90011fce:	2a25      	cmp	r2, #37	; 0x25
90011fd0:	d1f9      	bne.n	90011fc6 <_vfiprintf_r+0x96>
90011fd2:	ebba 0b04 	subs.w	fp, sl, r4
90011fd6:	d00b      	beq.n	90011ff0 <_vfiprintf_r+0xc0>
90011fd8:	465b      	mov	r3, fp
90011fda:	4622      	mov	r2, r4
90011fdc:	4629      	mov	r1, r5
90011fde:	4630      	mov	r0, r6
90011fe0:	f7ff ff93 	bl	90011f0a <__sfputs_r>
90011fe4:	3001      	adds	r0, #1
90011fe6:	f000 80aa 	beq.w	9001213e <_vfiprintf_r+0x20e>
90011fea:	9a09      	ldr	r2, [sp, #36]	; 0x24
90011fec:	445a      	add	r2, fp
90011fee:	9209      	str	r2, [sp, #36]	; 0x24
90011ff0:	f89a 3000 	ldrb.w	r3, [sl]
90011ff4:	2b00      	cmp	r3, #0
90011ff6:	f000 80a2 	beq.w	9001213e <_vfiprintf_r+0x20e>
90011ffa:	2300      	movs	r3, #0
90011ffc:	f04f 32ff 	mov.w	r2, #4294967295
90012000:	e9cd 2305 	strd	r2, r3, [sp, #20]
90012004:	f10a 0a01 	add.w	sl, sl, #1
90012008:	9304      	str	r3, [sp, #16]
9001200a:	9307      	str	r3, [sp, #28]
9001200c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
90012010:	931a      	str	r3, [sp, #104]	; 0x68
90012012:	4654      	mov	r4, sl
90012014:	2205      	movs	r2, #5
90012016:	f814 1b01 	ldrb.w	r1, [r4], #1
9001201a:	4858      	ldr	r0, [pc, #352]	; (9001217c <_vfiprintf_r+0x24c>)
9001201c:	f7ee f968 	bl	900002f0 <memchr>
90012020:	9a04      	ldr	r2, [sp, #16]
90012022:	b9d8      	cbnz	r0, 9001205c <_vfiprintf_r+0x12c>
90012024:	06d1      	lsls	r1, r2, #27
90012026:	bf44      	itt	mi
90012028:	2320      	movmi	r3, #32
9001202a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
9001202e:	0713      	lsls	r3, r2, #28
90012030:	bf44      	itt	mi
90012032:	232b      	movmi	r3, #43	; 0x2b
90012034:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
90012038:	f89a 3000 	ldrb.w	r3, [sl]
9001203c:	2b2a      	cmp	r3, #42	; 0x2a
9001203e:	d015      	beq.n	9001206c <_vfiprintf_r+0x13c>
90012040:	9a07      	ldr	r2, [sp, #28]
90012042:	4654      	mov	r4, sl
90012044:	2000      	movs	r0, #0
90012046:	f04f 0c0a 	mov.w	ip, #10
9001204a:	4621      	mov	r1, r4
9001204c:	f811 3b01 	ldrb.w	r3, [r1], #1
90012050:	3b30      	subs	r3, #48	; 0x30
90012052:	2b09      	cmp	r3, #9
90012054:	d94e      	bls.n	900120f4 <_vfiprintf_r+0x1c4>
90012056:	b1b0      	cbz	r0, 90012086 <_vfiprintf_r+0x156>
90012058:	9207      	str	r2, [sp, #28]
9001205a:	e014      	b.n	90012086 <_vfiprintf_r+0x156>
9001205c:	eba0 0308 	sub.w	r3, r0, r8
90012060:	fa09 f303 	lsl.w	r3, r9, r3
90012064:	4313      	orrs	r3, r2
90012066:	9304      	str	r3, [sp, #16]
90012068:	46a2      	mov	sl, r4
9001206a:	e7d2      	b.n	90012012 <_vfiprintf_r+0xe2>
9001206c:	9b03      	ldr	r3, [sp, #12]
9001206e:	1d19      	adds	r1, r3, #4
90012070:	681b      	ldr	r3, [r3, #0]
90012072:	9103      	str	r1, [sp, #12]
90012074:	2b00      	cmp	r3, #0
90012076:	bfbb      	ittet	lt
90012078:	425b      	neglt	r3, r3
9001207a:	f042 0202 	orrlt.w	r2, r2, #2
9001207e:	9307      	strge	r3, [sp, #28]
90012080:	9307      	strlt	r3, [sp, #28]
90012082:	bfb8      	it	lt
90012084:	9204      	strlt	r2, [sp, #16]
90012086:	7823      	ldrb	r3, [r4, #0]
90012088:	2b2e      	cmp	r3, #46	; 0x2e
9001208a:	d10c      	bne.n	900120a6 <_vfiprintf_r+0x176>
9001208c:	7863      	ldrb	r3, [r4, #1]
9001208e:	2b2a      	cmp	r3, #42	; 0x2a
90012090:	d135      	bne.n	900120fe <_vfiprintf_r+0x1ce>
90012092:	9b03      	ldr	r3, [sp, #12]
90012094:	1d1a      	adds	r2, r3, #4
90012096:	681b      	ldr	r3, [r3, #0]
90012098:	9203      	str	r2, [sp, #12]
9001209a:	2b00      	cmp	r3, #0
9001209c:	bfb8      	it	lt
9001209e:	f04f 33ff 	movlt.w	r3, #4294967295
900120a2:	3402      	adds	r4, #2
900120a4:	9305      	str	r3, [sp, #20]
900120a6:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 9001218c <_vfiprintf_r+0x25c>
900120aa:	7821      	ldrb	r1, [r4, #0]
900120ac:	2203      	movs	r2, #3
900120ae:	4650      	mov	r0, sl
900120b0:	f7ee f91e 	bl	900002f0 <memchr>
900120b4:	b140      	cbz	r0, 900120c8 <_vfiprintf_r+0x198>
900120b6:	2340      	movs	r3, #64	; 0x40
900120b8:	eba0 000a 	sub.w	r0, r0, sl
900120bc:	fa03 f000 	lsl.w	r0, r3, r0
900120c0:	9b04      	ldr	r3, [sp, #16]
900120c2:	4303      	orrs	r3, r0
900120c4:	3401      	adds	r4, #1
900120c6:	9304      	str	r3, [sp, #16]
900120c8:	f814 1b01 	ldrb.w	r1, [r4], #1
900120cc:	482c      	ldr	r0, [pc, #176]	; (90012180 <_vfiprintf_r+0x250>)
900120ce:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
900120d2:	2206      	movs	r2, #6
900120d4:	f7ee f90c 	bl	900002f0 <memchr>
900120d8:	2800      	cmp	r0, #0
900120da:	d03f      	beq.n	9001215c <_vfiprintf_r+0x22c>
900120dc:	4b29      	ldr	r3, [pc, #164]	; (90012184 <_vfiprintf_r+0x254>)
900120de:	bb1b      	cbnz	r3, 90012128 <_vfiprintf_r+0x1f8>
900120e0:	9b03      	ldr	r3, [sp, #12]
900120e2:	3307      	adds	r3, #7
900120e4:	f023 0307 	bic.w	r3, r3, #7
900120e8:	3308      	adds	r3, #8
900120ea:	9303      	str	r3, [sp, #12]
900120ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
900120ee:	443b      	add	r3, r7
900120f0:	9309      	str	r3, [sp, #36]	; 0x24
900120f2:	e767      	b.n	90011fc4 <_vfiprintf_r+0x94>
900120f4:	fb0c 3202 	mla	r2, ip, r2, r3
900120f8:	460c      	mov	r4, r1
900120fa:	2001      	movs	r0, #1
900120fc:	e7a5      	b.n	9001204a <_vfiprintf_r+0x11a>
900120fe:	2300      	movs	r3, #0
90012100:	3401      	adds	r4, #1
90012102:	9305      	str	r3, [sp, #20]
90012104:	4619      	mov	r1, r3
90012106:	f04f 0c0a 	mov.w	ip, #10
9001210a:	4620      	mov	r0, r4
9001210c:	f810 2b01 	ldrb.w	r2, [r0], #1
90012110:	3a30      	subs	r2, #48	; 0x30
90012112:	2a09      	cmp	r2, #9
90012114:	d903      	bls.n	9001211e <_vfiprintf_r+0x1ee>
90012116:	2b00      	cmp	r3, #0
90012118:	d0c5      	beq.n	900120a6 <_vfiprintf_r+0x176>
9001211a:	9105      	str	r1, [sp, #20]
9001211c:	e7c3      	b.n	900120a6 <_vfiprintf_r+0x176>
9001211e:	fb0c 2101 	mla	r1, ip, r1, r2
90012122:	4604      	mov	r4, r0
90012124:	2301      	movs	r3, #1
90012126:	e7f0      	b.n	9001210a <_vfiprintf_r+0x1da>
90012128:	ab03      	add	r3, sp, #12
9001212a:	9300      	str	r3, [sp, #0]
9001212c:	462a      	mov	r2, r5
9001212e:	4b16      	ldr	r3, [pc, #88]	; (90012188 <_vfiprintf_r+0x258>)
90012130:	a904      	add	r1, sp, #16
90012132:	4630      	mov	r0, r6
90012134:	f3af 8000 	nop.w
90012138:	4607      	mov	r7, r0
9001213a:	1c78      	adds	r0, r7, #1
9001213c:	d1d6      	bne.n	900120ec <_vfiprintf_r+0x1bc>
9001213e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
90012140:	07d9      	lsls	r1, r3, #31
90012142:	d405      	bmi.n	90012150 <_vfiprintf_r+0x220>
90012144:	89ab      	ldrh	r3, [r5, #12]
90012146:	059a      	lsls	r2, r3, #22
90012148:	d402      	bmi.n	90012150 <_vfiprintf_r+0x220>
9001214a:	6da8      	ldr	r0, [r5, #88]	; 0x58
9001214c:	f7ef fa5a 	bl	90001604 <__retarget_lock_release_recursive>
90012150:	89ab      	ldrh	r3, [r5, #12]
90012152:	065b      	lsls	r3, r3, #25
90012154:	f53f af12 	bmi.w	90011f7c <_vfiprintf_r+0x4c>
90012158:	9809      	ldr	r0, [sp, #36]	; 0x24
9001215a:	e711      	b.n	90011f80 <_vfiprintf_r+0x50>
9001215c:	ab03      	add	r3, sp, #12
9001215e:	9300      	str	r3, [sp, #0]
90012160:	462a      	mov	r2, r5
90012162:	4b09      	ldr	r3, [pc, #36]	; (90012188 <_vfiprintf_r+0x258>)
90012164:	a904      	add	r1, sp, #16
90012166:	4630      	mov	r0, r6
90012168:	f000 f880 	bl	9001226c <_printf_i>
9001216c:	e7e4      	b.n	90012138 <_vfiprintf_r+0x208>
9001216e:	bf00      	nop
90012170:	90015c24 	.word	0x90015c24
90012174:	90015c44 	.word	0x90015c44
90012178:	90015c04 	.word	0x90015c04
9001217c:	90015c64 	.word	0x90015c64
90012180:	90015c6e 	.word	0x90015c6e
90012184:	00000000 	.word	0x00000000
90012188:	90011f0b 	.word	0x90011f0b
9001218c:	90015c6a 	.word	0x90015c6a

90012190 <_printf_common>:
90012190:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
90012194:	4616      	mov	r6, r2
90012196:	4699      	mov	r9, r3
90012198:	688a      	ldr	r2, [r1, #8]
9001219a:	690b      	ldr	r3, [r1, #16]
9001219c:	f8dd 8020 	ldr.w	r8, [sp, #32]
900121a0:	4293      	cmp	r3, r2
900121a2:	bfb8      	it	lt
900121a4:	4613      	movlt	r3, r2
900121a6:	6033      	str	r3, [r6, #0]
900121a8:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
900121ac:	4607      	mov	r7, r0
900121ae:	460c      	mov	r4, r1
900121b0:	b10a      	cbz	r2, 900121b6 <_printf_common+0x26>
900121b2:	3301      	adds	r3, #1
900121b4:	6033      	str	r3, [r6, #0]
900121b6:	6823      	ldr	r3, [r4, #0]
900121b8:	0699      	lsls	r1, r3, #26
900121ba:	bf42      	ittt	mi
900121bc:	6833      	ldrmi	r3, [r6, #0]
900121be:	3302      	addmi	r3, #2
900121c0:	6033      	strmi	r3, [r6, #0]
900121c2:	6825      	ldr	r5, [r4, #0]
900121c4:	f015 0506 	ands.w	r5, r5, #6
900121c8:	d106      	bne.n	900121d8 <_printf_common+0x48>
900121ca:	f104 0a19 	add.w	sl, r4, #25
900121ce:	68e3      	ldr	r3, [r4, #12]
900121d0:	6832      	ldr	r2, [r6, #0]
900121d2:	1a9b      	subs	r3, r3, r2
900121d4:	42ab      	cmp	r3, r5
900121d6:	dc26      	bgt.n	90012226 <_printf_common+0x96>
900121d8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
900121dc:	1e13      	subs	r3, r2, #0
900121de:	6822      	ldr	r2, [r4, #0]
900121e0:	bf18      	it	ne
900121e2:	2301      	movne	r3, #1
900121e4:	0692      	lsls	r2, r2, #26
900121e6:	d42b      	bmi.n	90012240 <_printf_common+0xb0>
900121e8:	f104 0243 	add.w	r2, r4, #67	; 0x43
900121ec:	4649      	mov	r1, r9
900121ee:	4638      	mov	r0, r7
900121f0:	47c0      	blx	r8
900121f2:	3001      	adds	r0, #1
900121f4:	d01e      	beq.n	90012234 <_printf_common+0xa4>
900121f6:	6823      	ldr	r3, [r4, #0]
900121f8:	68e5      	ldr	r5, [r4, #12]
900121fa:	6832      	ldr	r2, [r6, #0]
900121fc:	f003 0306 	and.w	r3, r3, #6
90012200:	2b04      	cmp	r3, #4
90012202:	bf08      	it	eq
90012204:	1aad      	subeq	r5, r5, r2
90012206:	68a3      	ldr	r3, [r4, #8]
90012208:	6922      	ldr	r2, [r4, #16]
9001220a:	bf0c      	ite	eq
9001220c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
90012210:	2500      	movne	r5, #0
90012212:	4293      	cmp	r3, r2
90012214:	bfc4      	itt	gt
90012216:	1a9b      	subgt	r3, r3, r2
90012218:	18ed      	addgt	r5, r5, r3
9001221a:	2600      	movs	r6, #0
9001221c:	341a      	adds	r4, #26
9001221e:	42b5      	cmp	r5, r6
90012220:	d11a      	bne.n	90012258 <_printf_common+0xc8>
90012222:	2000      	movs	r0, #0
90012224:	e008      	b.n	90012238 <_printf_common+0xa8>
90012226:	2301      	movs	r3, #1
90012228:	4652      	mov	r2, sl
9001222a:	4649      	mov	r1, r9
9001222c:	4638      	mov	r0, r7
9001222e:	47c0      	blx	r8
90012230:	3001      	adds	r0, #1
90012232:	d103      	bne.n	9001223c <_printf_common+0xac>
90012234:	f04f 30ff 	mov.w	r0, #4294967295
90012238:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
9001223c:	3501      	adds	r5, #1
9001223e:	e7c6      	b.n	900121ce <_printf_common+0x3e>
90012240:	18e1      	adds	r1, r4, r3
90012242:	1c5a      	adds	r2, r3, #1
90012244:	2030      	movs	r0, #48	; 0x30
90012246:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
9001224a:	4422      	add	r2, r4
9001224c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
90012250:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
90012254:	3302      	adds	r3, #2
90012256:	e7c7      	b.n	900121e8 <_printf_common+0x58>
90012258:	2301      	movs	r3, #1
9001225a:	4622      	mov	r2, r4
9001225c:	4649      	mov	r1, r9
9001225e:	4638      	mov	r0, r7
90012260:	47c0      	blx	r8
90012262:	3001      	adds	r0, #1
90012264:	d0e6      	beq.n	90012234 <_printf_common+0xa4>
90012266:	3601      	adds	r6, #1
90012268:	e7d9      	b.n	9001221e <_printf_common+0x8e>
	...

9001226c <_printf_i>:
9001226c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
90012270:	7e0f      	ldrb	r7, [r1, #24]
90012272:	9d0c      	ldr	r5, [sp, #48]	; 0x30
90012274:	2f78      	cmp	r7, #120	; 0x78
90012276:	4691      	mov	r9, r2
90012278:	4680      	mov	r8, r0
9001227a:	460c      	mov	r4, r1
9001227c:	469a      	mov	sl, r3
9001227e:	f101 0243 	add.w	r2, r1, #67	; 0x43
90012282:	d807      	bhi.n	90012294 <_printf_i+0x28>
90012284:	2f62      	cmp	r7, #98	; 0x62
90012286:	d80a      	bhi.n	9001229e <_printf_i+0x32>
90012288:	2f00      	cmp	r7, #0
9001228a:	f000 80d8 	beq.w	9001243e <_printf_i+0x1d2>
9001228e:	2f58      	cmp	r7, #88	; 0x58
90012290:	f000 80a3 	beq.w	900123da <_printf_i+0x16e>
90012294:	f104 0542 	add.w	r5, r4, #66	; 0x42
90012298:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
9001229c:	e03a      	b.n	90012314 <_printf_i+0xa8>
9001229e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
900122a2:	2b15      	cmp	r3, #21
900122a4:	d8f6      	bhi.n	90012294 <_printf_i+0x28>
900122a6:	a101      	add	r1, pc, #4	; (adr r1, 900122ac <_printf_i+0x40>)
900122a8:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
900122ac:	90012305 	.word	0x90012305
900122b0:	90012319 	.word	0x90012319
900122b4:	90012295 	.word	0x90012295
900122b8:	90012295 	.word	0x90012295
900122bc:	90012295 	.word	0x90012295
900122c0:	90012295 	.word	0x90012295
900122c4:	90012319 	.word	0x90012319
900122c8:	90012295 	.word	0x90012295
900122cc:	90012295 	.word	0x90012295
900122d0:	90012295 	.word	0x90012295
900122d4:	90012295 	.word	0x90012295
900122d8:	90012425 	.word	0x90012425
900122dc:	90012349 	.word	0x90012349
900122e0:	90012407 	.word	0x90012407
900122e4:	90012295 	.word	0x90012295
900122e8:	90012295 	.word	0x90012295
900122ec:	90012447 	.word	0x90012447
900122f0:	90012295 	.word	0x90012295
900122f4:	90012349 	.word	0x90012349
900122f8:	90012295 	.word	0x90012295
900122fc:	90012295 	.word	0x90012295
90012300:	9001240f 	.word	0x9001240f
90012304:	682b      	ldr	r3, [r5, #0]
90012306:	1d1a      	adds	r2, r3, #4
90012308:	681b      	ldr	r3, [r3, #0]
9001230a:	602a      	str	r2, [r5, #0]
9001230c:	f104 0542 	add.w	r5, r4, #66	; 0x42
90012310:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
90012314:	2301      	movs	r3, #1
90012316:	e0a3      	b.n	90012460 <_printf_i+0x1f4>
90012318:	6820      	ldr	r0, [r4, #0]
9001231a:	6829      	ldr	r1, [r5, #0]
9001231c:	0606      	lsls	r6, r0, #24
9001231e:	f101 0304 	add.w	r3, r1, #4
90012322:	d50a      	bpl.n	9001233a <_printf_i+0xce>
90012324:	680e      	ldr	r6, [r1, #0]
90012326:	602b      	str	r3, [r5, #0]
90012328:	2e00      	cmp	r6, #0
9001232a:	da03      	bge.n	90012334 <_printf_i+0xc8>
9001232c:	232d      	movs	r3, #45	; 0x2d
9001232e:	4276      	negs	r6, r6
90012330:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
90012334:	485e      	ldr	r0, [pc, #376]	; (900124b0 <_printf_i+0x244>)
90012336:	230a      	movs	r3, #10
90012338:	e019      	b.n	9001236e <_printf_i+0x102>
9001233a:	680e      	ldr	r6, [r1, #0]
9001233c:	602b      	str	r3, [r5, #0]
9001233e:	f010 0f40 	tst.w	r0, #64	; 0x40
90012342:	bf18      	it	ne
90012344:	b236      	sxthne	r6, r6
90012346:	e7ef      	b.n	90012328 <_printf_i+0xbc>
90012348:	682b      	ldr	r3, [r5, #0]
9001234a:	6820      	ldr	r0, [r4, #0]
9001234c:	1d19      	adds	r1, r3, #4
9001234e:	6029      	str	r1, [r5, #0]
90012350:	0601      	lsls	r1, r0, #24
90012352:	d501      	bpl.n	90012358 <_printf_i+0xec>
90012354:	681e      	ldr	r6, [r3, #0]
90012356:	e002      	b.n	9001235e <_printf_i+0xf2>
90012358:	0646      	lsls	r6, r0, #25
9001235a:	d5fb      	bpl.n	90012354 <_printf_i+0xe8>
9001235c:	881e      	ldrh	r6, [r3, #0]
9001235e:	4854      	ldr	r0, [pc, #336]	; (900124b0 <_printf_i+0x244>)
90012360:	2f6f      	cmp	r7, #111	; 0x6f
90012362:	bf0c      	ite	eq
90012364:	2308      	moveq	r3, #8
90012366:	230a      	movne	r3, #10
90012368:	2100      	movs	r1, #0
9001236a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
9001236e:	6865      	ldr	r5, [r4, #4]
90012370:	60a5      	str	r5, [r4, #8]
90012372:	2d00      	cmp	r5, #0
90012374:	bfa2      	ittt	ge
90012376:	6821      	ldrge	r1, [r4, #0]
90012378:	f021 0104 	bicge.w	r1, r1, #4
9001237c:	6021      	strge	r1, [r4, #0]
9001237e:	b90e      	cbnz	r6, 90012384 <_printf_i+0x118>
90012380:	2d00      	cmp	r5, #0
90012382:	d04d      	beq.n	90012420 <_printf_i+0x1b4>
90012384:	4615      	mov	r5, r2
90012386:	fbb6 f1f3 	udiv	r1, r6, r3
9001238a:	fb03 6711 	mls	r7, r3, r1, r6
9001238e:	5dc7      	ldrb	r7, [r0, r7]
90012390:	f805 7d01 	strb.w	r7, [r5, #-1]!
90012394:	4637      	mov	r7, r6
90012396:	42bb      	cmp	r3, r7
90012398:	460e      	mov	r6, r1
9001239a:	d9f4      	bls.n	90012386 <_printf_i+0x11a>
9001239c:	2b08      	cmp	r3, #8
9001239e:	d10b      	bne.n	900123b8 <_printf_i+0x14c>
900123a0:	6823      	ldr	r3, [r4, #0]
900123a2:	07de      	lsls	r6, r3, #31
900123a4:	d508      	bpl.n	900123b8 <_printf_i+0x14c>
900123a6:	6923      	ldr	r3, [r4, #16]
900123a8:	6861      	ldr	r1, [r4, #4]
900123aa:	4299      	cmp	r1, r3
900123ac:	bfde      	ittt	le
900123ae:	2330      	movle	r3, #48	; 0x30
900123b0:	f805 3c01 	strble.w	r3, [r5, #-1]
900123b4:	f105 35ff 	addle.w	r5, r5, #4294967295
900123b8:	1b52      	subs	r2, r2, r5
900123ba:	6122      	str	r2, [r4, #16]
900123bc:	f8cd a000 	str.w	sl, [sp]
900123c0:	464b      	mov	r3, r9
900123c2:	aa03      	add	r2, sp, #12
900123c4:	4621      	mov	r1, r4
900123c6:	4640      	mov	r0, r8
900123c8:	f7ff fee2 	bl	90012190 <_printf_common>
900123cc:	3001      	adds	r0, #1
900123ce:	d14c      	bne.n	9001246a <_printf_i+0x1fe>
900123d0:	f04f 30ff 	mov.w	r0, #4294967295
900123d4:	b004      	add	sp, #16
900123d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900123da:	4835      	ldr	r0, [pc, #212]	; (900124b0 <_printf_i+0x244>)
900123dc:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
900123e0:	6829      	ldr	r1, [r5, #0]
900123e2:	6823      	ldr	r3, [r4, #0]
900123e4:	f851 6b04 	ldr.w	r6, [r1], #4
900123e8:	6029      	str	r1, [r5, #0]
900123ea:	061d      	lsls	r5, r3, #24
900123ec:	d514      	bpl.n	90012418 <_printf_i+0x1ac>
900123ee:	07df      	lsls	r7, r3, #31
900123f0:	bf44      	itt	mi
900123f2:	f043 0320 	orrmi.w	r3, r3, #32
900123f6:	6023      	strmi	r3, [r4, #0]
900123f8:	b91e      	cbnz	r6, 90012402 <_printf_i+0x196>
900123fa:	6823      	ldr	r3, [r4, #0]
900123fc:	f023 0320 	bic.w	r3, r3, #32
90012400:	6023      	str	r3, [r4, #0]
90012402:	2310      	movs	r3, #16
90012404:	e7b0      	b.n	90012368 <_printf_i+0xfc>
90012406:	6823      	ldr	r3, [r4, #0]
90012408:	f043 0320 	orr.w	r3, r3, #32
9001240c:	6023      	str	r3, [r4, #0]
9001240e:	2378      	movs	r3, #120	; 0x78
90012410:	4828      	ldr	r0, [pc, #160]	; (900124b4 <_printf_i+0x248>)
90012412:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
90012416:	e7e3      	b.n	900123e0 <_printf_i+0x174>
90012418:	0659      	lsls	r1, r3, #25
9001241a:	bf48      	it	mi
9001241c:	b2b6      	uxthmi	r6, r6
9001241e:	e7e6      	b.n	900123ee <_printf_i+0x182>
90012420:	4615      	mov	r5, r2
90012422:	e7bb      	b.n	9001239c <_printf_i+0x130>
90012424:	682b      	ldr	r3, [r5, #0]
90012426:	6826      	ldr	r6, [r4, #0]
90012428:	6961      	ldr	r1, [r4, #20]
9001242a:	1d18      	adds	r0, r3, #4
9001242c:	6028      	str	r0, [r5, #0]
9001242e:	0635      	lsls	r5, r6, #24
90012430:	681b      	ldr	r3, [r3, #0]
90012432:	d501      	bpl.n	90012438 <_printf_i+0x1cc>
90012434:	6019      	str	r1, [r3, #0]
90012436:	e002      	b.n	9001243e <_printf_i+0x1d2>
90012438:	0670      	lsls	r0, r6, #25
9001243a:	d5fb      	bpl.n	90012434 <_printf_i+0x1c8>
9001243c:	8019      	strh	r1, [r3, #0]
9001243e:	2300      	movs	r3, #0
90012440:	6123      	str	r3, [r4, #16]
90012442:	4615      	mov	r5, r2
90012444:	e7ba      	b.n	900123bc <_printf_i+0x150>
90012446:	682b      	ldr	r3, [r5, #0]
90012448:	1d1a      	adds	r2, r3, #4
9001244a:	602a      	str	r2, [r5, #0]
9001244c:	681d      	ldr	r5, [r3, #0]
9001244e:	6862      	ldr	r2, [r4, #4]
90012450:	2100      	movs	r1, #0
90012452:	4628      	mov	r0, r5
90012454:	f7ed ff4c 	bl	900002f0 <memchr>
90012458:	b108      	cbz	r0, 9001245e <_printf_i+0x1f2>
9001245a:	1b40      	subs	r0, r0, r5
9001245c:	6060      	str	r0, [r4, #4]
9001245e:	6863      	ldr	r3, [r4, #4]
90012460:	6123      	str	r3, [r4, #16]
90012462:	2300      	movs	r3, #0
90012464:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
90012468:	e7a8      	b.n	900123bc <_printf_i+0x150>
9001246a:	6923      	ldr	r3, [r4, #16]
9001246c:	462a      	mov	r2, r5
9001246e:	4649      	mov	r1, r9
90012470:	4640      	mov	r0, r8
90012472:	47d0      	blx	sl
90012474:	3001      	adds	r0, #1
90012476:	d0ab      	beq.n	900123d0 <_printf_i+0x164>
90012478:	6823      	ldr	r3, [r4, #0]
9001247a:	079b      	lsls	r3, r3, #30
9001247c:	d413      	bmi.n	900124a6 <_printf_i+0x23a>
9001247e:	68e0      	ldr	r0, [r4, #12]
90012480:	9b03      	ldr	r3, [sp, #12]
90012482:	4298      	cmp	r0, r3
90012484:	bfb8      	it	lt
90012486:	4618      	movlt	r0, r3
90012488:	e7a4      	b.n	900123d4 <_printf_i+0x168>
9001248a:	2301      	movs	r3, #1
9001248c:	4632      	mov	r2, r6
9001248e:	4649      	mov	r1, r9
90012490:	4640      	mov	r0, r8
90012492:	47d0      	blx	sl
90012494:	3001      	adds	r0, #1
90012496:	d09b      	beq.n	900123d0 <_printf_i+0x164>
90012498:	3501      	adds	r5, #1
9001249a:	68e3      	ldr	r3, [r4, #12]
9001249c:	9903      	ldr	r1, [sp, #12]
9001249e:	1a5b      	subs	r3, r3, r1
900124a0:	42ab      	cmp	r3, r5
900124a2:	dcf2      	bgt.n	9001248a <_printf_i+0x21e>
900124a4:	e7eb      	b.n	9001247e <_printf_i+0x212>
900124a6:	2500      	movs	r5, #0
900124a8:	f104 0619 	add.w	r6, r4, #25
900124ac:	e7f5      	b.n	9001249a <_printf_i+0x22e>
900124ae:	bf00      	nop
900124b0:	90015c75 	.word	0x90015c75
900124b4:	90015c86 	.word	0x90015c86

900124b8 <__sread>:
900124b8:	b510      	push	{r4, lr}
900124ba:	460c      	mov	r4, r1
900124bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
900124c0:	f000 fa62 	bl	90012988 <_read_r>
900124c4:	2800      	cmp	r0, #0
900124c6:	bfab      	itete	ge
900124c8:	6d63      	ldrge	r3, [r4, #84]	; 0x54
900124ca:	89a3      	ldrhlt	r3, [r4, #12]
900124cc:	181b      	addge	r3, r3, r0
900124ce:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
900124d2:	bfac      	ite	ge
900124d4:	6563      	strge	r3, [r4, #84]	; 0x54
900124d6:	81a3      	strhlt	r3, [r4, #12]
900124d8:	bd10      	pop	{r4, pc}

900124da <__swrite>:
900124da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900124de:	461f      	mov	r7, r3
900124e0:	898b      	ldrh	r3, [r1, #12]
900124e2:	05db      	lsls	r3, r3, #23
900124e4:	4605      	mov	r5, r0
900124e6:	460c      	mov	r4, r1
900124e8:	4616      	mov	r6, r2
900124ea:	d505      	bpl.n	900124f8 <__swrite+0x1e>
900124ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
900124f0:	2302      	movs	r3, #2
900124f2:	2200      	movs	r2, #0
900124f4:	f000 f9d0 	bl	90012898 <_lseek_r>
900124f8:	89a3      	ldrh	r3, [r4, #12]
900124fa:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
900124fe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
90012502:	81a3      	strh	r3, [r4, #12]
90012504:	4632      	mov	r2, r6
90012506:	463b      	mov	r3, r7
90012508:	4628      	mov	r0, r5
9001250a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
9001250e:	f000 b869 	b.w	900125e4 <_write_r>

90012512 <__sseek>:
90012512:	b510      	push	{r4, lr}
90012514:	460c      	mov	r4, r1
90012516:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001251a:	f000 f9bd 	bl	90012898 <_lseek_r>
9001251e:	1c43      	adds	r3, r0, #1
90012520:	89a3      	ldrh	r3, [r4, #12]
90012522:	bf15      	itete	ne
90012524:	6560      	strne	r0, [r4, #84]	; 0x54
90012526:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
9001252a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
9001252e:	81a3      	strheq	r3, [r4, #12]
90012530:	bf18      	it	ne
90012532:	81a3      	strhne	r3, [r4, #12]
90012534:	bd10      	pop	{r4, pc}

90012536 <__sclose>:
90012536:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001253a:	f000 b8db 	b.w	900126f4 <_close_r>
	...

90012540 <__swbuf_r>:
90012540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90012542:	460e      	mov	r6, r1
90012544:	4614      	mov	r4, r2
90012546:	4605      	mov	r5, r0
90012548:	b118      	cbz	r0, 90012552 <__swbuf_r+0x12>
9001254a:	6983      	ldr	r3, [r0, #24]
9001254c:	b90b      	cbnz	r3, 90012552 <__swbuf_r+0x12>
9001254e:	f7ff fc09 	bl	90011d64 <__sinit>
90012552:	4b21      	ldr	r3, [pc, #132]	; (900125d8 <__swbuf_r+0x98>)
90012554:	429c      	cmp	r4, r3
90012556:	d12b      	bne.n	900125b0 <__swbuf_r+0x70>
90012558:	686c      	ldr	r4, [r5, #4]
9001255a:	69a3      	ldr	r3, [r4, #24]
9001255c:	60a3      	str	r3, [r4, #8]
9001255e:	89a3      	ldrh	r3, [r4, #12]
90012560:	071a      	lsls	r2, r3, #28
90012562:	d52f      	bpl.n	900125c4 <__swbuf_r+0x84>
90012564:	6923      	ldr	r3, [r4, #16]
90012566:	b36b      	cbz	r3, 900125c4 <__swbuf_r+0x84>
90012568:	6923      	ldr	r3, [r4, #16]
9001256a:	6820      	ldr	r0, [r4, #0]
9001256c:	1ac0      	subs	r0, r0, r3
9001256e:	6963      	ldr	r3, [r4, #20]
90012570:	b2f6      	uxtb	r6, r6
90012572:	4283      	cmp	r3, r0
90012574:	4637      	mov	r7, r6
90012576:	dc04      	bgt.n	90012582 <__swbuf_r+0x42>
90012578:	4621      	mov	r1, r4
9001257a:	4628      	mov	r0, r5
9001257c:	f000 f950 	bl	90012820 <_fflush_r>
90012580:	bb30      	cbnz	r0, 900125d0 <__swbuf_r+0x90>
90012582:	68a3      	ldr	r3, [r4, #8]
90012584:	3b01      	subs	r3, #1
90012586:	60a3      	str	r3, [r4, #8]
90012588:	6823      	ldr	r3, [r4, #0]
9001258a:	1c5a      	adds	r2, r3, #1
9001258c:	6022      	str	r2, [r4, #0]
9001258e:	701e      	strb	r6, [r3, #0]
90012590:	6963      	ldr	r3, [r4, #20]
90012592:	3001      	adds	r0, #1
90012594:	4283      	cmp	r3, r0
90012596:	d004      	beq.n	900125a2 <__swbuf_r+0x62>
90012598:	89a3      	ldrh	r3, [r4, #12]
9001259a:	07db      	lsls	r3, r3, #31
9001259c:	d506      	bpl.n	900125ac <__swbuf_r+0x6c>
9001259e:	2e0a      	cmp	r6, #10
900125a0:	d104      	bne.n	900125ac <__swbuf_r+0x6c>
900125a2:	4621      	mov	r1, r4
900125a4:	4628      	mov	r0, r5
900125a6:	f000 f93b 	bl	90012820 <_fflush_r>
900125aa:	b988      	cbnz	r0, 900125d0 <__swbuf_r+0x90>
900125ac:	4638      	mov	r0, r7
900125ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
900125b0:	4b0a      	ldr	r3, [pc, #40]	; (900125dc <__swbuf_r+0x9c>)
900125b2:	429c      	cmp	r4, r3
900125b4:	d101      	bne.n	900125ba <__swbuf_r+0x7a>
900125b6:	68ac      	ldr	r4, [r5, #8]
900125b8:	e7cf      	b.n	9001255a <__swbuf_r+0x1a>
900125ba:	4b09      	ldr	r3, [pc, #36]	; (900125e0 <__swbuf_r+0xa0>)
900125bc:	429c      	cmp	r4, r3
900125be:	bf08      	it	eq
900125c0:	68ec      	ldreq	r4, [r5, #12]
900125c2:	e7ca      	b.n	9001255a <__swbuf_r+0x1a>
900125c4:	4621      	mov	r1, r4
900125c6:	4628      	mov	r0, r5
900125c8:	f000 f81e 	bl	90012608 <__swsetup_r>
900125cc:	2800      	cmp	r0, #0
900125ce:	d0cb      	beq.n	90012568 <__swbuf_r+0x28>
900125d0:	f04f 37ff 	mov.w	r7, #4294967295
900125d4:	e7ea      	b.n	900125ac <__swbuf_r+0x6c>
900125d6:	bf00      	nop
900125d8:	90015c24 	.word	0x90015c24
900125dc:	90015c44 	.word	0x90015c44
900125e0:	90015c04 	.word	0x90015c04

900125e4 <_write_r>:
900125e4:	b538      	push	{r3, r4, r5, lr}
900125e6:	4d07      	ldr	r5, [pc, #28]	; (90012604 <_write_r+0x20>)
900125e8:	4604      	mov	r4, r0
900125ea:	4608      	mov	r0, r1
900125ec:	4611      	mov	r1, r2
900125ee:	2200      	movs	r2, #0
900125f0:	602a      	str	r2, [r5, #0]
900125f2:	461a      	mov	r2, r3
900125f4:	f7ee fa92 	bl	90000b1c <_write>
900125f8:	1c43      	adds	r3, r0, #1
900125fa:	d102      	bne.n	90012602 <_write_r+0x1e>
900125fc:	682b      	ldr	r3, [r5, #0]
900125fe:	b103      	cbz	r3, 90012602 <_write_r+0x1e>
90012600:	6023      	str	r3, [r4, #0]
90012602:	bd38      	pop	{r3, r4, r5, pc}
90012604:	2400d3a8 	.word	0x2400d3a8

90012608 <__swsetup_r>:
90012608:	4b32      	ldr	r3, [pc, #200]	; (900126d4 <__swsetup_r+0xcc>)
9001260a:	b570      	push	{r4, r5, r6, lr}
9001260c:	681d      	ldr	r5, [r3, #0]
9001260e:	4606      	mov	r6, r0
90012610:	460c      	mov	r4, r1
90012612:	b125      	cbz	r5, 9001261e <__swsetup_r+0x16>
90012614:	69ab      	ldr	r3, [r5, #24]
90012616:	b913      	cbnz	r3, 9001261e <__swsetup_r+0x16>
90012618:	4628      	mov	r0, r5
9001261a:	f7ff fba3 	bl	90011d64 <__sinit>
9001261e:	4b2e      	ldr	r3, [pc, #184]	; (900126d8 <__swsetup_r+0xd0>)
90012620:	429c      	cmp	r4, r3
90012622:	d10f      	bne.n	90012644 <__swsetup_r+0x3c>
90012624:	686c      	ldr	r4, [r5, #4]
90012626:	89a3      	ldrh	r3, [r4, #12]
90012628:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
9001262c:	0719      	lsls	r1, r3, #28
9001262e:	d42c      	bmi.n	9001268a <__swsetup_r+0x82>
90012630:	06dd      	lsls	r5, r3, #27
90012632:	d411      	bmi.n	90012658 <__swsetup_r+0x50>
90012634:	2309      	movs	r3, #9
90012636:	6033      	str	r3, [r6, #0]
90012638:	f042 0340 	orr.w	r3, r2, #64	; 0x40
9001263c:	81a3      	strh	r3, [r4, #12]
9001263e:	f04f 30ff 	mov.w	r0, #4294967295
90012642:	e03e      	b.n	900126c2 <__swsetup_r+0xba>
90012644:	4b25      	ldr	r3, [pc, #148]	; (900126dc <__swsetup_r+0xd4>)
90012646:	429c      	cmp	r4, r3
90012648:	d101      	bne.n	9001264e <__swsetup_r+0x46>
9001264a:	68ac      	ldr	r4, [r5, #8]
9001264c:	e7eb      	b.n	90012626 <__swsetup_r+0x1e>
9001264e:	4b24      	ldr	r3, [pc, #144]	; (900126e0 <__swsetup_r+0xd8>)
90012650:	429c      	cmp	r4, r3
90012652:	bf08      	it	eq
90012654:	68ec      	ldreq	r4, [r5, #12]
90012656:	e7e6      	b.n	90012626 <__swsetup_r+0x1e>
90012658:	0758      	lsls	r0, r3, #29
9001265a:	d512      	bpl.n	90012682 <__swsetup_r+0x7a>
9001265c:	6b61      	ldr	r1, [r4, #52]	; 0x34
9001265e:	b141      	cbz	r1, 90012672 <__swsetup_r+0x6a>
90012660:	f104 0344 	add.w	r3, r4, #68	; 0x44
90012664:	4299      	cmp	r1, r3
90012666:	d002      	beq.n	9001266e <__swsetup_r+0x66>
90012668:	4630      	mov	r0, r6
9001266a:	f7ff f9bf 	bl	900119ec <_free_r>
9001266e:	2300      	movs	r3, #0
90012670:	6363      	str	r3, [r4, #52]	; 0x34
90012672:	89a3      	ldrh	r3, [r4, #12]
90012674:	f023 0324 	bic.w	r3, r3, #36	; 0x24
90012678:	81a3      	strh	r3, [r4, #12]
9001267a:	2300      	movs	r3, #0
9001267c:	6063      	str	r3, [r4, #4]
9001267e:	6923      	ldr	r3, [r4, #16]
90012680:	6023      	str	r3, [r4, #0]
90012682:	89a3      	ldrh	r3, [r4, #12]
90012684:	f043 0308 	orr.w	r3, r3, #8
90012688:	81a3      	strh	r3, [r4, #12]
9001268a:	6923      	ldr	r3, [r4, #16]
9001268c:	b94b      	cbnz	r3, 900126a2 <__swsetup_r+0x9a>
9001268e:	89a3      	ldrh	r3, [r4, #12]
90012690:	f403 7320 	and.w	r3, r3, #640	; 0x280
90012694:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90012698:	d003      	beq.n	900126a2 <__swsetup_r+0x9a>
9001269a:	4621      	mov	r1, r4
9001269c:	4630      	mov	r0, r6
9001269e:	f000 f933 	bl	90012908 <__smakebuf_r>
900126a2:	89a0      	ldrh	r0, [r4, #12]
900126a4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
900126a8:	f010 0301 	ands.w	r3, r0, #1
900126ac:	d00a      	beq.n	900126c4 <__swsetup_r+0xbc>
900126ae:	2300      	movs	r3, #0
900126b0:	60a3      	str	r3, [r4, #8]
900126b2:	6963      	ldr	r3, [r4, #20]
900126b4:	425b      	negs	r3, r3
900126b6:	61a3      	str	r3, [r4, #24]
900126b8:	6923      	ldr	r3, [r4, #16]
900126ba:	b943      	cbnz	r3, 900126ce <__swsetup_r+0xc6>
900126bc:	f010 0080 	ands.w	r0, r0, #128	; 0x80
900126c0:	d1ba      	bne.n	90012638 <__swsetup_r+0x30>
900126c2:	bd70      	pop	{r4, r5, r6, pc}
900126c4:	0781      	lsls	r1, r0, #30
900126c6:	bf58      	it	pl
900126c8:	6963      	ldrpl	r3, [r4, #20]
900126ca:	60a3      	str	r3, [r4, #8]
900126cc:	e7f4      	b.n	900126b8 <__swsetup_r+0xb0>
900126ce:	2000      	movs	r0, #0
900126d0:	e7f7      	b.n	900126c2 <__swsetup_r+0xba>
900126d2:	bf00      	nop
900126d4:	24000038 	.word	0x24000038
900126d8:	90015c24 	.word	0x90015c24
900126dc:	90015c44 	.word	0x90015c44
900126e0:	90015c04 	.word	0x90015c04

900126e4 <abort>:
900126e4:	b508      	push	{r3, lr}
900126e6:	2006      	movs	r0, #6
900126e8:	f000 f988 	bl	900129fc <raise>
900126ec:	2001      	movs	r0, #1
900126ee:	f7ee fa01 	bl	90000af4 <_exit>
	...

900126f4 <_close_r>:
900126f4:	b538      	push	{r3, r4, r5, lr}
900126f6:	4d06      	ldr	r5, [pc, #24]	; (90012710 <_close_r+0x1c>)
900126f8:	2300      	movs	r3, #0
900126fa:	4604      	mov	r4, r0
900126fc:	4608      	mov	r0, r1
900126fe:	602b      	str	r3, [r5, #0]
90012700:	f7ee fa1a 	bl	90000b38 <_close>
90012704:	1c43      	adds	r3, r0, #1
90012706:	d102      	bne.n	9001270e <_close_r+0x1a>
90012708:	682b      	ldr	r3, [r5, #0]
9001270a:	b103      	cbz	r3, 9001270e <_close_r+0x1a>
9001270c:	6023      	str	r3, [r4, #0]
9001270e:	bd38      	pop	{r3, r4, r5, pc}
90012710:	2400d3a8 	.word	0x2400d3a8

90012714 <__sflush_r>:
90012714:	898a      	ldrh	r2, [r1, #12]
90012716:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9001271a:	4605      	mov	r5, r0
9001271c:	0710      	lsls	r0, r2, #28
9001271e:	460c      	mov	r4, r1
90012720:	d458      	bmi.n	900127d4 <__sflush_r+0xc0>
90012722:	684b      	ldr	r3, [r1, #4]
90012724:	2b00      	cmp	r3, #0
90012726:	dc05      	bgt.n	90012734 <__sflush_r+0x20>
90012728:	6c0b      	ldr	r3, [r1, #64]	; 0x40
9001272a:	2b00      	cmp	r3, #0
9001272c:	dc02      	bgt.n	90012734 <__sflush_r+0x20>
9001272e:	2000      	movs	r0, #0
90012730:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
90012734:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
90012736:	2e00      	cmp	r6, #0
90012738:	d0f9      	beq.n	9001272e <__sflush_r+0x1a>
9001273a:	2300      	movs	r3, #0
9001273c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
90012740:	682f      	ldr	r7, [r5, #0]
90012742:	602b      	str	r3, [r5, #0]
90012744:	d032      	beq.n	900127ac <__sflush_r+0x98>
90012746:	6d60      	ldr	r0, [r4, #84]	; 0x54
90012748:	89a3      	ldrh	r3, [r4, #12]
9001274a:	075a      	lsls	r2, r3, #29
9001274c:	d505      	bpl.n	9001275a <__sflush_r+0x46>
9001274e:	6863      	ldr	r3, [r4, #4]
90012750:	1ac0      	subs	r0, r0, r3
90012752:	6b63      	ldr	r3, [r4, #52]	; 0x34
90012754:	b10b      	cbz	r3, 9001275a <__sflush_r+0x46>
90012756:	6c23      	ldr	r3, [r4, #64]	; 0x40
90012758:	1ac0      	subs	r0, r0, r3
9001275a:	2300      	movs	r3, #0
9001275c:	4602      	mov	r2, r0
9001275e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
90012760:	6a21      	ldr	r1, [r4, #32]
90012762:	4628      	mov	r0, r5
90012764:	47b0      	blx	r6
90012766:	1c43      	adds	r3, r0, #1
90012768:	89a3      	ldrh	r3, [r4, #12]
9001276a:	d106      	bne.n	9001277a <__sflush_r+0x66>
9001276c:	6829      	ldr	r1, [r5, #0]
9001276e:	291d      	cmp	r1, #29
90012770:	d82c      	bhi.n	900127cc <__sflush_r+0xb8>
90012772:	4a2a      	ldr	r2, [pc, #168]	; (9001281c <__sflush_r+0x108>)
90012774:	40ca      	lsrs	r2, r1
90012776:	07d6      	lsls	r6, r2, #31
90012778:	d528      	bpl.n	900127cc <__sflush_r+0xb8>
9001277a:	2200      	movs	r2, #0
9001277c:	6062      	str	r2, [r4, #4]
9001277e:	04d9      	lsls	r1, r3, #19
90012780:	6922      	ldr	r2, [r4, #16]
90012782:	6022      	str	r2, [r4, #0]
90012784:	d504      	bpl.n	90012790 <__sflush_r+0x7c>
90012786:	1c42      	adds	r2, r0, #1
90012788:	d101      	bne.n	9001278e <__sflush_r+0x7a>
9001278a:	682b      	ldr	r3, [r5, #0]
9001278c:	b903      	cbnz	r3, 90012790 <__sflush_r+0x7c>
9001278e:	6560      	str	r0, [r4, #84]	; 0x54
90012790:	6b61      	ldr	r1, [r4, #52]	; 0x34
90012792:	602f      	str	r7, [r5, #0]
90012794:	2900      	cmp	r1, #0
90012796:	d0ca      	beq.n	9001272e <__sflush_r+0x1a>
90012798:	f104 0344 	add.w	r3, r4, #68	; 0x44
9001279c:	4299      	cmp	r1, r3
9001279e:	d002      	beq.n	900127a6 <__sflush_r+0x92>
900127a0:	4628      	mov	r0, r5
900127a2:	f7ff f923 	bl	900119ec <_free_r>
900127a6:	2000      	movs	r0, #0
900127a8:	6360      	str	r0, [r4, #52]	; 0x34
900127aa:	e7c1      	b.n	90012730 <__sflush_r+0x1c>
900127ac:	6a21      	ldr	r1, [r4, #32]
900127ae:	2301      	movs	r3, #1
900127b0:	4628      	mov	r0, r5
900127b2:	47b0      	blx	r6
900127b4:	1c41      	adds	r1, r0, #1
900127b6:	d1c7      	bne.n	90012748 <__sflush_r+0x34>
900127b8:	682b      	ldr	r3, [r5, #0]
900127ba:	2b00      	cmp	r3, #0
900127bc:	d0c4      	beq.n	90012748 <__sflush_r+0x34>
900127be:	2b1d      	cmp	r3, #29
900127c0:	d001      	beq.n	900127c6 <__sflush_r+0xb2>
900127c2:	2b16      	cmp	r3, #22
900127c4:	d101      	bne.n	900127ca <__sflush_r+0xb6>
900127c6:	602f      	str	r7, [r5, #0]
900127c8:	e7b1      	b.n	9001272e <__sflush_r+0x1a>
900127ca:	89a3      	ldrh	r3, [r4, #12]
900127cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
900127d0:	81a3      	strh	r3, [r4, #12]
900127d2:	e7ad      	b.n	90012730 <__sflush_r+0x1c>
900127d4:	690f      	ldr	r7, [r1, #16]
900127d6:	2f00      	cmp	r7, #0
900127d8:	d0a9      	beq.n	9001272e <__sflush_r+0x1a>
900127da:	0793      	lsls	r3, r2, #30
900127dc:	680e      	ldr	r6, [r1, #0]
900127de:	bf08      	it	eq
900127e0:	694b      	ldreq	r3, [r1, #20]
900127e2:	600f      	str	r7, [r1, #0]
900127e4:	bf18      	it	ne
900127e6:	2300      	movne	r3, #0
900127e8:	eba6 0807 	sub.w	r8, r6, r7
900127ec:	608b      	str	r3, [r1, #8]
900127ee:	f1b8 0f00 	cmp.w	r8, #0
900127f2:	dd9c      	ble.n	9001272e <__sflush_r+0x1a>
900127f4:	6a21      	ldr	r1, [r4, #32]
900127f6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
900127f8:	4643      	mov	r3, r8
900127fa:	463a      	mov	r2, r7
900127fc:	4628      	mov	r0, r5
900127fe:	47b0      	blx	r6
90012800:	2800      	cmp	r0, #0
90012802:	dc06      	bgt.n	90012812 <__sflush_r+0xfe>
90012804:	89a3      	ldrh	r3, [r4, #12]
90012806:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001280a:	81a3      	strh	r3, [r4, #12]
9001280c:	f04f 30ff 	mov.w	r0, #4294967295
90012810:	e78e      	b.n	90012730 <__sflush_r+0x1c>
90012812:	4407      	add	r7, r0
90012814:	eba8 0800 	sub.w	r8, r8, r0
90012818:	e7e9      	b.n	900127ee <__sflush_r+0xda>
9001281a:	bf00      	nop
9001281c:	20400001 	.word	0x20400001

90012820 <_fflush_r>:
90012820:	b538      	push	{r3, r4, r5, lr}
90012822:	690b      	ldr	r3, [r1, #16]
90012824:	4605      	mov	r5, r0
90012826:	460c      	mov	r4, r1
90012828:	b913      	cbnz	r3, 90012830 <_fflush_r+0x10>
9001282a:	2500      	movs	r5, #0
9001282c:	4628      	mov	r0, r5
9001282e:	bd38      	pop	{r3, r4, r5, pc}
90012830:	b118      	cbz	r0, 9001283a <_fflush_r+0x1a>
90012832:	6983      	ldr	r3, [r0, #24]
90012834:	b90b      	cbnz	r3, 9001283a <_fflush_r+0x1a>
90012836:	f7ff fa95 	bl	90011d64 <__sinit>
9001283a:	4b14      	ldr	r3, [pc, #80]	; (9001288c <_fflush_r+0x6c>)
9001283c:	429c      	cmp	r4, r3
9001283e:	d11b      	bne.n	90012878 <_fflush_r+0x58>
90012840:	686c      	ldr	r4, [r5, #4]
90012842:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
90012846:	2b00      	cmp	r3, #0
90012848:	d0ef      	beq.n	9001282a <_fflush_r+0xa>
9001284a:	6e62      	ldr	r2, [r4, #100]	; 0x64
9001284c:	07d0      	lsls	r0, r2, #31
9001284e:	d404      	bmi.n	9001285a <_fflush_r+0x3a>
90012850:	0599      	lsls	r1, r3, #22
90012852:	d402      	bmi.n	9001285a <_fflush_r+0x3a>
90012854:	6da0      	ldr	r0, [r4, #88]	; 0x58
90012856:	f7ee fec9 	bl	900015ec <__retarget_lock_acquire_recursive>
9001285a:	4628      	mov	r0, r5
9001285c:	4621      	mov	r1, r4
9001285e:	f7ff ff59 	bl	90012714 <__sflush_r>
90012862:	6e63      	ldr	r3, [r4, #100]	; 0x64
90012864:	07da      	lsls	r2, r3, #31
90012866:	4605      	mov	r5, r0
90012868:	d4e0      	bmi.n	9001282c <_fflush_r+0xc>
9001286a:	89a3      	ldrh	r3, [r4, #12]
9001286c:	059b      	lsls	r3, r3, #22
9001286e:	d4dd      	bmi.n	9001282c <_fflush_r+0xc>
90012870:	6da0      	ldr	r0, [r4, #88]	; 0x58
90012872:	f7ee fec7 	bl	90001604 <__retarget_lock_release_recursive>
90012876:	e7d9      	b.n	9001282c <_fflush_r+0xc>
90012878:	4b05      	ldr	r3, [pc, #20]	; (90012890 <_fflush_r+0x70>)
9001287a:	429c      	cmp	r4, r3
9001287c:	d101      	bne.n	90012882 <_fflush_r+0x62>
9001287e:	68ac      	ldr	r4, [r5, #8]
90012880:	e7df      	b.n	90012842 <_fflush_r+0x22>
90012882:	4b04      	ldr	r3, [pc, #16]	; (90012894 <_fflush_r+0x74>)
90012884:	429c      	cmp	r4, r3
90012886:	bf08      	it	eq
90012888:	68ec      	ldreq	r4, [r5, #12]
9001288a:	e7da      	b.n	90012842 <_fflush_r+0x22>
9001288c:	90015c24 	.word	0x90015c24
90012890:	90015c44 	.word	0x90015c44
90012894:	90015c04 	.word	0x90015c04

90012898 <_lseek_r>:
90012898:	b538      	push	{r3, r4, r5, lr}
9001289a:	4d07      	ldr	r5, [pc, #28]	; (900128b8 <_lseek_r+0x20>)
9001289c:	4604      	mov	r4, r0
9001289e:	4608      	mov	r0, r1
900128a0:	4611      	mov	r1, r2
900128a2:	2200      	movs	r2, #0
900128a4:	602a      	str	r2, [r5, #0]
900128a6:	461a      	mov	r2, r3
900128a8:	f7ee f950 	bl	90000b4c <_lseek>
900128ac:	1c43      	adds	r3, r0, #1
900128ae:	d102      	bne.n	900128b6 <_lseek_r+0x1e>
900128b0:	682b      	ldr	r3, [r5, #0]
900128b2:	b103      	cbz	r3, 900128b6 <_lseek_r+0x1e>
900128b4:	6023      	str	r3, [r4, #0]
900128b6:	bd38      	pop	{r3, r4, r5, pc}
900128b8:	2400d3a8 	.word	0x2400d3a8

900128bc <__swhatbuf_r>:
900128bc:	b570      	push	{r4, r5, r6, lr}
900128be:	460e      	mov	r6, r1
900128c0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
900128c4:	2900      	cmp	r1, #0
900128c6:	b096      	sub	sp, #88	; 0x58
900128c8:	4614      	mov	r4, r2
900128ca:	461d      	mov	r5, r3
900128cc:	da08      	bge.n	900128e0 <__swhatbuf_r+0x24>
900128ce:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
900128d2:	2200      	movs	r2, #0
900128d4:	602a      	str	r2, [r5, #0]
900128d6:	061a      	lsls	r2, r3, #24
900128d8:	d410      	bmi.n	900128fc <__swhatbuf_r+0x40>
900128da:	f44f 6380 	mov.w	r3, #1024	; 0x400
900128de:	e00e      	b.n	900128fe <__swhatbuf_r+0x42>
900128e0:	466a      	mov	r2, sp
900128e2:	f000 f8a7 	bl	90012a34 <_fstat_r>
900128e6:	2800      	cmp	r0, #0
900128e8:	dbf1      	blt.n	900128ce <__swhatbuf_r+0x12>
900128ea:	9a01      	ldr	r2, [sp, #4]
900128ec:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
900128f0:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
900128f4:	425a      	negs	r2, r3
900128f6:	415a      	adcs	r2, r3
900128f8:	602a      	str	r2, [r5, #0]
900128fa:	e7ee      	b.n	900128da <__swhatbuf_r+0x1e>
900128fc:	2340      	movs	r3, #64	; 0x40
900128fe:	2000      	movs	r0, #0
90012900:	6023      	str	r3, [r4, #0]
90012902:	b016      	add	sp, #88	; 0x58
90012904:	bd70      	pop	{r4, r5, r6, pc}
	...

90012908 <__smakebuf_r>:
90012908:	898b      	ldrh	r3, [r1, #12]
9001290a:	b573      	push	{r0, r1, r4, r5, r6, lr}
9001290c:	079d      	lsls	r5, r3, #30
9001290e:	4606      	mov	r6, r0
90012910:	460c      	mov	r4, r1
90012912:	d507      	bpl.n	90012924 <__smakebuf_r+0x1c>
90012914:	f104 0347 	add.w	r3, r4, #71	; 0x47
90012918:	6023      	str	r3, [r4, #0]
9001291a:	6123      	str	r3, [r4, #16]
9001291c:	2301      	movs	r3, #1
9001291e:	6163      	str	r3, [r4, #20]
90012920:	b002      	add	sp, #8
90012922:	bd70      	pop	{r4, r5, r6, pc}
90012924:	ab01      	add	r3, sp, #4
90012926:	466a      	mov	r2, sp
90012928:	f7ff ffc8 	bl	900128bc <__swhatbuf_r>
9001292c:	9900      	ldr	r1, [sp, #0]
9001292e:	4605      	mov	r5, r0
90012930:	4630      	mov	r0, r6
90012932:	f7ff f8c7 	bl	90011ac4 <_malloc_r>
90012936:	b948      	cbnz	r0, 9001294c <__smakebuf_r+0x44>
90012938:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001293c:	059a      	lsls	r2, r3, #22
9001293e:	d4ef      	bmi.n	90012920 <__smakebuf_r+0x18>
90012940:	f023 0303 	bic.w	r3, r3, #3
90012944:	f043 0302 	orr.w	r3, r3, #2
90012948:	81a3      	strh	r3, [r4, #12]
9001294a:	e7e3      	b.n	90012914 <__smakebuf_r+0xc>
9001294c:	4b0d      	ldr	r3, [pc, #52]	; (90012984 <__smakebuf_r+0x7c>)
9001294e:	62b3      	str	r3, [r6, #40]	; 0x28
90012950:	89a3      	ldrh	r3, [r4, #12]
90012952:	6020      	str	r0, [r4, #0]
90012954:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90012958:	81a3      	strh	r3, [r4, #12]
9001295a:	9b00      	ldr	r3, [sp, #0]
9001295c:	6163      	str	r3, [r4, #20]
9001295e:	9b01      	ldr	r3, [sp, #4]
90012960:	6120      	str	r0, [r4, #16]
90012962:	b15b      	cbz	r3, 9001297c <__smakebuf_r+0x74>
90012964:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
90012968:	4630      	mov	r0, r6
9001296a:	f000 f875 	bl	90012a58 <_isatty_r>
9001296e:	b128      	cbz	r0, 9001297c <__smakebuf_r+0x74>
90012970:	89a3      	ldrh	r3, [r4, #12]
90012972:	f023 0303 	bic.w	r3, r3, #3
90012976:	f043 0301 	orr.w	r3, r3, #1
9001297a:	81a3      	strh	r3, [r4, #12]
9001297c:	89a0      	ldrh	r0, [r4, #12]
9001297e:	4305      	orrs	r5, r0
90012980:	81a5      	strh	r5, [r4, #12]
90012982:	e7cd      	b.n	90012920 <__smakebuf_r+0x18>
90012984:	90011cfd 	.word	0x90011cfd

90012988 <_read_r>:
90012988:	b538      	push	{r3, r4, r5, lr}
9001298a:	4d07      	ldr	r5, [pc, #28]	; (900129a8 <_read_r+0x20>)
9001298c:	4604      	mov	r4, r0
9001298e:	4608      	mov	r0, r1
90012990:	4611      	mov	r1, r2
90012992:	2200      	movs	r2, #0
90012994:	602a      	str	r2, [r5, #0]
90012996:	461a      	mov	r2, r3
90012998:	f7ee f8b2 	bl	90000b00 <_read>
9001299c:	1c43      	adds	r3, r0, #1
9001299e:	d102      	bne.n	900129a6 <_read_r+0x1e>
900129a0:	682b      	ldr	r3, [r5, #0]
900129a2:	b103      	cbz	r3, 900129a6 <_read_r+0x1e>
900129a4:	6023      	str	r3, [r4, #0]
900129a6:	bd38      	pop	{r3, r4, r5, pc}
900129a8:	2400d3a8 	.word	0x2400d3a8

900129ac <_raise_r>:
900129ac:	291f      	cmp	r1, #31
900129ae:	b538      	push	{r3, r4, r5, lr}
900129b0:	4604      	mov	r4, r0
900129b2:	460d      	mov	r5, r1
900129b4:	d904      	bls.n	900129c0 <_raise_r+0x14>
900129b6:	2316      	movs	r3, #22
900129b8:	6003      	str	r3, [r0, #0]
900129ba:	f04f 30ff 	mov.w	r0, #4294967295
900129be:	bd38      	pop	{r3, r4, r5, pc}
900129c0:	6c42      	ldr	r2, [r0, #68]	; 0x44
900129c2:	b112      	cbz	r2, 900129ca <_raise_r+0x1e>
900129c4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
900129c8:	b94b      	cbnz	r3, 900129de <_raise_r+0x32>
900129ca:	4620      	mov	r0, r4
900129cc:	f000 f830 	bl	90012a30 <_getpid_r>
900129d0:	462a      	mov	r2, r5
900129d2:	4601      	mov	r1, r0
900129d4:	4620      	mov	r0, r4
900129d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
900129da:	f000 b817 	b.w	90012a0c <_kill_r>
900129de:	2b01      	cmp	r3, #1
900129e0:	d00a      	beq.n	900129f8 <_raise_r+0x4c>
900129e2:	1c59      	adds	r1, r3, #1
900129e4:	d103      	bne.n	900129ee <_raise_r+0x42>
900129e6:	2316      	movs	r3, #22
900129e8:	6003      	str	r3, [r0, #0]
900129ea:	2001      	movs	r0, #1
900129ec:	e7e7      	b.n	900129be <_raise_r+0x12>
900129ee:	2400      	movs	r4, #0
900129f0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
900129f4:	4628      	mov	r0, r5
900129f6:	4798      	blx	r3
900129f8:	2000      	movs	r0, #0
900129fa:	e7e0      	b.n	900129be <_raise_r+0x12>

900129fc <raise>:
900129fc:	4b02      	ldr	r3, [pc, #8]	; (90012a08 <raise+0xc>)
900129fe:	4601      	mov	r1, r0
90012a00:	6818      	ldr	r0, [r3, #0]
90012a02:	f7ff bfd3 	b.w	900129ac <_raise_r>
90012a06:	bf00      	nop
90012a08:	24000038 	.word	0x24000038

90012a0c <_kill_r>:
90012a0c:	b538      	push	{r3, r4, r5, lr}
90012a0e:	4d07      	ldr	r5, [pc, #28]	; (90012a2c <_kill_r+0x20>)
90012a10:	2300      	movs	r3, #0
90012a12:	4604      	mov	r4, r0
90012a14:	4608      	mov	r0, r1
90012a16:	4611      	mov	r1, r2
90012a18:	602b      	str	r3, [r5, #0]
90012a1a:	f7ee f863 	bl	90000ae4 <_kill>
90012a1e:	1c43      	adds	r3, r0, #1
90012a20:	d102      	bne.n	90012a28 <_kill_r+0x1c>
90012a22:	682b      	ldr	r3, [r5, #0]
90012a24:	b103      	cbz	r3, 90012a28 <_kill_r+0x1c>
90012a26:	6023      	str	r3, [r4, #0]
90012a28:	bd38      	pop	{r3, r4, r5, pc}
90012a2a:	bf00      	nop
90012a2c:	2400d3a8 	.word	0x2400d3a8

90012a30 <_getpid_r>:
90012a30:	f7ee b856 	b.w	90000ae0 <_getpid>

90012a34 <_fstat_r>:
90012a34:	b538      	push	{r3, r4, r5, lr}
90012a36:	4d07      	ldr	r5, [pc, #28]	; (90012a54 <_fstat_r+0x20>)
90012a38:	2300      	movs	r3, #0
90012a3a:	4604      	mov	r4, r0
90012a3c:	4608      	mov	r0, r1
90012a3e:	4611      	mov	r1, r2
90012a40:	602b      	str	r3, [r5, #0]
90012a42:	f7ee f87c 	bl	90000b3e <_fstat>
90012a46:	1c43      	adds	r3, r0, #1
90012a48:	d102      	bne.n	90012a50 <_fstat_r+0x1c>
90012a4a:	682b      	ldr	r3, [r5, #0]
90012a4c:	b103      	cbz	r3, 90012a50 <_fstat_r+0x1c>
90012a4e:	6023      	str	r3, [r4, #0]
90012a50:	bd38      	pop	{r3, r4, r5, pc}
90012a52:	bf00      	nop
90012a54:	2400d3a8 	.word	0x2400d3a8

90012a58 <_isatty_r>:
90012a58:	b538      	push	{r3, r4, r5, lr}
90012a5a:	4d06      	ldr	r5, [pc, #24]	; (90012a74 <_isatty_r+0x1c>)
90012a5c:	2300      	movs	r3, #0
90012a5e:	4604      	mov	r4, r0
90012a60:	4608      	mov	r0, r1
90012a62:	602b      	str	r3, [r5, #0]
90012a64:	f7ee f870 	bl	90000b48 <_isatty>
90012a68:	1c43      	adds	r3, r0, #1
90012a6a:	d102      	bne.n	90012a72 <_isatty_r+0x1a>
90012a6c:	682b      	ldr	r3, [r5, #0]
90012a6e:	b103      	cbz	r3, 90012a72 <_isatty_r+0x1a>
90012a70:	6023      	str	r3, [r4, #0]
90012a72:	bd38      	pop	{r3, r4, r5, pc}
90012a74:	2400d3a8 	.word	0x2400d3a8

90012a78 <_init>:
90012a78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90012a7a:	bf00      	nop
90012a7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
90012a7e:	bc08      	pop	{r3}
90012a80:	469e      	mov	lr, r3
90012a82:	4770      	bx	lr

90012a84 <_fini>:
90012a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90012a86:	bf00      	nop
90012a88:	bcf8      	pop	{r3, r4, r5, r6, r7}
90012a8a:	bc08      	pop	{r3}
90012a8c:	469e      	mov	lr, r3
90012a8e:	4770      	bx	lr
